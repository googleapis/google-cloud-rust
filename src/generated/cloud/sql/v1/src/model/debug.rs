// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::SqlBackupRunsDeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBackupRunsDeleteRequest");
        debug_struct.field("id", &self.id);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlBackupRunsGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBackupRunsGetRequest");
        debug_struct.field("id", &self.id);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlBackupRunsInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBackupRunsInsertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlBackupRunsListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBackupRunsListRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupRun");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("status", &self.status);
        debug_struct.field("enqueued_time", &self.enqueued_time);
        debug_struct.field("id", &self.id);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("description", &self.description);
        debug_struct.field("window_start_time", &self.window_start_time);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("location", &self.location);
        debug_struct.field(
            "disk_encryption_configuration",
            &self.disk_encryption_configuration,
        );
        debug_struct.field("disk_encryption_status", &self.disk_encryption_status);
        debug_struct.field("backup_kind", &self.backup_kind);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("max_chargeable_bytes", &self.max_chargeable_bytes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupRunsListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupRunsListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectSettingsRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("read_time", &self.read_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectSettings");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("server_ca_cert", &self.server_ca_cert);
        debug_struct.field("ip_addresses", &self.ip_addresses);
        debug_struct.field("region", &self.region);
        debug_struct.field("database_version", &self.database_version);
        debug_struct.field("backend_type", &self.backend_type);
        debug_struct.field("psc_enabled", &self.psc_enabled);
        debug_struct.field("dns_name", &self.dns_name);
        debug_struct.field("server_ca_mode", &self.server_ca_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateEphemeralCertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateEphemeralCertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("public_key", &self.public_key);
        debug_struct.field("access_token", &self.access_token);
        debug_struct.field("read_time", &self.read_time);
        debug_struct.field("valid_duration", &self.valid_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateEphemeralCertResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateEphemeralCertResponse");
        debug_struct.field("ephemeral_cert", &self.ephemeral_cert);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlDatabasesDeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlDatabasesDeleteRequest");
        debug_struct.field("database", &self.database);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlDatabasesGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlDatabasesGetRequest");
        debug_struct.field("database", &self.database);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlDatabasesInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlDatabasesInsertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlDatabasesListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlDatabasesListRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlDatabasesUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlDatabasesUpdateRequest");
        debug_struct.field("database", &self.database);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabasesListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabasesListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlFlagsListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlFlagsListRequest");
        debug_struct.field("database_version", &self.database_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FlagsListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FlagsListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Flag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Flag");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("applies_to", &self.applies_to);
        debug_struct.field("allowed_string_values", &self.allowed_string_values);
        debug_struct.field("min_value", &self.min_value);
        debug_struct.field("max_value", &self.max_value);
        debug_struct.field("requires_restart", &self.requires_restart);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("in_beta", &self.in_beta);
        debug_struct.field("allowed_int_values", &self.allowed_int_values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesAddServerCaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesAddServerCaRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesCloneRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesCloneRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesDeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesDeleteRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesDemoteMasterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesDemoteMasterRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesDemoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesDemoteRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesExportRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesFailoverRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesFailoverRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesGetRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesImportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesImportRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesInsertRequest");
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesListRequest");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesListServerCasRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesListServerCasRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesPatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesPatchRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesPromoteReplicaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesPromoteReplicaRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("failover", &self.failover);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesSwitchoverRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesSwitchoverRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("db_timeout", &self.db_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesResetSslConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesResetSslConfigRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesRestartRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesRestartRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesRestoreBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesRestoreBackupRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesRotateServerCaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesRotateServerCaRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesStartReplicaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesStartReplicaRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesStopReplicaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesStopReplicaRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesTruncateLogRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesTruncateLogRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesPerformDiskShrinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesPerformDiskShrinkRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesUpdateRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesRescheduleMaintenanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesRescheduleMaintenanceRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesReencryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesReencryptRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesReencryptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesReencryptRequest");
        debug_struct.field(
            "backup_reencryption_config",
            &self.backup_reencryption_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupReencryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupReencryptionConfig");
        debug_struct.field("backup_limit", &self.backup_limit);
        debug_struct.field("backup_type", &self.backup_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesGetDiskShrinkConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesGetDiskShrinkConfigRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesVerifyExternalSyncSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesVerifyExternalSyncSettingsRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("verify_connection_only", &self.verify_connection_only);
        debug_struct.field("sync_mode", &self.sync_mode);
        debug_struct.field("verify_replication_only", &self.verify_replication_only);
        debug_struct.field("migration_type", &self.migration_type);
        debug_struct.field("sync_parallel_level", &self.sync_parallel_level);
        debug_struct.field("sync_config", &self.sync_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesStartExternalSyncRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesStartExternalSyncRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("sync_mode", &self.sync_mode);
        debug_struct.field("skip_verification", &self.skip_verification);
        debug_struct.field("sync_parallel_level", &self.sync_parallel_level);
        debug_struct.field("migration_type", &self.migration_type);
        debug_struct.field("sync_config", &self.sync_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesResetReplicaSizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesResetReplicaSizeRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesCreateEphemeralCertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesCreateEphemeralCertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesCloneRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesCloneRequest");
        debug_struct.field("clone_context", &self.clone_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesDemoteMasterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesDemoteMasterRequest");
        debug_struct.field("demote_master_context", &self.demote_master_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesDemoteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesDemoteRequest");
        debug_struct.field("demote_context", &self.demote_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesExportRequest");
        debug_struct.field("export_context", &self.export_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesFailoverRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesFailoverRequest");
        debug_struct.field("failover_context", &self.failover_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCertsCreateEphemeralRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCertsCreateEphemeralRequest");
        debug_struct.field("public_key", &self.public_key);
        debug_struct.field("access_token", &self.access_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesImportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesImportRequest");
        debug_struct.field("import_context", &self.import_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("items", &self.items);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesListServerCasResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesListServerCasResponse");
        debug_struct.field("certs", &self.certs);
        debug_struct.field("active_version", &self.active_version);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesRestoreBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesRestoreBackupRequest");
        debug_struct.field("restore_backup_context", &self.restore_backup_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesRotateServerCaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesRotateServerCaRequest");
        debug_struct.field("rotate_server_ca_context", &self.rotate_server_ca_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesTruncateLogRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesTruncateLogRequest");
        debug_struct.field("truncate_log_context", &self.truncate_log_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstancesAcquireSsrsLeaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstancesAcquireSsrsLeaseRequest");
        debug_struct.field(
            "acquire_ssrs_lease_context",
            &self.acquire_ssrs_lease_context,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesVerifyExternalSyncSettingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesVerifyExternalSyncSettingsResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("warnings", &self.warnings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesGetDiskShrinkConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesGetDiskShrinkConfigResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("minimal_target_size_gb", &self.minimal_target_size_gb);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesGetLatestRecoveryTimeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesGetLatestRecoveryTimeRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesGetLatestRecoveryTimeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesGetLatestRecoveryTimeResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("latest_recovery_time", &self.latest_recovery_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloneContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("pitr_timestamp_ms", &self.pitr_timestamp_ms);
        debug_struct.field("destination_instance_name", &self.destination_instance_name);
        debug_struct.field("bin_log_coordinates", &self.bin_log_coordinates);
        debug_struct.field("point_in_time", &self.point_in_time);
        debug_struct.field("allocated_ip_range", &self.allocated_ip_range);
        debug_struct.field("database_names", &self.database_names);
        debug_struct.field("preferred_zone", &self.preferred_zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BinLogCoordinates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinLogCoordinates");
        debug_struct.field("bin_log_file_name", &self.bin_log_file_name);
        debug_struct.field("bin_log_position", &self.bin_log_position);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseInstance");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("state", &self.state);
        debug_struct.field("database_version", &self.database_version);
        debug_struct.field("settings", &self.settings);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("failover_replica", &self.failover_replica);
        debug_struct.field("master_instance_name", &self.master_instance_name);
        debug_struct.field("replica_names", &self.replica_names);
        debug_struct.field("max_disk_size", &self.max_disk_size);
        debug_struct.field("current_disk_size", &self.current_disk_size);
        debug_struct.field("ip_addresses", &self.ip_addresses);
        debug_struct.field("server_ca_cert", &self.server_ca_cert);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("project", &self.project);
        debug_struct.field("ipv6_address", &self.ipv6_address);
        debug_struct.field(
            "service_account_email_address",
            &self.service_account_email_address,
        );
        debug_struct.field("on_premises_configuration", &self.on_premises_configuration);
        debug_struct.field("replica_configuration", &self.replica_configuration);
        debug_struct.field("backend_type", &self.backend_type);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("suspension_reason", &self.suspension_reason);
        debug_struct.field("connection_name", &self.connection_name);
        debug_struct.field("name", &self.name);
        debug_struct.field("region", &self.region);
        debug_struct.field("gce_zone", &self.gce_zone);
        debug_struct.field("secondary_gce_zone", &self.secondary_gce_zone);
        debug_struct.field(
            "disk_encryption_configuration",
            &self.disk_encryption_configuration,
        );
        debug_struct.field("disk_encryption_status", &self.disk_encryption_status);
        debug_struct.field("root_password", &self.root_password);
        debug_struct.field("scheduled_maintenance", &self.scheduled_maintenance);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field(
            "database_installed_version",
            &self.database_installed_version,
        );
        debug_struct.field("out_of_disk_report", &self.out_of_disk_report);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field(
            "available_maintenance_versions",
            &self.available_maintenance_versions,
        );
        debug_struct.field("maintenance_version", &self.maintenance_version);
        debug_struct.field(
            "upgradable_database_versions",
            &self.upgradable_database_versions,
        );
        debug_struct.field("sql_network_architecture", &self.sql_network_architecture);
        debug_struct.field(
            "psc_service_attachment_link",
            &self.psc_service_attachment_link,
        );
        debug_struct.field("dns_name", &self.dns_name);
        debug_struct.field("primary_dns_name", &self.primary_dns_name);
        debug_struct.field("write_endpoint", &self.write_endpoint);
        debug_struct.field("replication_cluster", &self.replication_cluster);
        debug_struct.field("gemini_config", &self.gemini_config);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field(
            "switch_transaction_logs_to_cloud_storage_enabled",
            &self.switch_transaction_logs_to_cloud_storage_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::database_instance::SqlFailoverReplica {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlFailoverReplica");
        debug_struct.field("name", &self.name);
        debug_struct.field("available", &self.available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::database_instance::SqlScheduledMaintenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlScheduledMaintenance");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("can_defer", &self.can_defer);
        debug_struct.field("can_reschedule", &self.can_reschedule);
        debug_struct.field("schedule_deadline_time", &self.schedule_deadline_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::database_instance::SqlOutOfDiskReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlOutOfDiskReport");
        debug_struct.field("sql_out_of_disk_state", &self.sql_out_of_disk_state);
        debug_struct.field(
            "sql_min_recommended_increase_size_gb",
            &self.sql_min_recommended_increase_size_gb,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GeminiInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GeminiInstanceConfig");
        debug_struct.field("entitled", &self.entitled);
        debug_struct.field(
            "google_vacuum_mgmt_enabled",
            &self.google_vacuum_mgmt_enabled,
        );
        debug_struct.field(
            "oom_session_cancel_enabled",
            &self.oom_session_cancel_enabled,
        );
        debug_struct.field("active_query_enabled", &self.active_query_enabled);
        debug_struct.field("index_advisor_enabled", &self.index_advisor_enabled);
        debug_struct.field("flag_recommender_enabled", &self.flag_recommender_enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicationCluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationCluster");
        debug_struct.field("psa_write_endpoint", &self.psa_write_endpoint);
        debug_struct.field("failover_dr_replica_name", &self.failover_dr_replica_name);
        debug_struct.field("dr_replica", &self.dr_replica);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AvailableDatabaseVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AvailableDatabaseVersion");
        debug_struct.field("major_version", &self.major_version);
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesRescheduleMaintenanceRequestBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesRescheduleMaintenanceRequestBody");
        debug_struct.field("reschedule", &self.reschedule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::sql_instances_reschedule_maintenance_request_body::Reschedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Reschedule");
        debug_struct.field("reschedule_type", &self.reschedule_type);
        debug_struct.field("schedule_time", &self.schedule_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DemoteMasterContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DemoteMasterContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("verify_gtid_consistency", &self.verify_gtid_consistency);
        debug_struct.field("master_instance_name", &self.master_instance_name);
        debug_struct.field("replica_configuration", &self.replica_configuration);
        debug_struct.field("skip_replication_setup", &self.skip_replication_setup);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DemoteContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DemoteContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field(
            "source_representative_instance_name",
            &self.source_representative_instance_name,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FailoverContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FailoverContext");
        debug_struct.field("settings_version", &self.settings_version);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestoreBackupContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestoreBackupContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("backup_run_id", &self.backup_run_id);
        debug_struct.field("instance_id", &self.instance_id);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RotateServerCaContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RotateServerCaContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("next_version", &self.next_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TruncateLogContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TruncateLogContext");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("log_type", &self.log_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlExternalSyncSettingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlExternalSyncSettingError");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("detail", &self.detail);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OnPremisesConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OnPremisesConfiguration");
        debug_struct.field("host_port", &self.host_port);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("ca_certificate", &self.ca_certificate);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("dump_file_path", &self.dump_file_path);
        debug_struct.field("source_instance", &self.source_instance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReplicaConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicaConfiguration");
        debug_struct.field("kind", &self.kind);
        debug_struct.field(
            "mysql_replica_configuration",
            &self.mysql_replica_configuration,
        );
        debug_struct.field("failover_target", &self.failover_target);
        debug_struct.field("cascadable_replica", &self.cascadable_replica);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesAcquireSsrsLeaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesAcquireSsrsLeaseRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesAcquireSsrsLeaseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesAcquireSsrsLeaseResponse");
        debug_struct.field("operation_id", &self.operation_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesReleaseSsrsLeaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesReleaseSsrsLeaseRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlInstancesReleaseSsrsLeaseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlInstancesReleaseSsrsLeaseResponse");
        debug_struct.field("operation_id", &self.operation_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlOperationsGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlOperationsGetRequest");
        debug_struct.field("operation", &self.operation);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlOperationsListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlOperationsListRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationsListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationsListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlOperationsCancelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlOperationsCancelRequest");
        debug_struct.field("operation", &self.operation);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AclEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AclEntry");
        debug_struct.field("value", &self.value);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApiWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApiWarning");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupRetentionSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupRetentionSettings");
        debug_struct.field("retention_unit", &self.retention_unit);
        debug_struct.field("retained_backups", &self.retained_backups);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupConfiguration");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("binary_log_enabled", &self.binary_log_enabled);
        debug_struct.field(
            "replication_log_archiving_enabled",
            &self.replication_log_archiving_enabled,
        );
        debug_struct.field("location", &self.location);
        debug_struct.field(
            "point_in_time_recovery_enabled",
            &self.point_in_time_recovery_enabled,
        );
        debug_struct.field("backup_retention_settings", &self.backup_retention_settings);
        debug_struct.field(
            "transaction_log_retention_days",
            &self.transaction_log_retention_days,
        );
        debug_struct.field(
            "transactional_log_storage_state",
            &self.transactional_log_storage_state,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PerformDiskShrinkContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformDiskShrinkContext");
        debug_struct.field("target_size_gb", &self.target_size_gb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackupContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupContext");
        debug_struct.field("backup_id", &self.backup_id);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Database {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Database");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("charset", &self.charset);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("name", &self.name);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("project", &self.project);
        debug_struct.field("database_details", &self.database_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlServerDatabaseDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerDatabaseDetails");
        debug_struct.field("compatibility_level", &self.compatibility_level);
        debug_struct.field("recovery_model", &self.recovery_model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseFlags");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MySqlSyncConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MySqlSyncConfig");
        debug_struct.field("initial_sync_flags", &self.initial_sync_flags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SyncFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SyncFlags");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceReference");
        debug_struct.field("name", &self.name);
        debug_struct.field("region", &self.region);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DemoteMasterConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DemoteMasterConfiguration");
        debug_struct.field("kind", &self.kind);
        debug_struct.field(
            "mysql_replica_configuration",
            &self.mysql_replica_configuration,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DemoteMasterMySqlReplicaConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DemoteMasterMySqlReplicaConfiguration");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("ca_certificate", &self.ca_certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExportContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportContext");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("databases", &self.databases);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("sql_export_options", &self.sql_export_options);
        debug_struct.field("csv_export_options", &self.csv_export_options);
        debug_struct.field("file_type", &self.file_type);
        debug_struct.field("offload", &self.offload);
        debug_struct.field("bak_export_options", &self.bak_export_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::export_context::SqlCsvExportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlCsvExportOptions");
        debug_struct.field("select_query", &self.select_query);
        debug_struct.field("escape_character", &self.escape_character);
        debug_struct.field("quote_character", &self.quote_character);
        debug_struct.field("fields_terminated_by", &self.fields_terminated_by);
        debug_struct.field("lines_terminated_by", &self.lines_terminated_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::export_context::SqlExportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlExportOptions");
        debug_struct.field("tables", &self.tables);
        debug_struct.field("schema_only", &self.schema_only);
        debug_struct.field("mysql_export_options", &self.mysql_export_options);
        debug_struct.field("threads", &self.threads);
        debug_struct.field("parallel", &self.parallel);
        debug_struct.field("postgres_export_options", &self.postgres_export_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::export_context::sql_export_options::MysqlExportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MysqlExportOptions");
        debug_struct.field("master_data", &self.master_data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::export_context::sql_export_options::PostgresExportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresExportOptions");
        debug_struct.field("clean", &self.clean);
        debug_struct.field("if_exists", &self.if_exists);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::export_context::SqlBakExportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBakExportOptions");
        debug_struct.field("striped", &self.striped);
        debug_struct.field("stripe_count", &self.stripe_count);
        debug_struct.field("bak_type", &self.bak_type);
        debug_struct.field("copy_only", &self.copy_only);
        debug_struct.field("differential_base", &self.differential_base);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImportContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportContext");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("database", &self.database);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("file_type", &self.file_type);
        debug_struct.field("csv_import_options", &self.csv_import_options);
        debug_struct.field("import_user", &self.import_user);
        debug_struct.field("bak_import_options", &self.bak_import_options);
        debug_struct.field("sql_import_options", &self.sql_import_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_context::SqlImportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlImportOptions");
        debug_struct.field("threads", &self.threads);
        debug_struct.field("parallel", &self.parallel);
        debug_struct.field("postgres_import_options", &self.postgres_import_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_context::sql_import_options::PostgresImportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgresImportOptions");
        debug_struct.field("clean", &self.clean);
        debug_struct.field("if_exists", &self.if_exists);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_context::SqlCsvImportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlCsvImportOptions");
        debug_struct.field("table", &self.table);
        debug_struct.field("columns", &self.columns);
        debug_struct.field("escape_character", &self.escape_character);
        debug_struct.field("quote_character", &self.quote_character);
        debug_struct.field("fields_terminated_by", &self.fields_terminated_by);
        debug_struct.field("lines_terminated_by", &self.lines_terminated_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_context::SqlBakImportOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlBakImportOptions");
        debug_struct.field("encryption_options", &self.encryption_options);
        debug_struct.field("striped", &self.striped);
        debug_struct.field("no_recovery", &self.no_recovery);
        debug_struct.field("recovery_only", &self.recovery_only);
        debug_struct.field("bak_type", &self.bak_type);
        debug_struct.field("stop_at", &self.stop_at);
        debug_struct.field("stop_at_mark", &self.stop_at_mark);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_context::sql_bak_import_options::EncryptionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionOptions");
        debug_struct.field("cert_path", &self.cert_path);
        debug_struct.field("pvk_path", &self.pvk_path);
        debug_struct.field("pvk_password", &self.pvk_password);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IpConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IpConfiguration");
        debug_struct.field("ipv4_enabled", &self.ipv4_enabled);
        debug_struct.field("private_network", &self.private_network);
        debug_struct.field("require_ssl", &self.require_ssl);
        debug_struct.field("authorized_networks", &self.authorized_networks);
        debug_struct.field("allocated_ip_range", &self.allocated_ip_range);
        debug_struct.field(
            "enable_private_path_for_google_cloud_services",
            &self.enable_private_path_for_google_cloud_services,
        );
        debug_struct.field("ssl_mode", &self.ssl_mode);
        debug_struct.field("psc_config", &self.psc_config);
        debug_struct.field("server_ca_mode", &self.server_ca_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PscConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PscConfig");
        debug_struct.field("psc_enabled", &self.psc_enabled);
        debug_struct.field("allowed_consumer_projects", &self.allowed_consumer_projects);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LocationPreference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationPreference");
        debug_struct.field("follow_gae_application", &self.follow_gae_application);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("secondary_zone", &self.secondary_zone);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("hour", &self.hour);
        debug_struct.field("day", &self.day);
        debug_struct.field("update_track", &self.update_track);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DenyMaintenancePeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DenyMaintenancePeriod");
        debug_struct.field("start_date", &self.start_date);
        debug_struct.field("end_date", &self.end_date);
        debug_struct.field("time", &self.time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsightsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightsConfig");
        debug_struct.field("query_insights_enabled", &self.query_insights_enabled);
        debug_struct.field("record_client_address", &self.record_client_address);
        debug_struct.field("record_application_tags", &self.record_application_tags);
        debug_struct.field("query_string_length", &self.query_string_length);
        debug_struct.field("query_plans_per_minute", &self.query_plans_per_minute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MySqlReplicaConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MySqlReplicaConfiguration");
        debug_struct.field("dump_file_path", &self.dump_file_path);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("connect_retry_interval", &self.connect_retry_interval);
        debug_struct.field("master_heartbeat_period", &self.master_heartbeat_period);
        debug_struct.field("ca_certificate", &self.ca_certificate);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("ssl_cipher", &self.ssl_cipher);
        debug_struct.field("verify_server_certificate", &self.verify_server_certificate);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskEncryptionConfiguration");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskEncryptionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskEncryptionStatus");
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IpMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IpMapping");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("time_to_retire", &self.time_to_retire);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("target_link", &self.target_link);
        debug_struct.field("status", &self.status);
        debug_struct.field("user", &self.user);
        debug_struct.field("insert_time", &self.insert_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("api_warning", &self.api_warning);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("import_context", &self.import_context);
        debug_struct.field("export_context", &self.export_context);
        debug_struct.field("backup_context", &self.backup_context);
        debug_struct.field("name", &self.name);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field(
            "acquire_ssrs_lease_context",
            &self.acquire_ssrs_lease_context,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationError");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationErrors");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("errors", &self.errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PasswordValidationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PasswordValidationPolicy");
        debug_struct.field("min_length", &self.min_length);
        debug_struct.field("complexity", &self.complexity);
        debug_struct.field("reuse_interval", &self.reuse_interval);
        debug_struct.field(
            "disallow_username_substring",
            &self.disallow_username_substring,
        );
        debug_struct.field("password_change_interval", &self.password_change_interval);
        debug_struct.field("enable_password_policy", &self.enable_password_policy);
        debug_struct.field(
            "disallow_compromised_credentials",
            &self.disallow_compromised_credentials,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataCacheConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataCacheConfig");
        debug_struct.field("data_cache_enabled", &self.data_cache_enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Settings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Settings");
        debug_struct.field("settings_version", &self.settings_version);
        debug_struct.field(
            "authorized_gae_applications",
            &self.authorized_gae_applications,
        );
        debug_struct.field("tier", &self.tier);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("user_labels", &self.user_labels);
        debug_struct.field("availability_type", &self.availability_type);
        debug_struct.field("pricing_plan", &self.pricing_plan);
        debug_struct.field("replication_type", &self.replication_type);
        debug_struct.field("storage_auto_resize_limit", &self.storage_auto_resize_limit);
        debug_struct.field("activation_policy", &self.activation_policy);
        debug_struct.field("ip_configuration", &self.ip_configuration);
        debug_struct.field("storage_auto_resize", &self.storage_auto_resize);
        debug_struct.field("location_preference", &self.location_preference);
        debug_struct.field("database_flags", &self.database_flags);
        debug_struct.field("data_disk_type", &self.data_disk_type);
        debug_struct.field("maintenance_window", &self.maintenance_window);
        debug_struct.field("backup_configuration", &self.backup_configuration);
        debug_struct.field(
            "database_replication_enabled",
            &self.database_replication_enabled,
        );
        debug_struct.field(
            "crash_safe_replication_enabled",
            &self.crash_safe_replication_enabled,
        );
        debug_struct.field("data_disk_size_gb", &self.data_disk_size_gb);
        debug_struct.field("active_directory_config", &self.active_directory_config);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("deny_maintenance_periods", &self.deny_maintenance_periods);
        debug_struct.field("insights_config", &self.insights_config);
        debug_struct.field(
            "password_validation_policy",
            &self.password_validation_policy,
        );
        debug_struct.field("sql_server_audit_config", &self.sql_server_audit_config);
        debug_struct.field("edition", &self.edition);
        debug_struct.field("connector_enforcement", &self.connector_enforcement);
        debug_struct.field(
            "deletion_protection_enabled",
            &self.deletion_protection_enabled,
        );
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("advanced_machine_features", &self.advanced_machine_features);
        debug_struct.field("data_cache_config", &self.data_cache_config);
        debug_struct.field(
            "enable_google_ml_integration",
            &self.enable_google_ml_integration,
        );
        debug_struct.field(
            "enable_dataplex_integration",
            &self.enable_dataplex_integration,
        );
        debug_struct.field("auto_upgrade_enabled", &self.auto_upgrade_enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdvancedMachineFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedMachineFeatures");
        debug_struct.field("threads_per_core", &self.threads_per_core);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCert");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("cert_serial_number", &self.cert_serial_number);
        debug_struct.field("cert", &self.cert);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("common_name", &self.common_name);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("sha1_fingerprint", &self.sha1_fingerprint);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("self_link", &self.self_link);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCertDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCertDetail");
        debug_struct.field("cert_info", &self.cert_info);
        debug_struct.field("cert_private_key", &self.cert_private_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlActiveDirectoryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlActiveDirectoryConfig");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("domain", &self.domain);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlServerAuditConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerAuditConfig");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("retention_interval", &self.retention_interval);
        debug_struct.field("upload_interval", &self.upload_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AcquireSsrsLeaseContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AcquireSsrsLeaseContext");
        debug_struct.field("setup_login", &self.setup_login);
        debug_struct.field("service_login", &self.service_login);
        debug_struct.field("report_database", &self.report_database);
        debug_struct.field("duration", &self.duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlSslCertsDeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlSslCertsDeleteRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("sha1_fingerprint", &self.sha1_fingerprint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlSslCertsGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlSslCertsGetRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("sha1_fingerprint", &self.sha1_fingerprint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlSslCertsInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlSslCertsInsertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlSslCertsListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlSslCertsListRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCertsInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCertsInsertRequest");
        debug_struct.field("common_name", &self.common_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCertsInsertResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCertsInsertResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("server_ca_cert", &self.server_ca_cert);
        debug_struct.field("client_cert", &self.client_cert);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslCertsListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslCertsListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlTiersListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlTiersListRequest");
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TiersListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TiersListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Tier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Tier");
        debug_struct.field("tier", &self.tier);
        debug_struct.field("ram", &self.ram);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("disk_quota", &self.disk_quota);
        debug_struct.field("region", &self.region);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlUsersDeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlUsersDeleteRequest");
        debug_struct.field("host", &self.host);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("name", &self.name);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlUsersGetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlUsersGetRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("name", &self.name);
        debug_struct.field("project", &self.project);
        debug_struct.field("host", &self.host);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlUsersInsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlUsersInsertRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlUsersListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlUsersListRequest");
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlUsersUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlUsersUpdateRequest");
        debug_struct.field("host", &self.host);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("name", &self.name);
        debug_struct.field("project", &self.project);
        debug_struct.field("body", &self.body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserPasswordValidationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserPasswordValidationPolicy");
        debug_struct.field("allowed_failed_attempts", &self.allowed_failed_attempts);
        debug_struct.field(
            "password_expiration_duration",
            &self.password_expiration_duration,
        );
        debug_struct.field(
            "enable_failed_attempts_check",
            &self.enable_failed_attempts_check,
        );
        debug_struct.field("status", &self.status);
        debug_struct.field(
            "enable_password_verification",
            &self.enable_password_verification,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PasswordStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PasswordStatus");
        debug_struct.field("locked", &self.locked);
        debug_struct.field("password_expiration_time", &self.password_expiration_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("User");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("password", &self.password);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("name", &self.name);
        debug_struct.field("host", &self.host);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("project", &self.project);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("password_policy", &self.password_policy);
        debug_struct.field("dual_password_type", &self.dual_password_type);
        debug_struct.field("user_details", &self.user_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlServerUserDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlServerUserDetails");
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("server_roles", &self.server_roles);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsersListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsersListResponse");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("items", &self.items);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
