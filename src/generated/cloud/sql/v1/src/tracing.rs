// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [SqlBackupRunsService](super::stub::SqlBackupRunsService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlBackupRunsService<T>
where T: super::stub::SqlBackupRunsService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlBackupRunsService<T>
where T: super::stub::SqlBackupRunsService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlBackupRunsService for SqlBackupRunsService<T>
where T: super::stub::SqlBackupRunsService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete(
        &self,
        req: crate::model::SqlBackupRunsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlBackupRunsService",
            "::delete"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::SqlBackupRunsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlBackupRunsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRun>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlBackupRunsService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlBackupRunsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRun>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert(
        &self,
        req: crate::model::SqlBackupRunsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlBackupRunsService",
            "::insert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.insert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::SqlBackupRunsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlBackupRunsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRunsListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlBackupRunsService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlBackupRunsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackupRunsListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [SqlConnectService](super::stub::SqlConnectService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlConnectService<T>
where T: super::stub::SqlConnectService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlConnectService<T>
where T: super::stub::SqlConnectService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlConnectService for SqlConnectService<T>
where T: super::stub::SqlConnectService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_connect_settings(
        &self,
        req: crate::model::GetConnectSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConnectSettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlConnectService",
            "::get_connect_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_connect_settings",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_connect_settings(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_connect_settings(
        &self,
        req: crate::model::GetConnectSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConnectSettings>> {
        self.inner.get_connect_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_ephemeral_cert(
        &self,
        req: crate::model::GenerateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateEphemeralCertResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlConnectService",
            "::generate_ephemeral_cert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_ephemeral_cert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.generate_ephemeral_cert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_ephemeral_cert(
        &self,
        req: crate::model::GenerateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateEphemeralCertResponse>> {
        self.inner.generate_ephemeral_cert(req, options).await
    }
}

/// Implements a [SqlDatabasesService](super::stub::SqlDatabasesService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlDatabasesService<T>
where T: super::stub::SqlDatabasesService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlDatabasesService<T>
where T: super::stub::SqlDatabasesService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlDatabasesService for SqlDatabasesService<T>
where T: super::stub::SqlDatabasesService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete(
        &self,
        req: crate::model::SqlDatabasesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::delete"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::SqlDatabasesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlDatabasesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Database>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlDatabasesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Database>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert(
        &self,
        req: crate::model::SqlDatabasesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::insert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.insert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::SqlDatabasesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlDatabasesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabasesListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlDatabasesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabasesListResponse>> {
        self.inner.list(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn patch(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::patch"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "patch",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.patch(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlDatabasesService",
            "::update"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::SqlDatabasesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }
}

/// Implements a [SqlFlagsService](super::stub::SqlFlagsService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlFlagsService<T>
where T: super::stub::SqlFlagsService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlFlagsService<T>
where T: super::stub::SqlFlagsService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlFlagsService for SqlFlagsService<T>
where T: super::stub::SqlFlagsService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlFlagsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlagsListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlFlagsService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlFlagsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlagsListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [SqlInstancesService](super::stub::SqlInstancesService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlInstancesService<T>
where T: super::stub::SqlInstancesService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlInstancesService<T>
where T: super::stub::SqlInstancesService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlInstancesService for SqlInstancesService<T>
where T: super::stub::SqlInstancesService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn add_server_ca(
        &self,
        req: crate::model::SqlInstancesAddServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::add_server_ca"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "add_server_ca",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.add_server_ca(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn add_server_ca(
        &self,
        req: crate::model::SqlInstancesAddServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_server_ca(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn clone(
        &self,
        req: crate::model::SqlInstancesCloneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::clone"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "clone",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.clone(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn clone(
        &self,
        req: crate::model::SqlInstancesCloneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.clone(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete(
        &self,
        req: crate::model::SqlInstancesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::delete"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::SqlInstancesDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn demote_master(
        &self,
        req: crate::model::SqlInstancesDemoteMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::demote_master"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "demote_master",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.demote_master(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn demote_master(
        &self,
        req: crate::model::SqlInstancesDemoteMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.demote_master(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn demote(
        &self,
        req: crate::model::SqlInstancesDemoteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::demote"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "demote",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.demote(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn demote(
        &self,
        req: crate::model::SqlInstancesDemoteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.demote(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export(
        &self,
        req: crate::model::SqlInstancesExportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::export"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.export(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export(
        &self,
        req: crate::model::SqlInstancesExportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.export(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn failover(
        &self,
        req: crate::model::SqlInstancesFailoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::failover"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "failover",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.failover(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn failover(
        &self,
        req: crate::model::SqlInstancesFailoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.failover(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reencrypt(
        &self,
        req: crate::model::SqlInstancesReencryptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::reencrypt"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reencrypt",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.reencrypt(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reencrypt(
        &self,
        req: crate::model::SqlInstancesReencryptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reencrypt(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlInstancesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabaseInstance>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlInstancesGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DatabaseInstance>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import(
        &self,
        req: crate::model::SqlInstancesImportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::import"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import(
        &self,
        req: crate::model::SqlInstancesImportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.import(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert(
        &self,
        req: crate::model::SqlInstancesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::insert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.insert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::SqlInstancesInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlInstancesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlInstancesListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListResponse>> {
        self.inner.list(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_server_cas(
        &self,
        req: crate::model::SqlInstancesListServerCasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListServerCasResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::list_server_cas"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_server_cas",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_server_cas(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_server_cas(
        &self,
        req: crate::model::SqlInstancesListServerCasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesListServerCasResponse>> {
        self.inner.list_server_cas(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn patch(
        &self,
        req: crate::model::SqlInstancesPatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::patch"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "patch",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.patch(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::SqlInstancesPatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn promote_replica(
        &self,
        req: crate::model::SqlInstancesPromoteReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::promote_replica"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "promote_replica",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.promote_replica(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn promote_replica(
        &self,
        req: crate::model::SqlInstancesPromoteReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.promote_replica(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn switchover(
        &self,
        req: crate::model::SqlInstancesSwitchoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::switchover"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "switchover",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.switchover(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn switchover(
        &self,
        req: crate::model::SqlInstancesSwitchoverRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.switchover(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reset_ssl_config(
        &self,
        req: crate::model::SqlInstancesResetSslConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::reset_ssl_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reset_ssl_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.reset_ssl_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reset_ssl_config(
        &self,
        req: crate::model::SqlInstancesResetSslConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reset_ssl_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn restart(
        &self,
        req: crate::model::SqlInstancesRestartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::restart"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "restart",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.restart(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn restart(
        &self,
        req: crate::model::SqlInstancesRestartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.restart(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn restore_backup(
        &self,
        req: crate::model::SqlInstancesRestoreBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::restore_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "restore_backup",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.restore_backup(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn restore_backup(
        &self,
        req: crate::model::SqlInstancesRestoreBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.restore_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn rotate_server_ca(
        &self,
        req: crate::model::SqlInstancesRotateServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::rotate_server_ca"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "rotate_server_ca",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.rotate_server_ca(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn rotate_server_ca(
        &self,
        req: crate::model::SqlInstancesRotateServerCaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.rotate_server_ca(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn start_replica(
        &self,
        req: crate::model::SqlInstancesStartReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::start_replica"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "start_replica",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.start_replica(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn start_replica(
        &self,
        req: crate::model::SqlInstancesStartReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_replica(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn stop_replica(
        &self,
        req: crate::model::SqlInstancesStopReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::stop_replica"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "stop_replica",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.stop_replica(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn stop_replica(
        &self,
        req: crate::model::SqlInstancesStopReplicaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_replica(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn truncate_log(
        &self,
        req: crate::model::SqlInstancesTruncateLogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::truncate_log"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "truncate_log",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.truncate_log(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn truncate_log(
        &self,
        req: crate::model::SqlInstancesTruncateLogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.truncate_log(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update(
        &self,
        req: crate::model::SqlInstancesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::update"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::SqlInstancesUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_ephemeral(
        &self,
        req: crate::model::SqlInstancesCreateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::create_ephemeral"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_ephemeral",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_ephemeral(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_ephemeral(
        &self,
        req: crate::model::SqlInstancesCreateEphemeralCertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        self.inner.create_ephemeral(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reschedule_maintenance(
        &self,
        req: crate::model::SqlInstancesRescheduleMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::reschedule_maintenance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reschedule_maintenance",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.reschedule_maintenance(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reschedule_maintenance(
        &self,
        req: crate::model::SqlInstancesRescheduleMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reschedule_maintenance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn verify_external_sync_settings(
        &self,
        req: crate::model::SqlInstancesVerifyExternalSyncSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesVerifyExternalSyncSettingsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::verify_external_sync_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "verify_external_sync_settings",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.verify_external_sync_settings(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn verify_external_sync_settings(
        &self,
        req: crate::model::SqlInstancesVerifyExternalSyncSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesVerifyExternalSyncSettingsResponse>> {
        self.inner.verify_external_sync_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn start_external_sync(
        &self,
        req: crate::model::SqlInstancesStartExternalSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::start_external_sync"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "start_external_sync",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.start_external_sync(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn start_external_sync(
        &self,
        req: crate::model::SqlInstancesStartExternalSyncRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_external_sync(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn perform_disk_shrink(
        &self,
        req: crate::model::SqlInstancesPerformDiskShrinkRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::perform_disk_shrink"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "perform_disk_shrink",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.perform_disk_shrink(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn perform_disk_shrink(
        &self,
        req: crate::model::SqlInstancesPerformDiskShrinkRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_disk_shrink(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_disk_shrink_config(
        &self,
        req: crate::model::SqlInstancesGetDiskShrinkConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetDiskShrinkConfigResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::get_disk_shrink_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_disk_shrink_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_disk_shrink_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_disk_shrink_config(
        &self,
        req: crate::model::SqlInstancesGetDiskShrinkConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetDiskShrinkConfigResponse>> {
        self.inner.get_disk_shrink_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn reset_replica_size(
        &self,
        req: crate::model::SqlInstancesResetReplicaSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::reset_replica_size"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "reset_replica_size",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.reset_replica_size(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn reset_replica_size(
        &self,
        req: crate::model::SqlInstancesResetReplicaSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reset_replica_size(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_latest_recovery_time(
        &self,
        req: crate::model::SqlInstancesGetLatestRecoveryTimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetLatestRecoveryTimeResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::get_latest_recovery_time"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_latest_recovery_time",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_latest_recovery_time(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_latest_recovery_time(
        &self,
        req: crate::model::SqlInstancesGetLatestRecoveryTimeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesGetLatestRecoveryTimeResponse>> {
        self.inner.get_latest_recovery_time(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn acquire_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesAcquireSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesAcquireSsrsLeaseResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::acquire_ssrs_lease"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "acquire_ssrs_lease",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.acquire_ssrs_lease(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn acquire_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesAcquireSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesAcquireSsrsLeaseResponse>> {
        self.inner.acquire_ssrs_lease(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn release_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesReleaseSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesReleaseSsrsLeaseResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlInstancesService",
            "::release_ssrs_lease"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "release_ssrs_lease",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.release_ssrs_lease(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn release_ssrs_lease(
        &self,
        req: crate::model::SqlInstancesReleaseSsrsLeaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SqlInstancesReleaseSsrsLeaseResponse>> {
        self.inner.release_ssrs_lease(req, options).await
    }
}

/// Implements a [SqlOperationsService](super::stub::SqlOperationsService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlOperationsService<T>
where T: super::stub::SqlOperationsService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlOperationsService<T>
where T: super::stub::SqlOperationsService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlOperationsService for SqlOperationsService<T>
where T: super::stub::SqlOperationsService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlOperationsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlOperationsService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlOperationsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlOperationsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationsListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlOperationsService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlOperationsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationsListResponse>> {
        self.inner.list(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel(
        &self,
        req: crate::model::SqlOperationsCancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlOperationsService",
            "::cancel"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel(
        &self,
        req: crate::model::SqlOperationsCancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel(req, options).await
    }
}

/// Implements a [SqlSslCertsService](super::stub::SqlSslCertsService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlSslCertsService<T>
where T: super::stub::SqlSslCertsService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlSslCertsService<T>
where T: super::stub::SqlSslCertsService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlSslCertsService for SqlSslCertsService<T>
where T: super::stub::SqlSslCertsService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete(
        &self,
        req: crate::model::SqlSslCertsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlSslCertsService",
            "::delete"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::SqlSslCertsDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlSslCertsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlSslCertsService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlSslCertsGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCert>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert(
        &self,
        req: crate::model::SqlSslCertsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsInsertResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlSslCertsService",
            "::insert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.insert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::SqlSslCertsInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsInsertResponse>> {
        self.inner.insert(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlSslCertsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlSslCertsService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlSslCertsListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertsListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [SqlTiersService](super::stub::SqlTiersService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlTiersService<T>
where T: super::stub::SqlTiersService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlTiersService<T>
where T: super::stub::SqlTiersService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlTiersService for SqlTiersService<T>
where T: super::stub::SqlTiersService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlTiersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TiersListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlTiersService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlTiersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TiersListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [SqlUsersService](super::stub::SqlUsersService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SqlUsersService<T>
where T: super::stub::SqlUsersService + std::fmt::Debug + Send + Sync {
    inner: T,
}

impl<T> SqlUsersService<T>
where T: super::stub::SqlUsersService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SqlUsersService for SqlUsersService<T>
where T: super::stub::SqlUsersService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete(
        &self,
        req: crate::model::SqlUsersDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlUsersService",
            "::delete"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::SqlUsersDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get(
        &self,
        req: crate::model::SqlUsersGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlUsersService",
            "::get"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::SqlUsersGetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        self.inner.get(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn insert(
        &self,
        req: crate::model::SqlUsersInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlUsersService",
            "::insert"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "insert",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.insert(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::SqlUsersInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list(
        &self,
        req: crate::model::SqlUsersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsersListResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlUsersService",
            "::list"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::SqlUsersListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsersListResponse>> {
        self.inner.list(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update(
        &self,
        req: crate::model::SqlUsersUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SqlUsersService",
            "::update"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::SqlUsersUpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }
}

