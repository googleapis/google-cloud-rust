// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Backup runs delete request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlBackupRunsDeleteRequest {
    /// The ID of the backup run to delete. To find a backup run ID, use the
    /// [list](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/backupRuns/list)
    /// method.
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsDeleteRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsDeleteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlBackupRunsDeleteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlBackupRunsDeleteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlBackupRunsDeleteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlBackupRunsDeleteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlBackupRunsDeleteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup runs get request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlBackupRunsGetRequest {
    /// The ID of this backup run.
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsGetRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlBackupRunsGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlBackupRunsGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlBackupRunsGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlBackupRunsGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlBackupRunsGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup runs insert request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlBackupRunsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::BackupRun>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlBackupRunsInsertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupRun>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlBackupRunsInsertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupRun>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlBackupRunsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlBackupRunsInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlBackupRunsInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlBackupRunsInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlBackupRunsInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<crate::model::BackupRun>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlBackupRunsInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup runs list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlBackupRunsListRequest {
    /// Cloud SQL instance ID, or "-" for all instances. This does not include
    /// the project ID.
    pub instance: std::string::String,

    /// Maximum number of backup runs per response.
    pub max_results: i32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlBackupRunsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlBackupRunsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlBackupRunsListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __max_results,
            __page_token,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlBackupRunsListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlBackupRunsListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlBackupRunsListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlBackupRunsListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A BackupRun resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupRun {
    /// This is always `sql#backupRun`.
    pub kind: std::string::String,

    /// The status of this run.
    pub status: crate::model::SqlBackupRunStatus,

    /// The time the run was enqueued in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub enqueued_time: std::option::Option<wkt::Timestamp>,

    /// The identifier for this backup run. Unique only for a specific Cloud SQL
    /// instance.
    pub id: i64,

    /// The time the backup operation actually started in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the backup operation completed in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Information about why the backup operation failed. This is only present if
    /// the run has the FAILED status.
    pub error: std::option::Option<crate::model::OperationError>,

    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
    /// This field defaults to "ON_DEMAND" and is ignored, when specified for
    /// insert requests.
    pub r#type: crate::model::SqlBackupRunType,

    /// The description of this run, only applicable to on-demand backups.
    pub description: std::string::String,

    /// The start time of the backup window during which this the backup was
    /// attempted in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for
    /// example `2012-11-15T16:19:00.094Z`.
    pub window_start_time: std::option::Option<wkt::Timestamp>,

    /// Name of the database instance.
    pub instance: std::string::String,

    /// The URI of this resource.
    pub self_link: std::string::String,

    /// Location of the backups.
    pub location: std::string::String,

    /// Encryption configuration specific to a backup.
    pub disk_encryption_configuration:
        std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Encryption status specific to a backup.
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    pub backup_kind: crate::model::SqlBackupKind,

    /// Backup time zone to prevent restores to an instance with
    /// a different time zone. Now relevant only for SQL Server.
    pub time_zone: std::string::String,

    /// Output only. The maximum chargeable bytes for the backup.
    pub max_chargeable_bytes: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRun::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [status][crate::model::BackupRun::status].
    pub fn set_status<T: std::convert::Into<crate::model::SqlBackupRunStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [enqueued_time][crate::model::BackupRun::enqueued_time].
    pub fn set_enqueued_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueued_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enqueued_time][crate::model::BackupRun::enqueued_time].
    pub fn set_or_clear_enqueued_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueued_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::BackupRun::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackupRun::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BackupRun::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BackupRun::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BackupRun::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::BackupRun::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationError>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::BackupRun::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationError>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::BackupRun::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlBackupRunType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupRun::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [window_start_time][crate::model::BackupRun::window_start_time].
    pub fn set_window_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.window_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_start_time][crate::model::BackupRun::window_start_time].
    pub fn set_or_clear_window_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.window_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::BackupRun::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::BackupRun::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [location][crate::model::BackupRun::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::BackupRun::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionConfiguration>,
    {
        self.disk_encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_configuration][crate::model::BackupRun::disk_encryption_configuration].
    pub fn set_or_clear_disk_encryption_configuration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionConfiguration>,
    {
        self.disk_encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::BackupRun::disk_encryption_status].
    pub fn set_disk_encryption_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionStatus>,
    {
        self.disk_encryption_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_status][crate::model::BackupRun::disk_encryption_status].
    pub fn set_or_clear_disk_encryption_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionStatus>,
    {
        self.disk_encryption_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_kind][crate::model::BackupRun::backup_kind].
    pub fn set_backup_kind<T: std::convert::Into<crate::model::SqlBackupKind>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_kind = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::BackupRun::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [max_chargeable_bytes][crate::model::BackupRun::max_chargeable_bytes].
    pub fn set_max_chargeable_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_chargeable_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_chargeable_bytes][crate::model::BackupRun::max_chargeable_bytes].
    pub fn set_or_clear_max_chargeable_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.max_chargeable_bytes = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __status,
            __enqueued_time,
            __id,
            __start_time,
            __end_time,
            __error,
            __type,
            __description,
            __window_start_time,
            __instance,
            __self_link,
            __location,
            __disk_encryption_configuration,
            __disk_encryption_status,
            __backup_kind,
            __time_zone,
            __max_chargeable_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "status" => Ok(__FieldTag::__status),
                            "enqueuedTime" => Ok(__FieldTag::__enqueued_time),
                            "enqueued_time" => Ok(__FieldTag::__enqueued_time),
                            "id" => Ok(__FieldTag::__id),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "error" => Ok(__FieldTag::__error),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "windowStartTime" => Ok(__FieldTag::__window_start_time),
                            "window_start_time" => Ok(__FieldTag::__window_start_time),
                            "instance" => Ok(__FieldTag::__instance),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "location" => Ok(__FieldTag::__location),
                            "diskEncryptionConfiguration" => {
                                Ok(__FieldTag::__disk_encryption_configuration)
                            }
                            "disk_encryption_configuration" => {
                                Ok(__FieldTag::__disk_encryption_configuration)
                            }
                            "diskEncryptionStatus" => Ok(__FieldTag::__disk_encryption_status),
                            "disk_encryption_status" => Ok(__FieldTag::__disk_encryption_status),
                            "backupKind" => Ok(__FieldTag::__backup_kind),
                            "backup_kind" => Ok(__FieldTag::__backup_kind),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "maxChargeableBytes" => Ok(__FieldTag::__max_chargeable_bytes),
                            "max_chargeable_bytes" => Ok(__FieldTag::__max_chargeable_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::SqlBackupRunStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enqueued_time => {
                            if !fields.insert(__FieldTag::__enqueued_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enqueued_time",
                                ));
                            }
                            result.enqueued_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<crate::model::OperationError>>(
                                )?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::SqlBackupRunType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__window_start_time => {
                            if !fields.insert(__FieldTag::__window_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window_start_time",
                                ));
                            }
                            result.window_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_encryption_configuration => {
                            if !fields.insert(__FieldTag::__disk_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption_configuration",
                                ));
                            }
                            result.disk_encryption_configuration = map.next_value::<std::option::Option<crate::model::DiskEncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__disk_encryption_status => {
                            if !fields.insert(__FieldTag::__disk_encryption_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption_status",
                                ));
                            }
                            result.disk_encryption_status = map.next_value::<std::option::Option<crate::model::DiskEncryptionStatus>>()?
                                ;
                        }
                        __FieldTag::__backup_kind => {
                            if !fields.insert(__FieldTag::__backup_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_kind",
                                ));
                            }
                            result.backup_kind = map
                                .next_value::<std::option::Option<crate::model::SqlBackupKind>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_chargeable_bytes => {
                            if !fields.insert(__FieldTag::__max_chargeable_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_chargeable_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_chargeable_bytes = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.enqueued_time.is_some() {
            state.serialize_entry("enqueuedTime", &self.enqueued_time)?;
        }
        if !wkt::internal::is_default(&self.id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.window_start_time.is_some() {
            state.serialize_entry("windowStartTime", &self.window_start_time)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.disk_encryption_configuration.is_some() {
            state.serialize_entry(
                "diskEncryptionConfiguration",
                &self.disk_encryption_configuration,
            )?;
        }
        if self.disk_encryption_status.is_some() {
            state.serialize_entry("diskEncryptionStatus", &self.disk_encryption_status)?;
        }
        if !wkt::internal::is_default(&self.backup_kind) {
            state.serialize_entry("backupKind", &self.backup_kind)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.max_chargeable_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxChargeableBytes", &__With(&self.max_chargeable_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup run list results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupRunsListResponse {
    /// This is always `sql#backupRunsList`.
    pub kind: std::string::String,

    /// A list of backup runs in reverse chronological order of the enqueued time.
    pub items: std::vec::Vec<crate::model::BackupRun>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRunsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRunsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::BackupRunsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupRun>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::BackupRunsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for BackupRunsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRunsListResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for BackupRunsListResponse {
    type PageItem = crate::model::BackupRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupRunsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupRunsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupRunsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupRunsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupRunsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Connect settings retrieval request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    pub read_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GetConnectSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GetConnectSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GetConnectSettingsRequest::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::GetConnectSettingsRequest::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GetConnectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GetConnectSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __read_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Connect settings retrieval response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectSettings {
    /// This is always `sql#connectSettings`.
    pub kind: std::string::String,

    /// SSL configuration.
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The assigned IP addresses for the instance.
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// The cloud region for the instance. For example, `us-central1`,
    /// `europe-west1`. The region cannot be changed after instance creation.
    pub region: std::string::String,

    /// The database engine type and version. The `databaseVersion`
    /// field cannot be changed after instance creation.
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
    /// or `MYSQL_5_6`.
    /// PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11`, `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
    /// SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
    /// `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
    /// `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// Whether PSC connectivity is enabled for this instance.
    pub psc_enabled: bool,

    /// The dns name of the instance.
    pub dns_name: std::string::String,

    /// Specify what type of CA is used for the server certificate.
    pub server_ca_mode: crate::model::connect_settings::CaMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ConnectSettings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::ConnectSettings::server_ca_cert].
    pub fn set_server_ca_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [server_ca_cert][crate::model::ConnectSettings::server_ca_cert].
    pub fn set_or_clear_server_ca_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_addresses][crate::model::ConnectSettings::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [region][crate::model::ConnectSettings::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::ConnectSettings::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::ConnectSettings::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [psc_enabled][crate::model::ConnectSettings::psc_enabled].
    pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.psc_enabled = v.into();
        self
    }

    /// Sets the value of [dns_name][crate::model::ConnectSettings::dns_name].
    pub fn set_dns_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_name = v.into();
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::ConnectSettings::server_ca_mode].
    pub fn set_server_ca_mode<T: std::convert::Into<crate::model::connect_settings::CaMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca_mode = v.into();
        self
    }
}

impl wkt::message::Message for ConnectSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ConnectSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __server_ca_cert,
            __ip_addresses,
            __region,
            __database_version,
            __backend_type,
            __psc_enabled,
            __dns_name,
            __server_ca_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "serverCaCert" => Ok(__FieldTag::__server_ca_cert),
                            "server_ca_cert" => Ok(__FieldTag::__server_ca_cert),
                            "ipAddresses" => Ok(__FieldTag::__ip_addresses),
                            "ip_addresses" => Ok(__FieldTag::__ip_addresses),
                            "region" => Ok(__FieldTag::__region),
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "backendType" => Ok(__FieldTag::__backend_type),
                            "backend_type" => Ok(__FieldTag::__backend_type),
                            "pscEnabled" => Ok(__FieldTag::__psc_enabled),
                            "psc_enabled" => Ok(__FieldTag::__psc_enabled),
                            "dnsName" => Ok(__FieldTag::__dns_name),
                            "dns_name" => Ok(__FieldTag::__dns_name),
                            "serverCaMode" => Ok(__FieldTag::__server_ca_mode),
                            "server_ca_mode" => Ok(__FieldTag::__server_ca_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_ca_cert => {
                            if !fields.insert(__FieldTag::__server_ca_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ca_cert",
                                ));
                            }
                            result.server_ca_cert =
                                map.next_value::<std::option::Option<crate::model::SslCert>>()?;
                        }
                        __FieldTag::__ip_addresses => {
                            if !fields.insert(__FieldTag::__ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_addresses",
                                ));
                            }
                            result.ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IpMapping>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map.next_value::<std::option::Option<crate::model::SqlDatabaseVersion>>()?.unwrap_or_default();
                        }
                        __FieldTag::__backend_type => {
                            if !fields.insert(__FieldTag::__backend_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_type",
                                ));
                            }
                            result.backend_type = map
                                .next_value::<std::option::Option<crate::model::SqlBackendType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_enabled => {
                            if !fields.insert(__FieldTag::__psc_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_enabled",
                                ));
                            }
                            result.psc_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_name => {
                            if !fields.insert(__FieldTag::__dns_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_name",
                                ));
                            }
                            result.dns_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_ca_mode => {
                            if !fields.insert(__FieldTag::__server_ca_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ca_mode",
                                ));
                            }
                            result.server_ca_mode = map.next_value::<std::option::Option<crate::model::connect_settings::CaMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.server_ca_cert.is_some() {
            state.serialize_entry("serverCaCert", &self.server_ca_cert)?;
        }
        if !self.ip_addresses.is_empty() {
            state.serialize_entry("ipAddresses", &self.ip_addresses)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !wkt::internal::is_default(&self.database_version) {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if !wkt::internal::is_default(&self.backend_type) {
            state.serialize_entry("backendType", &self.backend_type)?;
        }
        if !wkt::internal::is_default(&self.psc_enabled) {
            state.serialize_entry("pscEnabled", &self.psc_enabled)?;
        }
        if !self.dns_name.is_empty() {
            state.serialize_entry("dnsName", &self.dns_name)?;
        }
        if !wkt::internal::is_default(&self.server_ca_mode) {
            state.serialize_entry("serverCaMode", &self.server_ca_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConnectSettings].
pub mod connect_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Various Certificate Authority (CA) modes for certificate signing.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaMode::value] or
        /// [CaMode::name].
        UnknownValue(ca_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManagedInternalCa => std::option::Option::Some(1),
                Self::GoogleManagedCasCa => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_MODE_UNSPECIFIED"),
                Self::GoogleManagedInternalCa => {
                    std::option::Option::Some("GOOGLE_MANAGED_INTERNAL_CA")
                }
                Self::GoogleManagedCasCa => std::option::Option::Some("GOOGLE_MANAGED_CAS_CA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManagedInternalCa,
                2 => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CaMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_MODE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED_INTERNAL_CA" => Self::GoogleManagedInternalCa,
                "GOOGLE_MANAGED_CAS_CA" => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManagedInternalCa => serializer.serialize_i32(1),
                Self::GoogleManagedCasCa => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaMode>::new(
                ".google.cloud.sql.v1.ConnectSettings.CaMode",
            ))
        }
    }
}

/// Ephemeral certificate creation request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// PEM encoded public key to include in the signed certificate.
    pub public_key: std::string::String,

    /// Optional. Access token to include in the signed certificate.
    pub access_token: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// Optional. If set, it will contain the cert valid duration.
    pub valid_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GenerateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GenerateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateEphemeralCertRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::GenerateEphemeralCertRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GenerateEphemeralCertRequest::read_time].
    pub fn set_read_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_time][crate::model::GenerateEphemeralCertRequest::read_time].
    pub fn set_or_clear_read_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.read_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [valid_duration][crate::model::GenerateEphemeralCertRequest::valid_duration].
    pub fn set_valid_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.valid_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [valid_duration][crate::model::GenerateEphemeralCertRequest::valid_duration].
    pub fn set_or_clear_valid_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.valid_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateEphemeralCertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __public_key,
            __access_token,
            __read_time,
            __valid_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateEphemeralCertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "readTime" => Ok(__FieldTag::__read_time),
                            "read_time" => Ok(__FieldTag::__read_time),
                            "validDuration" => Ok(__FieldTag::__valid_duration),
                            "valid_duration" => Ok(__FieldTag::__valid_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateEphemeralCertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateEphemeralCertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_time => {
                            if !fields.insert(__FieldTag::__read_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_time",
                                ));
                            }
                            result.read_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__valid_duration => {
                            if !fields.insert(__FieldTag::__valid_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_duration",
                                ));
                            }
                            result.valid_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateEphemeralCertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.public_key.is_empty() {
            state.serialize_entry("public_key", &self.public_key)?;
        }
        if !self.access_token.is_empty() {
            state.serialize_entry("access_token", &self.access_token)?;
        }
        if self.read_time.is_some() {
            state.serialize_entry("readTime", &self.read_time)?;
        }
        if self.valid_duration.is_some() {
            state.serialize_entry("validDuration", &self.valid_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Ephemeral certificate creation request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateEphemeralCertResponse {
    /// Generated cert
    pub ephemeral_cert: std::option::Option<crate::model::SslCert>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateEphemeralCertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ephemeral_cert][crate::model::GenerateEphemeralCertResponse::ephemeral_cert].
    pub fn set_ephemeral_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.ephemeral_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ephemeral_cert][crate::model::GenerateEphemeralCertResponse::ephemeral_cert].
    pub fn set_or_clear_ephemeral_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.ephemeral_cert = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateEphemeralCertResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ephemeral_cert,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateEphemeralCertResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ephemeralCert" => Ok(__FieldTag::__ephemeral_cert),
                            "ephemeral_cert" => Ok(__FieldTag::__ephemeral_cert),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateEphemeralCertResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateEphemeralCertResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ephemeral_cert => {
                            if !fields.insert(__FieldTag::__ephemeral_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ephemeral_cert",
                                ));
                            }
                            result.ephemeral_cert =
                                map.next_value::<std::option::Option<crate::model::SslCert>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateEphemeralCertResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ephemeral_cert.is_some() {
            state.serialize_entry("ephemeralCert", &self.ephemeral_cert)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database delete request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabasesDeleteRequest {
    /// Name of the database to be deleted in the instance.
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesDeleteRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesDeleteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabasesDeleteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabasesDeleteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabasesDeleteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabasesDeleteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabasesDeleteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database get request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabasesGetRequest {
    /// Name of the database in the instance.
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesGetRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabasesGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabasesGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabasesGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabasesGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabasesGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database insert request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabasesInsertRequest {
    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::Database>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesInsertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlDatabasesInsertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlDatabasesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabasesInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabasesInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabasesInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabasesInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<crate::model::Database>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabasesInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabasesListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabasesListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabasesListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabasesListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabasesListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabasesListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database update request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlDatabasesUpdateRequest {
    /// Name of the database to be updated in the instance.
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::Database>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesUpdateRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesUpdateRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlDatabasesUpdateRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlDatabasesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesUpdateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlDatabasesUpdateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlDatabasesUpdateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlDatabasesUpdateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlDatabasesUpdateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<crate::model::Database>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlDatabasesUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabasesListResponse {
    /// This is always `sql#databasesList`.
    pub kind: std::string::String,

    /// List of database resources in the instance.
    pub items: std::vec::Vec<crate::model::Database>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabasesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabasesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::DatabasesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabasesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabasesListResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabasesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabasesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabasesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabasesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Database>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabasesListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Flags list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlFlagsListRequest {
    /// Database type and version you want to retrieve flags for. By default, this
    /// method returns flags for all database types and versions.
    pub database_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlFlagsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::SqlFlagsListRequest::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }
}

impl wkt::message::Message for SqlFlagsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlFlagsListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlFlagsListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlFlagsListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlFlagsListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlFlagsListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlFlagsListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database_version.is_empty() {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Flags list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FlagsListResponse {
    /// This is always `sql#flagsList`.
    pub kind: std::string::String,

    /// List of flags.
    pub items: std::vec::Vec<crate::model::Flag>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FlagsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::FlagsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::FlagsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Flag>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FlagsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FlagsListResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FlagsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FlagsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FlagsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FlagsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Flag>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FlagsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A flag resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Flag {
    /// This is the name of the flag. Flag names always use underscores, not
    /// hyphens, for example: `max_allowed_packet`
    pub name: std::string::String,

    /// The type of the flag. Flags are typed to being `BOOLEAN`, `STRING`,
    /// `INTEGER` or `NONE`. `NONE` is used for flags that do not take a
    /// value, such as `skip_grant_tables`.
    pub r#type: crate::model::SqlFlagType,

    /// The database version this flag applies to. Can be
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_8_0_18`, `MYSQL_8_0_26`, `MYSQL_5_7`,
    /// or `MYSQL_5_6`. PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12`. SQL Server instances:
    /// `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`,
    /// `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    /// See [the complete
    /// list](/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    pub applies_to: std::vec::Vec<crate::model::SqlDatabaseVersion>,

    /// For `STRING` flags, a list of strings that the value can be set to.
    pub allowed_string_values: std::vec::Vec<std::string::String>,

    /// For `INTEGER` flags, the minimum allowed value.
    pub min_value: std::option::Option<wkt::Int64Value>,

    /// For `INTEGER` flags, the maximum allowed value.
    pub max_value: std::option::Option<wkt::Int64Value>,

    /// Indicates whether changing this flag will trigger a database restart. Only
    /// applicable to Second Generation instances.
    pub requires_restart: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#flag`.
    pub kind: std::string::String,

    /// Whether or not the flag is considered in beta.
    pub in_beta: std::option::Option<wkt::BoolValue>,

    /// Use this field if only certain integers are accepted. Can be combined
    /// with min_value and max_value to add additional values.
    pub allowed_int_values: std::vec::Vec<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Flag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Flag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Flag::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlFlagType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [applies_to][crate::model::Flag::applies_to].
    pub fn set_applies_to<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlDatabaseVersion>,
    {
        use std::iter::Iterator;
        self.applies_to = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allowed_string_values][crate::model::Flag::allowed_string_values].
    pub fn set_allowed_string_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_string_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_value][crate::model::Flag::min_value].
    pub fn set_min_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.min_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_value][crate::model::Flag::min_value].
    pub fn set_or_clear_min_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.min_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_value][crate::model::Flag::max_value].
    pub fn set_max_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_value][crate::model::Flag::max_value].
    pub fn set_or_clear_max_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requires_restart][crate::model::Flag::requires_restart].
    pub fn set_requires_restart<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.requires_restart = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requires_restart][crate::model::Flag::requires_restart].
    pub fn set_or_clear_requires_restart<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.requires_restart = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Flag::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [in_beta][crate::model::Flag::in_beta].
    pub fn set_in_beta<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.in_beta = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_beta][crate::model::Flag::in_beta].
    pub fn set_or_clear_in_beta<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.in_beta = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allowed_int_values][crate::model::Flag::allowed_int_values].
    pub fn set_allowed_int_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.allowed_int_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Flag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Flag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Flag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __applies_to,
            __allowed_string_values,
            __min_value,
            __max_value,
            __requires_restart,
            __kind,
            __in_beta,
            __allowed_int_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Flag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "appliesTo" => Ok(__FieldTag::__applies_to),
                            "applies_to" => Ok(__FieldTag::__applies_to),
                            "allowedStringValues" => Ok(__FieldTag::__allowed_string_values),
                            "allowed_string_values" => Ok(__FieldTag::__allowed_string_values),
                            "minValue" => Ok(__FieldTag::__min_value),
                            "min_value" => Ok(__FieldTag::__min_value),
                            "maxValue" => Ok(__FieldTag::__max_value),
                            "max_value" => Ok(__FieldTag::__max_value),
                            "requiresRestart" => Ok(__FieldTag::__requires_restart),
                            "requires_restart" => Ok(__FieldTag::__requires_restart),
                            "kind" => Ok(__FieldTag::__kind),
                            "inBeta" => Ok(__FieldTag::__in_beta),
                            "in_beta" => Ok(__FieldTag::__in_beta),
                            "allowedIntValues" => Ok(__FieldTag::__allowed_int_values),
                            "allowed_int_values" => Ok(__FieldTag::__allowed_int_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Flag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Flag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::SqlFlagType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applies_to => {
                            if !fields.insert(__FieldTag::__applies_to) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applies_to",
                                ));
                            }
                            result.applies_to = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlDatabaseVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed_string_values => {
                            if !fields.insert(__FieldTag::__allowed_string_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_string_values",
                                ));
                            }
                            result.allowed_string_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__min_value => {
                            if !fields.insert(__FieldTag::__min_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_value",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_value => {
                            if !fields.insert(__FieldTag::__max_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_value",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__requires_restart => {
                            if !fields.insert(__FieldTag::__requires_restart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requires_restart",
                                ));
                            }
                            result.requires_restart =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__in_beta => {
                            if !fields.insert(__FieldTag::__in_beta) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_beta",
                                ));
                            }
                            result.in_beta =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__allowed_int_values => {
                            if !fields.insert(__FieldTag::__allowed_int_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_int_values",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allowed_int_values =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Flag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.applies_to.is_empty() {
            state.serialize_entry("appliesTo", &self.applies_to)?;
        }
        if !self.allowed_string_values.is_empty() {
            state.serialize_entry("allowedStringValues", &self.allowed_string_values)?;
        }
        if self.min_value.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minValue", &__With(&self.min_value))?;
        }
        if self.max_value.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxValue", &__With(&self.max_value))?;
        }
        if self.requires_restart.is_some() {
            state.serialize_entry("requiresRestart", &self.requires_restart)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.in_beta.is_some() {
            state.serialize_entry("inBeta", &self.in_beta)?;
        }
        if !self.allowed_int_values.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("allowedIntValues", &__With(&self.allowed_int_values))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance add server CA request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesAddServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAddServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAddServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAddServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAddServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAddServerCaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesAddServerCaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesAddServerCaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesAddServerCaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesAddServerCaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesAddServerCaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance clone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesCloneRequest {
    /// The ID of the Cloud SQL instance to be cloned (source). This does not
    /// include the project ID.
    pub instance: std::string::String,

    /// Project ID of the source as well as the clone Cloud SQL instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesCloneRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCloneRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCloneRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCloneRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesCloneRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesCloneRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesCloneRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCloneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesCloneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesCloneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesCloneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesCloneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesCloneRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesCloneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance delete request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be deleted.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDeleteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesDeleteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesDeleteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesDeleteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesDeleteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesDeleteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance demote master request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesDemoteMasterRequest {
    /// Cloud SQL instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesDemoteMasterRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteMasterRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteMasterRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteMasterRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesDemoteMasterRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesDemoteMasterRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesDemoteMasterRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteMasterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesDemoteMasterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesDemoteMasterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesDemoteMasterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesDemoteMasterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesDemoteMasterRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesDemoteMasterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance demote request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesDemoteRequest {
    /// Required. Cloud SQL instance name.
    pub instance: std::string::String,

    /// Required. ID of the project that contains the instance.
    pub project: std::string::String,

    /// Required. The request body.
    pub body: std::option::Option<crate::model::InstancesDemoteRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesDemoteRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesDemoteRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesDemoteRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesDemoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesDemoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesDemoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesDemoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesDemoteRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesDemoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance export request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesExportRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be exported.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesExportRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesExportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesExportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesExportRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesExportRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesExportRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesExportRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesExportRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance failover request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesFailoverRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesFailoverRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesFailoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesFailoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesFailoverRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesFailoverRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesFailoverRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesFailoverRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesFailoverRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesFailoverRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesFailoverRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesFailoverRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesFailoverRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesFailoverRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesFailoverRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance get request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesGetRequest {
    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance import request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesImportRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesImportRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesImportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesImportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesImportRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesImportRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesImportRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesImportRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesImportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesImportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesImportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesImportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesImportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesImportRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesImportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance insert request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesInsertRequest {
    /// Project ID of the project to which the newly created Cloud SQL instances
    /// should belong.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::DatabaseInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlInstancesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesInsertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesInsertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<crate::model::DatabaseInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesListRequest {
    /// A filter expression that filters resources listed in the response.
    /// The expression is in the form of field:value. For example,
    /// 'instanceType:CLOUD_SQL_INSTANCE'. Fields can be nested as needed as per
    /// their JSON representation, such as 'settings.userLabels.auto_start:true'.
    ///
    /// Multiple filter queries are space-separated. For example.
    /// 'state:RUNNABLE instanceType:CLOUD_SQL_INSTANCE'. By default, each
    /// expression is an AND expression. However, you can include AND and OR
    /// expressions explicitly.
    pub filter: std::string::String,

    /// The maximum number of instances to return. The service may return fewer
    /// than this value.
    /// If unspecified, at most 500 instances are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    pub page_token: std::string::String,

    /// Project ID of the project for which to list Cloud SQL instances.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::SqlInstancesListRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlInstancesListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlInstancesListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __filter,
            __max_results,
            __page_token,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filter" => Ok(__FieldTag::__filter),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance list server CAs request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesListServerCasRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesListServerCasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesListServerCasRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListServerCasRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListServerCasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListServerCasRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesListServerCasRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesListServerCasRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesListServerCasRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesListServerCasRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesListServerCasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance patch request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesPatchRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::DatabaseInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPatchRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPatchRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPatchRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesPatchRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesPatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPatchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesPatchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesPatchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesPatchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesPatchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<crate::model::DatabaseInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesPatchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance promote replica request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesPromoteReplicaRequest {
    /// Cloud SQL read replica instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    pub project: std::string::String,

    /// Set to true to invoke a replica failover to the designated DR
    /// replica. As part of replica failover, the promote operation attempts
    /// to add the original primary instance as a replica of the promoted
    /// DR replica when the original primary instance comes back online.
    /// If set to false or not specified, then the original primary
    /// instance becomes an independent Cloud SQL primary instance.
    /// Only applicable to MySQL.
    pub failover: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPromoteReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPromoteReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPromoteReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [failover][crate::model::SqlInstancesPromoteReplicaRequest::failover].
    pub fn set_failover<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.failover = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPromoteReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPromoteReplicaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesPromoteReplicaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __failover,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesPromoteReplicaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "failover" => Ok(__FieldTag::__failover),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesPromoteReplicaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesPromoteReplicaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failover => {
                            if !fields.insert(__FieldTag::__failover) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failover",
                                ));
                            }
                            result.failover = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesPromoteReplicaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.failover) {
            state.serialize_entry("failover", &self.failover)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance switchover request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesSwitchoverRequest {
    /// Cloud SQL read replica instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the replica.
    pub project: std::string::String,

    /// Optional. (MySQL only) Cloud SQL instance operations timeout, which is a
    /// sum of all database operations. Default value is 10 minutes and can be
    /// modified to a maximum value of 24 hours.
    pub db_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesSwitchoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesSwitchoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesSwitchoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [db_timeout][crate::model::SqlInstancesSwitchoverRequest::db_timeout].
    pub fn set_db_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.db_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [db_timeout][crate::model::SqlInstancesSwitchoverRequest::db_timeout].
    pub fn set_or_clear_db_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.db_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesSwitchoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesSwitchoverRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesSwitchoverRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __db_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesSwitchoverRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "dbTimeout" => Ok(__FieldTag::__db_timeout),
                            "db_timeout" => Ok(__FieldTag::__db_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesSwitchoverRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesSwitchoverRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__db_timeout => {
                            if !fields.insert(__FieldTag::__db_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for db_timeout",
                                ));
                            }
                            result.db_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesSwitchoverRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.db_timeout.is_some() {
            state.serialize_entry("dbTimeout", &self.db_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance reset SSL config request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesResetSslConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesResetSslConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetSslConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetSslConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetSslConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetSslConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesResetSslConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesResetSslConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesResetSslConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesResetSslConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesResetSslConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance restart request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesRestartRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be restarted.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRestartRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestartRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestartRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRestartRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestartRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesRestartRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesRestartRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesRestartRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesRestartRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesRestartRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance restore backup request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesRestoreBackupRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesRestoreBackupRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestoreBackupRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestoreBackupRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRestoreBackupRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesRestoreBackupRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesRestoreBackupRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesRestoreBackupRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestoreBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesRestoreBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesRestoreBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesRestoreBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesRestoreBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<
                                    crate::model::InstancesRestoreBackupRequest,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesRestoreBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance rotate server CA request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesRotateServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesRotateServerCaRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRotateServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRotateServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRotateServerCaRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesRotateServerCaRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesRotateServerCaRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesRotateServerCaRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRotateServerCaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesRotateServerCaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesRotateServerCaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesRotateServerCaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesRotateServerCaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<
                                    crate::model::InstancesRotateServerCaRequest,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesRotateServerCaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance start replica request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesStartReplicaRequest {
    /// Cloud SQL read replica instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStartReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStartReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartReplicaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesStartReplicaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesStartReplicaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesStartReplicaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesStartReplicaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesStartReplicaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance stop replica request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesStopReplicaRequest {
    /// Cloud SQL read replica instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStopReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStopReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStopReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStopReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStopReplicaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesStopReplicaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesStopReplicaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesStopReplicaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesStopReplicaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesStopReplicaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance truncate log request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesTruncateLogRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::InstancesTruncateLogRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesTruncateLogRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesTruncateLogRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesTruncateLogRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesTruncateLogRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesTruncateLogRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesTruncateLogRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesTruncateLogRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesTruncateLogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesTruncateLogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesTruncateLogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesTruncateLogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesTruncateLogRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesTruncateLogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance perform disk shrink request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesPerformDiskShrinkRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Perform disk shrink context.
    pub body: std::option::Option<crate::model::PerformDiskShrinkContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPerformDiskShrinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPerformDiskShrinkRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPerformDiskShrinkRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPerformDiskShrinkRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PerformDiskShrinkContext>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesPerformDiskShrinkRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PerformDiskShrinkContext>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesPerformDiskShrinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPerformDiskShrinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesPerformDiskShrinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesPerformDiskShrinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesPerformDiskShrinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesPerformDiskShrinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::PerformDiskShrinkContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesPerformDiskShrinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance update request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesUpdateRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::DatabaseInstance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesUpdateRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesUpdateRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseInstance>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesUpdateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesUpdateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesUpdateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesUpdateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesUpdateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<crate::model::DatabaseInstance>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance reschedule maintenance request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRescheduleMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRescheduleMaintenanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRescheduleMaintenanceRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRescheduleMaintenanceRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesRescheduleMaintenanceRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesRescheduleMaintenanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesRescheduleMaintenanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesRescheduleMaintenanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesRescheduleMaintenanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<
                                crate::model::SqlInstancesRescheduleMaintenanceRequestBody,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesRescheduleMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance reencrypt request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesReencryptRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    pub project: std::string::String,

    /// Reencrypt body that users request
    pub body: std::option::Option<crate::model::InstancesReencryptRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReencryptRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReencryptRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesReencryptRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesReencryptRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesReencryptRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesReencryptRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReencryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesReencryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesReencryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesReencryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesReencryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::InstancesReencryptRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesReencryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database Instance reencrypt request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesReencryptRequest {
    /// Configuration specific to backup re-encryption
    pub backup_reencryption_config: std::option::Option<crate::model::BackupReencryptionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_reencryption_config][crate::model::InstancesReencryptRequest::backup_reencryption_config].
    pub fn set_backup_reencryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupReencryptionConfig>,
    {
        self.backup_reencryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_reencryption_config][crate::model::InstancesReencryptRequest::backup_reencryption_config].
    pub fn set_or_clear_backup_reencryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupReencryptionConfig>,
    {
        self.backup_reencryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesReencryptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesReencryptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_reencryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesReencryptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupReencryptionConfig" => {
                                Ok(__FieldTag::__backup_reencryption_config)
                            }
                            "backup_reencryption_config" => {
                                Ok(__FieldTag::__backup_reencryption_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesReencryptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesReencryptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_reencryption_config => {
                            if !fields.insert(__FieldTag::__backup_reencryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_reencryption_config",
                                ));
                            }
                            result.backup_reencryption_config = map.next_value::<std::option::Option<crate::model::BackupReencryptionConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesReencryptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_reencryption_config.is_some() {
            state.serialize_entry("backupReencryptionConfig", &self.backup_reencryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup Reencryption Config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupReencryptionConfig {
    /// Backup re-encryption limit
    pub backup_limit: std::option::Option<i32>,

    /// Type of backups users want to re-encrypt.
    pub backup_type: std::option::Option<crate::model::backup_reencryption_config::BackupType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupReencryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_limit][crate::model::BackupReencryptionConfig::backup_limit].
    pub fn set_backup_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.backup_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_limit][crate::model::BackupReencryptionConfig::backup_limit].
    pub fn set_or_clear_backup_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.backup_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_type][crate::model::BackupReencryptionConfig::backup_type].
    pub fn set_backup_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_reencryption_config::BackupType>,
    {
        self.backup_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_type][crate::model::BackupReencryptionConfig::backup_type].
    pub fn set_or_clear_backup_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_reencryption_config::BackupType>,
    {
        self.backup_type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupReencryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupReencryptionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupReencryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_limit,
            __backup_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupReencryptionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupLimit" => Ok(__FieldTag::__backup_limit),
                            "backup_limit" => Ok(__FieldTag::__backup_limit),
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupReencryptionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupReencryptionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_limit => {
                            if !fields.insert(__FieldTag::__backup_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_limit",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map.next_value::<std::option::Option<
                                crate::model::backup_reencryption_config::BackupType,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupReencryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("backupLimit", &__With(&self.backup_limit))?;
        }
        if self.backup_type.is_some() {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupReencryptionConfig].
pub mod backup_reencryption_config {
    #[allow(unused_imports)]
    use super::*;

    /// Backup type for re-encryption
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// Unknown backup type, will be defaulted to AUTOMATIC backup type
        Unspecified,
        /// Reencrypt automatic backups
        Automated,
        /// Reencrypt on-demand backups
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automated => std::option::Option::Some(1),
                Self::OnDemand => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automated,
                2 => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATED" => Self::Automated,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automated => serializer.serialize_i32(1),
                Self::OnDemand => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.sql.v1.BackupReencryptionConfig.BackupType",
            ))
        }
    }
}

/// Instance get disk shrink config request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetDiskShrinkConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetDiskShrinkConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetDiskShrinkConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesGetDiskShrinkConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesGetDiskShrinkConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesGetDiskShrinkConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesGetDiskShrinkConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesGetDiskShrinkConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance verify external sync settings request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Flag to enable verifying connection only
    pub verify_connection_only: bool,

    /// External sync mode
    pub sync_mode:
        crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Optional. Flag to verify settings required by replication setup only
    pub verify_replication_only: bool,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type:
        crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    /// Optional. Parallel level for initial data sync. Only applicable for
    /// PostgreSQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    pub sync_config: std::option::Option<
        crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesVerifyExternalSyncSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [verify_connection_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_connection_only].
    pub fn set_verify_connection_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_connection_only = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_mode].
    pub fn set_sync_mode<
        T: std::convert::Into<
                crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [verify_replication_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_replication_only].
    pub fn set_verify_replication_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_replication_only = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::migration_type].
    pub fn set_migration_type<
        T: std::convert::Into<
                crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<
        T: std::convert::Into<crate::model::ExternalSyncParallelLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config].
    ///
    /// Note that all the setters affecting `sync_config` are mutually
    /// exclusive.
    pub fn set_sync_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_sync_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<
        T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesVerifyExternalSyncSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __verify_connection_only,
            __sync_mode,
            __verify_replication_only,
            __mysql_sync_config,
            __migration_type,
            __sync_parallel_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SqlInstancesVerifyExternalSyncSettingsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "verifyConnectionOnly" => Ok(__FieldTag::__verify_connection_only),
                            "verify_connection_only" => Ok(__FieldTag::__verify_connection_only),
                            "syncMode" => Ok(__FieldTag::__sync_mode),
                            "sync_mode" => Ok(__FieldTag::__sync_mode),
                            "verifyReplicationOnly" => Ok(__FieldTag::__verify_replication_only),
                            "verify_replication_only" => Ok(__FieldTag::__verify_replication_only),
                            "mysqlSyncConfig" => Ok(__FieldTag::__mysql_sync_config),
                            "mysql_sync_config" => Ok(__FieldTag::__mysql_sync_config),
                            "migrationType" => Ok(__FieldTag::__migration_type),
                            "migration_type" => Ok(__FieldTag::__migration_type),
                            "syncParallelLevel" => Ok(__FieldTag::__sync_parallel_level),
                            "sync_parallel_level" => Ok(__FieldTag::__sync_parallel_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesVerifyExternalSyncSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesVerifyExternalSyncSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verify_connection_only => {
                            if !fields.insert(__FieldTag::__verify_connection_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_connection_only",
                                ));
                            }
                            result.verify_connection_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_mode => {
                            if !fields.insert(__FieldTag::__sync_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_mode",
                                ));
                            }
                            result.sync_mode = map.next_value::<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__verify_replication_only => {
                            if !fields.insert(__FieldTag::__verify_replication_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_replication_only",
                                ));
                            }
                            result.verify_replication_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_sync_config => {
                            if !fields.insert(__FieldTag::__mysql_sync_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_sync_config",
                                ));
                            }
                            if result.sync_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sync_config`, a oneof with full ID .google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest.mysql_sync_config, latest field was mysqlSyncConfig",
                                ));
                            }
                            result.sync_config = std::option::Option::Some(
                                crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MySqlSyncConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__migration_type => {
                            if !fields.insert(__FieldTag::__migration_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_type",
                                ));
                            }
                            result.migration_type = map.next_value::<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sync_parallel_level => {
                            if !fields.insert(__FieldTag::__sync_parallel_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_parallel_level",
                                ));
                            }
                            result.sync_parallel_level = map.next_value::<std::option::Option<crate::model::ExternalSyncParallelLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesVerifyExternalSyncSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.verify_connection_only) {
            state.serialize_entry("verifyConnectionOnly", &self.verify_connection_only)?;
        }
        if !wkt::internal::is_default(&self.sync_mode) {
            state.serialize_entry("syncMode", &self.sync_mode)?;
        }
        if !wkt::internal::is_default(&self.verify_replication_only) {
            state.serialize_entry("verifyReplicationOnly", &self.verify_replication_only)?;
        }
        if let Some(value) = self.mysql_sync_config() {
            state.serialize_entry("mysqlSyncConfig", value)?;
        }
        if !wkt::internal::is_default(&self.migration_type) {
            state.serialize_entry("migrationType", &self.migration_type)?;
        }
        if !wkt::internal::is_default(&self.sync_parallel_level) {
            state.serialize_entry("syncParallelLevel", &self.sync_parallel_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SqlInstancesVerifyExternalSyncSettingsRequest].
pub mod sql_instances_verify_external_sync_settings_request {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExternalSyncMode {
        /// Unknown external sync mode, will be defaulted to ONLINE mode
        Unspecified,
        /// Online external sync will set up replication after initial data external
        /// sync
        Online,
        /// Offline external sync only dumps and loads a one-time snapshot of
        /// the primary instance's data
        Offline,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExternalSyncMode::value] or
        /// [ExternalSyncMode::name].
        UnknownValue(external_sync_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod external_sync_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExternalSyncMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Online => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXTERNAL_SYNC_MODE_UNSPECIFIED"),
                Self::Online => std::option::Option::Some("ONLINE"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExternalSyncMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExternalSyncMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExternalSyncMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Online,
                2 => Self::Offline,
                _ => Self::UnknownValue(external_sync_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExternalSyncMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXTERNAL_SYNC_MODE_UNSPECIFIED" => Self::Unspecified,
                "ONLINE" => Self::Online,
                "OFFLINE" => Self::Offline,
                _ => Self::UnknownValue(external_sync_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExternalSyncMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Online => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExternalSyncMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExternalSyncMode>::new(
                ".google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest.ExternalSyncMode"))
        }
    }

    /// MigrationType determines whether the migration is a physical file-based
    /// migration or a logical dump file-based migration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationType {
        /// Default value is a logical dump file-based migration
        Unspecified,
        /// Logical dump file-based migration
        Logical,
        /// Physical file-based migration
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MigrationType::value] or
        /// [MigrationType::name].
        UnknownValue(migration_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod migration_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MigrationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Logical => std::option::Option::Some(1),
                Self::Physical => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIGRATION_TYPE_UNSPECIFIED"),
                Self::Logical => std::option::Option::Some("LOGICAL"),
                Self::Physical => std::option::Option::Some("PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MigrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MigrationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MigrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Logical,
                2 => Self::Physical,
                _ => Self::UnknownValue(migration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MigrationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LOGICAL" => Self::Logical,
                "PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(migration_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MigrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Logical => serializer.serialize_i32(1),
                Self::Physical => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationType>::new(
                ".google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest.MigrationType",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// Optional. MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance start external sync request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesStartExternalSyncRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    pub project: std::string::String,

    /// External sync mode.
    pub sync_mode:
        crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Whether to skip the verification step (VESS).
    pub skip_verification: bool,

    /// Optional. Parallel level for initial data sync. Currently only applicable
    /// for MySQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type:
        crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    pub sync_config:
        std::option::Option<crate::model::sql_instances_start_external_sync_request::SyncConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStartExternalSyncRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartExternalSyncRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartExternalSyncRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesStartExternalSyncRequest::sync_mode].
    pub fn set_sync_mode<
        T: std::convert::Into<
                crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [skip_verification][crate::model::SqlInstancesStartExternalSyncRequest::skip_verification].
    pub fn set_skip_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_verification = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesStartExternalSyncRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<
        T: std::convert::Into<crate::model::ExternalSyncParallelLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesStartExternalSyncRequest::migration_type].
    pub fn set_migration_type<
        T: std::convert::Into<
                crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config].
    ///
    /// Note that all the setters affecting `sync_config` are mutually
    /// exclusive.
    pub fn set_sync_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::sql_instances_start_external_sync_request::SyncConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_sync_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<
        T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesStartExternalSyncRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartExternalSyncRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesStartExternalSyncRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __sync_mode,
            __skip_verification,
            __mysql_sync_config,
            __sync_parallel_level,
            __migration_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesStartExternalSyncRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "syncMode" => Ok(__FieldTag::__sync_mode),
                            "sync_mode" => Ok(__FieldTag::__sync_mode),
                            "skipVerification" => Ok(__FieldTag::__skip_verification),
                            "skip_verification" => Ok(__FieldTag::__skip_verification),
                            "mysqlSyncConfig" => Ok(__FieldTag::__mysql_sync_config),
                            "mysql_sync_config" => Ok(__FieldTag::__mysql_sync_config),
                            "syncParallelLevel" => Ok(__FieldTag::__sync_parallel_level),
                            "sync_parallel_level" => Ok(__FieldTag::__sync_parallel_level),
                            "migrationType" => Ok(__FieldTag::__migration_type),
                            "migration_type" => Ok(__FieldTag::__migration_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesStartExternalSyncRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesStartExternalSyncRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_mode => {
                            if !fields.insert(__FieldTag::__sync_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_mode",
                                ));
                            }
                            result.sync_mode = map.next_value::<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__skip_verification => {
                            if !fields.insert(__FieldTag::__skip_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_verification",
                                ));
                            }
                            result.skip_verification = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_sync_config => {
                            if !fields.insert(__FieldTag::__mysql_sync_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_sync_config",
                                ));
                            }
                            if result.sync_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `sync_config`, a oneof with full ID .google.cloud.sql.v1.SqlInstancesStartExternalSyncRequest.mysql_sync_config, latest field was mysqlSyncConfig",
                                ));
                            }
                            result.sync_config = std::option::Option::Some(
                                crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MySqlSyncConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sync_parallel_level => {
                            if !fields.insert(__FieldTag::__sync_parallel_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_parallel_level",
                                ));
                            }
                            result.sync_parallel_level = map.next_value::<std::option::Option<crate::model::ExternalSyncParallelLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__migration_type => {
                            if !fields.insert(__FieldTag::__migration_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_type",
                                ));
                            }
                            result.migration_type = map.next_value::<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesStartExternalSyncRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.sync_mode) {
            state.serialize_entry("syncMode", &self.sync_mode)?;
        }
        if !wkt::internal::is_default(&self.skip_verification) {
            state.serialize_entry("skipVerification", &self.skip_verification)?;
        }
        if let Some(value) = self.mysql_sync_config() {
            state.serialize_entry("mysqlSyncConfig", value)?;
        }
        if !wkt::internal::is_default(&self.sync_parallel_level) {
            state.serialize_entry("syncParallelLevel", &self.sync_parallel_level)?;
        }
        if !wkt::internal::is_default(&self.migration_type) {
            state.serialize_entry("migrationType", &self.migration_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SqlInstancesStartExternalSyncRequest].
pub mod sql_instances_start_external_sync_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance reset replica size request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesResetReplicaSizeRequest {
    /// Cloud SQL read replica instance name.
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesResetReplicaSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetReplicaSizeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetReplicaSizeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetReplicaSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetReplicaSizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesResetReplicaSizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesResetReplicaSizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesResetReplicaSizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesResetReplicaSizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesResetReplicaSizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance create ephemeral certificate request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesCreateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::SslCertsCreateEphemeralRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesCreateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCreateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCreateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCreateEphemeralCertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCertsCreateEphemeralRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesCreateEphemeralCertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCertsCreateEphemeralRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesCreateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCreateEphemeralCertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesCreateEphemeralCertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesCreateEphemeralCertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesCreateEphemeralCertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesCreateEphemeralCertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<
                                    crate::model::SslCertsCreateEphemeralRequest,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesCreateEphemeralCertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance clone request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesCloneRequest {
    /// Contains details about the clone operation.
    pub clone_context: std::option::Option<crate::model::CloneContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_context][crate::model::InstancesCloneRequest::clone_context].
    pub fn set_clone_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloneContext>,
    {
        self.clone_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_context][crate::model::InstancesCloneRequest::clone_context].
    pub fn set_or_clear_clone_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloneContext>,
    {
        self.clone_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesCloneRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesCloneRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clone_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesCloneRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloneContext" => Ok(__FieldTag::__clone_context),
                            "clone_context" => Ok(__FieldTag::__clone_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesCloneRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesCloneRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clone_context => {
                            if !fields.insert(__FieldTag::__clone_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_context",
                                ));
                            }
                            result.clone_context = map
                                .next_value::<std::option::Option<crate::model::CloneContext>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesCloneRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.clone_context.is_some() {
            state.serialize_entry("cloneContext", &self.clone_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database demote primary instance request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesDemoteMasterRequest {
    /// Contains details about the demoteMaster operation.
    pub demote_master_context: std::option::Option<crate::model::DemoteMasterContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_master_context][crate::model::InstancesDemoteMasterRequest::demote_master_context].
    pub fn set_demote_master_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterContext>,
    {
        self.demote_master_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [demote_master_context][crate::model::InstancesDemoteMasterRequest::demote_master_context].
    pub fn set_or_clear_demote_master_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterContext>,
    {
        self.demote_master_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteMasterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesDemoteMasterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __demote_master_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesDemoteMasterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "demoteMasterContext" => Ok(__FieldTag::__demote_master_context),
                            "demote_master_context" => Ok(__FieldTag::__demote_master_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesDemoteMasterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesDemoteMasterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__demote_master_context => {
                            if !fields.insert(__FieldTag::__demote_master_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for demote_master_context",
                                ));
                            }
                            result.demote_master_context = map.next_value::<std::option::Option<crate::model::DemoteMasterContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesDemoteMasterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.demote_master_context.is_some() {
            state.serialize_entry("demoteMasterContext", &self.demote_master_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This request is used to demote an existing standalone instance to be a
/// Cloud SQL read replica for an external database server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesDemoteRequest {
    /// Required. Contains details about the demote operation.
    pub demote_context: std::option::Option<crate::model::DemoteContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_context][crate::model::InstancesDemoteRequest::demote_context].
    pub fn set_demote_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DemoteContext>,
    {
        self.demote_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [demote_context][crate::model::InstancesDemoteRequest::demote_context].
    pub fn set_or_clear_demote_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DemoteContext>,
    {
        self.demote_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesDemoteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __demote_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesDemoteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "demoteContext" => Ok(__FieldTag::__demote_context),
                            "demote_context" => Ok(__FieldTag::__demote_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesDemoteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesDemoteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__demote_context => {
                            if !fields.insert(__FieldTag::__demote_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for demote_context",
                                ));
                            }
                            result.demote_context = map
                                .next_value::<std::option::Option<crate::model::DemoteContext>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesDemoteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.demote_context.is_some() {
            state.serialize_entry("demoteContext", &self.demote_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance export request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesExportRequest {
    /// Contains details about the export operation.
    pub export_context: std::option::Option<crate::model::ExportContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_context][crate::model::InstancesExportRequest::export_context].
    pub fn set_export_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportContext>,
    {
        self.export_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_context][crate::model::InstancesExportRequest::export_context].
    pub fn set_or_clear_export_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportContext>,
    {
        self.export_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __export_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportContext" => Ok(__FieldTag::__export_context),
                            "export_context" => Ok(__FieldTag::__export_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__export_context => {
                            if !fields.insert(__FieldTag::__export_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_context",
                                ));
                            }
                            result.export_context = map
                                .next_value::<std::option::Option<crate::model::ExportContext>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.export_context.is_some() {
            state.serialize_entry("exportContext", &self.export_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance failover request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesFailoverRequest {
    /// Failover Context.
    pub failover_context: std::option::Option<crate::model::FailoverContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [failover_context][crate::model::InstancesFailoverRequest::failover_context].
    pub fn set_failover_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FailoverContext>,
    {
        self.failover_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failover_context][crate::model::InstancesFailoverRequest::failover_context].
    pub fn set_or_clear_failover_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FailoverContext>,
    {
        self.failover_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesFailoverRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesFailoverRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __failover_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesFailoverRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "failoverContext" => Ok(__FieldTag::__failover_context),
                            "failover_context" => Ok(__FieldTag::__failover_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesFailoverRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesFailoverRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__failover_context => {
                            if !fields.insert(__FieldTag::__failover_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failover_context",
                                ));
                            }
                            result.failover_context = map
                                .next_value::<std::option::Option<crate::model::FailoverContext>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesFailoverRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.failover_context.is_some() {
            state.serialize_entry("failoverContext", &self.failover_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCerts create ephemeral certificate request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCertsCreateEphemeralRequest {
    /// PEM encoded public key to include in the signed certificate.
    pub public_key: std::string::String,

    /// Access token to include in the signed certificate.
    pub access_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsCreateEphemeralRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_key][crate::model::SslCertsCreateEphemeralRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::SslCertsCreateEphemeralRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsCreateEphemeralRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsCreateEphemeralRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCertsCreateEphemeralRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __public_key,
            __access_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCertsCreateEphemeralRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "public_key" => Ok(__FieldTag::__public_key),
                            "access_token" => Ok(__FieldTag::__access_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCertsCreateEphemeralRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCertsCreateEphemeralRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCertsCreateEphemeralRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.public_key.is_empty() {
            state.serialize_entry("public_key", &self.public_key)?;
        }
        if !self.access_token.is_empty() {
            state.serialize_entry("access_token", &self.access_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance import request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesImportRequest {
    /// Contains details about the import operation.
    pub import_context: std::option::Option<crate::model::ImportContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_context][crate::model::InstancesImportRequest::import_context].
    pub fn set_import_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportContext>,
    {
        self.import_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_context][crate::model::InstancesImportRequest::import_context].
    pub fn set_or_clear_import_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportContext>,
    {
        self.import_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesImportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesImportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __import_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesImportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importContext" => Ok(__FieldTag::__import_context),
                            "import_context" => Ok(__FieldTag::__import_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesImportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesImportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__import_context => {
                            if !fields.insert(__FieldTag::__import_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_context",
                                ));
                            }
                            result.import_context = map
                                .next_value::<std::option::Option<crate::model::ImportContext>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesImportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.import_context.is_some() {
            state.serialize_entry("importContext", &self.import_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instances list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesListResponse {
    /// This is always `sql#instancesList`.
    pub kind: std::string::String,

    /// List of warnings that occurred while handling the request.
    pub warnings: std::vec::Vec<crate::model::ApiWarning>,

    /// List of database instance resources.
    pub items: std::vec::Vec<crate::model::DatabaseInstance>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::InstancesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::InstancesListResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ApiWarning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::InstancesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseInstance>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstancesListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for InstancesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstancesListResponse {
    type PageItem = crate::model::DatabaseInstance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __warnings,
            __items,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "items" => Ok(__FieldTag::__items),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ApiWarning>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseInstance>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instances ListServerCas response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesListServerCasResponse {
    /// List of server CA certificates for the instance.
    pub certs: std::vec::Vec<crate::model::SslCert>,

    pub active_version: std::string::String,

    /// This is always `sql#instancesListServerCas`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesListServerCasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certs][crate::model::InstancesListServerCasResponse::certs].
    pub fn set_certs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>,
    {
        use std::iter::Iterator;
        self.certs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_version][crate::model::InstancesListServerCasResponse::active_version].
    pub fn set_active_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.active_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::InstancesListServerCasResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for InstancesListServerCasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListServerCasResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesListServerCasResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certs,
            __active_version,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesListServerCasResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certs" => Ok(__FieldTag::__certs),
                            "activeVersion" => Ok(__FieldTag::__active_version),
                            "active_version" => Ok(__FieldTag::__active_version),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesListServerCasResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesListServerCasResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certs => {
                            if !fields.insert(__FieldTag::__certs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certs",
                                ));
                            }
                            result.certs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SslCert>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__active_version => {
                            if !fields.insert(__FieldTag::__active_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_version",
                                ));
                            }
                            result.active_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesListServerCasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certs.is_empty() {
            state.serialize_entry("certs", &self.certs)?;
        }
        if !self.active_version.is_empty() {
            state.serialize_entry("activeVersion", &self.active_version)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance restore backup request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesRestoreBackupRequest {
    /// Parameters required to perform the restore backup operation.
    pub restore_backup_context: std::option::Option<crate::model::RestoreBackupContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_backup_context][crate::model::InstancesRestoreBackupRequest::restore_backup_context].
    pub fn set_restore_backup_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreBackupContext>,
    {
        self.restore_backup_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_backup_context][crate::model::InstancesRestoreBackupRequest::restore_backup_context].
    pub fn set_or_clear_restore_backup_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreBackupContext>,
    {
        self.restore_backup_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRestoreBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesRestoreBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_backup_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesRestoreBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restoreBackupContext" => Ok(__FieldTag::__restore_backup_context),
                            "restore_backup_context" => Ok(__FieldTag::__restore_backup_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesRestoreBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesRestoreBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_backup_context => {
                            if !fields.insert(__FieldTag::__restore_backup_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_backup_context",
                                ));
                            }
                            result.restore_backup_context = map.next_value::<std::option::Option<crate::model::RestoreBackupContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesRestoreBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restore_backup_context.is_some() {
            state.serialize_entry("restoreBackupContext", &self.restore_backup_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Rotate server CA request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesRotateServerCaRequest {
    /// Contains details about the rotate server CA operation.
    pub rotate_server_ca_context: std::option::Option<crate::model::RotateServerCaContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rotate_server_ca_context][crate::model::InstancesRotateServerCaRequest::rotate_server_ca_context].
    pub fn set_rotate_server_ca_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RotateServerCaContext>,
    {
        self.rotate_server_ca_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rotate_server_ca_context][crate::model::InstancesRotateServerCaRequest::rotate_server_ca_context].
    pub fn set_or_clear_rotate_server_ca_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RotateServerCaContext>,
    {
        self.rotate_server_ca_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRotateServerCaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesRotateServerCaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rotate_server_ca_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesRotateServerCaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rotateServerCaContext" => Ok(__FieldTag::__rotate_server_ca_context),
                            "rotate_server_ca_context" => {
                                Ok(__FieldTag::__rotate_server_ca_context)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesRotateServerCaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesRotateServerCaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rotate_server_ca_context => {
                            if !fields.insert(__FieldTag::__rotate_server_ca_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotate_server_ca_context",
                                ));
                            }
                            result.rotate_server_ca_context = map.next_value::<std::option::Option<crate::model::RotateServerCaContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesRotateServerCaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rotate_server_ca_context.is_some() {
            state.serialize_entry("rotateServerCaContext", &self.rotate_server_ca_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance truncate log request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesTruncateLogRequest {
    /// Contains details about the truncate log operation.
    pub truncate_log_context: std::option::Option<crate::model::TruncateLogContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [truncate_log_context][crate::model::InstancesTruncateLogRequest::truncate_log_context].
    pub fn set_truncate_log_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TruncateLogContext>,
    {
        self.truncate_log_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [truncate_log_context][crate::model::InstancesTruncateLogRequest::truncate_log_context].
    pub fn set_or_clear_truncate_log_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TruncateLogContext>,
    {
        self.truncate_log_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesTruncateLogRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesTruncateLogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __truncate_log_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesTruncateLogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "truncateLogContext" => Ok(__FieldTag::__truncate_log_context),
                            "truncate_log_context" => Ok(__FieldTag::__truncate_log_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesTruncateLogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesTruncateLogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__truncate_log_context => {
                            if !fields.insert(__FieldTag::__truncate_log_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for truncate_log_context",
                                ));
                            }
                            result.truncate_log_context = map.next_value::<std::option::Option<crate::model::TruncateLogContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesTruncateLogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.truncate_log_context.is_some() {
            state.serialize_entry("truncateLogContext", &self.truncate_log_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to acquire a lease for SSRS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesAcquireSsrsLeaseRequest {
    /// Contains details about the acquire SSRS lease operation.
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::InstancesAcquireSsrsLeaseRequest::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AcquireSsrsLeaseContext>,
    {
        self.acquire_ssrs_lease_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acquire_ssrs_lease_context][crate::model::InstancesAcquireSsrsLeaseRequest::acquire_ssrs_lease_context].
    pub fn set_or_clear_acquire_ssrs_lease_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AcquireSsrsLeaseContext>,
    {
        self.acquire_ssrs_lease_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesAcquireSsrsLeaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstancesAcquireSsrsLeaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __acquire_ssrs_lease_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstancesAcquireSsrsLeaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acquireSsrsLeaseContext" => {
                                Ok(__FieldTag::__acquire_ssrs_lease_context)
                            }
                            "acquire_ssrs_lease_context" => {
                                Ok(__FieldTag::__acquire_ssrs_lease_context)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstancesAcquireSsrsLeaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstancesAcquireSsrsLeaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__acquire_ssrs_lease_context => {
                            if !fields.insert(__FieldTag::__acquire_ssrs_lease_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acquire_ssrs_lease_context",
                                ));
                            }
                            result.acquire_ssrs_lease_context = map.next_value::<std::option::Option<crate::model::AcquireSsrsLeaseContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstancesAcquireSsrsLeaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.acquire_ssrs_lease_context.is_some() {
            state.serialize_entry("acquireSsrsLeaseContext", &self.acquire_ssrs_lease_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance verify external sync settings response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsResponse {
    /// This is always `sql#migrationSettingErrorList`.
    pub kind: std::string::String,

    /// List of migration violations.
    pub errors: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,

    /// List of migration warnings.
    pub warnings: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesVerifyExternalSyncSettingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesVerifyExternalSyncSettingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __errors,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SqlInstancesVerifyExternalSyncSettingsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "errors" => Ok(__FieldTag::__errors),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesVerifyExternalSyncSettingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesVerifyExternalSyncSettingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlExternalSyncSettingError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlExternalSyncSettingError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesVerifyExternalSyncSettingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance get disk shrink config response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigResponse {
    /// This is always `sql#getDiskShrinkConfig`.
    pub kind: std::string::String,

    /// The minimum size to which a disk can be shrunk in GigaBytes.
    pub minimal_target_size_gb: i64,

    /// Additional message to customers.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetDiskShrinkConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetDiskShrinkConfigResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [minimal_target_size_gb][crate::model::SqlInstancesGetDiskShrinkConfigResponse::minimal_target_size_gb].
    pub fn set_minimal_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.minimal_target_size_gb = v.into();
        self
    }

    /// Sets the value of [message][crate::model::SqlInstancesGetDiskShrinkConfigResponse::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesGetDiskShrinkConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __minimal_target_size_gb,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesGetDiskShrinkConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "minimalTargetSizeGb" => Ok(__FieldTag::__minimal_target_size_gb),
                            "minimal_target_size_gb" => Ok(__FieldTag::__minimal_target_size_gb),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesGetDiskShrinkConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesGetDiskShrinkConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimal_target_size_gb => {
                            if !fields.insert(__FieldTag::__minimal_target_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimal_target_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minimal_target_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesGetDiskShrinkConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.minimal_target_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimalTargetSizeGb", &__With(&self.minimal_target_size_gb))?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance get latest recovery time request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetLatestRecoveryTimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesGetLatestRecoveryTimeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesGetLatestRecoveryTimeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesGetLatestRecoveryTimeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesGetLatestRecoveryTimeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesGetLatestRecoveryTimeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance get latest recovery time response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeResponse {
    /// This is always `sql#getLatestRecoveryTime`.
    pub kind: std::string::String,

    /// Timestamp, identifies the latest recovery time of the source instance.
    pub latest_recovery_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetLatestRecoveryTimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [latest_recovery_time][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::latest_recovery_time].
    pub fn set_latest_recovery_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_recovery_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_recovery_time][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::latest_recovery_time].
    pub fn set_or_clear_latest_recovery_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_recovery_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesGetLatestRecoveryTimeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __latest_recovery_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for SqlInstancesGetLatestRecoveryTimeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "latestRecoveryTime" => Ok(__FieldTag::__latest_recovery_time),
                            "latest_recovery_time" => Ok(__FieldTag::__latest_recovery_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesGetLatestRecoveryTimeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesGetLatestRecoveryTimeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_recovery_time => {
                            if !fields.insert(__FieldTag::__latest_recovery_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_recovery_time",
                                ));
                            }
                            result.latest_recovery_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesGetLatestRecoveryTimeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.latest_recovery_time.is_some() {
            state.serialize_entry("latestRecoveryTime", &self.latest_recovery_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance clone context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneContext {
    /// This is always `sql#cloneContext`.
    pub kind: std::string::String,

    /// Reserved for future use.
    pub pitr_timestamp_ms: i64,

    /// Name of the Cloud SQL instance to be created as a clone.
    pub destination_instance_name: std::string::String,

    /// Binary log coordinates, if specified, identify the position up to which the
    /// source instance is cloned. If not specified, the source instance is
    /// cloned up to the most recent binary log coordinates.
    pub bin_log_coordinates: std::option::Option<crate::model::BinLogCoordinates>,

    /// Timestamp, if specified, identifies the time to which the source instance
    /// is cloned.
    pub point_in_time: std::option::Option<wkt::Timestamp>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the cloned instance
    /// ip will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Reserved for future use.
    pub allocated_ip_range: std::string::String,

    /// (SQL Server only) Clone only the specified databases from the source
    /// instance. Clone all databases if empty.
    pub database_names: std::vec::Vec<std::string::String>,

    /// Optional. Copy clone and point-in-time recovery clone of an instance to the
    /// specified zone. If no zone is specified, clone to the same primary zone as
    /// the source instance. This field applies to all DB types.
    pub preferred_zone: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::CloneContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [pitr_timestamp_ms][crate::model::CloneContext::pitr_timestamp_ms].
    pub fn set_pitr_timestamp_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pitr_timestamp_ms = v.into();
        self
    }

    /// Sets the value of [destination_instance_name][crate::model::CloneContext::destination_instance_name].
    pub fn set_destination_instance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_instance_name = v.into();
        self
    }

    /// Sets the value of [bin_log_coordinates][crate::model::CloneContext::bin_log_coordinates].
    pub fn set_bin_log_coordinates<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinLogCoordinates>,
    {
        self.bin_log_coordinates = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bin_log_coordinates][crate::model::CloneContext::bin_log_coordinates].
    pub fn set_or_clear_bin_log_coordinates<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinLogCoordinates>,
    {
        self.bin_log_coordinates = v.map(|x| x.into());
        self
    }

    /// Sets the value of [point_in_time][crate::model::CloneContext::point_in_time].
    pub fn set_point_in_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [point_in_time][crate::model::CloneContext::point_in_time].
    pub fn set_or_clear_point_in_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::CloneContext::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [database_names][crate::model::CloneContext::database_names].
    pub fn set_database_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [preferred_zone][crate::model::CloneContext::preferred_zone].
    pub fn set_preferred_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.preferred_zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preferred_zone][crate::model::CloneContext::preferred_zone].
    pub fn set_or_clear_preferred_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.preferred_zone = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloneContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.CloneContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __pitr_timestamp_ms,
            __destination_instance_name,
            __bin_log_coordinates,
            __point_in_time,
            __allocated_ip_range,
            __database_names,
            __preferred_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "pitrTimestampMs" => Ok(__FieldTag::__pitr_timestamp_ms),
                            "pitr_timestamp_ms" => Ok(__FieldTag::__pitr_timestamp_ms),
                            "destinationInstanceName" => {
                                Ok(__FieldTag::__destination_instance_name)
                            }
                            "destination_instance_name" => {
                                Ok(__FieldTag::__destination_instance_name)
                            }
                            "binLogCoordinates" => Ok(__FieldTag::__bin_log_coordinates),
                            "bin_log_coordinates" => Ok(__FieldTag::__bin_log_coordinates),
                            "pointInTime" => Ok(__FieldTag::__point_in_time),
                            "point_in_time" => Ok(__FieldTag::__point_in_time),
                            "allocatedIpRange" => Ok(__FieldTag::__allocated_ip_range),
                            "allocated_ip_range" => Ok(__FieldTag::__allocated_ip_range),
                            "databaseNames" => Ok(__FieldTag::__database_names),
                            "database_names" => Ok(__FieldTag::__database_names),
                            "preferredZone" => Ok(__FieldTag::__preferred_zone),
                            "preferred_zone" => Ok(__FieldTag::__preferred_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pitr_timestamp_ms => {
                            if !fields.insert(__FieldTag::__pitr_timestamp_ms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pitr_timestamp_ms",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitr_timestamp_ms =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__destination_instance_name => {
                            if !fields.insert(__FieldTag::__destination_instance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_instance_name",
                                ));
                            }
                            result.destination_instance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bin_log_coordinates => {
                            if !fields.insert(__FieldTag::__bin_log_coordinates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bin_log_coordinates",
                                ));
                            }
                            result.bin_log_coordinates = map
                                .next_value::<std::option::Option<crate::model::BinLogCoordinates>>(
                                )?;
                        }
                        __FieldTag::__point_in_time => {
                            if !fields.insert(__FieldTag::__point_in_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_in_time",
                                ));
                            }
                            result.point_in_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allocated_ip_range => {
                            if !fields.insert(__FieldTag::__allocated_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocated_ip_range",
                                ));
                            }
                            result.allocated_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_names => {
                            if !fields.insert(__FieldTag::__database_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_names",
                                ));
                            }
                            result.database_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__preferred_zone => {
                            if !fields.insert(__FieldTag::__preferred_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preferred_zone",
                                ));
                            }
                            result.preferred_zone =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.pitr_timestamp_ms) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitrTimestampMs", &__With(&self.pitr_timestamp_ms))?;
        }
        if !self.destination_instance_name.is_empty() {
            state.serialize_entry("destinationInstanceName", &self.destination_instance_name)?;
        }
        if self.bin_log_coordinates.is_some() {
            state.serialize_entry("binLogCoordinates", &self.bin_log_coordinates)?;
        }
        if self.point_in_time.is_some() {
            state.serialize_entry("pointInTime", &self.point_in_time)?;
        }
        if !self.allocated_ip_range.is_empty() {
            state.serialize_entry("allocatedIpRange", &self.allocated_ip_range)?;
        }
        if !self.database_names.is_empty() {
            state.serialize_entry("databaseNames", &self.database_names)?;
        }
        if self.preferred_zone.is_some() {
            state.serialize_entry("preferredZone", &self.preferred_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Binary log coordinates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BinLogCoordinates {
    /// Name of the binary log file for a Cloud SQL instance.
    pub bin_log_file_name: std::string::String,

    /// Position (offset) within the binary log file.
    pub bin_log_position: i64,

    /// This is always `sql#binLogCoordinates`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinLogCoordinates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bin_log_file_name][crate::model::BinLogCoordinates::bin_log_file_name].
    pub fn set_bin_log_file_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.bin_log_file_name = v.into();
        self
    }

    /// Sets the value of [bin_log_position][crate::model::BinLogCoordinates::bin_log_position].
    pub fn set_bin_log_position<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bin_log_position = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BinLogCoordinates::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BinLogCoordinates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BinLogCoordinates"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BinLogCoordinates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bin_log_file_name,
            __bin_log_position,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinLogCoordinates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "binLogFileName" => Ok(__FieldTag::__bin_log_file_name),
                            "bin_log_file_name" => Ok(__FieldTag::__bin_log_file_name),
                            "binLogPosition" => Ok(__FieldTag::__bin_log_position),
                            "bin_log_position" => Ok(__FieldTag::__bin_log_position),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BinLogCoordinates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinLogCoordinates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bin_log_file_name => {
                            if !fields.insert(__FieldTag::__bin_log_file_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bin_log_file_name",
                                ));
                            }
                            result.bin_log_file_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bin_log_position => {
                            if !fields.insert(__FieldTag::__bin_log_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bin_log_position",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bin_log_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BinLogCoordinates {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bin_log_file_name.is_empty() {
            state.serialize_entry("binLogFileName", &self.bin_log_file_name)?;
        }
        if !wkt::internal::is_default(&self.bin_log_position) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("binLogPosition", &__With(&self.bin_log_position))?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Cloud SQL instance resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseInstance {
    /// This is always `sql#instance`.
    pub kind: std::string::String,

    /// The current serving state of the Cloud SQL instance.
    pub state: crate::model::database_instance::SqlInstanceState,

    /// The database engine type and version. The `databaseVersion` field cannot
    /// be changed after instance creation.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// The user settings.
    pub settings: std::option::Option<crate::model::Settings>,

    /// This field is deprecated and will be removed from a future version of the
    /// API. Use the `settings.settingsVersion` field instead.
    pub etag: std::string::String,

    /// The name and status of the failover replica.
    pub failover_replica: std::option::Option<crate::model::database_instance::SqlFailoverReplica>,

    /// The name of the instance which will act as primary in the replication
    /// setup.
    pub master_instance_name: std::string::String,

    /// The replicas of the instance.
    pub replica_names: std::vec::Vec<std::string::String>,

    /// The maximum disk size of the instance in bytes.
    #[deprecated]
    pub max_disk_size: std::option::Option<wkt::Int64Value>,

    /// The current disk usage of the instance in bytes. This property has been
    /// deprecated. Use the
    /// "cloudsql.googleapis.com/database/disk/bytes_used" metric in Cloud
    /// Monitoring API instead. Please see [this
    /// announcement](https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ)
    /// for details.
    #[deprecated]
    pub current_disk_size: std::option::Option<wkt::Int64Value>,

    /// The assigned IP addresses for the instance.
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// SSL configuration.
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The instance type.
    pub instance_type: crate::model::SqlInstanceType,

    /// The project ID of the project containing the Cloud SQL instance. The Google
    /// apps domain is prefixed if applicable.
    pub project: std::string::String,

    /// The IPv6 address assigned to the instance.
    /// (Deprecated) This property was applicable only
    /// to First Generation instances.
    #[deprecated]
    pub ipv6_address: std::string::String,

    /// The service account email address assigned to the instance.\This
    /// property is read-only.
    pub service_account_email_address: std::string::String,

    /// Configuration specific to on-premises instances.
    pub on_premises_configuration: std::option::Option<crate::model::OnPremisesConfiguration>,

    /// Configuration specific to failover replicas and read replicas.
    pub replica_configuration: std::option::Option<crate::model::ReplicaConfiguration>,

    /// The backend type.
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    ///
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// The URI of this resource.
    pub self_link: std::string::String,

    /// If the instance state is SUSPENDED, the reason for the suspension.
    pub suspension_reason: std::vec::Vec<crate::model::SqlSuspensionReason>,

    /// Connection name of the Cloud SQL instance used in connection strings.
    pub connection_name: std::string::String,

    /// Name of the Cloud SQL instance. This does not include the project ID.
    pub name: std::string::String,

    /// The geographical region of the Cloud SQL instance.
    ///
    /// It can be one of the
    /// [regions](https://cloud.google.com/sql/docs/mysql/locations#location-r)
    /// where Cloud SQL operates:
    ///
    /// For example,  `asia-east1`, `europe-west1`, and  `us-central1`.
    /// The default value is `us-central1`.
    pub region: std::string::String,

    /// The Compute Engine zone that the instance is currently serving from. This
    /// value could be different from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary zone. WARNING:
    /// Changing this might restart the instance.
    pub gce_zone: std::string::String,

    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional instance. This value could be different
    /// from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary/failover zone.
    pub secondary_gce_zone: std::string::String,

    /// Disk encryption configuration specific to an instance.
    pub disk_encryption_configuration:
        std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Disk encryption status specific to an instance.
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Initial root password. Use only on creation. You must set root passwords
    /// before you can connect to PostgreSQL instances.
    pub root_password: std::string::String,

    /// The start time of any upcoming scheduled maintenance for this instance.
    pub scheduled_maintenance:
        std::option::Option<crate::model::database_instance::SqlScheduledMaintenance>,

    /// This status indicates whether the instance satisfies PZS.
    ///
    /// The status is reserved for future use.
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Stores the current database version running on the instance
    /// including minor version such as `MYSQL_8_0_18`.
    pub database_installed_version: std::string::String,

    /// This field represents the report generated by the proactive database
    /// wellness job for OutOfDisk issues.
    ///
    /// * Writers:
    /// * the proactive database wellness job for OOD.
    /// * Readers:
    /// * the proactive database wellness job
    pub out_of_disk_report:
        std::option::Option<crate::model::database_instance::SqlOutOfDiskReport>,

    /// Output only. The time when the instance was created in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. List all maintenance versions applicable on the instance
    pub available_maintenance_versions: std::vec::Vec<std::string::String>,

    /// The current software version on the instance.
    pub maintenance_version: std::string::String,

    /// Output only. All database versions that are available for upgrade.
    pub upgradable_database_versions: std::vec::Vec<crate::model::AvailableDatabaseVersion>,

    pub sql_network_architecture:
        std::option::Option<crate::model::database_instance::SqlNetworkArchitecture>,

    /// Output only. The link to service attachment of PSC instance.
    pub psc_service_attachment_link: std::option::Option<std::string::String>,

    /// Output only. The dns name of the instance.
    pub dns_name: std::option::Option<std::string::String>,

    /// Output only. DEPRECATED: please use write_endpoint instead.
    #[deprecated]
    pub primary_dns_name: std::option::Option<std::string::String>,

    /// Output only. The dns name of the primary instance in a replication group.
    pub write_endpoint: std::option::Option<std::string::String>,

    /// Optional. A primary instance and disaster recovery (DR) replica pair.
    /// A DR replica is a cross-region replica that you designate
    /// for failover in the event that the primary instance
    /// experiences regional failure. Only applicable to MySQL.
    pub replication_cluster: std::option::Option<crate::model::ReplicationCluster>,

    /// Gemini instance configuration.
    pub gemini_config: std::option::Option<crate::model::GeminiInstanceConfig>,

    /// Output only. This status indicates whether the instance satisfies PZI.
    ///
    /// The status is reserved for future use.
    pub satisfies_pzi: std::option::Option<wkt::BoolValue>,

    /// Input only. Whether Cloud SQL is enabled to switch storing point-in-time
    /// recovery log files from a data disk to Cloud Storage.
    pub switch_transaction_logs_to_cloud_storage_enabled: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabaseInstance::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatabaseInstance::state].
    pub fn set_state<T: std::convert::Into<crate::model::database_instance::SqlInstanceState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::DatabaseInstance::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::DatabaseInstance::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::DatabaseInstance::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Settings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::DatabaseInstance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [failover_replica][crate::model::DatabaseInstance::failover_replica].
    pub fn set_failover_replica<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlFailoverReplica>,
    {
        self.failover_replica = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failover_replica][crate::model::DatabaseInstance::failover_replica].
    pub fn set_or_clear_failover_replica<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlFailoverReplica>,
    {
        self.failover_replica = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DatabaseInstance::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [replica_names][crate::model::DatabaseInstance::replica_names].
    pub fn set_replica_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [max_disk_size][crate::model::DatabaseInstance::max_disk_size].
    #[deprecated]
    pub fn set_max_disk_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_disk_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_disk_size][crate::model::DatabaseInstance::max_disk_size].
    #[deprecated]
    pub fn set_or_clear_max_disk_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.max_disk_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_disk_size][crate::model::DatabaseInstance::current_disk_size].
    #[deprecated]
    pub fn set_current_disk_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.current_disk_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_disk_size][crate::model::DatabaseInstance::current_disk_size].
    #[deprecated]
    pub fn set_or_clear_current_disk_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.current_disk_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_addresses][crate::model::DatabaseInstance::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::DatabaseInstance::server_ca_cert].
    pub fn set_server_ca_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [server_ca_cert][crate::model::DatabaseInstance::server_ca_cert].
    pub fn set_or_clear_server_ca_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_type][crate::model::DatabaseInstance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::SqlInstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [project][crate::model::DatabaseInstance::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [ipv6_address][crate::model::DatabaseInstance::ipv6_address].
    #[deprecated]
    pub fn set_ipv6_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ipv6_address = v.into();
        self
    }

    /// Sets the value of [service_account_email_address][crate::model::DatabaseInstance::service_account_email_address].
    pub fn set_service_account_email_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email_address = v.into();
        self
    }

    /// Sets the value of [on_premises_configuration][crate::model::DatabaseInstance::on_premises_configuration].
    pub fn set_on_premises_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OnPremisesConfiguration>,
    {
        self.on_premises_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_premises_configuration][crate::model::DatabaseInstance::on_premises_configuration].
    pub fn set_or_clear_on_premises_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OnPremisesConfiguration>,
    {
        self.on_premises_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DatabaseInstance::replica_configuration].
    pub fn set_replica_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaConfiguration>,
    {
        self.replica_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_configuration][crate::model::DatabaseInstance::replica_configuration].
    pub fn set_or_clear_replica_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicaConfiguration>,
    {
        self.replica_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backend_type][crate::model::DatabaseInstance::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::DatabaseInstance::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [suspension_reason][crate::model::DatabaseInstance::suspension_reason].
    pub fn set_suspension_reason<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlSuspensionReason>,
    {
        use std::iter::Iterator;
        self.suspension_reason = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_name][crate::model::DatabaseInstance::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DatabaseInstance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DatabaseInstance::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::DatabaseInstance::gce_zone].
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [secondary_gce_zone][crate::model::DatabaseInstance::secondary_gce_zone].
    pub fn set_secondary_gce_zone<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_gce_zone = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::DatabaseInstance::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionConfiguration>,
    {
        self.disk_encryption_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_configuration][crate::model::DatabaseInstance::disk_encryption_configuration].
    pub fn set_or_clear_disk_encryption_configuration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionConfiguration>,
    {
        self.disk_encryption_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::DatabaseInstance::disk_encryption_status].
    pub fn set_disk_encryption_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionStatus>,
    {
        self.disk_encryption_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_status][crate::model::DatabaseInstance::disk_encryption_status].
    pub fn set_or_clear_disk_encryption_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskEncryptionStatus>,
    {
        self.disk_encryption_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [root_password][crate::model::DatabaseInstance::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [scheduled_maintenance][crate::model::DatabaseInstance::scheduled_maintenance].
    pub fn set_scheduled_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlScheduledMaintenance>,
    {
        self.scheduled_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduled_maintenance][crate::model::DatabaseInstance::scheduled_maintenance].
    pub fn set_or_clear_scheduled_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlScheduledMaintenance>,
    {
        self.scheduled_maintenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DatabaseInstance::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::DatabaseInstance::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_installed_version][crate::model::DatabaseInstance::database_installed_version].
    pub fn set_database_installed_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_installed_version = v.into();
        self
    }

    /// Sets the value of [out_of_disk_report][crate::model::DatabaseInstance::out_of_disk_report].
    pub fn set_out_of_disk_report<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlOutOfDiskReport>,
    {
        self.out_of_disk_report = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [out_of_disk_report][crate::model::DatabaseInstance::out_of_disk_report].
    pub fn set_or_clear_out_of_disk_report<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlOutOfDiskReport>,
    {
        self.out_of_disk_report = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::DatabaseInstance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DatabaseInstance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [available_maintenance_versions][crate::model::DatabaseInstance::available_maintenance_versions].
    pub fn set_available_maintenance_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_maintenance_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maintenance_version][crate::model::DatabaseInstance::maintenance_version].
    pub fn set_maintenance_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_version = v.into();
        self
    }

    /// Sets the value of [upgradable_database_versions][crate::model::DatabaseInstance::upgradable_database_versions].
    pub fn set_upgradable_database_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AvailableDatabaseVersion>,
    {
        use std::iter::Iterator;
        self.upgradable_database_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sql_network_architecture][crate::model::DatabaseInstance::sql_network_architecture].
    pub fn set_sql_network_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlNetworkArchitecture>,
    {
        self.sql_network_architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_network_architecture][crate::model::DatabaseInstance::sql_network_architecture].
    pub fn set_or_clear_sql_network_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_instance::SqlNetworkArchitecture>,
    {
        self.sql_network_architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [psc_service_attachment_link][crate::model::DatabaseInstance::psc_service_attachment_link].
    pub fn set_psc_service_attachment_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.psc_service_attachment_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_service_attachment_link][crate::model::DatabaseInstance::psc_service_attachment_link].
    pub fn set_or_clear_psc_service_attachment_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.psc_service_attachment_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dns_name][crate::model::DatabaseInstance::dns_name].
    pub fn set_dns_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.dns_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dns_name][crate::model::DatabaseInstance::dns_name].
    pub fn set_or_clear_dns_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.dns_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [primary_dns_name][crate::model::DatabaseInstance::primary_dns_name].
    #[deprecated]
    pub fn set_primary_dns_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.primary_dns_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_dns_name][crate::model::DatabaseInstance::primary_dns_name].
    #[deprecated]
    pub fn set_or_clear_primary_dns_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.primary_dns_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [write_endpoint][crate::model::DatabaseInstance::write_endpoint].
    pub fn set_write_endpoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.write_endpoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [write_endpoint][crate::model::DatabaseInstance::write_endpoint].
    pub fn set_or_clear_write_endpoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.write_endpoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_cluster][crate::model::DatabaseInstance::replication_cluster].
    pub fn set_replication_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCluster>,
    {
        self.replication_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_cluster][crate::model::DatabaseInstance::replication_cluster].
    pub fn set_or_clear_replication_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCluster>,
    {
        self.replication_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gemini_config][crate::model::DatabaseInstance::gemini_config].
    pub fn set_gemini_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GeminiInstanceConfig>,
    {
        self.gemini_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gemini_config][crate::model::DatabaseInstance::gemini_config].
    pub fn set_or_clear_gemini_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GeminiInstanceConfig>,
    {
        self.gemini_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DatabaseInstance::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::DatabaseInstance::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [switch_transaction_logs_to_cloud_storage_enabled][crate::model::DatabaseInstance::switch_transaction_logs_to_cloud_storage_enabled].
    pub fn set_switch_transaction_logs_to_cloud_storage_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.switch_transaction_logs_to_cloud_storage_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [switch_transaction_logs_to_cloud_storage_enabled][crate::model::DatabaseInstance::switch_transaction_logs_to_cloud_storage_enabled].
    pub fn set_or_clear_switch_transaction_logs_to_cloud_storage_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.switch_transaction_logs_to_cloud_storage_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatabaseInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseInstance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __state,
            __database_version,
            __settings,
            __etag,
            __failover_replica,
            __master_instance_name,
            __replica_names,
            __max_disk_size,
            __current_disk_size,
            __ip_addresses,
            __server_ca_cert,
            __instance_type,
            __project,
            __ipv6_address,
            __service_account_email_address,
            __on_premises_configuration,
            __replica_configuration,
            __backend_type,
            __self_link,
            __suspension_reason,
            __connection_name,
            __name,
            __region,
            __gce_zone,
            __secondary_gce_zone,
            __disk_encryption_configuration,
            __disk_encryption_status,
            __root_password,
            __scheduled_maintenance,
            __satisfies_pzs,
            __database_installed_version,
            __out_of_disk_report,
            __create_time,
            __available_maintenance_versions,
            __maintenance_version,
            __upgradable_database_versions,
            __sql_network_architecture,
            __psc_service_attachment_link,
            __dns_name,
            __primary_dns_name,
            __write_endpoint,
            __replication_cluster,
            __gemini_config,
            __satisfies_pzi,
            __switch_transaction_logs_to_cloud_storage_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseInstance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "state" => Ok(__FieldTag::__state),
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "settings" => Ok(__FieldTag::__settings),
                            "etag" => Ok(__FieldTag::__etag),
                            "failoverReplica" => Ok(__FieldTag::__failover_replica),
                            "failover_replica" => Ok(__FieldTag::__failover_replica),
                            "masterInstanceName" => Ok(__FieldTag::__master_instance_name),
                            "master_instance_name" => Ok(__FieldTag::__master_instance_name),
                            "replicaNames" => Ok(__FieldTag::__replica_names),
                            "replica_names" => Ok(__FieldTag::__replica_names),
                            "maxDiskSize" => Ok(__FieldTag::__max_disk_size),
                            "max_disk_size" => Ok(__FieldTag::__max_disk_size),
                            "currentDiskSize" => Ok(__FieldTag::__current_disk_size),
                            "current_disk_size" => Ok(__FieldTag::__current_disk_size),
                            "ipAddresses" => Ok(__FieldTag::__ip_addresses),
                            "ip_addresses" => Ok(__FieldTag::__ip_addresses),
                            "serverCaCert" => Ok(__FieldTag::__server_ca_cert),
                            "server_ca_cert" => Ok(__FieldTag::__server_ca_cert),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "project" => Ok(__FieldTag::__project),
                            "ipv6Address" => Ok(__FieldTag::__ipv6_address),
                            "ipv6_address" => Ok(__FieldTag::__ipv6_address),
                            "serviceAccountEmailAddress" => {
                                Ok(__FieldTag::__service_account_email_address)
                            }
                            "service_account_email_address" => {
                                Ok(__FieldTag::__service_account_email_address)
                            }
                            "onPremisesConfiguration" => {
                                Ok(__FieldTag::__on_premises_configuration)
                            }
                            "on_premises_configuration" => {
                                Ok(__FieldTag::__on_premises_configuration)
                            }
                            "replicaConfiguration" => Ok(__FieldTag::__replica_configuration),
                            "replica_configuration" => Ok(__FieldTag::__replica_configuration),
                            "backendType" => Ok(__FieldTag::__backend_type),
                            "backend_type" => Ok(__FieldTag::__backend_type),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "suspensionReason" => Ok(__FieldTag::__suspension_reason),
                            "suspension_reason" => Ok(__FieldTag::__suspension_reason),
                            "connectionName" => Ok(__FieldTag::__connection_name),
                            "connection_name" => Ok(__FieldTag::__connection_name),
                            "name" => Ok(__FieldTag::__name),
                            "region" => Ok(__FieldTag::__region),
                            "gceZone" => Ok(__FieldTag::__gce_zone),
                            "gce_zone" => Ok(__FieldTag::__gce_zone),
                            "secondaryGceZone" => Ok(__FieldTag::__secondary_gce_zone),
                            "secondary_gce_zone" => Ok(__FieldTag::__secondary_gce_zone),
                            "diskEncryptionConfiguration" => {
                                Ok(__FieldTag::__disk_encryption_configuration)
                            }
                            "disk_encryption_configuration" => {
                                Ok(__FieldTag::__disk_encryption_configuration)
                            }
                            "diskEncryptionStatus" => Ok(__FieldTag::__disk_encryption_status),
                            "disk_encryption_status" => Ok(__FieldTag::__disk_encryption_status),
                            "rootPassword" => Ok(__FieldTag::__root_password),
                            "root_password" => Ok(__FieldTag::__root_password),
                            "scheduledMaintenance" => Ok(__FieldTag::__scheduled_maintenance),
                            "scheduled_maintenance" => Ok(__FieldTag::__scheduled_maintenance),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "databaseInstalledVersion" => {
                                Ok(__FieldTag::__database_installed_version)
                            }
                            "database_installed_version" => {
                                Ok(__FieldTag::__database_installed_version)
                            }
                            "outOfDiskReport" => Ok(__FieldTag::__out_of_disk_report),
                            "out_of_disk_report" => Ok(__FieldTag::__out_of_disk_report),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "availableMaintenanceVersions" => {
                                Ok(__FieldTag::__available_maintenance_versions)
                            }
                            "available_maintenance_versions" => {
                                Ok(__FieldTag::__available_maintenance_versions)
                            }
                            "maintenanceVersion" => Ok(__FieldTag::__maintenance_version),
                            "maintenance_version" => Ok(__FieldTag::__maintenance_version),
                            "upgradableDatabaseVersions" => {
                                Ok(__FieldTag::__upgradable_database_versions)
                            }
                            "upgradable_database_versions" => {
                                Ok(__FieldTag::__upgradable_database_versions)
                            }
                            "sqlNetworkArchitecture" => Ok(__FieldTag::__sql_network_architecture),
                            "sql_network_architecture" => {
                                Ok(__FieldTag::__sql_network_architecture)
                            }
                            "pscServiceAttachmentLink" => {
                                Ok(__FieldTag::__psc_service_attachment_link)
                            }
                            "psc_service_attachment_link" => {
                                Ok(__FieldTag::__psc_service_attachment_link)
                            }
                            "dnsName" => Ok(__FieldTag::__dns_name),
                            "dns_name" => Ok(__FieldTag::__dns_name),
                            "primaryDnsName" => Ok(__FieldTag::__primary_dns_name),
                            "primary_dns_name" => Ok(__FieldTag::__primary_dns_name),
                            "writeEndpoint" => Ok(__FieldTag::__write_endpoint),
                            "write_endpoint" => Ok(__FieldTag::__write_endpoint),
                            "replicationCluster" => Ok(__FieldTag::__replication_cluster),
                            "replication_cluster" => Ok(__FieldTag::__replication_cluster),
                            "geminiConfig" => Ok(__FieldTag::__gemini_config),
                            "gemini_config" => Ok(__FieldTag::__gemini_config),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "switchTransactionLogsToCloudStorageEnabled" => {
                                Ok(__FieldTag::__switch_transaction_logs_to_cloud_storage_enabled)
                            }
                            "switch_transaction_logs_to_cloud_storage_enabled" => {
                                Ok(__FieldTag::__switch_transaction_logs_to_cloud_storage_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseInstance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseInstance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::database_instance::SqlInstanceState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map.next_value::<std::option::Option<crate::model::SqlDatabaseVersion>>()?.unwrap_or_default();
                        }
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings =
                                map.next_value::<std::option::Option<crate::model::Settings>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failover_replica => {
                            if !fields.insert(__FieldTag::__failover_replica) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failover_replica",
                                ));
                            }
                            result.failover_replica = map.next_value::<std::option::Option<
                                crate::model::database_instance::SqlFailoverReplica,
                            >>()?;
                        }
                        __FieldTag::__master_instance_name => {
                            if !fields.insert(__FieldTag::__master_instance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_instance_name",
                                ));
                            }
                            result.master_instance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_names => {
                            if !fields.insert(__FieldTag::__replica_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_names",
                                ));
                            }
                            result.replica_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_disk_size => {
                            if !fields.insert(__FieldTag::__max_disk_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_disk_size",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_disk_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__current_disk_size => {
                            if !fields.insert(__FieldTag::__current_disk_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_disk_size",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.current_disk_size = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__ip_addresses => {
                            if !fields.insert(__FieldTag::__ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_addresses",
                                ));
                            }
                            result.ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IpMapping>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__server_ca_cert => {
                            if !fields.insert(__FieldTag::__server_ca_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ca_cert",
                                ));
                            }
                            result.server_ca_cert =
                                map.next_value::<std::option::Option<crate::model::SslCert>>()?;
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<crate::model::SqlInstanceType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ipv6_address => {
                            if !fields.insert(__FieldTag::__ipv6_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_address",
                                ));
                            }
                            result.ipv6_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_email_address => {
                            if !fields.insert(__FieldTag::__service_account_email_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email_address",
                                ));
                            }
                            result.service_account_email_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__on_premises_configuration => {
                            if !fields.insert(__FieldTag::__on_premises_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for on_premises_configuration",
                                ));
                            }
                            result.on_premises_configuration = map.next_value::<std::option::Option<crate::model::OnPremisesConfiguration>>()?
                                ;
                        }
                        __FieldTag::__replica_configuration => {
                            if !fields.insert(__FieldTag::__replica_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_configuration",
                                ));
                            }
                            result.replica_configuration = map.next_value::<std::option::Option<crate::model::ReplicaConfiguration>>()?
                                ;
                        }
                        __FieldTag::__backend_type => {
                            if !fields.insert(__FieldTag::__backend_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backend_type",
                                ));
                            }
                            result.backend_type = map
                                .next_value::<std::option::Option<crate::model::SqlBackendType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suspension_reason => {
                            if !fields.insert(__FieldTag::__suspension_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspension_reason",
                                ));
                            }
                            result.suspension_reason = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlSuspensionReason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_name => {
                            if !fields.insert(__FieldTag::__connection_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_name",
                                ));
                            }
                            result.connection_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gce_zone => {
                            if !fields.insert(__FieldTag::__gce_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_zone",
                                ));
                            }
                            result.gce_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_gce_zone => {
                            if !fields.insert(__FieldTag::__secondary_gce_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_gce_zone",
                                ));
                            }
                            result.secondary_gce_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_encryption_configuration => {
                            if !fields.insert(__FieldTag::__disk_encryption_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption_configuration",
                                ));
                            }
                            result.disk_encryption_configuration = map.next_value::<std::option::Option<crate::model::DiskEncryptionConfiguration>>()?
                                ;
                        }
                        __FieldTag::__disk_encryption_status => {
                            if !fields.insert(__FieldTag::__disk_encryption_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption_status",
                                ));
                            }
                            result.disk_encryption_status = map.next_value::<std::option::Option<crate::model::DiskEncryptionStatus>>()?
                                ;
                        }
                        __FieldTag::__root_password => {
                            if !fields.insert(__FieldTag::__root_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_password",
                                ));
                            }
                            result.root_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduled_maintenance => {
                            if !fields.insert(__FieldTag::__scheduled_maintenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_maintenance",
                                ));
                            }
                            result.scheduled_maintenance = map.next_value::<std::option::Option<
                                crate::model::database_instance::SqlScheduledMaintenance,
                            >>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__database_installed_version => {
                            if !fields.insert(__FieldTag::__database_installed_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_installed_version",
                                ));
                            }
                            result.database_installed_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__out_of_disk_report => {
                            if !fields.insert(__FieldTag::__out_of_disk_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for out_of_disk_report",
                                ));
                            }
                            result.out_of_disk_report = map.next_value::<std::option::Option<
                                crate::model::database_instance::SqlOutOfDiskReport,
                            >>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__available_maintenance_versions => {
                            if !fields.insert(__FieldTag::__available_maintenance_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_maintenance_versions",
                                ));
                            }
                            result.available_maintenance_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__maintenance_version => {
                            if !fields.insert(__FieldTag::__maintenance_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_version",
                                ));
                            }
                            result.maintenance_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgradable_database_versions => {
                            if !fields.insert(__FieldTag::__upgradable_database_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgradable_database_versions",
                                ));
                            }
                            result.upgradable_database_versions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AvailableDatabaseVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_network_architecture => {
                            if !fields.insert(__FieldTag::__sql_network_architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_network_architecture",
                                ));
                            }
                            result.sql_network_architecture = map
                                .next_value::<std::option::Option<
                                    crate::model::database_instance::SqlNetworkArchitecture,
                                >>()?;
                        }
                        __FieldTag::__psc_service_attachment_link => {
                            if !fields.insert(__FieldTag::__psc_service_attachment_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachment_link",
                                ));
                            }
                            result.psc_service_attachment_link =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__dns_name => {
                            if !fields.insert(__FieldTag::__dns_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_name",
                                ));
                            }
                            result.dns_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__primary_dns_name => {
                            if !fields.insert(__FieldTag::__primary_dns_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_dns_name",
                                ));
                            }
                            result.primary_dns_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__write_endpoint => {
                            if !fields.insert(__FieldTag::__write_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_endpoint",
                                ));
                            }
                            result.write_endpoint =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__replication_cluster => {
                            if !fields.insert(__FieldTag::__replication_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_cluster",
                                ));
                            }
                            result.replication_cluster = map.next_value::<std::option::Option<crate::model::ReplicationCluster>>()?
                                ;
                        }
                        __FieldTag::__gemini_config => {
                            if !fields.insert(__FieldTag::__gemini_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gemini_config",
                                ));
                            }
                            result.gemini_config = map.next_value::<std::option::Option<crate::model::GeminiInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__switch_transaction_logs_to_cloud_storage_enabled => {
                            if !fields.insert(
                                __FieldTag::__switch_transaction_logs_to_cloud_storage_enabled,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for switch_transaction_logs_to_cloud_storage_enabled",
                                ));
                            }
                            result.switch_transaction_logs_to_cloud_storage_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.database_version) {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.failover_replica.is_some() {
            state.serialize_entry("failoverReplica", &self.failover_replica)?;
        }
        if !self.master_instance_name.is_empty() {
            state.serialize_entry("masterInstanceName", &self.master_instance_name)?;
        }
        if !self.replica_names.is_empty() {
            state.serialize_entry("replicaNames", &self.replica_names)?;
        }
        if self.max_disk_size.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxDiskSize", &__With(&self.max_disk_size))?;
        }
        if self.current_disk_size.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("currentDiskSize", &__With(&self.current_disk_size))?;
        }
        if !self.ip_addresses.is_empty() {
            state.serialize_entry("ipAddresses", &self.ip_addresses)?;
        }
        if self.server_ca_cert.is_some() {
            state.serialize_entry("serverCaCert", &self.server_ca_cert)?;
        }
        if !wkt::internal::is_default(&self.instance_type) {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.ipv6_address.is_empty() {
            state.serialize_entry("ipv6Address", &self.ipv6_address)?;
        }
        if !self.service_account_email_address.is_empty() {
            state.serialize_entry(
                "serviceAccountEmailAddress",
                &self.service_account_email_address,
            )?;
        }
        if self.on_premises_configuration.is_some() {
            state.serialize_entry("onPremisesConfiguration", &self.on_premises_configuration)?;
        }
        if self.replica_configuration.is_some() {
            state.serialize_entry("replicaConfiguration", &self.replica_configuration)?;
        }
        if !wkt::internal::is_default(&self.backend_type) {
            state.serialize_entry("backendType", &self.backend_type)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.suspension_reason.is_empty() {
            state.serialize_entry("suspensionReason", &self.suspension_reason)?;
        }
        if !self.connection_name.is_empty() {
            state.serialize_entry("connectionName", &self.connection_name)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.gce_zone.is_empty() {
            state.serialize_entry("gceZone", &self.gce_zone)?;
        }
        if !self.secondary_gce_zone.is_empty() {
            state.serialize_entry("secondaryGceZone", &self.secondary_gce_zone)?;
        }
        if self.disk_encryption_configuration.is_some() {
            state.serialize_entry(
                "diskEncryptionConfiguration",
                &self.disk_encryption_configuration,
            )?;
        }
        if self.disk_encryption_status.is_some() {
            state.serialize_entry("diskEncryptionStatus", &self.disk_encryption_status)?;
        }
        if !self.root_password.is_empty() {
            state.serialize_entry("rootPassword", &self.root_password)?;
        }
        if self.scheduled_maintenance.is_some() {
            state.serialize_entry("scheduledMaintenance", &self.scheduled_maintenance)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self.database_installed_version.is_empty() {
            state.serialize_entry("databaseInstalledVersion", &self.database_installed_version)?;
        }
        if self.out_of_disk_report.is_some() {
            state.serialize_entry("outOfDiskReport", &self.out_of_disk_report)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.available_maintenance_versions.is_empty() {
            state.serialize_entry(
                "availableMaintenanceVersions",
                &self.available_maintenance_versions,
            )?;
        }
        if !self.maintenance_version.is_empty() {
            state.serialize_entry("maintenanceVersion", &self.maintenance_version)?;
        }
        if !self.upgradable_database_versions.is_empty() {
            state.serialize_entry(
                "upgradableDatabaseVersions",
                &self.upgradable_database_versions,
            )?;
        }
        if self.sql_network_architecture.is_some() {
            state.serialize_entry("sqlNetworkArchitecture", &self.sql_network_architecture)?;
        }
        if self.psc_service_attachment_link.is_some() {
            state.serialize_entry(
                "pscServiceAttachmentLink",
                &self.psc_service_attachment_link,
            )?;
        }
        if self.dns_name.is_some() {
            state.serialize_entry("dnsName", &self.dns_name)?;
        }
        if self.primary_dns_name.is_some() {
            state.serialize_entry("primaryDnsName", &self.primary_dns_name)?;
        }
        if self.write_endpoint.is_some() {
            state.serialize_entry("writeEndpoint", &self.write_endpoint)?;
        }
        if self.replication_cluster.is_some() {
            state.serialize_entry("replicationCluster", &self.replication_cluster)?;
        }
        if self.gemini_config.is_some() {
            state.serialize_entry("geminiConfig", &self.gemini_config)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self
            .switch_transaction_logs_to_cloud_storage_enabled
            .is_some()
        {
            state.serialize_entry(
                "switchTransactionLogsToCloudStorageEnabled",
                &self.switch_transaction_logs_to_cloud_storage_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatabaseInstance].
pub mod database_instance {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlFailoverReplica {
        /// The name of the failover replica. If specified at instance creation, a
        /// failover replica is created for the instance. The name
        /// doesn't include the project ID.
        pub name: std::string::String,

        /// The availability status of the failover replica. A false status indicates
        /// that the failover replica is out of sync. The primary instance can only
        /// failover to the failover replica when the status is true.
        pub available: std::option::Option<wkt::BoolValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlFailoverReplica {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::database_instance::SqlFailoverReplica::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [available][crate::model::database_instance::SqlFailoverReplica::available].
        pub fn set_available<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.available = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [available][crate::model::database_instance::SqlFailoverReplica::available].
        pub fn set_or_clear_available<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.available = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlFailoverReplica {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlFailoverReplica"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlFailoverReplica {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __available,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlFailoverReplica")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "available" => Ok(__FieldTag::__available),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlFailoverReplica;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlFailoverReplica")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__available => {
                                if !fields.insert(__FieldTag::__available) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for available",
                                    ));
                                }
                                result.available =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlFailoverReplica {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if self.available.is_some() {
                state.serialize_entry("available", &self.available)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Any scheduled maintenance for this instance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlScheduledMaintenance {
        /// The start time of any upcoming scheduled maintenance for this instance.
        pub start_time: std::option::Option<wkt::Timestamp>,

        #[deprecated]
        pub can_defer: bool,

        /// If the scheduled maintenance can be rescheduled.
        pub can_reschedule: bool,

        /// Maintenance cannot be rescheduled to start beyond this deadline.
        pub schedule_deadline_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlScheduledMaintenance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::database_instance::SqlScheduledMaintenance::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::database_instance::SqlScheduledMaintenance::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [can_defer][crate::model::database_instance::SqlScheduledMaintenance::can_defer].
        #[deprecated]
        pub fn set_can_defer<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_defer = v.into();
            self
        }

        /// Sets the value of [can_reschedule][crate::model::database_instance::SqlScheduledMaintenance::can_reschedule].
        pub fn set_can_reschedule<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_reschedule = v.into();
            self
        }

        /// Sets the value of [schedule_deadline_time][crate::model::database_instance::SqlScheduledMaintenance::schedule_deadline_time].
        pub fn set_schedule_deadline_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_deadline_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schedule_deadline_time][crate::model::database_instance::SqlScheduledMaintenance::schedule_deadline_time].
        pub fn set_or_clear_schedule_deadline_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_deadline_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlScheduledMaintenance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlScheduledMaintenance"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlScheduledMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __can_defer,
                __can_reschedule,
                __schedule_deadline_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlScheduledMaintenance")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "canDefer" => Ok(__FieldTag::__can_defer),
                                "can_defer" => Ok(__FieldTag::__can_defer),
                                "canReschedule" => Ok(__FieldTag::__can_reschedule),
                                "can_reschedule" => Ok(__FieldTag::__can_reschedule),
                                "scheduleDeadlineTime" => Ok(__FieldTag::__schedule_deadline_time),
                                "schedule_deadline_time" => {
                                    Ok(__FieldTag::__schedule_deadline_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlScheduledMaintenance;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlScheduledMaintenance")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__can_defer => {
                                if !fields.insert(__FieldTag::__can_defer) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for can_defer",
                                    ));
                                }
                                result.can_defer = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__can_reschedule => {
                                if !fields.insert(__FieldTag::__can_reschedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for can_reschedule",
                                    ));
                                }
                                result.can_reschedule = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__schedule_deadline_time => {
                                if !fields.insert(__FieldTag::__schedule_deadline_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule_deadline_time",
                                    ));
                                }
                                result.schedule_deadline_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlScheduledMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if !wkt::internal::is_default(&self.can_defer) {
                state.serialize_entry("canDefer", &self.can_defer)?;
            }
            if !wkt::internal::is_default(&self.can_reschedule) {
                state.serialize_entry("canReschedule", &self.can_reschedule)?;
            }
            if self.schedule_deadline_time.is_some() {
                state.serialize_entry("scheduleDeadlineTime", &self.schedule_deadline_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// This message wraps up the information written by out-of-disk detection job.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlOutOfDiskReport {
        /// This field represents the state generated by the proactive database
        /// wellness job for OutOfDisk issues.
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        /// * the proactive database wellness job
        pub sql_out_of_disk_state: std::option::Option<
            crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState,
        >,

        /// The minimum recommended increase size in GigaBytes
        /// This field is consumed by the frontend
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        pub sql_min_recommended_increase_size_gb: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlOutOfDiskReport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_out_of_disk_state][crate::model::database_instance::SqlOutOfDiskReport::sql_out_of_disk_state].
        pub fn set_sql_out_of_disk_state<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState,
                >,
        {
            self.sql_out_of_disk_state = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sql_out_of_disk_state][crate::model::database_instance::SqlOutOfDiskReport::sql_out_of_disk_state].
        pub fn set_or_clear_sql_out_of_disk_state<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState,
                >,
        {
            self.sql_out_of_disk_state = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sql_min_recommended_increase_size_gb][crate::model::database_instance::SqlOutOfDiskReport::sql_min_recommended_increase_size_gb].
        pub fn set_sql_min_recommended_increase_size_gb<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.sql_min_recommended_increase_size_gb = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sql_min_recommended_increase_size_gb][crate::model::database_instance::SqlOutOfDiskReport::sql_min_recommended_increase_size_gb].
        pub fn set_or_clear_sql_min_recommended_increase_size_gb<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.sql_min_recommended_increase_size_gb = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlOutOfDiskReport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlOutOfDiskReport"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlOutOfDiskReport {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sql_out_of_disk_state,
                __sql_min_recommended_increase_size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlOutOfDiskReport")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sqlOutOfDiskState" => Ok(__FieldTag::__sql_out_of_disk_state),
                                "sql_out_of_disk_state" => Ok(__FieldTag::__sql_out_of_disk_state),
                                "sqlMinRecommendedIncreaseSizeGb" => {
                                    Ok(__FieldTag::__sql_min_recommended_increase_size_gb)
                                }
                                "sql_min_recommended_increase_size_gb" => {
                                    Ok(__FieldTag::__sql_min_recommended_increase_size_gb)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlOutOfDiskReport;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlOutOfDiskReport")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sql_out_of_disk_state => {
                                if !fields.insert(__FieldTag::__sql_out_of_disk_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_out_of_disk_state",
                                    ));
                                }
                                result.sql_out_of_disk_state = map.next_value::<std::option::Option<crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState>>()?
                                    ;
                            }
                            __FieldTag::__sql_min_recommended_increase_size_gb => {
                                if !fields
                                    .insert(__FieldTag::__sql_min_recommended_increase_size_gb)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_min_recommended_increase_size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.sql_min_recommended_increase_size_gb =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlOutOfDiskReport {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.sql_out_of_disk_state.is_some() {
                state.serialize_entry("sqlOutOfDiskState", &self.sql_out_of_disk_state)?;
            }
            if self.sql_min_recommended_increase_size_gb.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "sqlMinRecommendedIncreaseSizeGb",
                    &__With(&self.sql_min_recommended_increase_size_gb),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SqlOutOfDiskReport].
    pub mod sql_out_of_disk_report {
        #[allow(unused_imports)]
        use super::*;

        /// This enum lists all possible states regarding out-of-disk issues.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SqlOutOfDiskState {
            /// Unspecified state
            Unspecified,
            /// The instance has plenty space on data disk
            Normal,
            /// Data disk is almost used up. It is shutdown to prevent data
            /// corruption.
            SoftShutdown,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SqlOutOfDiskState::value] or
            /// [SqlOutOfDiskState::name].
            UnknownValue(sql_out_of_disk_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sql_out_of_disk_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SqlOutOfDiskState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Normal => std::option::Option::Some(1),
                    Self::SoftShutdown => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SQL_OUT_OF_DISK_STATE_UNSPECIFIED")
                    }
                    Self::Normal => std::option::Option::Some("NORMAL"),
                    Self::SoftShutdown => std::option::Option::Some("SOFT_SHUTDOWN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SqlOutOfDiskState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SqlOutOfDiskState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SqlOutOfDiskState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Normal,
                    2 => Self::SoftShutdown,
                    _ => Self::UnknownValue(sql_out_of_disk_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SqlOutOfDiskState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" => Self::Unspecified,
                    "NORMAL" => Self::Normal,
                    "SOFT_SHUTDOWN" => Self::SoftShutdown,
                    _ => Self::UnknownValue(sql_out_of_disk_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SqlOutOfDiskState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Normal => serializer.serialize_i32(1),
                    Self::SoftShutdown => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SqlOutOfDiskState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOutOfDiskState>::new(
                    ".google.cloud.sql.v1.DatabaseInstance.SqlOutOfDiskReport.SqlOutOfDiskState",
                ))
            }
        }
    }

    /// The current serving state of the database instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlInstanceState {
        /// The state of the instance is unknown.
        Unspecified,
        /// The instance is running, or has been stopped by owner.
        Runnable,
        /// The instance is not available, for example due to problems with billing.
        Suspended,
        /// The instance is being deleted.
        PendingDelete,
        /// The instance is being created.
        PendingCreate,
        /// The instance is down for maintenance.
        Maintenance,
        /// The creation of the instance failed or a fatal error occurred during
        /// maintenance.
        Failed,
        /// Deprecated
        #[deprecated]
        OnlineMaintenance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlInstanceState::value] or
        /// [SqlInstanceState::name].
        UnknownValue(sql_instance_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlInstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Runnable => std::option::Option::Some(1),
                Self::Suspended => std::option::Option::Some(2),
                Self::PendingDelete => std::option::Option::Some(3),
                Self::PendingCreate => std::option::Option::Some(4),
                Self::Maintenance => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::OnlineMaintenance => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_INSTANCE_STATE_UNSPECIFIED"),
                Self::Runnable => std::option::Option::Some("RUNNABLE"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::PendingDelete => std::option::Option::Some("PENDING_DELETE"),
                Self::PendingCreate => std::option::Option::Some("PENDING_CREATE"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::OnlineMaintenance => std::option::Option::Some("ONLINE_MAINTENANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlInstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlInstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlInstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Runnable,
                2 => Self::Suspended,
                3 => Self::PendingDelete,
                4 => Self::PendingCreate,
                5 => Self::Maintenance,
                6 => Self::Failed,
                7 => Self::OnlineMaintenance,
                _ => Self::UnknownValue(sql_instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlInstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_INSTANCE_STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNABLE" => Self::Runnable,
                "SUSPENDED" => Self::Suspended,
                "PENDING_DELETE" => Self::PendingDelete,
                "PENDING_CREATE" => Self::PendingCreate,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "ONLINE_MAINTENANCE" => Self::OnlineMaintenance,
                _ => Self::UnknownValue(sql_instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlInstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Runnable => serializer.serialize_i32(1),
                Self::Suspended => serializer.serialize_i32(2),
                Self::PendingDelete => serializer.serialize_i32(3),
                Self::PendingCreate => serializer.serialize_i32(4),
                Self::Maintenance => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::OnlineMaintenance => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlInstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlInstanceState>::new(
                ".google.cloud.sql.v1.DatabaseInstance.SqlInstanceState",
            ))
        }
    }

    /// The SQL network architecture for the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlNetworkArchitecture {
        Unspecified,
        /// The instance uses the new network architecture.
        NewNetworkArchitecture,
        /// The instance uses the old network architecture.
        OldNetworkArchitecture,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlNetworkArchitecture::value] or
        /// [SqlNetworkArchitecture::name].
        UnknownValue(sql_network_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_network_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlNetworkArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NewNetworkArchitecture => std::option::Option::Some(1),
                Self::OldNetworkArchitecture => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SQL_NETWORK_ARCHITECTURE_UNSPECIFIED")
                }
                Self::NewNetworkArchitecture => {
                    std::option::Option::Some("NEW_NETWORK_ARCHITECTURE")
                }
                Self::OldNetworkArchitecture => {
                    std::option::Option::Some("OLD_NETWORK_ARCHITECTURE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlNetworkArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlNetworkArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlNetworkArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NewNetworkArchitecture,
                2 => Self::OldNetworkArchitecture,
                _ => Self::UnknownValue(sql_network_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlNetworkArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "NEW_NETWORK_ARCHITECTURE" => Self::NewNetworkArchitecture,
                "OLD_NETWORK_ARCHITECTURE" => Self::OldNetworkArchitecture,
                _ => Self::UnknownValue(sql_network_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlNetworkArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NewNetworkArchitecture => serializer.serialize_i32(1),
                Self::OldNetworkArchitecture => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlNetworkArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlNetworkArchitecture>::new(
                ".google.cloud.sql.v1.DatabaseInstance.SqlNetworkArchitecture",
            ))
        }
    }
}

/// Gemini instance configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GeminiInstanceConfig {
    /// Output only. Whether Gemini is enabled.
    pub entitled: std::option::Option<bool>,

    /// Output only. Whether the vacuum management is enabled.
    pub google_vacuum_mgmt_enabled: std::option::Option<bool>,

    /// Output only. Whether canceling the out-of-memory (OOM) session is enabled.
    pub oom_session_cancel_enabled: std::option::Option<bool>,

    /// Output only. Whether the active query is enabled.
    pub active_query_enabled: std::option::Option<bool>,

    /// Output only. Whether the index advisor is enabled.
    pub index_advisor_enabled: std::option::Option<bool>,

    /// Output only. Whether the flag recommender is enabled.
    pub flag_recommender_enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GeminiInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitled][crate::model::GeminiInstanceConfig::entitled].
    pub fn set_entitled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.entitled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entitled][crate::model::GeminiInstanceConfig::entitled].
    pub fn set_or_clear_entitled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.entitled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [google_vacuum_mgmt_enabled][crate::model::GeminiInstanceConfig::google_vacuum_mgmt_enabled].
    pub fn set_google_vacuum_mgmt_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.google_vacuum_mgmt_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [google_vacuum_mgmt_enabled][crate::model::GeminiInstanceConfig::google_vacuum_mgmt_enabled].
    pub fn set_or_clear_google_vacuum_mgmt_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.google_vacuum_mgmt_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [oom_session_cancel_enabled][crate::model::GeminiInstanceConfig::oom_session_cancel_enabled].
    pub fn set_oom_session_cancel_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.oom_session_cancel_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [oom_session_cancel_enabled][crate::model::GeminiInstanceConfig::oom_session_cancel_enabled].
    pub fn set_or_clear_oom_session_cancel_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.oom_session_cancel_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_query_enabled][crate::model::GeminiInstanceConfig::active_query_enabled].
    pub fn set_active_query_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.active_query_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [active_query_enabled][crate::model::GeminiInstanceConfig::active_query_enabled].
    pub fn set_or_clear_active_query_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.active_query_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index_advisor_enabled][crate::model::GeminiInstanceConfig::index_advisor_enabled].
    pub fn set_index_advisor_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.index_advisor_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_advisor_enabled][crate::model::GeminiInstanceConfig::index_advisor_enabled].
    pub fn set_or_clear_index_advisor_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.index_advisor_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [flag_recommender_enabled][crate::model::GeminiInstanceConfig::flag_recommender_enabled].
    pub fn set_flag_recommender_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flag_recommender_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flag_recommender_enabled][crate::model::GeminiInstanceConfig::flag_recommender_enabled].
    pub fn set_or_clear_flag_recommender_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flag_recommender_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GeminiInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GeminiInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GeminiInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitled,
            __google_vacuum_mgmt_enabled,
            __oom_session_cancel_enabled,
            __active_query_enabled,
            __index_advisor_enabled,
            __flag_recommender_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeminiInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitled" => Ok(__FieldTag::__entitled),
                            "googleVacuumMgmtEnabled" => {
                                Ok(__FieldTag::__google_vacuum_mgmt_enabled)
                            }
                            "google_vacuum_mgmt_enabled" => {
                                Ok(__FieldTag::__google_vacuum_mgmt_enabled)
                            }
                            "oomSessionCancelEnabled" => {
                                Ok(__FieldTag::__oom_session_cancel_enabled)
                            }
                            "oom_session_cancel_enabled" => {
                                Ok(__FieldTag::__oom_session_cancel_enabled)
                            }
                            "activeQueryEnabled" => Ok(__FieldTag::__active_query_enabled),
                            "active_query_enabled" => Ok(__FieldTag::__active_query_enabled),
                            "indexAdvisorEnabled" => Ok(__FieldTag::__index_advisor_enabled),
                            "index_advisor_enabled" => Ok(__FieldTag::__index_advisor_enabled),
                            "flagRecommenderEnabled" => Ok(__FieldTag::__flag_recommender_enabled),
                            "flag_recommender_enabled" => {
                                Ok(__FieldTag::__flag_recommender_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GeminiInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeminiInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitled => {
                            if !fields.insert(__FieldTag::__entitled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitled",
                                ));
                            }
                            result.entitled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__google_vacuum_mgmt_enabled => {
                            if !fields.insert(__FieldTag::__google_vacuum_mgmt_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_vacuum_mgmt_enabled",
                                ));
                            }
                            result.google_vacuum_mgmt_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__oom_session_cancel_enabled => {
                            if !fields.insert(__FieldTag::__oom_session_cancel_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oom_session_cancel_enabled",
                                ));
                            }
                            result.oom_session_cancel_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__active_query_enabled => {
                            if !fields.insert(__FieldTag::__active_query_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_query_enabled",
                                ));
                            }
                            result.active_query_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__index_advisor_enabled => {
                            if !fields.insert(__FieldTag::__index_advisor_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_advisor_enabled",
                                ));
                            }
                            result.index_advisor_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__flag_recommender_enabled => {
                            if !fields.insert(__FieldTag::__flag_recommender_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flag_recommender_enabled",
                                ));
                            }
                            result.flag_recommender_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GeminiInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entitled.is_some() {
            state.serialize_entry("entitled", &self.entitled)?;
        }
        if self.google_vacuum_mgmt_enabled.is_some() {
            state.serialize_entry("googleVacuumMgmtEnabled", &self.google_vacuum_mgmt_enabled)?;
        }
        if self.oom_session_cancel_enabled.is_some() {
            state.serialize_entry("oomSessionCancelEnabled", &self.oom_session_cancel_enabled)?;
        }
        if self.active_query_enabled.is_some() {
            state.serialize_entry("activeQueryEnabled", &self.active_query_enabled)?;
        }
        if self.index_advisor_enabled.is_some() {
            state.serialize_entry("indexAdvisorEnabled", &self.index_advisor_enabled)?;
        }
        if self.flag_recommender_enabled.is_some() {
            state.serialize_entry("flagRecommenderEnabled", &self.flag_recommender_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A primary instance and disaster recovery (DR) replica pair.
/// A DR replica is a cross-region replica that you designate for failover in
/// the event that the primary instance experiences regional failure.
/// Only applicable to MySQL.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationCluster {
    /// Output only. If set, it indicates this instance has a private service
    /// access (PSA) dns endpoint that is pointing to the primary instance of the
    /// cluster. If this instance is the primary, the dns should be pointing to
    /// this instance. After Switchover or Replica failover, this DNS endpoint
    /// points to the promoted instance. This is a read-only field, returned to the
    /// user as information. This field can exist even if a standalone instance
    /// does not yet have a replica, or had a DR replica that was deleted.
    pub psa_write_endpoint: std::string::String,

    /// Optional. If the instance is a primary instance, then this field identifies
    /// the disaster recovery (DR) replica. A DR replica is an optional
    /// configuration for Enterprise Plus edition instances. If the instance is a
    /// read replica, then the field is not set. Set this field to a replica name
    /// to designate a DR replica for a primary instance. Remove the replica name
    /// to remove the DR replica designation.
    pub failover_dr_replica_name: std::string::String,

    /// Output only. Read-only field that indicates whether the replica is a DR
    /// replica. This field is not set if the instance is a primary instance.
    pub dr_replica: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psa_write_endpoint][crate::model::ReplicationCluster::psa_write_endpoint].
    pub fn set_psa_write_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psa_write_endpoint = v.into();
        self
    }

    /// Sets the value of [failover_dr_replica_name][crate::model::ReplicationCluster::failover_dr_replica_name].
    pub fn set_failover_dr_replica_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.failover_dr_replica_name = v.into();
        self
    }

    /// Sets the value of [dr_replica][crate::model::ReplicationCluster::dr_replica].
    pub fn set_dr_replica<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dr_replica = v.into();
        self
    }
}

impl wkt::message::Message for ReplicationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicationCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __psa_write_endpoint,
            __failover_dr_replica_name,
            __dr_replica,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "psaWriteEndpoint" => Ok(__FieldTag::__psa_write_endpoint),
                            "psa_write_endpoint" => Ok(__FieldTag::__psa_write_endpoint),
                            "failoverDrReplicaName" => Ok(__FieldTag::__failover_dr_replica_name),
                            "failover_dr_replica_name" => {
                                Ok(__FieldTag::__failover_dr_replica_name)
                            }
                            "drReplica" => Ok(__FieldTag::__dr_replica),
                            "dr_replica" => Ok(__FieldTag::__dr_replica),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__psa_write_endpoint => {
                            if !fields.insert(__FieldTag::__psa_write_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psa_write_endpoint",
                                ));
                            }
                            result.psa_write_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failover_dr_replica_name => {
                            if !fields.insert(__FieldTag::__failover_dr_replica_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failover_dr_replica_name",
                                ));
                            }
                            result.failover_dr_replica_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dr_replica => {
                            if !fields.insert(__FieldTag::__dr_replica) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dr_replica",
                                ));
                            }
                            result.dr_replica = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.psa_write_endpoint.is_empty() {
            state.serialize_entry("psaWriteEndpoint", &self.psa_write_endpoint)?;
        }
        if !self.failover_dr_replica_name.is_empty() {
            state.serialize_entry("failoverDrReplicaName", &self.failover_dr_replica_name)?;
        }
        if !wkt::internal::is_default(&self.dr_replica) {
            state.serialize_entry("drReplica", &self.dr_replica)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An available database version. It can be a major or a minor version.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AvailableDatabaseVersion {
    /// The version's major version name.
    pub major_version: std::option::Option<std::string::String>,

    /// The database version name. For MySQL 8.0, this string provides the database
    /// major and minor version.
    pub name: std::option::Option<std::string::String>,

    /// The database version's display name.
    pub display_name: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvailableDatabaseVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [major_version][crate::model::AvailableDatabaseVersion::major_version].
    pub fn set_major_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.major_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [major_version][crate::model::AvailableDatabaseVersion::major_version].
    pub fn set_or_clear_major_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.major_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::AvailableDatabaseVersion::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::AvailableDatabaseVersion::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::AvailableDatabaseVersion::display_name].
    pub fn set_display_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_name][crate::model::AvailableDatabaseVersion::display_name].
    pub fn set_or_clear_display_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AvailableDatabaseVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AvailableDatabaseVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AvailableDatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __major_version,
            __name,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvailableDatabaseVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "majorVersion" => Ok(__FieldTag::__major_version),
                            "major_version" => Ok(__FieldTag::__major_version),
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AvailableDatabaseVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvailableDatabaseVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__major_version => {
                            if !fields.insert(__FieldTag::__major_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_version",
                                ));
                            }
                            result.major_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AvailableDatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.major_version.is_some() {
            state.serialize_entry("majorVersion", &self.major_version)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Reschedule options for maintenance windows.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequestBody {
    /// Required. The type of the reschedule the user wants.
    pub reschedule: std::option::Option<
        crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRescheduleMaintenanceRequestBody {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reschedule][crate::model::SqlInstancesRescheduleMaintenanceRequestBody::reschedule].
    pub fn set_reschedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule,
            >,
    {
        self.reschedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reschedule][crate::model::SqlInstancesRescheduleMaintenanceRequestBody::reschedule].
    pub fn set_or_clear_reschedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule,
            >,
    {
        self.reschedule = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequestBody {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesRescheduleMaintenanceRequestBody {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reschedule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SqlInstancesRescheduleMaintenanceRequestBody",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reschedule" => Ok(__FieldTag::__reschedule),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesRescheduleMaintenanceRequestBody;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesRescheduleMaintenanceRequestBody")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reschedule => {
                            if !fields.insert(__FieldTag::__reschedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reschedule",
                                ));
                            }
                            result.reschedule = map.next_value::<std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesRescheduleMaintenanceRequestBody {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reschedule.is_some() {
            state.serialize_entry("reschedule", &self.reschedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SqlInstancesRescheduleMaintenanceRequestBody].
pub mod sql_instances_reschedule_maintenance_request_body {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Reschedule {
        /// Required. The type of the reschedule.
        pub reschedule_type:
            crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType,

        /// Optional. Timestamp when the maintenance shall be rescheduled to if
        /// reschedule_type=SPECIFIC_TIME, in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
        /// `2012-11-15T16:19:00.094Z`.
        pub schedule_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Reschedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reschedule_type][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::reschedule_type].
        pub fn set_reschedule_type<
            T: std::convert::Into<
                    crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.reschedule_type = v.into();
            self
        }

        /// Sets the value of [schedule_time][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::schedule_time].
        pub fn set_schedule_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schedule_time][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::schedule_time].
        pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.schedule_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Reschedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody.Reschedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Reschedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reschedule_type,
                __schedule_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Reschedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rescheduleType" => Ok(__FieldTag::__reschedule_type),
                                "reschedule_type" => Ok(__FieldTag::__reschedule_type),
                                "scheduleTime" => Ok(__FieldTag::__schedule_time),
                                "schedule_time" => Ok(__FieldTag::__schedule_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Reschedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Reschedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reschedule_type => {
                                if !fields.insert(__FieldTag::__reschedule_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reschedule_type",
                                    ));
                                }
                                result.reschedule_type = map.next_value::<std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__schedule_time => {
                                if !fields.insert(__FieldTag::__schedule_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule_time",
                                    ));
                                }
                                result.schedule_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Reschedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.reschedule_type) {
                state.serialize_entry("rescheduleType", &self.reschedule_type)?;
            }
            if self.schedule_time.is_some() {
                state.serialize_entry("scheduleTime", &self.schedule_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RescheduleType {
        Unspecified,
        /// Reschedules maintenance to happen now (within 5 minutes).
        Immediate,
        /// Reschedules maintenance to occur within one week from the originally
        /// scheduled day and time.
        NextAvailableWindow,
        /// Reschedules maintenance to a specific time and day.
        SpecificTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RescheduleType::value] or
        /// [RescheduleType::name].
        UnknownValue(reschedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reschedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RescheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediate => std::option::Option::Some(1),
                Self::NextAvailableWindow => std::option::Option::Some(2),
                Self::SpecificTime => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESCHEDULE_TYPE_UNSPECIFIED"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::NextAvailableWindow => std::option::Option::Some("NEXT_AVAILABLE_WINDOW"),
                Self::SpecificTime => std::option::Option::Some("SPECIFIC_TIME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RescheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediate,
                2 => Self::NextAvailableWindow,
                3 => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RescheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATE" => Self::Immediate,
                "NEXT_AVAILABLE_WINDOW" => Self::NextAvailableWindow,
                "SPECIFIC_TIME" => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RescheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediate => serializer.serialize_i32(1),
                Self::NextAvailableWindow => serializer.serialize_i32(2),
                Self::SpecificTime => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RescheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RescheduleType>::new(
                ".google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody.RescheduleType",
            ))
        }
    }
}

/// Database instance demote primary instance context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DemoteMasterContext {
    /// This is always `sql#demoteMasterContext`.
    pub kind: std::string::String,

    /// Verify the GTID consistency for demote operation. Default value:
    /// `True`. Setting this flag to `false` enables you to bypass the GTID
    /// consistency check between on-premises primary instance and Cloud SQL
    /// instance during the demotion operation but also exposes you to the risk of
    /// future replication failures. Change the value only if you know the reason
    /// for the GTID divergence and are confident that doing so will not cause any
    /// replication issues.
    pub verify_gtid_consistency: std::option::Option<wkt::BoolValue>,

    /// The name of the instance which will act as on-premises primary instance
    /// in the replication setup.
    pub master_instance_name: std::string::String,

    /// Configuration specific to read-replicas replicating from the on-premises
    /// primary instance.
    pub replica_configuration: std::option::Option<crate::model::DemoteMasterConfiguration>,

    /// Flag to skip replication setup on the instance.
    pub skip_replication_setup: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [verify_gtid_consistency][crate::model::DemoteMasterContext::verify_gtid_consistency].
    pub fn set_verify_gtid_consistency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.verify_gtid_consistency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_gtid_consistency][crate::model::DemoteMasterContext::verify_gtid_consistency].
    pub fn set_or_clear_verify_gtid_consistency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.verify_gtid_consistency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DemoteMasterContext::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DemoteMasterContext::replica_configuration].
    pub fn set_replica_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterConfiguration>,
    {
        self.replica_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_configuration][crate::model::DemoteMasterContext::replica_configuration].
    pub fn set_or_clear_replica_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterConfiguration>,
    {
        self.replica_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_replication_setup][crate::model::DemoteMasterContext::skip_replication_setup].
    pub fn set_skip_replication_setup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_replication_setup = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DemoteMasterContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __verify_gtid_consistency,
            __master_instance_name,
            __replica_configuration,
            __skip_replication_setup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DemoteMasterContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "verifyGtidConsistency" => Ok(__FieldTag::__verify_gtid_consistency),
                            "verify_gtid_consistency" => Ok(__FieldTag::__verify_gtid_consistency),
                            "masterInstanceName" => Ok(__FieldTag::__master_instance_name),
                            "master_instance_name" => Ok(__FieldTag::__master_instance_name),
                            "replicaConfiguration" => Ok(__FieldTag::__replica_configuration),
                            "replica_configuration" => Ok(__FieldTag::__replica_configuration),
                            "skipReplicationSetup" => Ok(__FieldTag::__skip_replication_setup),
                            "skip_replication_setup" => Ok(__FieldTag::__skip_replication_setup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DemoteMasterContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DemoteMasterContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verify_gtid_consistency => {
                            if !fields.insert(__FieldTag::__verify_gtid_consistency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_gtid_consistency",
                                ));
                            }
                            result.verify_gtid_consistency =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__master_instance_name => {
                            if !fields.insert(__FieldTag::__master_instance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_instance_name",
                                ));
                            }
                            result.master_instance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_configuration => {
                            if !fields.insert(__FieldTag::__replica_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_configuration",
                                ));
                            }
                            result.replica_configuration = map.next_value::<std::option::Option<crate::model::DemoteMasterConfiguration>>()?
                                ;
                        }
                        __FieldTag::__skip_replication_setup => {
                            if !fields.insert(__FieldTag::__skip_replication_setup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_replication_setup",
                                ));
                            }
                            result.skip_replication_setup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DemoteMasterContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.verify_gtid_consistency.is_some() {
            state.serialize_entry("verifyGtidConsistency", &self.verify_gtid_consistency)?;
        }
        if !self.master_instance_name.is_empty() {
            state.serialize_entry("masterInstanceName", &self.master_instance_name)?;
        }
        if self.replica_configuration.is_some() {
            state.serialize_entry("replicaConfiguration", &self.replica_configuration)?;
        }
        if !wkt::internal::is_default(&self.skip_replication_setup) {
            state.serialize_entry("skipReplicationSetup", &self.skip_replication_setup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This context is used to demote an existing standalone instance to be
/// a Cloud SQL read replica for an external database server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DemoteContext {
    /// This is always `sql#demoteContext`.
    pub kind: std::string::String,

    /// Required. The name of the instance which acts as the on-premises primary
    /// instance in the replication setup.
    pub source_representative_instance_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [source_representative_instance_name][crate::model::DemoteContext::source_representative_instance_name].
    pub fn set_source_representative_instance_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_representative_instance_name = v.into();
        self
    }
}

impl wkt::message::Message for DemoteContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DemoteContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __source_representative_instance_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DemoteContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "sourceRepresentativeInstanceName" => {
                                Ok(__FieldTag::__source_representative_instance_name)
                            }
                            "source_representative_instance_name" => {
                                Ok(__FieldTag::__source_representative_instance_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DemoteContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DemoteContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_representative_instance_name => {
                            if !fields.insert(__FieldTag::__source_representative_instance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_representative_instance_name",
                                ));
                            }
                            result.source_representative_instance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DemoteContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.source_representative_instance_name.is_empty() {
            state.serialize_entry(
                "sourceRepresentativeInstanceName",
                &self.source_representative_instance_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance failover context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FailoverContext {
    /// The current settings version of this instance. Request will be rejected if
    /// this version doesn't match the current settings version.
    pub settings_version: i64,

    /// This is always `sql#failoverContext`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::FailoverContext::settings_version].
    pub fn set_settings_version<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.settings_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::FailoverContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for FailoverContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FailoverContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailoverContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __settings_version,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailoverContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "settingsVersion" => Ok(__FieldTag::__settings_version),
                            "settings_version" => Ok(__FieldTag::__settings_version),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailoverContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailoverContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__settings_version => {
                            if !fields.insert(__FieldTag::__settings_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings_version",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.settings_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailoverContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.settings_version) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("settingsVersion", &__With(&self.settings_version))?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance restore from backup context.
/// Backup context contains source instance id and project id.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreBackupContext {
    /// This is always `sql#restoreBackupContext`.
    pub kind: std::string::String,

    /// The ID of the backup run to restore from.
    pub backup_run_id: i64,

    /// The ID of the instance that the backup was taken from.
    pub instance_id: std::string::String,

    /// The full project ID of the source instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RestoreBackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [backup_run_id][crate::model::RestoreBackupContext::backup_run_id].
    pub fn set_backup_run_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_run_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::RestoreBackupContext::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [project][crate::model::RestoreBackupContext::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for RestoreBackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RestoreBackupContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreBackupContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __backup_run_id,
            __instance_id,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreBackupContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "backupRunId" => Ok(__FieldTag::__backup_run_id),
                            "backup_run_id" => Ok(__FieldTag::__backup_run_id),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreBackupContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreBackupContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_run_id => {
                            if !fields.insert(__FieldTag::__backup_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_run_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_run_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreBackupContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.backup_run_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupRunId", &__With(&self.backup_run_id))?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance rotate server CA context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RotateServerCaContext {
    /// This is always `sql#rotateServerCaContext`.
    pub kind: std::string::String,

    /// The fingerprint of the next version to be rotated to. If left unspecified,
    /// will be rotated to the most recently added server CA version.
    pub next_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RotateServerCaContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RotateServerCaContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_version][crate::model::RotateServerCaContext::next_version].
    pub fn set_next_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_version = v.into();
        self
    }
}

impl wkt::message::Message for RotateServerCaContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RotateServerCaContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RotateServerCaContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __next_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RotateServerCaContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "nextVersion" => Ok(__FieldTag::__next_version),
                            "next_version" => Ok(__FieldTag::__next_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RotateServerCaContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RotateServerCaContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_version => {
                            if !fields.insert(__FieldTag::__next_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_version",
                                ));
                            }
                            result.next_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RotateServerCaContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.next_version.is_empty() {
            state.serialize_entry("nextVersion", &self.next_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database Instance truncate log context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TruncateLogContext {
    /// This is always `sql#truncateLogContext`.
    pub kind: std::string::String,

    /// The type of log to truncate. Valid values are `MYSQL_GENERAL_TABLE` and
    /// `MYSQL_SLOW_TABLE`.
    pub log_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TruncateLogContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TruncateLogContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [log_type][crate::model::TruncateLogContext::log_type].
    pub fn set_log_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_type = v.into();
        self
    }
}

impl wkt::message::Message for TruncateLogContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TruncateLogContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TruncateLogContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __log_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TruncateLogContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "logType" => Ok(__FieldTag::__log_type),
                            "log_type" => Ok(__FieldTag::__log_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TruncateLogContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TruncateLogContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_type => {
                            if !fields.insert(__FieldTag::__log_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_type",
                                ));
                            }
                            result.log_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TruncateLogContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.log_type.is_empty() {
            state.serialize_entry("logType", &self.log_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// External primary instance migration setting error/warning.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlExternalSyncSettingError {
    /// Can be `sql#externalSyncSettingError` or
    /// `sql#externalSyncSettingWarning`.
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    pub r#type: crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType,

    /// Additional information about the error encountered.
    pub detail: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlExternalSyncSettingError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlExternalSyncSettingError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlExternalSyncSettingError::type].
    pub fn set_type<
        T: std::convert::Into<
                crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::SqlExternalSyncSettingError::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for SqlExternalSyncSettingError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlExternalSyncSettingError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlExternalSyncSettingError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __type,
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlExternalSyncSettingError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "type" => Ok(__FieldTag::__type),
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlExternalSyncSettingError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlExternalSyncSettingError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlExternalSyncSettingError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SqlExternalSyncSettingError].
pub mod sql_external_sync_setting_error {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlExternalSyncSettingErrorType {
        Unspecified,
        ConnectionFailure,
        BinlogNotEnabled,
        IncompatibleDatabaseVersion,
        ReplicaAlreadySetup,
        /// The replication user is missing privileges that are required.
        InsufficientPrivilege,
        /// Unsupported migration type.
        UnsupportedMigrationType,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses,
        /// Extensions installed are either not supported or having unsupported
        /// versions.
        UnsupportedExtensions,
        /// The value of parameter rds.logical_replication is not set to 1.
        InvalidRdsLogicalReplication,
        /// The primary instance logging setup doesn't allow EM sync.
        InvalidLoggingSetup,
        /// The primary instance database parameter setup doesn't allow EM sync.
        InvalidDbParam,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode,
        /// SQL Server Agent is not running.
        SqlserverAgentNotRunning,
        /// The table definition is not support due to missing primary key or replica
        /// identity, applicable for postgres.
        UnsupportedTableDefinition,
        /// The customer has a definer that will break EM setup.
        UnsupportedDefiner,
        /// SQL Server @@SERVERNAME does not match actual host name.
        SqlserverServernameMismatch,
        /// The primary instance has been setup and will fail the setup.
        PrimaryAlreadySetup,
        /// The primary instance has unsupported binary log format.
        UnsupportedBinlogFormat,
        /// The primary instance's binary log retention setting.
        BinlogRetentionSetting,
        /// The primary instance has tables with unsupported storage engine.
        UnsupportedStorageEngine,
        /// Source has tables with limited support
        /// eg: PostgreSQL tables without primary keys.
        LimitedSupportTables,
        /// The replica instance contains existing data.
        ExistingDataInReplica,
        /// The replication user is missing privileges that are optional.
        MissingOptionalPrivileges,
        /// Additional BACKUP_ADMIN privilege is granted to the replication user
        /// which may lock source MySQL 8 instance for DDLs during initial sync.
        RiskyBackupAdminPrivilege,
        /// The Cloud Storage bucket is missing necessary permissions.
        InsufficientGcsPermissions,
        /// The Cloud Storage bucket has an error in the file or contains invalid
        /// file information.
        InvalidFileInfo,
        /// The source instance has unsupported database settings for migration.
        UnsupportedDatabaseSettings,
        /// The replication user is missing parallel import specific privileges.
        /// (e.g. LOCK TABLES) for MySQL.
        MysqlParallelImportInsufficientPrivilege,
        /// The global variable local_infile is off on external server replica.
        LocalInfileOff,
        /// This code instructs customers to turn on point-in-time recovery manually
        /// for the instance after promoting the Cloud SQL for PostgreSQL instance.
        TurnOnPitrAfterPromote,
        /// The minor version of replica database is incompatible with the source.
        IncompatibleDatabaseMinorVersion,
        /// This warning message indicates that Cloud SQL uses the maximum number of
        /// subscriptions to migrate data from the source to the destination.
        SourceMaxSubscriptions,
        /// Unable to verify definers on the source for MySQL.
        UnableToVerifyDefiners,
        /// If a time out occurs while the subscription counts are calculated, then
        /// this value is set to 1. Otherwise, this value is set to 2.
        SubscriptionCalculationStatus,
        /// Count of subscriptions needed to sync source data for PostgreSQL
        /// database.
        PgSubscriptionCount,
        /// Final parallel level that is used to do migration.
        PgSyncParallelLevel,
        /// The disk size of the replica instance is smaller than the data size of
        /// the source instance.
        InsufficientDiskSize,
        /// The data size of the source instance is greater than 1 TB, the number of
        /// cores of the replica instance is less than 8, and the memory of the
        /// replica is less than 32 GB.
        InsufficientMachineTier,
        /// The warning message indicates the unsupported extensions will not be
        /// migrated to the destination.
        UnsupportedExtensionsNotMigrated,
        /// The warning message indicates the pg_cron extension and settings will not
        /// be migrated to the destination.
        ExtensionsNotMigrated,
        /// The error message indicates that pg_cron flags are enabled on the
        /// destination which is not supported during the migration.
        PgCronFlagEnabledInReplica,
        /// This error message indicates that the specified extensions are not
        /// enabled on destination instance. For example, before you can migrate
        /// data to the destination instance, you must enable the PGAudit extension
        /// on the instance.
        ExtensionsNotEnabledInReplica,
        /// The source database has generated columns that can't be migrated. Please
        /// change them to regular columns before migration.
        UnsupportedColumns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlExternalSyncSettingErrorType::value] or
        /// [SqlExternalSyncSettingErrorType::name].
        UnknownValue(sql_external_sync_setting_error_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_external_sync_setting_error_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlExternalSyncSettingErrorType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectionFailure => std::option::Option::Some(1),
                Self::BinlogNotEnabled => std::option::Option::Some(2),
                Self::IncompatibleDatabaseVersion => std::option::Option::Some(3),
                Self::ReplicaAlreadySetup => std::option::Option::Some(4),
                Self::InsufficientPrivilege => std::option::Option::Some(5),
                Self::UnsupportedMigrationType => std::option::Option::Some(6),
                Self::NoPglogicalInstalled => std::option::Option::Some(7),
                Self::PglogicalNodeAlreadyExists => std::option::Option::Some(8),
                Self::InvalidWalLevel => std::option::Option::Some(9),
                Self::InvalidSharedPreloadLibrary => std::option::Option::Some(10),
                Self::InsufficientMaxReplicationSlots => std::option::Option::Some(11),
                Self::InsufficientMaxWalSenders => std::option::Option::Some(12),
                Self::InsufficientMaxWorkerProcesses => std::option::Option::Some(13),
                Self::UnsupportedExtensions => std::option::Option::Some(14),
                Self::InvalidRdsLogicalReplication => std::option::Option::Some(15),
                Self::InvalidLoggingSetup => std::option::Option::Some(16),
                Self::InvalidDbParam => std::option::Option::Some(17),
                Self::UnsupportedGtidMode => std::option::Option::Some(18),
                Self::SqlserverAgentNotRunning => std::option::Option::Some(19),
                Self::UnsupportedTableDefinition => std::option::Option::Some(20),
                Self::UnsupportedDefiner => std::option::Option::Some(21),
                Self::SqlserverServernameMismatch => std::option::Option::Some(22),
                Self::PrimaryAlreadySetup => std::option::Option::Some(23),
                Self::UnsupportedBinlogFormat => std::option::Option::Some(24),
                Self::BinlogRetentionSetting => std::option::Option::Some(25),
                Self::UnsupportedStorageEngine => std::option::Option::Some(26),
                Self::LimitedSupportTables => std::option::Option::Some(27),
                Self::ExistingDataInReplica => std::option::Option::Some(28),
                Self::MissingOptionalPrivileges => std::option::Option::Some(29),
                Self::RiskyBackupAdminPrivilege => std::option::Option::Some(30),
                Self::InsufficientGcsPermissions => std::option::Option::Some(31),
                Self::InvalidFileInfo => std::option::Option::Some(32),
                Self::UnsupportedDatabaseSettings => std::option::Option::Some(33),
                Self::MysqlParallelImportInsufficientPrivilege => std::option::Option::Some(34),
                Self::LocalInfileOff => std::option::Option::Some(35),
                Self::TurnOnPitrAfterPromote => std::option::Option::Some(36),
                Self::IncompatibleDatabaseMinorVersion => std::option::Option::Some(37),
                Self::SourceMaxSubscriptions => std::option::Option::Some(38),
                Self::UnableToVerifyDefiners => std::option::Option::Some(39),
                Self::SubscriptionCalculationStatus => std::option::Option::Some(40),
                Self::PgSubscriptionCount => std::option::Option::Some(41),
                Self::PgSyncParallelLevel => std::option::Option::Some(42),
                Self::InsufficientDiskSize => std::option::Option::Some(43),
                Self::InsufficientMachineTier => std::option::Option::Some(44),
                Self::UnsupportedExtensionsNotMigrated => std::option::Option::Some(45),
                Self::ExtensionsNotMigrated => std::option::Option::Some(46),
                Self::PgCronFlagEnabledInReplica => std::option::Option::Some(47),
                Self::ExtensionsNotEnabledInReplica => std::option::Option::Some(48),
                Self::UnsupportedColumns => std::option::Option::Some(49),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED")
                }
                Self::ConnectionFailure => std::option::Option::Some("CONNECTION_FAILURE"),
                Self::BinlogNotEnabled => std::option::Option::Some("BINLOG_NOT_ENABLED"),
                Self::IncompatibleDatabaseVersion => {
                    std::option::Option::Some("INCOMPATIBLE_DATABASE_VERSION")
                }
                Self::ReplicaAlreadySetup => std::option::Option::Some("REPLICA_ALREADY_SETUP"),
                Self::InsufficientPrivilege => std::option::Option::Some("INSUFFICIENT_PRIVILEGE"),
                Self::UnsupportedMigrationType => {
                    std::option::Option::Some("UNSUPPORTED_MIGRATION_TYPE")
                }
                Self::NoPglogicalInstalled => std::option::Option::Some("NO_PGLOGICAL_INSTALLED"),
                Self::PglogicalNodeAlreadyExists => {
                    std::option::Option::Some("PGLOGICAL_NODE_ALREADY_EXISTS")
                }
                Self::InvalidWalLevel => std::option::Option::Some("INVALID_WAL_LEVEL"),
                Self::InvalidSharedPreloadLibrary => {
                    std::option::Option::Some("INVALID_SHARED_PRELOAD_LIBRARY")
                }
                Self::InsufficientMaxReplicationSlots => {
                    std::option::Option::Some("INSUFFICIENT_MAX_REPLICATION_SLOTS")
                }
                Self::InsufficientMaxWalSenders => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WAL_SENDERS")
                }
                Self::InsufficientMaxWorkerProcesses => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WORKER_PROCESSES")
                }
                Self::UnsupportedExtensions => std::option::Option::Some("UNSUPPORTED_EXTENSIONS"),
                Self::InvalidRdsLogicalReplication => {
                    std::option::Option::Some("INVALID_RDS_LOGICAL_REPLICATION")
                }
                Self::InvalidLoggingSetup => std::option::Option::Some("INVALID_LOGGING_SETUP"),
                Self::InvalidDbParam => std::option::Option::Some("INVALID_DB_PARAM"),
                Self::UnsupportedGtidMode => std::option::Option::Some("UNSUPPORTED_GTID_MODE"),
                Self::SqlserverAgentNotRunning => {
                    std::option::Option::Some("SQLSERVER_AGENT_NOT_RUNNING")
                }
                Self::UnsupportedTableDefinition => {
                    std::option::Option::Some("UNSUPPORTED_TABLE_DEFINITION")
                }
                Self::UnsupportedDefiner => std::option::Option::Some("UNSUPPORTED_DEFINER"),
                Self::SqlserverServernameMismatch => {
                    std::option::Option::Some("SQLSERVER_SERVERNAME_MISMATCH")
                }
                Self::PrimaryAlreadySetup => std::option::Option::Some("PRIMARY_ALREADY_SETUP"),
                Self::UnsupportedBinlogFormat => {
                    std::option::Option::Some("UNSUPPORTED_BINLOG_FORMAT")
                }
                Self::BinlogRetentionSetting => {
                    std::option::Option::Some("BINLOG_RETENTION_SETTING")
                }
                Self::UnsupportedStorageEngine => {
                    std::option::Option::Some("UNSUPPORTED_STORAGE_ENGINE")
                }
                Self::LimitedSupportTables => std::option::Option::Some("LIMITED_SUPPORT_TABLES"),
                Self::ExistingDataInReplica => {
                    std::option::Option::Some("EXISTING_DATA_IN_REPLICA")
                }
                Self::MissingOptionalPrivileges => {
                    std::option::Option::Some("MISSING_OPTIONAL_PRIVILEGES")
                }
                Self::RiskyBackupAdminPrivilege => {
                    std::option::Option::Some("RISKY_BACKUP_ADMIN_PRIVILEGE")
                }
                Self::InsufficientGcsPermissions => {
                    std::option::Option::Some("INSUFFICIENT_GCS_PERMISSIONS")
                }
                Self::InvalidFileInfo => std::option::Option::Some("INVALID_FILE_INFO"),
                Self::UnsupportedDatabaseSettings => {
                    std::option::Option::Some("UNSUPPORTED_DATABASE_SETTINGS")
                }
                Self::MysqlParallelImportInsufficientPrivilege => {
                    std::option::Option::Some("MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE")
                }
                Self::LocalInfileOff => std::option::Option::Some("LOCAL_INFILE_OFF"),
                Self::TurnOnPitrAfterPromote => {
                    std::option::Option::Some("TURN_ON_PITR_AFTER_PROMOTE")
                }
                Self::IncompatibleDatabaseMinorVersion => {
                    std::option::Option::Some("INCOMPATIBLE_DATABASE_MINOR_VERSION")
                }
                Self::SourceMaxSubscriptions => {
                    std::option::Option::Some("SOURCE_MAX_SUBSCRIPTIONS")
                }
                Self::UnableToVerifyDefiners => {
                    std::option::Option::Some("UNABLE_TO_VERIFY_DEFINERS")
                }
                Self::SubscriptionCalculationStatus => {
                    std::option::Option::Some("SUBSCRIPTION_CALCULATION_STATUS")
                }
                Self::PgSubscriptionCount => std::option::Option::Some("PG_SUBSCRIPTION_COUNT"),
                Self::PgSyncParallelLevel => std::option::Option::Some("PG_SYNC_PARALLEL_LEVEL"),
                Self::InsufficientDiskSize => std::option::Option::Some("INSUFFICIENT_DISK_SIZE"),
                Self::InsufficientMachineTier => {
                    std::option::Option::Some("INSUFFICIENT_MACHINE_TIER")
                }
                Self::UnsupportedExtensionsNotMigrated => {
                    std::option::Option::Some("UNSUPPORTED_EXTENSIONS_NOT_MIGRATED")
                }
                Self::ExtensionsNotMigrated => std::option::Option::Some("EXTENSIONS_NOT_MIGRATED"),
                Self::PgCronFlagEnabledInReplica => {
                    std::option::Option::Some("PG_CRON_FLAG_ENABLED_IN_REPLICA")
                }
                Self::ExtensionsNotEnabledInReplica => {
                    std::option::Option::Some("EXTENSIONS_NOT_ENABLED_IN_REPLICA")
                }
                Self::UnsupportedColumns => std::option::Option::Some("UNSUPPORTED_COLUMNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlExternalSyncSettingErrorType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlExternalSyncSettingErrorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlExternalSyncSettingErrorType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectionFailure,
                2 => Self::BinlogNotEnabled,
                3 => Self::IncompatibleDatabaseVersion,
                4 => Self::ReplicaAlreadySetup,
                5 => Self::InsufficientPrivilege,
                6 => Self::UnsupportedMigrationType,
                7 => Self::NoPglogicalInstalled,
                8 => Self::PglogicalNodeAlreadyExists,
                9 => Self::InvalidWalLevel,
                10 => Self::InvalidSharedPreloadLibrary,
                11 => Self::InsufficientMaxReplicationSlots,
                12 => Self::InsufficientMaxWalSenders,
                13 => Self::InsufficientMaxWorkerProcesses,
                14 => Self::UnsupportedExtensions,
                15 => Self::InvalidRdsLogicalReplication,
                16 => Self::InvalidLoggingSetup,
                17 => Self::InvalidDbParam,
                18 => Self::UnsupportedGtidMode,
                19 => Self::SqlserverAgentNotRunning,
                20 => Self::UnsupportedTableDefinition,
                21 => Self::UnsupportedDefiner,
                22 => Self::SqlserverServernameMismatch,
                23 => Self::PrimaryAlreadySetup,
                24 => Self::UnsupportedBinlogFormat,
                25 => Self::BinlogRetentionSetting,
                26 => Self::UnsupportedStorageEngine,
                27 => Self::LimitedSupportTables,
                28 => Self::ExistingDataInReplica,
                29 => Self::MissingOptionalPrivileges,
                30 => Self::RiskyBackupAdminPrivilege,
                31 => Self::InsufficientGcsPermissions,
                32 => Self::InvalidFileInfo,
                33 => Self::UnsupportedDatabaseSettings,
                34 => Self::MysqlParallelImportInsufficientPrivilege,
                35 => Self::LocalInfileOff,
                36 => Self::TurnOnPitrAfterPromote,
                37 => Self::IncompatibleDatabaseMinorVersion,
                38 => Self::SourceMaxSubscriptions,
                39 => Self::UnableToVerifyDefiners,
                40 => Self::SubscriptionCalculationStatus,
                41 => Self::PgSubscriptionCount,
                42 => Self::PgSyncParallelLevel,
                43 => Self::InsufficientDiskSize,
                44 => Self::InsufficientMachineTier,
                45 => Self::UnsupportedExtensionsNotMigrated,
                46 => Self::ExtensionsNotMigrated,
                47 => Self::PgCronFlagEnabledInReplica,
                48 => Self::ExtensionsNotEnabledInReplica,
                49 => Self::UnsupportedColumns,
                _ => Self::UnknownValue(sql_external_sync_setting_error_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlExternalSyncSettingErrorType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONNECTION_FAILURE" => Self::ConnectionFailure,
                "BINLOG_NOT_ENABLED" => Self::BinlogNotEnabled,
                "INCOMPATIBLE_DATABASE_VERSION" => Self::IncompatibleDatabaseVersion,
                "REPLICA_ALREADY_SETUP" => Self::ReplicaAlreadySetup,
                "INSUFFICIENT_PRIVILEGE" => Self::InsufficientPrivilege,
                "UNSUPPORTED_MIGRATION_TYPE" => Self::UnsupportedMigrationType,
                "NO_PGLOGICAL_INSTALLED" => Self::NoPglogicalInstalled,
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Self::PglogicalNodeAlreadyExists,
                "INVALID_WAL_LEVEL" => Self::InvalidWalLevel,
                "INVALID_SHARED_PRELOAD_LIBRARY" => Self::InvalidSharedPreloadLibrary,
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => Self::InsufficientMaxReplicationSlots,
                "INSUFFICIENT_MAX_WAL_SENDERS" => Self::InsufficientMaxWalSenders,
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => Self::InsufficientMaxWorkerProcesses,
                "UNSUPPORTED_EXTENSIONS" => Self::UnsupportedExtensions,
                "INVALID_RDS_LOGICAL_REPLICATION" => Self::InvalidRdsLogicalReplication,
                "INVALID_LOGGING_SETUP" => Self::InvalidLoggingSetup,
                "INVALID_DB_PARAM" => Self::InvalidDbParam,
                "UNSUPPORTED_GTID_MODE" => Self::UnsupportedGtidMode,
                "SQLSERVER_AGENT_NOT_RUNNING" => Self::SqlserverAgentNotRunning,
                "UNSUPPORTED_TABLE_DEFINITION" => Self::UnsupportedTableDefinition,
                "UNSUPPORTED_DEFINER" => Self::UnsupportedDefiner,
                "SQLSERVER_SERVERNAME_MISMATCH" => Self::SqlserverServernameMismatch,
                "PRIMARY_ALREADY_SETUP" => Self::PrimaryAlreadySetup,
                "UNSUPPORTED_BINLOG_FORMAT" => Self::UnsupportedBinlogFormat,
                "BINLOG_RETENTION_SETTING" => Self::BinlogRetentionSetting,
                "UNSUPPORTED_STORAGE_ENGINE" => Self::UnsupportedStorageEngine,
                "LIMITED_SUPPORT_TABLES" => Self::LimitedSupportTables,
                "EXISTING_DATA_IN_REPLICA" => Self::ExistingDataInReplica,
                "MISSING_OPTIONAL_PRIVILEGES" => Self::MissingOptionalPrivileges,
                "RISKY_BACKUP_ADMIN_PRIVILEGE" => Self::RiskyBackupAdminPrivilege,
                "INSUFFICIENT_GCS_PERMISSIONS" => Self::InsufficientGcsPermissions,
                "INVALID_FILE_INFO" => Self::InvalidFileInfo,
                "UNSUPPORTED_DATABASE_SETTINGS" => Self::UnsupportedDatabaseSettings,
                "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Self::MysqlParallelImportInsufficientPrivilege
                }
                "LOCAL_INFILE_OFF" => Self::LocalInfileOff,
                "TURN_ON_PITR_AFTER_PROMOTE" => Self::TurnOnPitrAfterPromote,
                "INCOMPATIBLE_DATABASE_MINOR_VERSION" => Self::IncompatibleDatabaseMinorVersion,
                "SOURCE_MAX_SUBSCRIPTIONS" => Self::SourceMaxSubscriptions,
                "UNABLE_TO_VERIFY_DEFINERS" => Self::UnableToVerifyDefiners,
                "SUBSCRIPTION_CALCULATION_STATUS" => Self::SubscriptionCalculationStatus,
                "PG_SUBSCRIPTION_COUNT" => Self::PgSubscriptionCount,
                "PG_SYNC_PARALLEL_LEVEL" => Self::PgSyncParallelLevel,
                "INSUFFICIENT_DISK_SIZE" => Self::InsufficientDiskSize,
                "INSUFFICIENT_MACHINE_TIER" => Self::InsufficientMachineTier,
                "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED" => Self::UnsupportedExtensionsNotMigrated,
                "EXTENSIONS_NOT_MIGRATED" => Self::ExtensionsNotMigrated,
                "PG_CRON_FLAG_ENABLED_IN_REPLICA" => Self::PgCronFlagEnabledInReplica,
                "EXTENSIONS_NOT_ENABLED_IN_REPLICA" => Self::ExtensionsNotEnabledInReplica,
                "UNSUPPORTED_COLUMNS" => Self::UnsupportedColumns,
                _ => Self::UnknownValue(sql_external_sync_setting_error_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlExternalSyncSettingErrorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectionFailure => serializer.serialize_i32(1),
                Self::BinlogNotEnabled => serializer.serialize_i32(2),
                Self::IncompatibleDatabaseVersion => serializer.serialize_i32(3),
                Self::ReplicaAlreadySetup => serializer.serialize_i32(4),
                Self::InsufficientPrivilege => serializer.serialize_i32(5),
                Self::UnsupportedMigrationType => serializer.serialize_i32(6),
                Self::NoPglogicalInstalled => serializer.serialize_i32(7),
                Self::PglogicalNodeAlreadyExists => serializer.serialize_i32(8),
                Self::InvalidWalLevel => serializer.serialize_i32(9),
                Self::InvalidSharedPreloadLibrary => serializer.serialize_i32(10),
                Self::InsufficientMaxReplicationSlots => serializer.serialize_i32(11),
                Self::InsufficientMaxWalSenders => serializer.serialize_i32(12),
                Self::InsufficientMaxWorkerProcesses => serializer.serialize_i32(13),
                Self::UnsupportedExtensions => serializer.serialize_i32(14),
                Self::InvalidRdsLogicalReplication => serializer.serialize_i32(15),
                Self::InvalidLoggingSetup => serializer.serialize_i32(16),
                Self::InvalidDbParam => serializer.serialize_i32(17),
                Self::UnsupportedGtidMode => serializer.serialize_i32(18),
                Self::SqlserverAgentNotRunning => serializer.serialize_i32(19),
                Self::UnsupportedTableDefinition => serializer.serialize_i32(20),
                Self::UnsupportedDefiner => serializer.serialize_i32(21),
                Self::SqlserverServernameMismatch => serializer.serialize_i32(22),
                Self::PrimaryAlreadySetup => serializer.serialize_i32(23),
                Self::UnsupportedBinlogFormat => serializer.serialize_i32(24),
                Self::BinlogRetentionSetting => serializer.serialize_i32(25),
                Self::UnsupportedStorageEngine => serializer.serialize_i32(26),
                Self::LimitedSupportTables => serializer.serialize_i32(27),
                Self::ExistingDataInReplica => serializer.serialize_i32(28),
                Self::MissingOptionalPrivileges => serializer.serialize_i32(29),
                Self::RiskyBackupAdminPrivilege => serializer.serialize_i32(30),
                Self::InsufficientGcsPermissions => serializer.serialize_i32(31),
                Self::InvalidFileInfo => serializer.serialize_i32(32),
                Self::UnsupportedDatabaseSettings => serializer.serialize_i32(33),
                Self::MysqlParallelImportInsufficientPrivilege => serializer.serialize_i32(34),
                Self::LocalInfileOff => serializer.serialize_i32(35),
                Self::TurnOnPitrAfterPromote => serializer.serialize_i32(36),
                Self::IncompatibleDatabaseMinorVersion => serializer.serialize_i32(37),
                Self::SourceMaxSubscriptions => serializer.serialize_i32(38),
                Self::UnableToVerifyDefiners => serializer.serialize_i32(39),
                Self::SubscriptionCalculationStatus => serializer.serialize_i32(40),
                Self::PgSubscriptionCount => serializer.serialize_i32(41),
                Self::PgSyncParallelLevel => serializer.serialize_i32(42),
                Self::InsufficientDiskSize => serializer.serialize_i32(43),
                Self::InsufficientMachineTier => serializer.serialize_i32(44),
                Self::UnsupportedExtensionsNotMigrated => serializer.serialize_i32(45),
                Self::ExtensionsNotMigrated => serializer.serialize_i32(46),
                Self::PgCronFlagEnabledInReplica => serializer.serialize_i32(47),
                Self::ExtensionsNotEnabledInReplica => serializer.serialize_i32(48),
                Self::UnsupportedColumns => serializer.serialize_i32(49),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlExternalSyncSettingErrorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<
                SqlExternalSyncSettingErrorType,
            >::new(
                ".google.cloud.sql.v1.SqlExternalSyncSettingError.SqlExternalSyncSettingErrorType",
            ))
        }
    }
}

/// On-premises instance configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OnPremisesConfiguration {
    /// The host and port of the on-premises instance in host:port format
    pub host_port: std::string::String,

    /// This is always `sql#onPremisesConfiguration`.
    pub kind: std::string::String,

    /// The username for connecting to on-premises instance.
    pub username: std::string::String,

    /// The password for connecting to on-premises instance.
    pub password: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    pub client_key: std::string::String,

    /// The dump file to create the Cloud SQL replica.
    pub dump_file_path: std::string::String,

    /// The reference to Cloud SQL instance if the source is Cloud SQL.
    pub source_instance: std::option::Option<crate::model::InstanceReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OnPremisesConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::OnPremisesConfiguration::host_port].
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::OnPremisesConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OnPremisesConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OnPremisesConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::OnPremisesConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::OnPremisesConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::OnPremisesConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [dump_file_path][crate::model::OnPremisesConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::OnPremisesConfiguration::source_instance].
    pub fn set_source_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceReference>,
    {
        self.source_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance][crate::model::OnPremisesConfiguration::source_instance].
    pub fn set_or_clear_source_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceReference>,
    {
        self.source_instance = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OnPremisesConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OnPremisesConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OnPremisesConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_port,
            __kind,
            __username,
            __password,
            __ca_certificate,
            __client_certificate,
            __client_key,
            __dump_file_path,
            __source_instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OnPremisesConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostPort" => Ok(__FieldTag::__host_port),
                            "host_port" => Ok(__FieldTag::__host_port),
                            "kind" => Ok(__FieldTag::__kind),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "dumpFilePath" => Ok(__FieldTag::__dump_file_path),
                            "dump_file_path" => Ok(__FieldTag::__dump_file_path),
                            "sourceInstance" => Ok(__FieldTag::__source_instance),
                            "source_instance" => Ok(__FieldTag::__source_instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OnPremisesConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OnPremisesConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_port => {
                            if !fields.insert(__FieldTag::__host_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_port",
                                ));
                            }
                            result.host_port = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dump_file_path => {
                            if !fields.insert(__FieldTag::__dump_file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dump_file_path",
                                ));
                            }
                            result.dump_file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_instance => {
                            if !fields.insert(__FieldTag::__source_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_instance",
                                ));
                            }
                            result.source_instance = map
                                .next_value::<std::option::Option<crate::model::InstanceReference>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OnPremisesConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_port.is_empty() {
            state.serialize_entry("hostPort", &self.host_port)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self.dump_file_path.is_empty() {
            state.serialize_entry("dumpFilePath", &self.dump_file_path)?;
        }
        if self.source_instance.is_some() {
            state.serialize_entry("sourceInstance", &self.source_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Read-replica configuration for connecting to the primary instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicaConfiguration {
    /// This is always `sql#replicaConfiguration`.
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    pub mysql_replica_configuration: std::option::Option<crate::model::MySqlReplicaConfiguration>,

    /// Specifies if the replica is the failover target. If the field is set to
    /// `true`, the replica will be designated as a failover replica. In case the
    /// primary instance fails, the replica instance will be promoted as the new
    /// primary instance. Only one replica can be specified as failover target, and
    /// the replica has to be in different zone with the primary instance.
    pub failover_target: std::option::Option<wkt::BoolValue>,

    /// Optional. Specifies if a SQL Server replica is a cascadable replica. A
    /// cascadable replica is a SQL Server cross region replica that supports
    /// replica(s) under it.
    pub cascadable_replica: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::ReplicaConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MySqlReplicaConfiguration>,
    {
        self.mysql_replica_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mysql_replica_configuration][crate::model::ReplicaConfiguration::mysql_replica_configuration].
    pub fn set_or_clear_mysql_replica_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MySqlReplicaConfiguration>,
    {
        self.mysql_replica_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failover_target][crate::model::ReplicaConfiguration::failover_target].
    pub fn set_failover_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.failover_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failover_target][crate::model::ReplicaConfiguration::failover_target].
    pub fn set_or_clear_failover_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.failover_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cascadable_replica][crate::model::ReplicaConfiguration::cascadable_replica].
    pub fn set_cascadable_replica<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.cascadable_replica = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cascadable_replica][crate::model::ReplicaConfiguration::cascadable_replica].
    pub fn set_or_clear_cascadable_replica<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.cascadable_replica = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicaConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicaConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __mysql_replica_configuration,
            __failover_target,
            __cascadable_replica,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicaConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "mysqlReplicaConfiguration" => {
                                Ok(__FieldTag::__mysql_replica_configuration)
                            }
                            "mysql_replica_configuration" => {
                                Ok(__FieldTag::__mysql_replica_configuration)
                            }
                            "failoverTarget" => Ok(__FieldTag::__failover_target),
                            "failover_target" => Ok(__FieldTag::__failover_target),
                            "cascadableReplica" => Ok(__FieldTag::__cascadable_replica),
                            "cascadable_replica" => Ok(__FieldTag::__cascadable_replica),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicaConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicaConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_replica_configuration => {
                            if !fields.insert(__FieldTag::__mysql_replica_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_replica_configuration",
                                ));
                            }
                            result.mysql_replica_configuration = map.next_value::<std::option::Option<crate::model::MySqlReplicaConfiguration>>()?
                                ;
                        }
                        __FieldTag::__failover_target => {
                            if !fields.insert(__FieldTag::__failover_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failover_target",
                                ));
                            }
                            result.failover_target =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__cascadable_replica => {
                            if !fields.insert(__FieldTag::__cascadable_replica) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cascadable_replica",
                                ));
                            }
                            result.cascadable_replica =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicaConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.mysql_replica_configuration.is_some() {
            state.serialize_entry(
                "mysqlReplicaConfiguration",
                &self.mysql_replica_configuration,
            )?;
        }
        if self.failover_target.is_some() {
            state.serialize_entry("failoverTarget", &self.failover_target)?;
        }
        if self.cascadable_replica.is_some() {
            state.serialize_entry("cascadableReplica", &self.cascadable_replica)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to acquire a lease for SSRS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseRequest {
    /// Required. Cloud SQL instance ID. This doesn't include the project ID. It's
    /// composed of lowercase letters, numbers, and hyphens, and it must start with
    /// a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    pub instance: std::string::String,

    /// Required. Project ID of the project that contains the instance (Example:
    /// project-id).
    pub project: std::string::String,

    /// Required. The request body.
    pub body: std::option::Option<crate::model::InstancesAcquireSsrsLeaseRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAcquireSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAcquireSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesAcquireSsrsLeaseRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesAcquireSsrsLeaseRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlInstancesAcquireSsrsLeaseRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancesAcquireSsrsLeaseRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesAcquireSsrsLeaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesAcquireSsrsLeaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesAcquireSsrsLeaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesAcquireSsrsLeaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<
                                crate::model::InstancesAcquireSsrsLeaseRequest,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesAcquireSsrsLeaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the acquire SSRS lease request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseResponse {
    /// The unique identifier for this operation.
    pub operation_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAcquireSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesAcquireSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesAcquireSsrsLeaseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesAcquireSsrsLeaseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesAcquireSsrsLeaseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesAcquireSsrsLeaseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesAcquireSsrsLeaseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to release a lease for SSRS.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseRequest {
    /// Required. The Cloud SQL instance ID. This doesn't include the project ID.
    /// The instance ID contains lowercase letters, numbers, and hyphens, and it
    /// must start with a letter. This ID can have a maximum length of 98
    /// characters.
    pub instance: std::string::String,

    /// Required. The project ID that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReleaseSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReleaseSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReleaseSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesReleaseSsrsLeaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesReleaseSsrsLeaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesReleaseSsrsLeaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesReleaseSsrsLeaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesReleaseSsrsLeaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the release SSRS lease request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseResponse {
    /// The unique identifier for this operation.
    pub operation_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReleaseSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesReleaseSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlInstancesReleaseSsrsLeaseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlInstancesReleaseSsrsLeaseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlInstancesReleaseSsrsLeaseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlInstancesReleaseSsrsLeaseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlInstancesReleaseSsrsLeaseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operations get request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlOperationsGetRequest {
    /// Instance operation ID.
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsGetRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlOperationsGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlOperationsGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operation" => Ok(__FieldTag::__operation),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlOperationsGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlOperationsGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlOperationsGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operations list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlOperationsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Maximum number of operations per response.
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlOperationsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlOperationsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlOperationsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlOperationsListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __max_results,
            __page_token,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlOperationsListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlOperationsListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlOperationsListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlOperationsListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operations list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationsListResponse {
    /// This is always `sql#operationsList`.
    pub kind: std::string::String,

    /// List of operation resources.
    pub items: std::vec::Vec<crate::model::Operation>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::OperationsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for OperationsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationsListResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for OperationsListResponse {
    type PageItem = crate::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operations cancel request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlOperationsCancelRequest {
    /// Instance operation ID.
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsCancelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsCancelRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsCancelRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsCancelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsCancelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlOperationsCancelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlOperationsCancelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operation" => Ok(__FieldTag::__operation),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlOperationsCancelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlOperationsCancelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlOperationsCancelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An entry for an Access Control list.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AclEntry {
    /// The allowlisted value for the access control list.
    pub value: std::string::String,

    /// The time when this access control entry expires in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A label to identify this entry.
    pub name: std::string::String,

    /// This is always `sql#aclEntry`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::AclEntry::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::AclEntry::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::AclEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::AclEntry::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for AclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AclEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AclEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __expiration_time,
            __name,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AclEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "name" => Ok(__FieldTag::__name),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AclEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AclEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AclEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Admin API warning message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ApiWarning {
    /// Code to uniquely identify the warning type.
    pub code: crate::model::api_warning::SqlApiWarningCode,

    /// The warning message.
    pub message: std::string::String,

    /// The region name for REGION_UNREACHABLE warning.
    pub region: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiWarning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ApiWarning::code].
    pub fn set_code<T: std::convert::Into<crate::model::api_warning::SqlApiWarningCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ApiWarning::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ApiWarning::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for ApiWarning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ApiWarning"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApiWarning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApiWarning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApiWarning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApiWarning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code =
                                map.next_value::<std::option::Option<
                                    crate::model::api_warning::SqlApiWarningCode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApiWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ApiWarning].
pub mod api_warning {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlApiWarningCode {
        /// An unknown or unset warning type from Cloud SQL API.
        Unspecified,
        /// Warning when one or more regions are not reachable.  The returned result
        /// set may be incomplete.
        RegionUnreachable,
        /// Warning when user provided maxResults parameter exceeds the limit.  The
        /// returned result set may be incomplete.
        MaxResultsExceedsLimit,
        /// Warning when user tries to create/update a user with credentials that
        /// have previously been compromised by a public data breach.
        CompromisedCredentials,
        /// Warning when the operation succeeds but some non-critical workflow state
        /// failed.
        InternalStateFailure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlApiWarningCode::value] or
        /// [SqlApiWarningCode::name].
        UnknownValue(sql_api_warning_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_api_warning_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlApiWarningCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RegionUnreachable => std::option::Option::Some(1),
                Self::MaxResultsExceedsLimit => std::option::Option::Some(2),
                Self::CompromisedCredentials => std::option::Option::Some(3),
                Self::InternalStateFailure => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_API_WARNING_CODE_UNSPECIFIED"),
                Self::RegionUnreachable => std::option::Option::Some("REGION_UNREACHABLE"),
                Self::MaxResultsExceedsLimit => {
                    std::option::Option::Some("MAX_RESULTS_EXCEEDS_LIMIT")
                }
                Self::CompromisedCredentials => {
                    std::option::Option::Some("COMPROMISED_CREDENTIALS")
                }
                Self::InternalStateFailure => std::option::Option::Some("INTERNAL_STATE_FAILURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlApiWarningCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlApiWarningCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlApiWarningCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RegionUnreachable,
                2 => Self::MaxResultsExceedsLimit,
                3 => Self::CompromisedCredentials,
                4 => Self::InternalStateFailure,
                _ => Self::UnknownValue(sql_api_warning_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlApiWarningCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_API_WARNING_CODE_UNSPECIFIED" => Self::Unspecified,
                "REGION_UNREACHABLE" => Self::RegionUnreachable,
                "MAX_RESULTS_EXCEEDS_LIMIT" => Self::MaxResultsExceedsLimit,
                "COMPROMISED_CREDENTIALS" => Self::CompromisedCredentials,
                "INTERNAL_STATE_FAILURE" => Self::InternalStateFailure,
                _ => Self::UnknownValue(sql_api_warning_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlApiWarningCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RegionUnreachable => serializer.serialize_i32(1),
                Self::MaxResultsExceedsLimit => serializer.serialize_i32(2),
                Self::CompromisedCredentials => serializer.serialize_i32(3),
                Self::InternalStateFailure => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlApiWarningCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlApiWarningCode>::new(
                ".google.cloud.sql.v1.ApiWarning.SqlApiWarningCode",
            ))
        }
    }
}

/// We currently only support backup retention by specifying the number
/// of backups we will retain.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupRetentionSettings {
    /// The unit that 'retained_backups' represents.
    pub retention_unit: crate::model::backup_retention_settings::RetentionUnit,

    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    pub retained_backups: std::option::Option<wkt::Int32Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRetentionSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_unit][crate::model::BackupRetentionSettings::retention_unit].
    pub fn set_retention_unit<
        T: std::convert::Into<crate::model::backup_retention_settings::RetentionUnit>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention_unit = v.into();
        self
    }

    /// Sets the value of [retained_backups][crate::model::BackupRetentionSettings::retained_backups].
    pub fn set_retained_backups<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.retained_backups = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retained_backups][crate::model::BackupRetentionSettings::retained_backups].
    pub fn set_or_clear_retained_backups<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.retained_backups = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupRetentionSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRetentionSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupRetentionSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retention_unit,
            __retained_backups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupRetentionSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retentionUnit" => Ok(__FieldTag::__retention_unit),
                            "retention_unit" => Ok(__FieldTag::__retention_unit),
                            "retainedBackups" => Ok(__FieldTag::__retained_backups),
                            "retained_backups" => Ok(__FieldTag::__retained_backups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupRetentionSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupRetentionSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retention_unit => {
                            if !fields.insert(__FieldTag::__retention_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_unit",
                                ));
                            }
                            result.retention_unit = map
                                .next_value::<std::option::Option<
                                    crate::model::backup_retention_settings::RetentionUnit,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retained_backups => {
                            if !fields.insert(__FieldTag::__retained_backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retained_backups",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retained_backups = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupRetentionSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.retention_unit) {
            state.serialize_entry("retentionUnit", &self.retention_unit)?;
        }
        if self.retained_backups.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("retainedBackups", &__With(&self.retained_backups))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupRetentionSettings].
pub mod backup_retention_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The units that retained_backups specifies, we only support COUNT.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetentionUnit {
        /// Backup retention unit is unspecified, will be treated as COUNT.
        Unspecified,
        /// Retention will be by count, eg. "retain the most recent 7 backups".
        Count,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetentionUnit::value] or
        /// [RetentionUnit::name].
        UnknownValue(retention_unit::UnknownValue),
    }

    #[doc(hidden)]
    pub mod retention_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RetentionUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Count => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETENTION_UNIT_UNSPECIFIED"),
                Self::Count => std::option::Option::Some("COUNT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RetentionUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RetentionUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RetentionUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Count,
                _ => Self::UnknownValue(retention_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RetentionUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETENTION_UNIT_UNSPECIFIED" => Self::Unspecified,
                "COUNT" => Self::Count,
                _ => Self::UnknownValue(retention_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RetentionUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Count => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetentionUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetentionUnit>::new(
                ".google.cloud.sql.v1.BackupRetentionSettings.RetentionUnit",
            ))
        }
    }
}

/// Database instance backup configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupConfiguration {
    /// Start time for the daily backup configuration in UTC timezone in the 24
    /// hour format - `HH:MM`.
    pub start_time: std::string::String,

    /// Whether this configuration is enabled.
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#backupConfiguration`.
    pub kind: std::string::String,

    /// (MySQL only) Whether binary log is enabled. If backup configuration is
    /// disabled, binarylog must be disabled as well.
    pub binary_log_enabled: std::option::Option<wkt::BoolValue>,

    /// Reserved for future use.
    pub replication_log_archiving_enabled: std::option::Option<wkt::BoolValue>,

    /// Location of the backup
    pub location: std::string::String,

    /// Whether point in time recovery is enabled.
    pub point_in_time_recovery_enabled: std::option::Option<wkt::BoolValue>,

    /// Backup retention settings.
    pub backup_retention_settings: std::option::Option<crate::model::BackupRetentionSettings>,

    /// The number of days of transaction logs we retain for point in time
    /// restore, from 1-7.
    pub transaction_log_retention_days: std::option::Option<wkt::Int32Value>,

    /// Output only. This value contains the storage location of transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    pub transactional_log_storage_state:
        std::option::Option<crate::model::backup_configuration::TransactionalLogStorageState>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BackupConfiguration::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::BackupConfiguration::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::BackupConfiguration::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::BackupConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [binary_log_enabled][crate::model::BackupConfiguration::binary_log_enabled].
    pub fn set_binary_log_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.binary_log_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_log_enabled][crate::model::BackupConfiguration::binary_log_enabled].
    pub fn set_or_clear_binary_log_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.binary_log_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replication_log_archiving_enabled][crate::model::BackupConfiguration::replication_log_archiving_enabled].
    pub fn set_replication_log_archiving_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.replication_log_archiving_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_log_archiving_enabled][crate::model::BackupConfiguration::replication_log_archiving_enabled].
    pub fn set_or_clear_replication_log_archiving_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.replication_log_archiving_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::BackupConfiguration::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [point_in_time_recovery_enabled][crate::model::BackupConfiguration::point_in_time_recovery_enabled].
    pub fn set_point_in_time_recovery_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.point_in_time_recovery_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [point_in_time_recovery_enabled][crate::model::BackupConfiguration::point_in_time_recovery_enabled].
    pub fn set_or_clear_point_in_time_recovery_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.point_in_time_recovery_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_retention_settings][crate::model::BackupConfiguration::backup_retention_settings].
    pub fn set_backup_retention_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupRetentionSettings>,
    {
        self.backup_retention_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_retention_settings][crate::model::BackupConfiguration::backup_retention_settings].
    pub fn set_or_clear_backup_retention_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupRetentionSettings>,
    {
        self.backup_retention_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transaction_log_retention_days][crate::model::BackupConfiguration::transaction_log_retention_days].
    pub fn set_transaction_log_retention_days<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.transaction_log_retention_days = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_log_retention_days][crate::model::BackupConfiguration::transaction_log_retention_days].
    pub fn set_or_clear_transaction_log_retention_days<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.transaction_log_retention_days = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transactional_log_storage_state][crate::model::BackupConfiguration::transactional_log_storage_state].
    pub fn set_transactional_log_storage_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_configuration::TransactionalLogStorageState>,
    {
        self.transactional_log_storage_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transactional_log_storage_state][crate::model::BackupConfiguration::transactional_log_storage_state].
    pub fn set_or_clear_transactional_log_storage_state<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::backup_configuration::TransactionalLogStorageState>,
    {
        self.transactional_log_storage_state = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __enabled,
            __kind,
            __binary_log_enabled,
            __replication_log_archiving_enabled,
            __location,
            __point_in_time_recovery_enabled,
            __backup_retention_settings,
            __transaction_log_retention_days,
            __transactional_log_storage_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "kind" => Ok(__FieldTag::__kind),
                            "binaryLogEnabled" => Ok(__FieldTag::__binary_log_enabled),
                            "binary_log_enabled" => Ok(__FieldTag::__binary_log_enabled),
                            "replicationLogArchivingEnabled" => {
                                Ok(__FieldTag::__replication_log_archiving_enabled)
                            }
                            "replication_log_archiving_enabled" => {
                                Ok(__FieldTag::__replication_log_archiving_enabled)
                            }
                            "location" => Ok(__FieldTag::__location),
                            "pointInTimeRecoveryEnabled" => {
                                Ok(__FieldTag::__point_in_time_recovery_enabled)
                            }
                            "point_in_time_recovery_enabled" => {
                                Ok(__FieldTag::__point_in_time_recovery_enabled)
                            }
                            "backupRetentionSettings" => {
                                Ok(__FieldTag::__backup_retention_settings)
                            }
                            "backup_retention_settings" => {
                                Ok(__FieldTag::__backup_retention_settings)
                            }
                            "transactionLogRetentionDays" => {
                                Ok(__FieldTag::__transaction_log_retention_days)
                            }
                            "transaction_log_retention_days" => {
                                Ok(__FieldTag::__transaction_log_retention_days)
                            }
                            "transactionalLogStorageState" => {
                                Ok(__FieldTag::__transactional_log_storage_state)
                            }
                            "transactional_log_storage_state" => {
                                Ok(__FieldTag::__transactional_log_storage_state)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binary_log_enabled => {
                            if !fields.insert(__FieldTag::__binary_log_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_log_enabled",
                                ));
                            }
                            result.binary_log_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__replication_log_archiving_enabled => {
                            if !fields.insert(__FieldTag::__replication_log_archiving_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_log_archiving_enabled",
                                ));
                            }
                            result.replication_log_archiving_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__point_in_time_recovery_enabled => {
                            if !fields.insert(__FieldTag::__point_in_time_recovery_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_in_time_recovery_enabled",
                                ));
                            }
                            result.point_in_time_recovery_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__backup_retention_settings => {
                            if !fields.insert(__FieldTag::__backup_retention_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_retention_settings",
                                ));
                            }
                            result.backup_retention_settings = map.next_value::<std::option::Option<crate::model::BackupRetentionSettings>>()?
                                ;
                        }
                        __FieldTag::__transaction_log_retention_days => {
                            if !fields.insert(__FieldTag::__transaction_log_retention_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transaction_log_retention_days",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.transaction_log_retention_days = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__transactional_log_storage_state => {
                            if !fields.insert(__FieldTag::__transactional_log_storage_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transactional_log_storage_state",
                                ));
                            }
                            result.transactional_log_storage_state = map
                                .next_value::<std::option::Option<
                                crate::model::backup_configuration::TransactionalLogStorageState,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.start_time.is_empty() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.binary_log_enabled.is_some() {
            state.serialize_entry("binaryLogEnabled", &self.binary_log_enabled)?;
        }
        if self.replication_log_archiving_enabled.is_some() {
            state.serialize_entry(
                "replicationLogArchivingEnabled",
                &self.replication_log_archiving_enabled,
            )?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.point_in_time_recovery_enabled.is_some() {
            state.serialize_entry(
                "pointInTimeRecoveryEnabled",
                &self.point_in_time_recovery_enabled,
            )?;
        }
        if self.backup_retention_settings.is_some() {
            state.serialize_entry("backupRetentionSettings", &self.backup_retention_settings)?;
        }
        if self.transaction_log_retention_days.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "transactionLogRetentionDays",
                &__With(&self.transaction_log_retention_days),
            )?;
        }
        if self.transactional_log_storage_state.is_some() {
            state.serialize_entry(
                "transactionalLogStorageState",
                &self.transactional_log_storage_state,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupConfiguration].
pub mod backup_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// This value contains the storage location of the transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransactionalLogStorageState {
        /// Unspecified.
        Unspecified,
        /// The transaction logs used for PITR for the instance are stored
        /// on a data disk.
        Disk,
        /// The transaction logs used for PITR for the instance are switching from
        /// being stored on a data disk to being stored in Cloud Storage.
        /// Only applicable to MySQL.
        SwitchingToCloudStorage,
        /// The transaction logs used for PITR for the instance are now stored
        /// in Cloud Storage. Previously, they were stored on a data disk.
        /// Only applicable to MySQL.
        SwitchedToCloudStorage,
        /// The transaction logs used for PITR for the instance are stored in
        /// Cloud Storage. Only applicable to MySQL and PostgreSQL.
        CloudStorage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransactionalLogStorageState::value] or
        /// [TransactionalLogStorageState::name].
        UnknownValue(transactional_log_storage_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transactional_log_storage_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransactionalLogStorageState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disk => std::option::Option::Some(1),
                Self::SwitchingToCloudStorage => std::option::Option::Some(2),
                Self::SwitchedToCloudStorage => std::option::Option::Some(3),
                Self::CloudStorage => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED")
                }
                Self::Disk => std::option::Option::Some("DISK"),
                Self::SwitchingToCloudStorage => {
                    std::option::Option::Some("SWITCHING_TO_CLOUD_STORAGE")
                }
                Self::SwitchedToCloudStorage => {
                    std::option::Option::Some("SWITCHED_TO_CLOUD_STORAGE")
                }
                Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransactionalLogStorageState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransactionalLogStorageState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransactionalLogStorageState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disk,
                2 => Self::SwitchingToCloudStorage,
                3 => Self::SwitchedToCloudStorage,
                4 => Self::CloudStorage,
                _ => Self::UnknownValue(transactional_log_storage_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransactionalLogStorageState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED" => Self::Unspecified,
                "DISK" => Self::Disk,
                "SWITCHING_TO_CLOUD_STORAGE" => Self::SwitchingToCloudStorage,
                "SWITCHED_TO_CLOUD_STORAGE" => Self::SwitchedToCloudStorage,
                "CLOUD_STORAGE" => Self::CloudStorage,
                _ => Self::UnknownValue(transactional_log_storage_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransactionalLogStorageState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disk => serializer.serialize_i32(1),
                Self::SwitchingToCloudStorage => serializer.serialize_i32(2),
                Self::SwitchedToCloudStorage => serializer.serialize_i32(3),
                Self::CloudStorage => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionalLogStorageState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TransactionalLogStorageState>::new(
                    ".google.cloud.sql.v1.BackupConfiguration.TransactionalLogStorageState",
                ),
            )
        }
    }
}

/// Perform disk shrink context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PerformDiskShrinkContext {
    /// The target disk shrink size in GigaBytes.
    pub target_size_gb: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformDiskShrinkContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_size_gb][crate::model::PerformDiskShrinkContext::target_size_gb].
    pub fn set_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.target_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for PerformDiskShrinkContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PerformDiskShrinkContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PerformDiskShrinkContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_size_gb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PerformDiskShrinkContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetSizeGb" => Ok(__FieldTag::__target_size_gb),
                            "target_size_gb" => Ok(__FieldTag::__target_size_gb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PerformDiskShrinkContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PerformDiskShrinkContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_size_gb => {
                            if !fields.insert(__FieldTag::__target_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PerformDiskShrinkContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("targetSizeGb", &__With(&self.target_size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Backup context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupContext {
    /// The identifier of the backup.
    pub backup_id: i64,

    /// This is always `sql#backupContext`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_id][crate::model::BackupContext::backup_id].
    pub fn set_backup_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_id,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.backup_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupId", &__With(&self.backup_id))?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a SQL database on the Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// This is always `sql#database`.
    pub kind: std::string::String,

    /// The Cloud SQL charset value.
    pub charset: std::string::String,

    /// The Cloud SQL collation value.
    pub collation: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    pub etag: std::string::String,

    /// The name of the database in the Cloud SQL instance. This does not include
    /// the project ID or instance name.
    pub name: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    pub instance: std::string::String,

    /// The URI of this resource.
    pub self_link: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable.
    pub project: std::string::String,

    pub database_details: std::option::Option<crate::model::database::DatabaseDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Database::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::Database::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Database::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [project][crate::model::Database::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [database_details][crate::model::Database::database_details].
    ///
    /// Note that all the setters affecting `database_details` are mutually
    /// exclusive.
    pub fn set_database_details<
        T: std::convert::Into<std::option::Option<crate::model::database::DatabaseDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_details = v.into();
        self
    }

    /// The value of [database_details][crate::model::Database::database_details]
    /// if it holds a `SqlserverDatabaseDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlserver_database_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerDatabaseDetails>> {
        #[allow(unreachable_patterns)]
        self.database_details.as_ref().and_then(|v| match v {
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [database_details][crate::model::Database::database_details]
    /// to hold a `SqlserverDatabaseDetails`.
    ///
    /// Note that all the setters affecting `database_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_database_details<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerDatabaseDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_details = std::option::Option::Some(
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Database"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Database {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __charset,
            __collation,
            __etag,
            __name,
            __instance,
            __self_link,
            __project,
            __sqlserver_database_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Database")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "charset" => Ok(__FieldTag::__charset),
                            "collation" => Ok(__FieldTag::__collation),
                            "etag" => Ok(__FieldTag::__etag),
                            "name" => Ok(__FieldTag::__name),
                            "instance" => Ok(__FieldTag::__instance),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "project" => Ok(__FieldTag::__project),
                            "sqlserverDatabaseDetails" => {
                                Ok(__FieldTag::__sqlserver_database_details)
                            }
                            "sqlserver_database_details" => {
                                Ok(__FieldTag::__sqlserver_database_details)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Database;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Database")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__charset => {
                            if !fields.insert(__FieldTag::__charset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for charset",
                                ));
                            }
                            result.charset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sqlserver_database_details => {
                            if !fields.insert(__FieldTag::__sqlserver_database_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sqlserver_database_details",
                                ));
                            }
                            if result.database_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `database_details`, a oneof with full ID .google.cloud.sql.v1.Database.sqlserver_database_details, latest field was sqlserverDatabaseDetails",
                                ));
                            }
                            result.database_details = std::option::Option::Some(
                                crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlServerDatabaseDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Database {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.charset.is_empty() {
            state.serialize_entry("charset", &self.charset)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if let Some(value) = self.sqlserver_database_details() {
            state.serialize_entry("sqlserverDatabaseDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Database].
pub mod database {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DatabaseDetails {
        SqlserverDatabaseDetails(std::boxed::Box<crate::model::SqlServerDatabaseDetails>),
    }
}

/// Represents a Sql Server database on the Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerDatabaseDetails {
    /// The version of SQL Server with which the database is to be made compatible
    pub compatibility_level: i32,

    /// The recovery model of a SQL Server database
    pub recovery_model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerDatabaseDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compatibility_level][crate::model::SqlServerDatabaseDetails::compatibility_level].
    pub fn set_compatibility_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compatibility_level = v.into();
        self
    }

    /// Sets the value of [recovery_model][crate::model::SqlServerDatabaseDetails::recovery_model].
    pub fn set_recovery_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recovery_model = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerDatabaseDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerDatabaseDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerDatabaseDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compatibility_level,
            __recovery_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerDatabaseDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compatibilityLevel" => Ok(__FieldTag::__compatibility_level),
                            "compatibility_level" => Ok(__FieldTag::__compatibility_level),
                            "recoveryModel" => Ok(__FieldTag::__recovery_model),
                            "recovery_model" => Ok(__FieldTag::__recovery_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerDatabaseDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerDatabaseDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compatibility_level => {
                            if !fields.insert(__FieldTag::__compatibility_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compatibility_level",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.compatibility_level =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__recovery_model => {
                            if !fields.insert(__FieldTag::__recovery_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recovery_model",
                                ));
                            }
                            result.recovery_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerDatabaseDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.compatibility_level) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("compatibilityLevel", &__With(&self.compatibility_level))?;
        }
        if !self.recovery_model.is_empty() {
            state.serialize_entry("recoveryModel", &self.recovery_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database flags for Cloud SQL instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseFlags {
    /// The name of the flag. These flags are passed at instance startup, so
    /// include both server options and system variables. Flags are
    /// specified with underscores, not hyphens. For more information, see
    /// [Configuring Database Flags](https://cloud.google.com/sql/docs/mysql/flags)
    /// in the Cloud SQL documentation.
    pub name: std::string::String,

    /// The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatabaseFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseFlags"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseFlags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseFlags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseFlags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseFlags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseFlags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// MySQL-specific external server sync settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MySqlSyncConfig {
    /// Flags to use for the initial dump.
    pub initial_sync_flags: std::vec::Vec<crate::model::SyncFlags>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlSyncConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_sync_flags][crate::model::MySqlSyncConfig::initial_sync_flags].
    pub fn set_initial_sync_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SyncFlags>,
    {
        use std::iter::Iterator;
        self.initial_sync_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MySqlSyncConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlSyncConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MySqlSyncConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initial_sync_flags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MySqlSyncConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initialSyncFlags" => Ok(__FieldTag::__initial_sync_flags),
                            "initial_sync_flags" => Ok(__FieldTag::__initial_sync_flags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MySqlSyncConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MySqlSyncConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initial_sync_flags => {
                            if !fields.insert(__FieldTag::__initial_sync_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_sync_flags",
                                ));
                            }
                            result.initial_sync_flags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SyncFlags>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MySqlSyncConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.initial_sync_flags.is_empty() {
            state.serialize_entry("initialSyncFlags", &self.initial_sync_flags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Initial sync flags for certain Cloud SQL APIs.
/// Currently used for the MySQL external server initial dump.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SyncFlags {
    /// The name of the flag.
    pub name: std::string::String,

    /// The value of the flag. This field must be omitted if the flag
    /// doesn't take a value.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SyncFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::SyncFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for SyncFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SyncFlags"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SyncFlags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SyncFlags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SyncFlags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SyncFlags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SyncFlags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Reference to another Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceReference {
    /// The name of the Cloud SQL instance being referenced.
    /// This does not include the project ID.
    pub name: std::string::String,

    /// The region of the Cloud SQL instance being referenced.
    pub region: std::string::String,

    /// The project ID of the Cloud SQL instance being referenced.
    /// The default is the same project ID as the instance references it.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::InstanceReference::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [project][crate::model::InstanceReference::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstanceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __region,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "region" => Ok(__FieldTag::__region),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Read-replica configuration for connecting to the on-premises primary
/// instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DemoteMasterConfiguration {
    /// This is always `sql#demoteMasterConfiguration`.
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    pub mysql_replica_configuration:
        std::option::Option<crate::model::DemoteMasterMySqlReplicaConfiguration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::DemoteMasterConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterMySqlReplicaConfiguration>,
    {
        self.mysql_replica_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mysql_replica_configuration][crate::model::DemoteMasterConfiguration::mysql_replica_configuration].
    pub fn set_or_clear_mysql_replica_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DemoteMasterMySqlReplicaConfiguration>,
    {
        self.mysql_replica_configuration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DemoteMasterConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DemoteMasterConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __mysql_replica_configuration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DemoteMasterConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "mysqlReplicaConfiguration" => {
                                Ok(__FieldTag::__mysql_replica_configuration)
                            }
                            "mysql_replica_configuration" => {
                                Ok(__FieldTag::__mysql_replica_configuration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DemoteMasterConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DemoteMasterConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql_replica_configuration => {
                            if !fields.insert(__FieldTag::__mysql_replica_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql_replica_configuration",
                                ));
                            }
                            result.mysql_replica_configuration = map
                                .next_value::<std::option::Option<
                                    crate::model::DemoteMasterMySqlReplicaConfiguration,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DemoteMasterConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.mysql_replica_configuration.is_some() {
            state.serialize_entry(
                "mysqlReplicaConfiguration",
                &self.mysql_replica_configuration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DemoteMasterMySqlReplicaConfiguration {
    /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
    pub kind: std::string::String,

    /// The username for the replication connection.
    pub username: std::string::String,

    /// The password for the replication connection.
    pub password: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate. The format of the replica's
    /// private key can be either PKCS #1 or PKCS #8.
    pub client_key: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    pub client_certificate: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    pub ca_certificate: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterMySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterMySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::DemoteMasterMySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::DemoteMasterMySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::DemoteMasterMySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterMySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterMySqlReplicaConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DemoteMasterMySqlReplicaConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __username,
            __password,
            __client_key,
            __client_certificate,
            __ca_certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DemoteMasterMySqlReplicaConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DemoteMasterMySqlReplicaConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DemoteMasterMySqlReplicaConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DemoteMasterMySqlReplicaConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance export context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportContext {
    /// The path to the file in Google Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails. If
    /// `fileType` is `SQL` and the filename ends with .gz,
    /// the contents are compressed.
    pub uri: std::string::String,

    /// Databases to be exported. <br /> `MySQL instances:` If
    /// `fileType` is `SQL` and no database is specified, all
    /// databases are exported, except for the `mysql` system database.
    /// If `fileType` is `CSV`, you can specify one database,
    /// either by using this property or by using the
    /// `csvExportOptions.selectQuery` property, which takes precedence
    /// over this property. <br /> `PostgreSQL instances:` You must specify
    /// one database to be exported. If `fileType` is `CSV`,
    /// this database must match the one specified in the
    /// `csvExportOptions.selectQuery` property. <br /> `SQL Server
    /// instances:` You must specify one database to be exported, and the
    /// `fileType` must be `BAK`.
    pub databases: std::vec::Vec<std::string::String>,

    /// This is always `sql#exportContext`.
    pub kind: std::string::String,

    /// Options for exporting data as SQL statements.
    pub sql_export_options: std::option::Option<crate::model::export_context::SqlExportOptions>,

    /// Options for exporting data as CSV. `MySQL` and `PostgreSQL`
    /// instances only.
    pub csv_export_options: std::option::Option<crate::model::export_context::SqlCsvExportOptions>,

    /// The file type for the specified uri.
    pub file_type: crate::model::SqlFileType,

    /// Option for export offload.
    pub offload: std::option::Option<wkt::BoolValue>,

    /// Options for exporting data as BAK files.
    pub bak_export_options: std::option::Option<crate::model::export_context::SqlBakExportOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ExportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [databases][crate::model::ExportContext::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::ExportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [sql_export_options][crate::model::ExportContext::sql_export_options].
    pub fn set_sql_export_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlExportOptions>,
    {
        self.sql_export_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_export_options][crate::model::ExportContext::sql_export_options].
    pub fn set_or_clear_sql_export_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlExportOptions>,
    {
        self.sql_export_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [csv_export_options][crate::model::ExportContext::csv_export_options].
    pub fn set_csv_export_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlCsvExportOptions>,
    {
        self.csv_export_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [csv_export_options][crate::model::ExportContext::csv_export_options].
    pub fn set_or_clear_csv_export_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlCsvExportOptions>,
    {
        self.csv_export_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_type][crate::model::ExportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [offload][crate::model::ExportContext::offload].
    pub fn set_offload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.offload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [offload][crate::model::ExportContext::offload].
    pub fn set_or_clear_offload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.offload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bak_export_options][crate::model::ExportContext::bak_export_options].
    pub fn set_bak_export_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlBakExportOptions>,
    {
        self.bak_export_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bak_export_options][crate::model::ExportContext::bak_export_options].
    pub fn set_or_clear_bak_export_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::export_context::SqlBakExportOptions>,
    {
        self.bak_export_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ExportContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __databases,
            __kind,
            __sql_export_options,
            __csv_export_options,
            __file_type,
            __offload,
            __bak_export_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "databases" => Ok(__FieldTag::__databases),
                            "kind" => Ok(__FieldTag::__kind),
                            "sqlExportOptions" => Ok(__FieldTag::__sql_export_options),
                            "sql_export_options" => Ok(__FieldTag::__sql_export_options),
                            "csvExportOptions" => Ok(__FieldTag::__csv_export_options),
                            "csv_export_options" => Ok(__FieldTag::__csv_export_options),
                            "fileType" => Ok(__FieldTag::__file_type),
                            "file_type" => Ok(__FieldTag::__file_type),
                            "offload" => Ok(__FieldTag::__offload),
                            "bakExportOptions" => Ok(__FieldTag::__bak_export_options),
                            "bak_export_options" => Ok(__FieldTag::__bak_export_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__databases => {
                            if !fields.insert(__FieldTag::__databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for databases",
                                ));
                            }
                            result.databases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_export_options => {
                            if !fields.insert(__FieldTag::__sql_export_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_export_options",
                                ));
                            }
                            result.sql_export_options = map.next_value::<std::option::Option<
                                crate::model::export_context::SqlExportOptions,
                            >>()?;
                        }
                        __FieldTag::__csv_export_options => {
                            if !fields.insert(__FieldTag::__csv_export_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_export_options",
                                ));
                            }
                            result.csv_export_options = map.next_value::<std::option::Option<
                                crate::model::export_context::SqlCsvExportOptions,
                            >>()?;
                        }
                        __FieldTag::__file_type => {
                            if !fields.insert(__FieldTag::__file_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_type",
                                ));
                            }
                            result.file_type = map
                                .next_value::<std::option::Option<crate::model::SqlFileType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offload => {
                            if !fields.insert(__FieldTag::__offload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offload",
                                ));
                            }
                            result.offload =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__bak_export_options => {
                            if !fields.insert(__FieldTag::__bak_export_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bak_export_options",
                                ));
                            }
                            result.bak_export_options = map.next_value::<std::option::Option<
                                crate::model::export_context::SqlBakExportOptions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.databases.is_empty() {
            state.serialize_entry("databases", &self.databases)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.sql_export_options.is_some() {
            state.serialize_entry("sqlExportOptions", &self.sql_export_options)?;
        }
        if self.csv_export_options.is_some() {
            state.serialize_entry("csvExportOptions", &self.csv_export_options)?;
        }
        if !wkt::internal::is_default(&self.file_type) {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if self.offload.is_some() {
            state.serialize_entry("offload", &self.offload)?;
        }
        if self.bak_export_options.is_some() {
            state.serialize_entry("bakExportOptions", &self.bak_export_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportContext].
pub mod export_context {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlCsvExportOptions {
        /// The select query used to extract the data.
        pub select_query: std::string::String,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        pub lines_terminated_by: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlCsvExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [select_query][crate::model::export_context::SqlCsvExportOptions::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::export_context::SqlCsvExportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::export_context::SqlCsvExportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::export_context::SqlCsvExportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::export_context::SqlCsvExportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.lines_terminated_by = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlCsvExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlCsvExportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlCsvExportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __select_query,
                __escape_character,
                __quote_character,
                __fields_terminated_by,
                __lines_terminated_by,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlCsvExportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "selectQuery" => Ok(__FieldTag::__select_query),
                                "select_query" => Ok(__FieldTag::__select_query),
                                "escapeCharacter" => Ok(__FieldTag::__escape_character),
                                "escape_character" => Ok(__FieldTag::__escape_character),
                                "quoteCharacter" => Ok(__FieldTag::__quote_character),
                                "quote_character" => Ok(__FieldTag::__quote_character),
                                "fieldsTerminatedBy" => Ok(__FieldTag::__fields_terminated_by),
                                "fields_terminated_by" => Ok(__FieldTag::__fields_terminated_by),
                                "linesTerminatedBy" => Ok(__FieldTag::__lines_terminated_by),
                                "lines_terminated_by" => Ok(__FieldTag::__lines_terminated_by),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlCsvExportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlCsvExportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__select_query => {
                                if !fields.insert(__FieldTag::__select_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for select_query",
                                    ));
                                }
                                result.select_query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__escape_character => {
                                if !fields.insert(__FieldTag::__escape_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for escape_character",
                                    ));
                                }
                                result.escape_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__quote_character => {
                                if !fields.insert(__FieldTag::__quote_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quote_character",
                                    ));
                                }
                                result.quote_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fields_terminated_by => {
                                if !fields.insert(__FieldTag::__fields_terminated_by) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fields_terminated_by",
                                    ));
                                }
                                result.fields_terminated_by = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__lines_terminated_by => {
                                if !fields.insert(__FieldTag::__lines_terminated_by) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lines_terminated_by",
                                    ));
                                }
                                result.lines_terminated_by = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlCsvExportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.select_query.is_empty() {
                state.serialize_entry("selectQuery", &self.select_query)?;
            }
            if !self.escape_character.is_empty() {
                state.serialize_entry("escapeCharacter", &self.escape_character)?;
            }
            if !self.quote_character.is_empty() {
                state.serialize_entry("quoteCharacter", &self.quote_character)?;
            }
            if !self.fields_terminated_by.is_empty() {
                state.serialize_entry("fieldsTerminatedBy", &self.fields_terminated_by)?;
            }
            if !self.lines_terminated_by.is_empty() {
                state.serialize_entry("linesTerminatedBy", &self.lines_terminated_by)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlExportOptions {
        /// Tables to export, or that were exported, from the specified database. If
        /// you specify tables, specify one and only one database. For PostgreSQL
        /// instances, you can specify only one table.
        pub tables: std::vec::Vec<std::string::String>,

        /// Export only schemas.
        pub schema_only: std::option::Option<wkt::BoolValue>,

        pub mysql_export_options: std::option::Option<
            crate::model::export_context::sql_export_options::MysqlExportOptions,
        >,

        /// Optional. The number of threads to use for parallel export.
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the export should be parallel.
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for exporting from a Cloud SQL for PostgreSQL instance.
        pub postgres_export_options: std::option::Option<
            crate::model::export_context::sql_export_options::PostgresExportOptions,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tables][crate::model::export_context::SqlExportOptions::tables].
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [schema_only][crate::model::export_context::SqlExportOptions::schema_only].
        pub fn set_schema_only<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.schema_only = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schema_only][crate::model::export_context::SqlExportOptions::schema_only].
        pub fn set_or_clear_schema_only<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.schema_only = v.map(|x| x.into());
            self
        }

        /// Sets the value of [mysql_export_options][crate::model::export_context::SqlExportOptions::mysql_export_options].
        pub fn set_mysql_export_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::export_context::sql_export_options::MysqlExportOptions,
                >,
        {
            self.mysql_export_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [mysql_export_options][crate::model::export_context::SqlExportOptions::mysql_export_options].
        pub fn set_or_clear_mysql_export_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::export_context::sql_export_options::MysqlExportOptions,
                >,
        {
            self.mysql_export_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [threads][crate::model::export_context::SqlExportOptions::threads].
        pub fn set_threads<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.threads = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [threads][crate::model::export_context::SqlExportOptions::threads].
        pub fn set_or_clear_threads<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.threads = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parallel][crate::model::export_context::SqlExportOptions::parallel].
        pub fn set_parallel<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.parallel = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parallel][crate::model::export_context::SqlExportOptions::parallel].
        pub fn set_or_clear_parallel<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.parallel = v.map(|x| x.into());
            self
        }

        /// Sets the value of [postgres_export_options][crate::model::export_context::SqlExportOptions::postgres_export_options].
        pub fn set_postgres_export_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::export_context::sql_export_options::PostgresExportOptions,
                >,
        {
            self.postgres_export_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [postgres_export_options][crate::model::export_context::SqlExportOptions::postgres_export_options].
        pub fn set_or_clear_postgres_export_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::export_context::sql_export_options::PostgresExportOptions,
                >,
        {
            self.postgres_export_options = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlExportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tables,
                __schema_only,
                __mysql_export_options,
                __threads,
                __parallel,
                __postgres_export_options,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlExportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tables" => Ok(__FieldTag::__tables),
                                "schemaOnly" => Ok(__FieldTag::__schema_only),
                                "schema_only" => Ok(__FieldTag::__schema_only),
                                "mysqlExportOptions" => Ok(__FieldTag::__mysql_export_options),
                                "mysql_export_options" => Ok(__FieldTag::__mysql_export_options),
                                "threads" => Ok(__FieldTag::__threads),
                                "parallel" => Ok(__FieldTag::__parallel),
                                "postgresExportOptions" => {
                                    Ok(__FieldTag::__postgres_export_options)
                                }
                                "postgres_export_options" => {
                                    Ok(__FieldTag::__postgres_export_options)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlExportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlExportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tables => {
                                if !fields.insert(__FieldTag::__tables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables",
                                    ));
                                }
                                result.tables = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__schema_only => {
                                if !fields.insert(__FieldTag::__schema_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema_only",
                                    ));
                                }
                                result.schema_only =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__mysql_export_options => {
                                if !fields.insert(__FieldTag::__mysql_export_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mysql_export_options",
                                    ));
                                }
                                result.mysql_export_options = map.next_value::<std::option::Option<crate::model::export_context::sql_export_options::MysqlExportOptions>>()?
                                    ;
                            }
                            __FieldTag::__threads => {
                                if !fields.insert(__FieldTag::__threads) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threads",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int32Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.threads = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__parallel => {
                                if !fields.insert(__FieldTag::__parallel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parallel",
                                    ));
                                }
                                result.parallel =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__postgres_export_options => {
                                if !fields.insert(__FieldTag::__postgres_export_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for postgres_export_options",
                                    ));
                                }
                                result.postgres_export_options = map.next_value::<std::option::Option<crate::model::export_context::sql_export_options::PostgresExportOptions>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlExportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tables.is_empty() {
                state.serialize_entry("tables", &self.tables)?;
            }
            if self.schema_only.is_some() {
                state.serialize_entry("schemaOnly", &self.schema_only)?;
            }
            if self.mysql_export_options.is_some() {
                state.serialize_entry("mysqlExportOptions", &self.mysql_export_options)?;
            }
            if self.threads.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("threads", &__With(&self.threads))?;
            }
            if self.parallel.is_some() {
                state.serialize_entry("parallel", &self.parallel)?;
            }
            if self.postgres_export_options.is_some() {
                state.serialize_entry("postgresExportOptions", &self.postgres_export_options)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SqlExportOptions].
    pub mod sql_export_options {
        #[allow(unused_imports)]
        use super::*;

        /// Options for exporting from MySQL.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MysqlExportOptions {
            /// Option to include SQL statement required to set up replication. If set
            /// to `1`, the dump file includes a CHANGE MASTER TO statement with the
            /// binary log coordinates, and --set-gtid-purged is set to ON. If set to
            /// `2`, the CHANGE MASTER TO statement is written as a SQL comment and
            /// has no effect. If set to any value other than `1`, --set-gtid-purged
            /// is set to OFF.
            pub master_data: std::option::Option<wkt::Int32Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MysqlExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [master_data][crate::model::export_context::sql_export_options::MysqlExportOptions::master_data].
            pub fn set_master_data<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Int32Value>,
            {
                self.master_data = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [master_data][crate::model::export_context::sql_export_options::MysqlExportOptions::master_data].
            pub fn set_or_clear_master_data<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Int32Value>,
            {
                self.master_data = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for MysqlExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.MysqlExportOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MysqlExportOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __master_data,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MysqlExportOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "masterData" => Ok(__FieldTag::__master_data),
                                    "master_data" => Ok(__FieldTag::__master_data),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MysqlExportOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MysqlExportOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__master_data => {
                                    if !fields.insert(__FieldTag::__master_data) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for master_data",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<wkt::Int32Value>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.master_data = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MysqlExportOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.master_data.is_some() {
                    struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("masterData", &__With(&self.master_data))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PostgresExportOptions {
            /// Optional. Use this option to include DROP \<object\> SQL statements.
            /// These statements are used to delete database objects before running the
            /// import operation.
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. Option to include an IF EXISTS SQL statement with each DROP
            /// statement produced by clean.
            pub if_exists: std::option::Option<wkt::BoolValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PostgresExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::export_context::sql_export_options::PostgresExportOptions::clean].
            pub fn set_clean<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [clean][crate::model::export_context::sql_export_options::PostgresExportOptions::clean].
            pub fn set_or_clear_clean<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean = v.map(|x| x.into());
                self
            }

            /// Sets the value of [if_exists][crate::model::export_context::sql_export_options::PostgresExportOptions::if_exists].
            pub fn set_if_exists<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.if_exists = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [if_exists][crate::model::export_context::sql_export_options::PostgresExportOptions::if_exists].
            pub fn set_or_clear_if_exists<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.if_exists = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for PostgresExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.PostgresExportOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PostgresExportOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __clean,
                    __if_exists,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PostgresExportOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "clean" => Ok(__FieldTag::__clean),
                                    "ifExists" => Ok(__FieldTag::__if_exists),
                                    "if_exists" => Ok(__FieldTag::__if_exists),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PostgresExportOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PostgresExportOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__clean => {
                                    if !fields.insert(__FieldTag::__clean) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for clean"),
                                        );
                                    }
                                    result.clean =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__if_exists => {
                                    if !fields.insert(__FieldTag::__if_exists) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for if_exists",
                                            ),
                                        );
                                    }
                                    result.if_exists =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PostgresExportOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.clean.is_some() {
                    state.serialize_entry("clean", &self.clean)?;
                }
                if self.if_exists.is_some() {
                    state.serialize_entry("ifExists", &self.if_exists)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Options for exporting BAK files (SQL Server-only)
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlBakExportOptions {
        /// Whether or not the export should be striped.
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Option for specifying how many stripes to use for the export.
        /// If blank, and the value of the striped field is true,
        /// the number of stripes is automatically chosen.
        pub stripe_count: std::option::Option<wkt::Int32Value>,

        /// Type of this bak file will be export, FULL or DIFF, SQL Server only
        pub bak_type: crate::model::BakType,

        /// Deprecated: copy_only is deprecated. Use differential_base instead
        #[deprecated]
        pub copy_only: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup can be used as a differential base
        /// copy_only backup can not be served as differential base
        pub differential_base: std::option::Option<wkt::BoolValue>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlBakExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [striped][crate::model::export_context::SqlBakExportOptions::striped].
        pub fn set_striped<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.striped = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [striped][crate::model::export_context::SqlBakExportOptions::striped].
        pub fn set_or_clear_striped<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.striped = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stripe_count][crate::model::export_context::SqlBakExportOptions::stripe_count].
        pub fn set_stripe_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.stripe_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stripe_count][crate::model::export_context::SqlBakExportOptions::stripe_count].
        pub fn set_or_clear_stripe_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.stripe_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [bak_type][crate::model::export_context::SqlBakExportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [copy_only][crate::model::export_context::SqlBakExportOptions::copy_only].
        #[deprecated]
        pub fn set_copy_only<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.copy_only = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [copy_only][crate::model::export_context::SqlBakExportOptions::copy_only].
        #[deprecated]
        pub fn set_or_clear_copy_only<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.copy_only = v.map(|x| x.into());
            self
        }

        /// Sets the value of [differential_base][crate::model::export_context::SqlBakExportOptions::differential_base].
        pub fn set_differential_base<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.differential_base = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [differential_base][crate::model::export_context::SqlBakExportOptions::differential_base].
        pub fn set_or_clear_differential_base<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.differential_base = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlBakExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlBakExportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlBakExportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __striped,
                __stripe_count,
                __bak_type,
                __copy_only,
                __differential_base,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlBakExportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "striped" => Ok(__FieldTag::__striped),
                                "stripeCount" => Ok(__FieldTag::__stripe_count),
                                "stripe_count" => Ok(__FieldTag::__stripe_count),
                                "bakType" => Ok(__FieldTag::__bak_type),
                                "bak_type" => Ok(__FieldTag::__bak_type),
                                "copyOnly" => Ok(__FieldTag::__copy_only),
                                "copy_only" => Ok(__FieldTag::__copy_only),
                                "differentialBase" => Ok(__FieldTag::__differential_base),
                                "differential_base" => Ok(__FieldTag::__differential_base),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlBakExportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlBakExportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__striped => {
                                if !fields.insert(__FieldTag::__striped) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for striped",
                                    ));
                                }
                                result.striped =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__stripe_count => {
                                if !fields.insert(__FieldTag::__stripe_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stripe_count",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int32Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.stripe_count = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__bak_type => {
                                if !fields.insert(__FieldTag::__bak_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bak_type",
                                    ));
                                }
                                result.bak_type = map
                                    .next_value::<std::option::Option<crate::model::BakType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__copy_only => {
                                if !fields.insert(__FieldTag::__copy_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for copy_only",
                                    ));
                                }
                                result.copy_only =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__differential_base => {
                                if !fields.insert(__FieldTag::__differential_base) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for differential_base",
                                    ));
                                }
                                result.differential_base =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlBakExportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.striped.is_some() {
                state.serialize_entry("striped", &self.striped)?;
            }
            if self.stripe_count.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("stripeCount", &__With(&self.stripe_count))?;
            }
            if !wkt::internal::is_default(&self.bak_type) {
                state.serialize_entry("bakType", &self.bak_type)?;
            }
            if self.copy_only.is_some() {
                state.serialize_entry("copyOnly", &self.copy_only)?;
            }
            if self.differential_base.is_some() {
                state.serialize_entry("differentialBase", &self.differential_base)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Database instance import context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportContext {
    /// Path to the import file in Cloud Storage, in the form
    /// `gs://bucketName/fileName`. Compressed gzip files (.gz) are supported
    /// when `fileType` is `SQL`. The instance must have
    /// write permissions to the bucket and read access to the file.
    pub uri: std::string::String,

    /// The target database for the import. If `fileType` is `SQL`, this field
    /// is required only if the import file does not specify a database, and is
    /// overridden by any database specification in the import file. If
    /// `fileType` is `CSV`, one database must be specified.
    pub database: std::string::String,

    /// This is always `sql#importContext`.
    pub kind: std::string::String,

    /// The file type for the specified uri.\`SQL`: The file
    /// contains SQL statements. \`CSV`: The file contains CSV data.
    pub file_type: crate::model::SqlFileType,

    /// Options for importing data as CSV.
    pub csv_import_options: std::option::Option<crate::model::import_context::SqlCsvImportOptions>,

    /// The PostgreSQL user for this import operation. PostgreSQL instances only.
    pub import_user: std::string::String,

    /// Import parameters specific to SQL Server .BAK files
    pub bak_import_options: std::option::Option<crate::model::import_context::SqlBakImportOptions>,

    /// Optional. Options for importing data from SQL statements.
    pub sql_import_options: std::option::Option<crate::model::import_context::SqlImportOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ImportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ImportContext::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ImportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ImportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [csv_import_options][crate::model::ImportContext::csv_import_options].
    pub fn set_csv_import_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlCsvImportOptions>,
    {
        self.csv_import_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [csv_import_options][crate::model::ImportContext::csv_import_options].
    pub fn set_or_clear_csv_import_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlCsvImportOptions>,
    {
        self.csv_import_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_user][crate::model::ImportContext::import_user].
    pub fn set_import_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_user = v.into();
        self
    }

    /// Sets the value of [bak_import_options][crate::model::ImportContext::bak_import_options].
    pub fn set_bak_import_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlBakImportOptions>,
    {
        self.bak_import_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bak_import_options][crate::model::ImportContext::bak_import_options].
    pub fn set_or_clear_bak_import_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlBakImportOptions>,
    {
        self.bak_import_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sql_import_options][crate::model::ImportContext::sql_import_options].
    pub fn set_sql_import_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlImportOptions>,
    {
        self.sql_import_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_import_options][crate::model::ImportContext::sql_import_options].
    pub fn set_or_clear_sql_import_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_context::SqlImportOptions>,
    {
        self.sql_import_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ImportContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __database,
            __kind,
            __file_type,
            __csv_import_options,
            __import_user,
            __bak_import_options,
            __sql_import_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "database" => Ok(__FieldTag::__database),
                            "kind" => Ok(__FieldTag::__kind),
                            "fileType" => Ok(__FieldTag::__file_type),
                            "file_type" => Ok(__FieldTag::__file_type),
                            "csvImportOptions" => Ok(__FieldTag::__csv_import_options),
                            "csv_import_options" => Ok(__FieldTag::__csv_import_options),
                            "importUser" => Ok(__FieldTag::__import_user),
                            "import_user" => Ok(__FieldTag::__import_user),
                            "bakImportOptions" => Ok(__FieldTag::__bak_import_options),
                            "bak_import_options" => Ok(__FieldTag::__bak_import_options),
                            "sqlImportOptions" => Ok(__FieldTag::__sql_import_options),
                            "sql_import_options" => Ok(__FieldTag::__sql_import_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_type => {
                            if !fields.insert(__FieldTag::__file_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_type",
                                ));
                            }
                            result.file_type = map
                                .next_value::<std::option::Option<crate::model::SqlFileType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__csv_import_options => {
                            if !fields.insert(__FieldTag::__csv_import_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_import_options",
                                ));
                            }
                            result.csv_import_options = map.next_value::<std::option::Option<
                                crate::model::import_context::SqlCsvImportOptions,
                            >>()?;
                        }
                        __FieldTag::__import_user => {
                            if !fields.insert(__FieldTag::__import_user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_user",
                                ));
                            }
                            result.import_user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bak_import_options => {
                            if !fields.insert(__FieldTag::__bak_import_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bak_import_options",
                                ));
                            }
                            result.bak_import_options = map.next_value::<std::option::Option<
                                crate::model::import_context::SqlBakImportOptions,
                            >>()?;
                        }
                        __FieldTag::__sql_import_options => {
                            if !fields.insert(__FieldTag::__sql_import_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_import_options",
                                ));
                            }
                            result.sql_import_options = map.next_value::<std::option::Option<
                                crate::model::import_context::SqlImportOptions,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.file_type) {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if self.csv_import_options.is_some() {
            state.serialize_entry("csvImportOptions", &self.csv_import_options)?;
        }
        if !self.import_user.is_empty() {
            state.serialize_entry("importUser", &self.import_user)?;
        }
        if self.bak_import_options.is_some() {
            state.serialize_entry("bakImportOptions", &self.bak_import_options)?;
        }
        if self.sql_import_options.is_some() {
            state.serialize_entry("sqlImportOptions", &self.sql_import_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportContext].
pub mod import_context {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlImportOptions {
        /// Optional. The number of threads to use for parallel import.
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the import should be parallel.
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for importing from a Cloud SQL for PostgreSQL instance.
        pub postgres_import_options: std::option::Option<
            crate::model::import_context::sql_import_options::PostgresImportOptions,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threads][crate::model::import_context::SqlImportOptions::threads].
        pub fn set_threads<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.threads = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [threads][crate::model::import_context::SqlImportOptions::threads].
        pub fn set_or_clear_threads<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int32Value>,
        {
            self.threads = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parallel][crate::model::import_context::SqlImportOptions::parallel].
        pub fn set_parallel<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.parallel = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parallel][crate::model::import_context::SqlImportOptions::parallel].
        pub fn set_or_clear_parallel<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.parallel = v.map(|x| x.into());
            self
        }

        /// Sets the value of [postgres_import_options][crate::model::import_context::SqlImportOptions::postgres_import_options].
        pub fn set_postgres_import_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::import_context::sql_import_options::PostgresImportOptions,
                >,
        {
            self.postgres_import_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [postgres_import_options][crate::model::import_context::SqlImportOptions::postgres_import_options].
        pub fn set_or_clear_postgres_import_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::import_context::sql_import_options::PostgresImportOptions,
                >,
        {
            self.postgres_import_options = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlImportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __threads,
                __parallel,
                __postgres_import_options,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlImportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "threads" => Ok(__FieldTag::__threads),
                                "parallel" => Ok(__FieldTag::__parallel),
                                "postgresImportOptions" => {
                                    Ok(__FieldTag::__postgres_import_options)
                                }
                                "postgres_import_options" => {
                                    Ok(__FieldTag::__postgres_import_options)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlImportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlImportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__threads => {
                                if !fields.insert(__FieldTag::__threads) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for threads",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int32Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.threads = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__parallel => {
                                if !fields.insert(__FieldTag::__parallel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parallel",
                                    ));
                                }
                                result.parallel =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__postgres_import_options => {
                                if !fields.insert(__FieldTag::__postgres_import_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for postgres_import_options",
                                    ));
                                }
                                result.postgres_import_options = map.next_value::<std::option::Option<crate::model::import_context::sql_import_options::PostgresImportOptions>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlImportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.threads.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("threads", &__With(&self.threads))?;
            }
            if self.parallel.is_some() {
                state.serialize_entry("parallel", &self.parallel)?;
            }
            if self.postgres_import_options.is_some() {
                state.serialize_entry("postgresImportOptions", &self.postgres_import_options)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SqlImportOptions].
    pub mod sql_import_options {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PostgresImportOptions {
            /// Optional. The --clean flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. The --if-exists flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            pub if_exists: std::option::Option<wkt::BoolValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PostgresImportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::import_context::sql_import_options::PostgresImportOptions::clean].
            pub fn set_clean<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [clean][crate::model::import_context::sql_import_options::PostgresImportOptions::clean].
            pub fn set_or_clear_clean<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.clean = v.map(|x| x.into());
                self
            }

            /// Sets the value of [if_exists][crate::model::import_context::sql_import_options::PostgresImportOptions::if_exists].
            pub fn set_if_exists<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.if_exists = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [if_exists][crate::model::import_context::sql_import_options::PostgresImportOptions::if_exists].
            pub fn set_or_clear_if_exists<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::BoolValue>,
            {
                self.if_exists = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for PostgresImportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions.PostgresImportOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PostgresImportOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __clean,
                    __if_exists,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PostgresImportOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "clean" => Ok(__FieldTag::__clean),
                                    "ifExists" => Ok(__FieldTag::__if_exists),
                                    "if_exists" => Ok(__FieldTag::__if_exists),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PostgresImportOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PostgresImportOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__clean => {
                                    if !fields.insert(__FieldTag::__clean) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for clean"),
                                        );
                                    }
                                    result.clean =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::__if_exists => {
                                    if !fields.insert(__FieldTag::__if_exists) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for if_exists",
                                            ),
                                        );
                                    }
                                    result.if_exists =
                                        map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PostgresImportOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.clean.is_some() {
                    state.serialize_entry("clean", &self.clean)?;
                }
                if self.if_exists.is_some() {
                    state.serialize_entry("ifExists", &self.if_exists)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlCsvImportOptions {
        /// The table to which CSV data is imported.
        pub table: std::string::String,

        /// The columns to which CSV data is imported. If not specified, all columns
        /// of the database table are loaded with CSV data.
        pub columns: std::vec::Vec<std::string::String>,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        pub lines_terminated_by: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlCsvImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::import_context::SqlCsvImportOptions::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::import_context::SqlCsvImportOptions::columns].
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [escape_character][crate::model::import_context::SqlCsvImportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::import_context::SqlCsvImportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::import_context::SqlCsvImportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::import_context::SqlCsvImportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.lines_terminated_by = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlCsvImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlCsvImportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlCsvImportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __table,
                __columns,
                __escape_character,
                __quote_character,
                __fields_terminated_by,
                __lines_terminated_by,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlCsvImportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "table" => Ok(__FieldTag::__table),
                                "columns" => Ok(__FieldTag::__columns),
                                "escapeCharacter" => Ok(__FieldTag::__escape_character),
                                "escape_character" => Ok(__FieldTag::__escape_character),
                                "quoteCharacter" => Ok(__FieldTag::__quote_character),
                                "quote_character" => Ok(__FieldTag::__quote_character),
                                "fieldsTerminatedBy" => Ok(__FieldTag::__fields_terminated_by),
                                "fields_terminated_by" => Ok(__FieldTag::__fields_terminated_by),
                                "linesTerminatedBy" => Ok(__FieldTag::__lines_terminated_by),
                                "lines_terminated_by" => Ok(__FieldTag::__lines_terminated_by),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlCsvImportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlCsvImportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__columns => {
                                if !fields.insert(__FieldTag::__columns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for columns",
                                    ));
                                }
                                result.columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__escape_character => {
                                if !fields.insert(__FieldTag::__escape_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for escape_character",
                                    ));
                                }
                                result.escape_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__quote_character => {
                                if !fields.insert(__FieldTag::__quote_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quote_character",
                                    ));
                                }
                                result.quote_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fields_terminated_by => {
                                if !fields.insert(__FieldTag::__fields_terminated_by) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fields_terminated_by",
                                    ));
                                }
                                result.fields_terminated_by = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__lines_terminated_by => {
                                if !fields.insert(__FieldTag::__lines_terminated_by) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lines_terminated_by",
                                    ));
                                }
                                result.lines_terminated_by = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlCsvImportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self.columns.is_empty() {
                state.serialize_entry("columns", &self.columns)?;
            }
            if !self.escape_character.is_empty() {
                state.serialize_entry("escapeCharacter", &self.escape_character)?;
            }
            if !self.quote_character.is_empty() {
                state.serialize_entry("quoteCharacter", &self.quote_character)?;
            }
            if !self.fields_terminated_by.is_empty() {
                state.serialize_entry("fieldsTerminatedBy", &self.fields_terminated_by)?;
            }
            if !self.lines_terminated_by.is_empty() {
                state.serialize_entry("linesTerminatedBy", &self.lines_terminated_by)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlBakImportOptions {
        pub encryption_options: std::option::Option<
            crate::model::import_context::sql_bak_import_options::EncryptionOptions,
        >,

        /// Whether or not the backup set being restored is striped.
        /// Applies only to Cloud SQL for SQL Server.
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing will restore database
        /// with NORECOVERY option
        /// Applies only to Cloud SQL for SQL Server.
        pub no_recovery: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing request will just bring database
        /// online without downloading Bak content only one of "no_recovery" and
        /// "recovery_only" can be true otherwise error will return. Applies only to
        /// Cloud SQL for SQL Server.
        pub recovery_only: std::option::Option<wkt::BoolValue>,

        /// Type of the bak content, FULL or DIFF
        pub bak_type: crate::model::BakType,

        /// Optional. The timestamp when the import should stop. This timestamp is in
        /// the [RFC 3339](https://tools.ietf.org/html/rfc3339) format (for example,
        /// `2023-10-01T16:19:00.094`). This field is equivalent to the STOPAT
        /// keyword and applies to Cloud SQL for SQL Server only.
        pub stop_at: std::option::Option<wkt::Timestamp>,

        /// Optional. The marked transaction where the import should stop. This field
        /// is equivalent to the STOPATMARK keyword and applies to Cloud SQL for SQL
        /// Server only.
        pub stop_at_mark: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlBakImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encryption_options][crate::model::import_context::SqlBakImportOptions::encryption_options].
        pub fn set_encryption_options<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::import_context::sql_bak_import_options::EncryptionOptions,
                >,
        {
            self.encryption_options = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encryption_options][crate::model::import_context::SqlBakImportOptions::encryption_options].
        pub fn set_or_clear_encryption_options<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::import_context::sql_bak_import_options::EncryptionOptions,
                >,
        {
            self.encryption_options = v.map(|x| x.into());
            self
        }

        /// Sets the value of [striped][crate::model::import_context::SqlBakImportOptions::striped].
        pub fn set_striped<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.striped = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [striped][crate::model::import_context::SqlBakImportOptions::striped].
        pub fn set_or_clear_striped<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.striped = v.map(|x| x.into());
            self
        }

        /// Sets the value of [no_recovery][crate::model::import_context::SqlBakImportOptions::no_recovery].
        pub fn set_no_recovery<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.no_recovery = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [no_recovery][crate::model::import_context::SqlBakImportOptions::no_recovery].
        pub fn set_or_clear_no_recovery<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.no_recovery = v.map(|x| x.into());
            self
        }

        /// Sets the value of [recovery_only][crate::model::import_context::SqlBakImportOptions::recovery_only].
        pub fn set_recovery_only<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.recovery_only = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [recovery_only][crate::model::import_context::SqlBakImportOptions::recovery_only].
        pub fn set_or_clear_recovery_only<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::BoolValue>,
        {
            self.recovery_only = v.map(|x| x.into());
            self
        }

        /// Sets the value of [bak_type][crate::model::import_context::SqlBakImportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [stop_at][crate::model::import_context::SqlBakImportOptions::stop_at].
        pub fn set_stop_at<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.stop_at = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stop_at][crate::model::import_context::SqlBakImportOptions::stop_at].
        pub fn set_or_clear_stop_at<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.stop_at = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stop_at_mark][crate::model::import_context::SqlBakImportOptions::stop_at_mark].
        pub fn set_stop_at_mark<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.stop_at_mark = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlBakImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlBakImportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encryption_options,
                __striped,
                __no_recovery,
                __recovery_only,
                __bak_type,
                __stop_at,
                __stop_at_mark,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlBakImportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encryptionOptions" => Ok(__FieldTag::__encryption_options),
                                "encryption_options" => Ok(__FieldTag::__encryption_options),
                                "striped" => Ok(__FieldTag::__striped),
                                "noRecovery" => Ok(__FieldTag::__no_recovery),
                                "no_recovery" => Ok(__FieldTag::__no_recovery),
                                "recoveryOnly" => Ok(__FieldTag::__recovery_only),
                                "recovery_only" => Ok(__FieldTag::__recovery_only),
                                "bakType" => Ok(__FieldTag::__bak_type),
                                "bak_type" => Ok(__FieldTag::__bak_type),
                                "stopAt" => Ok(__FieldTag::__stop_at),
                                "stop_at" => Ok(__FieldTag::__stop_at),
                                "stopAtMark" => Ok(__FieldTag::__stop_at_mark),
                                "stop_at_mark" => Ok(__FieldTag::__stop_at_mark),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlBakImportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlBakImportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encryption_options => {
                                if !fields.insert(__FieldTag::__encryption_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encryption_options",
                                    ));
                                }
                                result.encryption_options = map.next_value::<std::option::Option<crate::model::import_context::sql_bak_import_options::EncryptionOptions>>()?
                                    ;
                            }
                            __FieldTag::__striped => {
                                if !fields.insert(__FieldTag::__striped) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for striped",
                                    ));
                                }
                                result.striped =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__no_recovery => {
                                if !fields.insert(__FieldTag::__no_recovery) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_recovery",
                                    ));
                                }
                                result.no_recovery =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__recovery_only => {
                                if !fields.insert(__FieldTag::__recovery_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recovery_only",
                                    ));
                                }
                                result.recovery_only =
                                    map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                            }
                            __FieldTag::__bak_type => {
                                if !fields.insert(__FieldTag::__bak_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bak_type",
                                    ));
                                }
                                result.bak_type = map
                                    .next_value::<std::option::Option<crate::model::BakType>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__stop_at => {
                                if !fields.insert(__FieldTag::__stop_at) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stop_at",
                                    ));
                                }
                                result.stop_at =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__stop_at_mark => {
                                if !fields.insert(__FieldTag::__stop_at_mark) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stop_at_mark",
                                    ));
                                }
                                result.stop_at_mark = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlBakImportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.encryption_options.is_some() {
                state.serialize_entry("encryptionOptions", &self.encryption_options)?;
            }
            if self.striped.is_some() {
                state.serialize_entry("striped", &self.striped)?;
            }
            if self.no_recovery.is_some() {
                state.serialize_entry("noRecovery", &self.no_recovery)?;
            }
            if self.recovery_only.is_some() {
                state.serialize_entry("recoveryOnly", &self.recovery_only)?;
            }
            if !wkt::internal::is_default(&self.bak_type) {
                state.serialize_entry("bakType", &self.bak_type)?;
            }
            if self.stop_at.is_some() {
                state.serialize_entry("stopAt", &self.stop_at)?;
            }
            if !self.stop_at_mark.is_empty() {
                state.serialize_entry("stopAtMark", &self.stop_at_mark)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SqlBakImportOptions].
    pub mod sql_bak_import_options {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct EncryptionOptions {
            /// Path to the Certificate (.cer) in Cloud Storage, in the form
            /// `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            pub cert_path: std::string::String,

            /// Path to the Certificate Private Key (.pvk)  in Cloud Storage, in the
            /// form `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            pub pvk_path: std::string::String,

            /// Password that encrypts the private key
            pub pvk_password: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cert_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::cert_path].
            pub fn set_cert_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cert_path = v.into();
                self
            }

            /// Sets the value of [pvk_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_path].
            pub fn set_pvk_path<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.pvk_path = v.into();
                self
            }

            /// Sets the value of [pvk_password][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_password].
            pub fn set_pvk_password<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.pvk_password = v.into();
                self
            }
        }

        impl wkt::message::Message for EncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions.EncryptionOptions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for EncryptionOptions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __cert_path,
                    __pvk_path,
                    __pvk_password,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for EncryptionOptions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "certPath" => Ok(__FieldTag::__cert_path),
                                    "cert_path" => Ok(__FieldTag::__cert_path),
                                    "pvkPath" => Ok(__FieldTag::__pvk_path),
                                    "pvk_path" => Ok(__FieldTag::__pvk_path),
                                    "pvkPassword" => Ok(__FieldTag::__pvk_password),
                                    "pvk_password" => Ok(__FieldTag::__pvk_password),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = EncryptionOptions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct EncryptionOptions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__cert_path => {
                                    if !fields.insert(__FieldTag::__cert_path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cert_path",
                                            ),
                                        );
                                    }
                                    result.cert_path = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__pvk_path => {
                                    if !fields.insert(__FieldTag::__pvk_path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pvk_path",
                                            ),
                                        );
                                    }
                                    result.pvk_path = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__pvk_password => {
                                    if !fields.insert(__FieldTag::__pvk_password) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pvk_password",
                                            ),
                                        );
                                    }
                                    result.pvk_password = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for EncryptionOptions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.cert_path.is_empty() {
                    state.serialize_entry("certPath", &self.cert_path)?;
                }
                if !self.pvk_path.is_empty() {
                    state.serialize_entry("pvkPath", &self.pvk_path)?;
                }
                if !self.pvk_password.is_empty() {
                    state.serialize_entry("pvkPassword", &self.pvk_password)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// IP Management configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IpConfiguration {
    /// Whether the instance is assigned a public IP address or not.
    pub ipv4_enabled: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    pub private_network: std::string::String,

    /// Use `ssl_mode` instead.
    ///
    /// Whether SSL/TLS connections over IP are enforced.
    /// If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections.
    /// For SSL/TLS connections, the client certificate won't be verified. If
    /// set to true, then only allow connections encrypted with SSL/TLS and with
    /// valid client certificates. If you want to enforce SSL/TLS without enforcing
    /// the requirement for valid client certificates, then use the `ssl_mode` flag
    /// instead of the `require_ssl` flag.
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. In 'CIDR' notation, also known as 'slash' notation (for
    /// example: `157.197.200.0/24`).
    pub authorized_networks: std::vec::Vec<crate::model::AclEntry>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the instance ip
    /// will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// `[a-z]([-a-z0-9]*[a-z0-9])?.`
    pub allocated_ip_range: std::string::String,

    /// Controls connectivity to private IP instances from Google services,
    /// such as BigQuery.
    pub enable_private_path_for_google_cloud_services: std::option::Option<wkt::BoolValue>,

    /// Specify how SSL/TLS is enforced in database connections. If you must use
    /// the `require_ssl` flag for backward compatibility, then only the following
    /// value pairs are valid:
    ///
    /// For PostgreSQL and MySQL:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`
    /// * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true`
    ///
    /// For SQL Server:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=true`
    ///
    /// The value of `ssl_mode` has priority over the value of `require_ssl`.
    ///
    /// For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and
    /// `require_ssl=false`, `ssl_mode=ENCRYPTED_ONLY` means accept only SSL
    /// connections, while `require_ssl=false` means accept both non-SSL
    /// and SSL connections. In this case, MySQL and PostgreSQL databases respect
    /// `ssl_mode` and accepts only SSL connections.
    pub ssl_mode: crate::model::ip_configuration::SslMode,

    /// PSC settings for this instance.
    pub psc_config: std::option::Option<crate::model::PscConfig>,

    /// Specify what type of CA is used for the server certificate.
    pub server_ca_mode: std::option::Option<crate::model::ip_configuration::CaMode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ipv4_enabled][crate::model::IpConfiguration::ipv4_enabled].
    pub fn set_ipv4_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ipv4_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv4_enabled][crate::model::IpConfiguration::ipv4_enabled].
    pub fn set_or_clear_ipv4_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.ipv4_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_network][crate::model::IpConfiguration::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::IpConfiguration::require_ssl].
    pub fn set_require_ssl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_ssl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [require_ssl][crate::model::IpConfiguration::require_ssl].
    pub fn set_or_clear_require_ssl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_ssl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorized_networks][crate::model::IpConfiguration::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AclEntry>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::IpConfiguration::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [enable_private_path_for_google_cloud_services][crate::model::IpConfiguration::enable_private_path_for_google_cloud_services].
    pub fn set_enable_private_path_for_google_cloud_services<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_private_path_for_google_cloud_services = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_private_path_for_google_cloud_services][crate::model::IpConfiguration::enable_private_path_for_google_cloud_services].
    pub fn set_or_clear_enable_private_path_for_google_cloud_services<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_private_path_for_google_cloud_services = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_mode][crate::model::IpConfiguration::ssl_mode].
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ip_configuration::SslMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::IpConfiguration::psc_config].
    pub fn set_psc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PscConfig>,
    {
        self.psc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_config][crate::model::IpConfiguration::psc_config].
    pub fn set_or_clear_psc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PscConfig>,
    {
        self.psc_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::IpConfiguration::server_ca_mode].
    pub fn set_server_ca_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ip_configuration::CaMode>,
    {
        self.server_ca_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [server_ca_mode][crate::model::IpConfiguration::server_ca_mode].
    pub fn set_or_clear_server_ca_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ip_configuration::CaMode>,
    {
        self.server_ca_mode = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IpConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IpConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ipv4_enabled,
            __private_network,
            __require_ssl,
            __authorized_networks,
            __allocated_ip_range,
            __enable_private_path_for_google_cloud_services,
            __ssl_mode,
            __psc_config,
            __server_ca_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipv4Enabled" => Ok(__FieldTag::__ipv4_enabled),
                            "ipv4_enabled" => Ok(__FieldTag::__ipv4_enabled),
                            "privateNetwork" => Ok(__FieldTag::__private_network),
                            "private_network" => Ok(__FieldTag::__private_network),
                            "requireSsl" => Ok(__FieldTag::__require_ssl),
                            "require_ssl" => Ok(__FieldTag::__require_ssl),
                            "authorizedNetworks" => Ok(__FieldTag::__authorized_networks),
                            "authorized_networks" => Ok(__FieldTag::__authorized_networks),
                            "allocatedIpRange" => Ok(__FieldTag::__allocated_ip_range),
                            "allocated_ip_range" => Ok(__FieldTag::__allocated_ip_range),
                            "enablePrivatePathForGoogleCloudServices" => {
                                Ok(__FieldTag::__enable_private_path_for_google_cloud_services)
                            }
                            "enable_private_path_for_google_cloud_services" => {
                                Ok(__FieldTag::__enable_private_path_for_google_cloud_services)
                            }
                            "sslMode" => Ok(__FieldTag::__ssl_mode),
                            "ssl_mode" => Ok(__FieldTag::__ssl_mode),
                            "pscConfig" => Ok(__FieldTag::__psc_config),
                            "psc_config" => Ok(__FieldTag::__psc_config),
                            "serverCaMode" => Ok(__FieldTag::__server_ca_mode),
                            "server_ca_mode" => Ok(__FieldTag::__server_ca_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IpConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ipv4_enabled => {
                            if !fields.insert(__FieldTag::__ipv4_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv4_enabled",
                                ));
                            }
                            result.ipv4_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__private_network => {
                            if !fields.insert(__FieldTag::__private_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_network",
                                ));
                            }
                            result.private_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__require_ssl => {
                            if !fields.insert(__FieldTag::__require_ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_ssl",
                                ));
                            }
                            result.require_ssl =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__authorized_networks => {
                            if !fields.insert(__FieldTag::__authorized_networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_networks",
                                ));
                            }
                            result.authorized_networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AclEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allocated_ip_range => {
                            if !fields.insert(__FieldTag::__allocated_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocated_ip_range",
                                ));
                            }
                            result.allocated_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_path_for_google_cloud_services => {
                            if !fields
                                .insert(__FieldTag::__enable_private_path_for_google_cloud_services)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_path_for_google_cloud_services",
                                ));
                            }
                            result.enable_private_path_for_google_cloud_services =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__ssl_mode => {
                            if !fields.insert(__FieldTag::__ssl_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_mode",
                                ));
                            }
                            result.ssl_mode = map.next_value::<std::option::Option<crate::model::ip_configuration::SslMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__psc_config => {
                            if !fields.insert(__FieldTag::__psc_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_config",
                                ));
                            }
                            result.psc_config =
                                map.next_value::<std::option::Option<crate::model::PscConfig>>()?;
                        }
                        __FieldTag::__server_ca_mode => {
                            if !fields.insert(__FieldTag::__server_ca_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ca_mode",
                                ));
                            }
                            result.server_ca_mode = map.next_value::<std::option::Option<crate::model::ip_configuration::CaMode>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IpConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ipv4_enabled.is_some() {
            state.serialize_entry("ipv4Enabled", &self.ipv4_enabled)?;
        }
        if !self.private_network.is_empty() {
            state.serialize_entry("privateNetwork", &self.private_network)?;
        }
        if self.require_ssl.is_some() {
            state.serialize_entry("requireSsl", &self.require_ssl)?;
        }
        if !self.authorized_networks.is_empty() {
            state.serialize_entry("authorizedNetworks", &self.authorized_networks)?;
        }
        if !self.allocated_ip_range.is_empty() {
            state.serialize_entry("allocatedIpRange", &self.allocated_ip_range)?;
        }
        if self.enable_private_path_for_google_cloud_services.is_some() {
            state.serialize_entry(
                "enablePrivatePathForGoogleCloudServices",
                &self.enable_private_path_for_google_cloud_services,
            )?;
        }
        if !wkt::internal::is_default(&self.ssl_mode) {
            state.serialize_entry("sslMode", &self.ssl_mode)?;
        }
        if self.psc_config.is_some() {
            state.serialize_entry("pscConfig", &self.psc_config)?;
        }
        if self.server_ca_mode.is_some() {
            state.serialize_entry("serverCaMode", &self.server_ca_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [IpConfiguration].
pub mod ip_configuration {
    #[allow(unused_imports)]
    use super::*;

    /// The SSL options for database connections.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslMode {
        /// The SSL mode is unknown.
        Unspecified,
        /// Allow non-SSL/non-TLS and SSL/TLS connections.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        AllowUnencryptedAndEncrypted,
        /// Only allow connections encrypted with SSL/TLS.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        EncryptedOnly,
        /// Only allow connections encrypted with SSL/TLS and with valid
        /// client certificates.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be true or
        /// cleared to avoid the conflict between values of two flags.
        /// PostgreSQL clients or users that connect using IAM database
        /// authentication must use either the
        /// [Cloud SQL Auth
        /// Proxy](https://cloud.google.com/sql/docs/postgres/connect-auth-proxy) or
        /// [Cloud SQL
        /// Connectors](https://cloud.google.com/sql/docs/postgres/connect-connectors)
        /// to enforce client identity verification.
        ///
        /// Only applicable to MySQL and PostgreSQL. Not applicable to SQL Server.
        TrustedClientCertificateRequired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslMode::value] or
        /// [SslMode::name].
        UnknownValue(ssl_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllowUnencryptedAndEncrypted => std::option::Option::Some(1),
                Self::EncryptedOnly => std::option::Option::Some(2),
                Self::TrustedClientCertificateRequired => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MODE_UNSPECIFIED"),
                Self::AllowUnencryptedAndEncrypted => {
                    std::option::Option::Some("ALLOW_UNENCRYPTED_AND_ENCRYPTED")
                }
                Self::EncryptedOnly => std::option::Option::Some("ENCRYPTED_ONLY"),
                Self::TrustedClientCertificateRequired => {
                    std::option::Option::Some("TRUSTED_CLIENT_CERTIFICATE_REQUIRED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllowUnencryptedAndEncrypted,
                2 => Self::EncryptedOnly,
                3 => Self::TrustedClientCertificateRequired,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MODE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => Self::AllowUnencryptedAndEncrypted,
                "ENCRYPTED_ONLY" => Self::EncryptedOnly,
                "TRUSTED_CLIENT_CERTIFICATE_REQUIRED" => Self::TrustedClientCertificateRequired,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllowUnencryptedAndEncrypted => serializer.serialize_i32(1),
                Self::EncryptedOnly => serializer.serialize_i32(2),
                Self::TrustedClientCertificateRequired => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslMode>::new(
                ".google.cloud.sql.v1.IpConfiguration.SslMode",
            ))
        }
    }

    /// Various Certificate Authority (CA) modes for certificate signing.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaMode::value] or
        /// [CaMode::name].
        UnknownValue(ca_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManagedInternalCa => std::option::Option::Some(1),
                Self::GoogleManagedCasCa => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_MODE_UNSPECIFIED"),
                Self::GoogleManagedInternalCa => {
                    std::option::Option::Some("GOOGLE_MANAGED_INTERNAL_CA")
                }
                Self::GoogleManagedCasCa => std::option::Option::Some("GOOGLE_MANAGED_CAS_CA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManagedInternalCa,
                2 => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CaMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_MODE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED_INTERNAL_CA" => Self::GoogleManagedInternalCa,
                "GOOGLE_MANAGED_CAS_CA" => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManagedInternalCa => serializer.serialize_i32(1),
                Self::GoogleManagedCasCa => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaMode>::new(
                ".google.cloud.sql.v1.IpConfiguration.CaMode",
            ))
        }
    }
}

/// PSC settings for a Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PscConfig {
    /// Whether PSC connectivity is enabled for this instance.
    pub psc_enabled: std::option::Option<bool>,

    /// Optional. The list of consumer projects that are allow-listed for PSC
    /// connections to this instance. This instance can be connected to with PSC
    /// from any network in these projects.
    ///
    /// Each consumer project in this list may be represented by a project number
    /// (numeric) or by a project id (alphanumeric).
    pub allowed_consumer_projects: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_enabled][crate::model::PscConfig::psc_enabled].
    pub fn set_psc_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.psc_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_enabled][crate::model::PscConfig::psc_enabled].
    pub fn set_or_clear_psc_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.psc_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allowed_consumer_projects][crate::model::PscConfig::allowed_consumer_projects].
    pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PscConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PscConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PscConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __psc_enabled,
            __allowed_consumer_projects,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PscConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pscEnabled" => Ok(__FieldTag::__psc_enabled),
                            "psc_enabled" => Ok(__FieldTag::__psc_enabled),
                            "allowedConsumerProjects" => {
                                Ok(__FieldTag::__allowed_consumer_projects)
                            }
                            "allowed_consumer_projects" => {
                                Ok(__FieldTag::__allowed_consumer_projects)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PscConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PscConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__psc_enabled => {
                            if !fields.insert(__FieldTag::__psc_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_enabled",
                                ));
                            }
                            result.psc_enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__allowed_consumer_projects => {
                            if !fields.insert(__FieldTag::__allowed_consumer_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_consumer_projects",
                                ));
                            }
                            result.allowed_consumer_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PscConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.psc_enabled.is_some() {
            state.serialize_entry("pscEnabled", &self.psc_enabled)?;
        }
        if !self.allowed_consumer_projects.is_empty() {
            state.serialize_entry("allowedConsumerProjects", &self.allowed_consumer_projects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Preferred location. This specifies where a Cloud SQL instance is located.
/// Note that if the preferred location is not available, the instance will be
/// located as close as possible within the region. Only one location may be
/// specified.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPreference {
    /// The App Engine application to follow, it must be in the same region as the
    /// Cloud SQL instance. WARNING: Changing this might restart the instance.
    #[deprecated]
    pub follow_gae_application: std::string::String,

    /// The preferred Compute Engine zone (for example: us-central1-a,
    /// us-central1-b, etc.). WARNING: Changing this might restart the instance.
    pub zone: std::string::String,

    /// The preferred Compute Engine zone for the secondary/failover
    /// (for example: us-central1-a, us-central1-b, etc.).
    /// To disable this field, set it to 'no_secondary_zone'.
    pub secondary_zone: std::string::String,

    /// This is always `sql#locationPreference`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationPreference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [follow_gae_application][crate::model::LocationPreference::follow_gae_application].
    #[deprecated]
    pub fn set_follow_gae_application<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.follow_gae_application = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::LocationPreference::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::LocationPreference::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::LocationPreference::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for LocationPreference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.LocationPreference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationPreference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __follow_gae_application,
            __zone,
            __secondary_zone,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationPreference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "followGaeApplication" => Ok(__FieldTag::__follow_gae_application),
                            "follow_gae_application" => Ok(__FieldTag::__follow_gae_application),
                            "zone" => Ok(__FieldTag::__zone),
                            "secondaryZone" => Ok(__FieldTag::__secondary_zone),
                            "secondary_zone" => Ok(__FieldTag::__secondary_zone),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationPreference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationPreference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__follow_gae_application => {
                            if !fields.insert(__FieldTag::__follow_gae_application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for follow_gae_application",
                                ));
                            }
                            result.follow_gae_application = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_zone => {
                            if !fields.insert(__FieldTag::__secondary_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_zone",
                                ));
                            }
                            result.secondary_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationPreference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.follow_gae_application.is_empty() {
            state.serialize_entry("followGaeApplication", &self.follow_gae_application)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.secondary_zone.is_empty() {
            state.serialize_entry("secondaryZone", &self.secondary_zone)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Maintenance window. This specifies when a Cloud SQL instance is
/// restarted for system maintenance purposes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Hour of day - 0 to 23. Specify in the UTC time zone.
    pub hour: std::option::Option<wkt::Int32Value>,

    /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
    /// `SATURDAY`, or `SUNDAY`. Specify in the UTC time zone.
    /// Returned in output as an integer, 1 to 7, where `1` equals Monday.
    pub day: std::option::Option<wkt::Int32Value>,

    /// Maintenance timing settings: `canary`, `stable`, or `week5`.
    /// For more information, see [About maintenance on Cloud SQL
    /// instances](https://cloud.google.com/sql/docs/mysql/maintenance).
    pub update_track: crate::model::SqlUpdateTrack,

    /// This is always `sql#maintenanceWindow`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hour][crate::model::MaintenanceWindow::hour].
    pub fn set_hour<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.hour = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hour][crate::model::MaintenanceWindow::hour].
    pub fn set_or_clear_hour<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.hour = v.map(|x| x.into());
        self
    }

    /// Sets the value of [day][crate::model::MaintenanceWindow::day].
    pub fn set_day<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.day = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [day][crate::model::MaintenanceWindow::day].
    pub fn set_or_clear_day<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.day = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_track][crate::model::MaintenanceWindow::update_track].
    pub fn set_update_track<T: std::convert::Into<crate::model::SqlUpdateTrack>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_track = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::MaintenanceWindow::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hour,
            __day,
            __update_track,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hour" => Ok(__FieldTag::__hour),
                            "day" => Ok(__FieldTag::__day),
                            "updateTrack" => Ok(__FieldTag::__update_track),
                            "update_track" => Ok(__FieldTag::__update_track),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hour => {
                            if !fields.insert(__FieldTag::__hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hour",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hour = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.day = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__update_track => {
                            if !fields.insert(__FieldTag::__update_track) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_track",
                                ));
                            }
                            result.update_track = map
                                .next_value::<std::option::Option<crate::model::SqlUpdateTrack>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hour.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hour", &__With(&self.hour))?;
        }
        if self.day.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("day", &__With(&self.day))?;
        }
        if !wkt::internal::is_default(&self.update_track) {
            state.serialize_entry("updateTrack", &self.update_track)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Deny maintenance Periods. This specifies a date range during when all CSA
/// rollout will be denied.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DenyMaintenancePeriod {
    /// "deny maintenance period" start date. If the year of the start date is
    /// empty, the year of the end date also must be empty. In this case, it means
    /// the deny maintenance period recurs every year. The date is in format
    /// yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
    pub start_date: std::string::String,

    /// "deny maintenance period" end date. If the year of the end date is empty,
    /// the year of the start date also must be empty. In this case, it means the
    /// no maintenance interval recurs every year. The date is in format yyyy-mm-dd
    /// i.e., 2020-11-01, or mm-dd, i.e., 11-01
    pub end_date: std::string::String,

    /// Time in UTC when the "deny maintenance period" starts on start_date and
    /// ends on end_date. The time is in format: HH:mm:SS, i.e., 00:00:00
    pub time: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DenyMaintenancePeriod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_date][crate::model::DenyMaintenancePeriod::start_date].
    pub fn set_start_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_date = v.into();
        self
    }

    /// Sets the value of [end_date][crate::model::DenyMaintenancePeriod::end_date].
    pub fn set_end_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_date = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DenyMaintenancePeriod::time].
    pub fn set_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time = v.into();
        self
    }
}

impl wkt::message::Message for DenyMaintenancePeriod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DenyMaintenancePeriod"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DenyMaintenancePeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_date,
            __end_date,
            __time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DenyMaintenancePeriod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startDate" => Ok(__FieldTag::__start_date),
                            "start_date" => Ok(__FieldTag::__start_date),
                            "endDate" => Ok(__FieldTag::__end_date),
                            "end_date" => Ok(__FieldTag::__end_date),
                            "time" => Ok(__FieldTag::__time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DenyMaintenancePeriod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DenyMaintenancePeriod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_date => {
                            if !fields.insert(__FieldTag::__start_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_date",
                                ));
                            }
                            result.start_date = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_date => {
                            if !fields.insert(__FieldTag::__end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_date",
                                ));
                            }
                            result.end_date = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time => {
                            if !fields.insert(__FieldTag::__time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time",
                                ));
                            }
                            result.time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DenyMaintenancePeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.start_date.is_empty() {
            state.serialize_entry("startDate", &self.start_date)?;
        }
        if !self.end_date.is_empty() {
            state.serialize_entry("endDate", &self.end_date)?;
        }
        if !self.time.is_empty() {
            state.serialize_entry("time", &self.time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Insights configuration. This specifies when Cloud SQL Insights feature is
/// enabled and optional configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightsConfig {
    /// Whether Query Insights feature is enabled.
    pub query_insights_enabled: bool,

    /// Whether Query Insights will record client address when enabled.
    pub record_client_address: bool,

    /// Whether Query Insights will record application tags from query when
    /// enabled.
    pub record_application_tags: bool,

    /// Maximum query length stored in bytes. Default value: 1024 bytes.
    /// Range: 256-4500 bytes. Query length more than this field value will be
    /// truncated to this value. When unset, query length will be the default
    /// value. Changing query length will restart the database.
    pub query_string_length: std::option::Option<wkt::Int32Value>,

    /// Number of query execution plans captured by Insights per minute
    /// for all queries combined. Default is 5.
    pub query_plans_per_minute: std::option::Option<wkt::Int32Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_insights_enabled][crate::model::InsightsConfig::query_insights_enabled].
    pub fn set_query_insights_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.query_insights_enabled = v.into();
        self
    }

    /// Sets the value of [record_client_address][crate::model::InsightsConfig::record_client_address].
    pub fn set_record_client_address<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_client_address = v.into();
        self
    }

    /// Sets the value of [record_application_tags][crate::model::InsightsConfig::record_application_tags].
    pub fn set_record_application_tags<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_application_tags = v.into();
        self
    }

    /// Sets the value of [query_string_length][crate::model::InsightsConfig::query_string_length].
    pub fn set_query_string_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.query_string_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_string_length][crate::model::InsightsConfig::query_string_length].
    pub fn set_or_clear_query_string_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.query_string_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_plans_per_minute][crate::model::InsightsConfig::query_plans_per_minute].
    pub fn set_query_plans_per_minute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.query_plans_per_minute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_plans_per_minute][crate::model::InsightsConfig::query_plans_per_minute].
    pub fn set_or_clear_query_plans_per_minute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.query_plans_per_minute = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsightsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InsightsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_insights_enabled,
            __record_client_address,
            __record_application_tags,
            __query_string_length,
            __query_plans_per_minute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryInsightsEnabled" => Ok(__FieldTag::__query_insights_enabled),
                            "query_insights_enabled" => Ok(__FieldTag::__query_insights_enabled),
                            "recordClientAddress" => Ok(__FieldTag::__record_client_address),
                            "record_client_address" => Ok(__FieldTag::__record_client_address),
                            "recordApplicationTags" => Ok(__FieldTag::__record_application_tags),
                            "record_application_tags" => Ok(__FieldTag::__record_application_tags),
                            "queryStringLength" => Ok(__FieldTag::__query_string_length),
                            "query_string_length" => Ok(__FieldTag::__query_string_length),
                            "queryPlansPerMinute" => Ok(__FieldTag::__query_plans_per_minute),
                            "query_plans_per_minute" => Ok(__FieldTag::__query_plans_per_minute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_insights_enabled => {
                            if !fields.insert(__FieldTag::__query_insights_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_insights_enabled",
                                ));
                            }
                            result.query_insights_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__record_client_address => {
                            if !fields.insert(__FieldTag::__record_client_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_client_address",
                                ));
                            }
                            result.record_client_address = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__record_application_tags => {
                            if !fields.insert(__FieldTag::__record_application_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_application_tags",
                                ));
                            }
                            result.record_application_tags = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_string_length => {
                            if !fields.insert(__FieldTag::__query_string_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_string_length",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.query_string_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__query_plans_per_minute => {
                            if !fields.insert(__FieldTag::__query_plans_per_minute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_plans_per_minute",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.query_plans_per_minute = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.query_insights_enabled) {
            state.serialize_entry("queryInsightsEnabled", &self.query_insights_enabled)?;
        }
        if !wkt::internal::is_default(&self.record_client_address) {
            state.serialize_entry("recordClientAddress", &self.record_client_address)?;
        }
        if !wkt::internal::is_default(&self.record_application_tags) {
            state.serialize_entry("recordApplicationTags", &self.record_application_tags)?;
        }
        if self.query_string_length.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("queryStringLength", &__With(&self.query_string_length))?;
        }
        if self.query_plans_per_minute.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("queryPlansPerMinute", &__With(&self.query_plans_per_minute))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MySqlReplicaConfiguration {
    /// Path to a SQL dump file in Google Cloud Storage from which the replica
    /// instance is to be created. The URI is in the form gs://bucketName/fileName.
    /// Compressed gzip files (.gz) are also supported.
    /// Dumps have the binlog co-ordinates from which replication
    /// begins. This can be accomplished by setting --master-data to 1 when using
    /// mysqldump.
    pub dump_file_path: std::string::String,

    /// The username for the replication connection.
    pub username: std::string::String,

    /// The password for the replication connection.
    pub password: std::string::String,

    /// Seconds to wait between connect retries. MySQL's default is 60 seconds.
    pub connect_retry_interval: std::option::Option<wkt::Int32Value>,

    /// Interval in milliseconds between replication heartbeats.
    pub master_heartbeat_period: std::option::Option<wkt::Int64Value>,

    /// PEM representation of the trusted CA's x509 certificate.
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    pub client_key: std::string::String,

    /// A list of permissible ciphers to use for SSL encryption.
    pub ssl_cipher: std::string::String,

    /// Whether or not to check the primary instance's Common Name value in the
    /// certificate that it sends during the SSL handshake.
    pub verify_server_certificate: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#mysqlReplicaConfiguration`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dump_file_path][crate::model::MySqlReplicaConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [connect_retry_interval][crate::model::MySqlReplicaConfiguration::connect_retry_interval].
    pub fn set_connect_retry_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.connect_retry_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connect_retry_interval][crate::model::MySqlReplicaConfiguration::connect_retry_interval].
    pub fn set_or_clear_connect_retry_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.connect_retry_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_heartbeat_period][crate::model::MySqlReplicaConfiguration::master_heartbeat_period].
    pub fn set_master_heartbeat_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.master_heartbeat_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_heartbeat_period][crate::model::MySqlReplicaConfiguration::master_heartbeat_period].
    pub fn set_or_clear_master_heartbeat_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.master_heartbeat_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ca_certificate][crate::model::MySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::MySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [ssl_cipher][crate::model::MySqlReplicaConfiguration::ssl_cipher].
    pub fn set_ssl_cipher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_cipher = v.into();
        self
    }

    /// Sets the value of [verify_server_certificate][crate::model::MySqlReplicaConfiguration::verify_server_certificate].
    pub fn set_verify_server_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.verify_server_certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_server_certificate][crate::model::MySqlReplicaConfiguration::verify_server_certificate].
    pub fn set_or_clear_verify_server_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.verify_server_certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::MySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlReplicaConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MySqlReplicaConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dump_file_path,
            __username,
            __password,
            __connect_retry_interval,
            __master_heartbeat_period,
            __ca_certificate,
            __client_certificate,
            __client_key,
            __ssl_cipher,
            __verify_server_certificate,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MySqlReplicaConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dumpFilePath" => Ok(__FieldTag::__dump_file_path),
                            "dump_file_path" => Ok(__FieldTag::__dump_file_path),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "connectRetryInterval" => Ok(__FieldTag::__connect_retry_interval),
                            "connect_retry_interval" => Ok(__FieldTag::__connect_retry_interval),
                            "masterHeartbeatPeriod" => Ok(__FieldTag::__master_heartbeat_period),
                            "master_heartbeat_period" => Ok(__FieldTag::__master_heartbeat_period),
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "sslCipher" => Ok(__FieldTag::__ssl_cipher),
                            "ssl_cipher" => Ok(__FieldTag::__ssl_cipher),
                            "verifyServerCertificate" => {
                                Ok(__FieldTag::__verify_server_certificate)
                            }
                            "verify_server_certificate" => {
                                Ok(__FieldTag::__verify_server_certificate)
                            }
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MySqlReplicaConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MySqlReplicaConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dump_file_path => {
                            if !fields.insert(__FieldTag::__dump_file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dump_file_path",
                                ));
                            }
                            result.dump_file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connect_retry_interval => {
                            if !fields.insert(__FieldTag::__connect_retry_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connect_retry_interval",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.connect_retry_interval = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__master_heartbeat_period => {
                            if !fields.insert(__FieldTag::__master_heartbeat_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_heartbeat_period",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.master_heartbeat_period = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_cipher => {
                            if !fields.insert(__FieldTag::__ssl_cipher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_cipher",
                                ));
                            }
                            result.ssl_cipher = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verify_server_certificate => {
                            if !fields.insert(__FieldTag::__verify_server_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_server_certificate",
                                ));
                            }
                            result.verify_server_certificate =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MySqlReplicaConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dump_file_path.is_empty() {
            state.serialize_entry("dumpFilePath", &self.dump_file_path)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if self.connect_retry_interval.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "connectRetryInterval",
                &__With(&self.connect_retry_interval),
            )?;
        }
        if self.master_heartbeat_period.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "masterHeartbeatPeriod",
                &__With(&self.master_heartbeat_period),
            )?;
        }
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self.ssl_cipher.is_empty() {
            state.serialize_entry("sslCipher", &self.ssl_cipher)?;
        }
        if self.verify_server_certificate.is_some() {
            state.serialize_entry("verifyServerCertificate", &self.verify_server_certificate)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Disk encryption configuration for an instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskEncryptionConfiguration {
    /// Resource name of KMS key for disk encryption
    pub kms_key_name: std::string::String,

    /// This is always `sql#diskEncryptionConfiguration`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::DiskEncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionConfiguration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskEncryptionConfiguration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskEncryptionConfiguration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskEncryptionConfiguration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskEncryptionConfiguration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskEncryptionConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Disk encryption status for an instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskEncryptionStatus {
    /// KMS key version used to encrypt the Cloud SQL instance resource
    pub kms_key_version_name: std::string::String,

    /// This is always `sql#diskEncryptionStatus`.
    pub kind: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEncryptionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::DiskEncryptionStatus::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionStatus::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskEncryptionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_version_name,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskEncryptionStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskEncryptionStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskEncryptionStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskEncryptionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance IP mapping
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IpMapping {
    /// The type of this IP address. A `PRIMARY` address is a public address that
    /// can accept incoming connections. A `PRIVATE` address is a private address
    /// that can accept incoming connections. An `OUTGOING` address is the source
    /// address of connections originating from the instance, if supported.
    pub r#type: crate::model::SqlIpAddressType,

    /// The IP address assigned.
    pub ip_address: std::string::String,

    /// The due time for this IP to be retired in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`. This field is only available when
    /// the IP is scheduled to be retired.
    pub time_to_retire: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::IpMapping::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlIpAddressType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::IpMapping::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [time_to_retire][crate::model::IpMapping::time_to_retire].
    pub fn set_time_to_retire<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time_to_retire = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_to_retire][crate::model::IpMapping::time_to_retire].
    pub fn set_or_clear_time_to_retire<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.time_to_retire = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IpMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IpMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __ip_address,
            __time_to_retire,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "timeToRetire" => Ok(__FieldTag::__time_to_retire),
                            "time_to_retire" => Ok(__FieldTag::__time_to_retire),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IpMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::SqlIpAddressType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_to_retire => {
                            if !fields.insert(__FieldTag::__time_to_retire) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_to_retire",
                                ));
                            }
                            result.time_to_retire =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IpMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.time_to_retire.is_some() {
            state.serialize_entry("timeToRetire", &self.time_to_retire)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An Operation resource.&nbsp;For successful operations that return an
/// Operation resource, only the fields relevant to the operation are populated
/// in the resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// This is always `sql#operation`.
    pub kind: std::string::String,

    pub target_link: std::string::String,

    /// The status of an operation.
    pub status: crate::model::operation::SqlOperationStatus,

    /// The email address of the user who initiated this operation.
    pub user: std::string::String,

    /// The time this operation was enqueued in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation actually started in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation finished in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// If errors occurred during processing of this operation, this field will be
    /// populated.
    pub error: std::option::Option<crate::model::OperationErrors>,

    /// An Admin API warning message.
    pub api_warning: std::option::Option<crate::model::ApiWarning>,

    /// The type of the operation. Valid values are:
    ///
    /// * `CREATE`
    /// * `DELETE`
    /// * `UPDATE`
    /// * `RESTART`
    /// * `IMPORT`
    /// * `EXPORT`
    /// * `BACKUP_VOLUME`
    /// * `RESTORE_VOLUME`
    /// * `CREATE_USER`
    /// * `DELETE_USER`
    /// * `CREATE_DATABASE`
    /// * `DELETE_DATABASE`
    pub operation_type: crate::model::operation::SqlOperationType,

    /// The context for import operation, if applicable.
    pub import_context: std::option::Option<crate::model::ImportContext>,

    /// The context for export operation, if applicable.
    pub export_context: std::option::Option<crate::model::ExportContext>,

    /// The context for backup operation, if applicable.
    pub backup_context: std::option::Option<crate::model::BackupContext>,

    /// An identifier that uniquely identifies the operation. You can use this
    /// identifier to retrieve the Operations resource that has information about
    /// the operation.
    pub name: std::string::String,

    /// Name of the database instance related to this operation.
    pub target_id: std::string::String,

    /// The URI of this resource.
    pub self_link: std::string::String,

    /// The project ID of the target instance related to this operation.
    pub target_project: std::string::String,

    /// The context for acquire SSRS lease operation, if applicable.
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Operation::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_link = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::SqlOperationStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Operation::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_insert_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_or_clear_insert_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.insert_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Operation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Operation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationErrors>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Operation::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationErrors>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [api_warning][crate::model::Operation::api_warning].
    pub fn set_api_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApiWarning>,
    {
        self.api_warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [api_warning][crate::model::Operation::api_warning].
    pub fn set_or_clear_api_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApiWarning>,
    {
        self.api_warning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation::SqlOperationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [import_context][crate::model::Operation::import_context].
    pub fn set_import_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportContext>,
    {
        self.import_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_context][crate::model::Operation::import_context].
    pub fn set_or_clear_import_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportContext>,
    {
        self.import_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [export_context][crate::model::Operation::export_context].
    pub fn set_export_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportContext>,
    {
        self.export_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_context][crate::model::Operation::export_context].
    pub fn set_or_clear_export_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportContext>,
    {
        self.export_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_context][crate::model::Operation::backup_context].
    pub fn set_backup_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupContext>,
    {
        self.backup_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_context][crate::model::Operation::backup_context].
    pub fn set_or_clear_backup_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupContext>,
    {
        self.backup_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::Operation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::Operation::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::Operation::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AcquireSsrsLeaseContext>,
    {
        self.acquire_ssrs_lease_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [acquire_ssrs_lease_context][crate::model::Operation::acquire_ssrs_lease_context].
    pub fn set_or_clear_acquire_ssrs_lease_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AcquireSsrsLeaseContext>,
    {
        self.acquire_ssrs_lease_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Operation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __target_link,
            __status,
            __user,
            __insert_time,
            __start_time,
            __end_time,
            __error,
            __api_warning,
            __operation_type,
            __import_context,
            __export_context,
            __backup_context,
            __name,
            __target_id,
            __self_link,
            __target_project,
            __acquire_ssrs_lease_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "targetLink" => Ok(__FieldTag::__target_link),
                            "target_link" => Ok(__FieldTag::__target_link),
                            "status" => Ok(__FieldTag::__status),
                            "user" => Ok(__FieldTag::__user),
                            "insertTime" => Ok(__FieldTag::__insert_time),
                            "insert_time" => Ok(__FieldTag::__insert_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "error" => Ok(__FieldTag::__error),
                            "apiWarning" => Ok(__FieldTag::__api_warning),
                            "api_warning" => Ok(__FieldTag::__api_warning),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "importContext" => Ok(__FieldTag::__import_context),
                            "import_context" => Ok(__FieldTag::__import_context),
                            "exportContext" => Ok(__FieldTag::__export_context),
                            "export_context" => Ok(__FieldTag::__export_context),
                            "backupContext" => Ok(__FieldTag::__backup_context),
                            "backup_context" => Ok(__FieldTag::__backup_context),
                            "name" => Ok(__FieldTag::__name),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "acquireSsrsLeaseContext" => {
                                Ok(__FieldTag::__acquire_ssrs_lease_context)
                            }
                            "acquire_ssrs_lease_context" => {
                                Ok(__FieldTag::__acquire_ssrs_lease_context)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_link => {
                            if !fields.insert(__FieldTag::__target_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_link",
                                ));
                            }
                            result.target_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<
                                    crate::model::operation::SqlOperationStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insert_time => {
                            if !fields.insert(__FieldTag::__insert_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insert_time",
                                ));
                            }
                            result.insert_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<crate::model::OperationErrors>>(
                                )?;
                        }
                        __FieldTag::__api_warning => {
                            if !fields.insert(__FieldTag::__api_warning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_warning",
                                ));
                            }
                            result.api_warning =
                                map.next_value::<std::option::Option<crate::model::ApiWarning>>()?;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map.next_value::<std::option::Option<crate::model::operation::SqlOperationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__import_context => {
                            if !fields.insert(__FieldTag::__import_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_context",
                                ));
                            }
                            result.import_context = map
                                .next_value::<std::option::Option<crate::model::ImportContext>>()?;
                        }
                        __FieldTag::__export_context => {
                            if !fields.insert(__FieldTag::__export_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_context",
                                ));
                            }
                            result.export_context = map
                                .next_value::<std::option::Option<crate::model::ExportContext>>()?;
                        }
                        __FieldTag::__backup_context => {
                            if !fields.insert(__FieldTag::__backup_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_context",
                                ));
                            }
                            result.backup_context = map
                                .next_value::<std::option::Option<crate::model::BackupContext>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__acquire_ssrs_lease_context => {
                            if !fields.insert(__FieldTag::__acquire_ssrs_lease_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for acquire_ssrs_lease_context",
                                ));
                            }
                            result.acquire_ssrs_lease_context = map.next_value::<std::option::Option<crate::model::AcquireSsrsLeaseContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.target_link.is_empty() {
            state.serialize_entry("targetLink", &self.target_link)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if self.insert_time.is_some() {
            state.serialize_entry("insertTime", &self.insert_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.api_warning.is_some() {
            state.serialize_entry("apiWarning", &self.api_warning)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if self.import_context.is_some() {
            state.serialize_entry("importContext", &self.import_context)?;
        }
        if self.export_context.is_some() {
            state.serialize_entry("exportContext", &self.export_context)?;
        }
        if self.backup_context.is_some() {
            state.serialize_entry("backupContext", &self.backup_context)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if self.acquire_ssrs_lease_context.is_some() {
            state.serialize_entry("acquireSsrsLeaseContext", &self.acquire_ssrs_lease_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// The type of Cloud SQL operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlOperationType {
        /// Unknown operation type.
        Unspecified,
        /// Imports data into a Cloud SQL instance.
        Import,
        /// Exports data from a Cloud SQL instance to a Cloud Storage
        /// bucket.
        Export,
        /// Creates a new Cloud SQL instance.
        Create,
        /// Updates the settings of a Cloud SQL instance.
        Update,
        /// Deletes a Cloud SQL instance.
        Delete,
        /// Restarts the Cloud SQL instance.
        Restart,
        #[deprecated]
        Backup,
        #[deprecated]
        Snapshot,
        /// Performs instance backup.
        BackupVolume,
        /// Deletes an instance backup.
        DeleteVolume,
        /// Restores an instance backup.
        RestoreVolume,
        /// Injects a privileged user in mysql for MOB instances.
        InjectUser,
        /// Clones a Cloud SQL instance.
        Clone,
        /// Stops replication on a Cloud SQL read replica instance.
        StopReplica,
        /// Starts replication on a Cloud SQL read replica instance.
        StartReplica,
        /// Promotes a Cloud SQL replica instance.
        PromoteReplica,
        /// Creates a Cloud SQL replica instance.
        CreateReplica,
        /// Creates a new user in a Cloud SQL instance.
        CreateUser,
        /// Deletes a user from a Cloud SQL instance.
        DeleteUser,
        /// Updates an existing user in a Cloud SQL instance.
        UpdateUser,
        /// Creates a database in the Cloud SQL instance.
        CreateDatabase,
        /// Deletes a database in the Cloud SQL instance.
        DeleteDatabase,
        /// Updates a database in the Cloud SQL instance.
        UpdateDatabase,
        /// Performs failover of an HA-enabled Cloud SQL
        /// failover replica.
        Failover,
        /// Deletes the backup taken by a backup run.
        DeleteBackup,
        RecreateReplica,
        /// Truncates a general or slow log table in MySQL.
        TruncateLog,
        /// Demotes the stand-alone instance to be a Cloud SQL
        /// read replica for an external database server.
        DemoteMaster,
        /// Indicates that the instance is currently in maintenance. Maintenance
        /// typically causes the instance to be unavailable for 1-3 minutes.
        Maintenance,
        /// This field is deprecated, and will be removed in future version of API.
        #[deprecated]
        EnablePrivateIp,
        #[deprecated]
        DeferMaintenance,
        /// Creates clone instance.
        #[deprecated]
        CreateClone,
        /// Reschedule maintenance to another time.
        RescheduleMaintenance,
        /// Starts external sync of a Cloud SQL EM replica to an external primary
        /// instance.
        StartExternalSync,
        /// Recovers logs from an instance's old data disk.
        LogCleanup,
        /// Performs auto-restart of an HA-enabled Cloud SQL database for auto
        /// recovery.
        AutoRestart,
        /// Re-encrypts CMEK instances with latest key version.
        Reencrypt,
        /// Switches the roles of the primary and replica pair. The target instance
        /// should be the replica.
        Switchover,
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        AcquireSsrsLease,
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        ReleaseSsrsLease,
        /// Reconfigures old primary after a promote replica operation. Effect of a
        /// promote operation to the old primary is executed in this operation,
        /// asynchronously from the promote replica operation executed to the
        /// replica.
        ReconfigureOldPrimary,
        /// Indicates that the instance, its read replicas, and its cascading
        /// replicas are in maintenance. Maintenance typically gets initiated on
        /// groups of replicas first, followed by the primary instance. For each
        /// instance, maintenance typically causes the instance to be unavailable for
        /// 1-3 minutes.
        ClusterMaintenance,
        /// Indicates that the instance (and any of its replicas) are currently in
        /// maintenance. This is initiated as a self-service request by using SSM.
        /// Maintenance typically causes the instance to be unavailable for 1-3
        /// minutes.
        SelfServiceMaintenance,
        /// Switches a primary instance to a replica. This operation runs as part of
        /// a switchover operation to the original primary instance.
        SwitchoverToReplica,
        /// Updates the major version of a Cloud SQL instance.
        MajorVersionUpgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlOperationType::value] or
        /// [SqlOperationType::name].
        UnknownValue(sql_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Import => std::option::Option::Some(1),
                Self::Export => std::option::Option::Some(2),
                Self::Create => std::option::Option::Some(3),
                Self::Update => std::option::Option::Some(4),
                Self::Delete => std::option::Option::Some(5),
                Self::Restart => std::option::Option::Some(6),
                Self::Backup => std::option::Option::Some(7),
                Self::Snapshot => std::option::Option::Some(8),
                Self::BackupVolume => std::option::Option::Some(9),
                Self::DeleteVolume => std::option::Option::Some(10),
                Self::RestoreVolume => std::option::Option::Some(11),
                Self::InjectUser => std::option::Option::Some(12),
                Self::Clone => std::option::Option::Some(14),
                Self::StopReplica => std::option::Option::Some(15),
                Self::StartReplica => std::option::Option::Some(16),
                Self::PromoteReplica => std::option::Option::Some(17),
                Self::CreateReplica => std::option::Option::Some(18),
                Self::CreateUser => std::option::Option::Some(19),
                Self::DeleteUser => std::option::Option::Some(20),
                Self::UpdateUser => std::option::Option::Some(21),
                Self::CreateDatabase => std::option::Option::Some(22),
                Self::DeleteDatabase => std::option::Option::Some(23),
                Self::UpdateDatabase => std::option::Option::Some(24),
                Self::Failover => std::option::Option::Some(25),
                Self::DeleteBackup => std::option::Option::Some(26),
                Self::RecreateReplica => std::option::Option::Some(27),
                Self::TruncateLog => std::option::Option::Some(28),
                Self::DemoteMaster => std::option::Option::Some(29),
                Self::Maintenance => std::option::Option::Some(30),
                Self::EnablePrivateIp => std::option::Option::Some(31),
                Self::DeferMaintenance => std::option::Option::Some(32),
                Self::CreateClone => std::option::Option::Some(33),
                Self::RescheduleMaintenance => std::option::Option::Some(34),
                Self::StartExternalSync => std::option::Option::Some(35),
                Self::LogCleanup => std::option::Option::Some(36),
                Self::AutoRestart => std::option::Option::Some(37),
                Self::Reencrypt => std::option::Option::Some(38),
                Self::Switchover => std::option::Option::Some(39),
                Self::AcquireSsrsLease => std::option::Option::Some(42),
                Self::ReleaseSsrsLease => std::option::Option::Some(43),
                Self::ReconfigureOldPrimary => std::option::Option::Some(44),
                Self::ClusterMaintenance => std::option::Option::Some(45),
                Self::SelfServiceMaintenance => std::option::Option::Some(46),
                Self::SwitchoverToReplica => std::option::Option::Some(47),
                Self::MajorVersionUpgrade => std::option::Option::Some(48),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_OPERATION_TYPE_UNSPECIFIED"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::Export => std::option::Option::Some("EXPORT"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::Backup => std::option::Option::Some("BACKUP"),
                Self::Snapshot => std::option::Option::Some("SNAPSHOT"),
                Self::BackupVolume => std::option::Option::Some("BACKUP_VOLUME"),
                Self::DeleteVolume => std::option::Option::Some("DELETE_VOLUME"),
                Self::RestoreVolume => std::option::Option::Some("RESTORE_VOLUME"),
                Self::InjectUser => std::option::Option::Some("INJECT_USER"),
                Self::Clone => std::option::Option::Some("CLONE"),
                Self::StopReplica => std::option::Option::Some("STOP_REPLICA"),
                Self::StartReplica => std::option::Option::Some("START_REPLICA"),
                Self::PromoteReplica => std::option::Option::Some("PROMOTE_REPLICA"),
                Self::CreateReplica => std::option::Option::Some("CREATE_REPLICA"),
                Self::CreateUser => std::option::Option::Some("CREATE_USER"),
                Self::DeleteUser => std::option::Option::Some("DELETE_USER"),
                Self::UpdateUser => std::option::Option::Some("UPDATE_USER"),
                Self::CreateDatabase => std::option::Option::Some("CREATE_DATABASE"),
                Self::DeleteDatabase => std::option::Option::Some("DELETE_DATABASE"),
                Self::UpdateDatabase => std::option::Option::Some("UPDATE_DATABASE"),
                Self::Failover => std::option::Option::Some("FAILOVER"),
                Self::DeleteBackup => std::option::Option::Some("DELETE_BACKUP"),
                Self::RecreateReplica => std::option::Option::Some("RECREATE_REPLICA"),
                Self::TruncateLog => std::option::Option::Some("TRUNCATE_LOG"),
                Self::DemoteMaster => std::option::Option::Some("DEMOTE_MASTER"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::EnablePrivateIp => std::option::Option::Some("ENABLE_PRIVATE_IP"),
                Self::DeferMaintenance => std::option::Option::Some("DEFER_MAINTENANCE"),
                Self::CreateClone => std::option::Option::Some("CREATE_CLONE"),
                Self::RescheduleMaintenance => std::option::Option::Some("RESCHEDULE_MAINTENANCE"),
                Self::StartExternalSync => std::option::Option::Some("START_EXTERNAL_SYNC"),
                Self::LogCleanup => std::option::Option::Some("LOG_CLEANUP"),
                Self::AutoRestart => std::option::Option::Some("AUTO_RESTART"),
                Self::Reencrypt => std::option::Option::Some("REENCRYPT"),
                Self::Switchover => std::option::Option::Some("SWITCHOVER"),
                Self::AcquireSsrsLease => std::option::Option::Some("ACQUIRE_SSRS_LEASE"),
                Self::ReleaseSsrsLease => std::option::Option::Some("RELEASE_SSRS_LEASE"),
                Self::ReconfigureOldPrimary => std::option::Option::Some("RECONFIGURE_OLD_PRIMARY"),
                Self::ClusterMaintenance => std::option::Option::Some("CLUSTER_MAINTENANCE"),
                Self::SelfServiceMaintenance => {
                    std::option::Option::Some("SELF_SERVICE_MAINTENANCE")
                }
                Self::SwitchoverToReplica => std::option::Option::Some("SWITCHOVER_TO_REPLICA"),
                Self::MajorVersionUpgrade => std::option::Option::Some("MAJOR_VERSION_UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Import,
                2 => Self::Export,
                3 => Self::Create,
                4 => Self::Update,
                5 => Self::Delete,
                6 => Self::Restart,
                7 => Self::Backup,
                8 => Self::Snapshot,
                9 => Self::BackupVolume,
                10 => Self::DeleteVolume,
                11 => Self::RestoreVolume,
                12 => Self::InjectUser,
                14 => Self::Clone,
                15 => Self::StopReplica,
                16 => Self::StartReplica,
                17 => Self::PromoteReplica,
                18 => Self::CreateReplica,
                19 => Self::CreateUser,
                20 => Self::DeleteUser,
                21 => Self::UpdateUser,
                22 => Self::CreateDatabase,
                23 => Self::DeleteDatabase,
                24 => Self::UpdateDatabase,
                25 => Self::Failover,
                26 => Self::DeleteBackup,
                27 => Self::RecreateReplica,
                28 => Self::TruncateLog,
                29 => Self::DemoteMaster,
                30 => Self::Maintenance,
                31 => Self::EnablePrivateIp,
                32 => Self::DeferMaintenance,
                33 => Self::CreateClone,
                34 => Self::RescheduleMaintenance,
                35 => Self::StartExternalSync,
                36 => Self::LogCleanup,
                37 => Self::AutoRestart,
                38 => Self::Reencrypt,
                39 => Self::Switchover,
                42 => Self::AcquireSsrsLease,
                43 => Self::ReleaseSsrsLease,
                44 => Self::ReconfigureOldPrimary,
                45 => Self::ClusterMaintenance,
                46 => Self::SelfServiceMaintenance,
                47 => Self::SwitchoverToReplica,
                48 => Self::MajorVersionUpgrade,
                _ => Self::UnknownValue(sql_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT" => Self::Import,
                "EXPORT" => Self::Export,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "RESTART" => Self::Restart,
                "BACKUP" => Self::Backup,
                "SNAPSHOT" => Self::Snapshot,
                "BACKUP_VOLUME" => Self::BackupVolume,
                "DELETE_VOLUME" => Self::DeleteVolume,
                "RESTORE_VOLUME" => Self::RestoreVolume,
                "INJECT_USER" => Self::InjectUser,
                "CLONE" => Self::Clone,
                "STOP_REPLICA" => Self::StopReplica,
                "START_REPLICA" => Self::StartReplica,
                "PROMOTE_REPLICA" => Self::PromoteReplica,
                "CREATE_REPLICA" => Self::CreateReplica,
                "CREATE_USER" => Self::CreateUser,
                "DELETE_USER" => Self::DeleteUser,
                "UPDATE_USER" => Self::UpdateUser,
                "CREATE_DATABASE" => Self::CreateDatabase,
                "DELETE_DATABASE" => Self::DeleteDatabase,
                "UPDATE_DATABASE" => Self::UpdateDatabase,
                "FAILOVER" => Self::Failover,
                "DELETE_BACKUP" => Self::DeleteBackup,
                "RECREATE_REPLICA" => Self::RecreateReplica,
                "TRUNCATE_LOG" => Self::TruncateLog,
                "DEMOTE_MASTER" => Self::DemoteMaster,
                "MAINTENANCE" => Self::Maintenance,
                "ENABLE_PRIVATE_IP" => Self::EnablePrivateIp,
                "DEFER_MAINTENANCE" => Self::DeferMaintenance,
                "CREATE_CLONE" => Self::CreateClone,
                "RESCHEDULE_MAINTENANCE" => Self::RescheduleMaintenance,
                "START_EXTERNAL_SYNC" => Self::StartExternalSync,
                "LOG_CLEANUP" => Self::LogCleanup,
                "AUTO_RESTART" => Self::AutoRestart,
                "REENCRYPT" => Self::Reencrypt,
                "SWITCHOVER" => Self::Switchover,
                "ACQUIRE_SSRS_LEASE" => Self::AcquireSsrsLease,
                "RELEASE_SSRS_LEASE" => Self::ReleaseSsrsLease,
                "RECONFIGURE_OLD_PRIMARY" => Self::ReconfigureOldPrimary,
                "CLUSTER_MAINTENANCE" => Self::ClusterMaintenance,
                "SELF_SERVICE_MAINTENANCE" => Self::SelfServiceMaintenance,
                "SWITCHOVER_TO_REPLICA" => Self::SwitchoverToReplica,
                "MAJOR_VERSION_UPGRADE" => Self::MajorVersionUpgrade,
                _ => Self::UnknownValue(sql_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Import => serializer.serialize_i32(1),
                Self::Export => serializer.serialize_i32(2),
                Self::Create => serializer.serialize_i32(3),
                Self::Update => serializer.serialize_i32(4),
                Self::Delete => serializer.serialize_i32(5),
                Self::Restart => serializer.serialize_i32(6),
                Self::Backup => serializer.serialize_i32(7),
                Self::Snapshot => serializer.serialize_i32(8),
                Self::BackupVolume => serializer.serialize_i32(9),
                Self::DeleteVolume => serializer.serialize_i32(10),
                Self::RestoreVolume => serializer.serialize_i32(11),
                Self::InjectUser => serializer.serialize_i32(12),
                Self::Clone => serializer.serialize_i32(14),
                Self::StopReplica => serializer.serialize_i32(15),
                Self::StartReplica => serializer.serialize_i32(16),
                Self::PromoteReplica => serializer.serialize_i32(17),
                Self::CreateReplica => serializer.serialize_i32(18),
                Self::CreateUser => serializer.serialize_i32(19),
                Self::DeleteUser => serializer.serialize_i32(20),
                Self::UpdateUser => serializer.serialize_i32(21),
                Self::CreateDatabase => serializer.serialize_i32(22),
                Self::DeleteDatabase => serializer.serialize_i32(23),
                Self::UpdateDatabase => serializer.serialize_i32(24),
                Self::Failover => serializer.serialize_i32(25),
                Self::DeleteBackup => serializer.serialize_i32(26),
                Self::RecreateReplica => serializer.serialize_i32(27),
                Self::TruncateLog => serializer.serialize_i32(28),
                Self::DemoteMaster => serializer.serialize_i32(29),
                Self::Maintenance => serializer.serialize_i32(30),
                Self::EnablePrivateIp => serializer.serialize_i32(31),
                Self::DeferMaintenance => serializer.serialize_i32(32),
                Self::CreateClone => serializer.serialize_i32(33),
                Self::RescheduleMaintenance => serializer.serialize_i32(34),
                Self::StartExternalSync => serializer.serialize_i32(35),
                Self::LogCleanup => serializer.serialize_i32(36),
                Self::AutoRestart => serializer.serialize_i32(37),
                Self::Reencrypt => serializer.serialize_i32(38),
                Self::Switchover => serializer.serialize_i32(39),
                Self::AcquireSsrsLease => serializer.serialize_i32(42),
                Self::ReleaseSsrsLease => serializer.serialize_i32(43),
                Self::ReconfigureOldPrimary => serializer.serialize_i32(44),
                Self::ClusterMaintenance => serializer.serialize_i32(45),
                Self::SelfServiceMaintenance => serializer.serialize_i32(46),
                Self::SwitchoverToReplica => serializer.serialize_i32(47),
                Self::MajorVersionUpgrade => serializer.serialize_i32(48),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOperationType>::new(
                ".google.cloud.sql.v1.Operation.SqlOperationType",
            ))
        }
    }

    /// The status of an operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlOperationStatus {
        /// The state of the operation is unknown.
        Unspecified,
        /// The operation has been queued, but has not started yet.
        Pending,
        /// The operation is running.
        Running,
        /// The operation completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlOperationStatus::value] or
        /// [SqlOperationStatus::name].
        UnknownValue(sql_operation_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_operation_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlOperationStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_OPERATION_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlOperationStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlOperationStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlOperationStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(sql_operation_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlOperationStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_OPERATION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(sql_operation_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlOperationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOperationStatus>::new(
                ".google.cloud.sql.v1.Operation.SqlOperationStatus",
            ))
        }
    }
}

/// Database instance operation error.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationError {
    /// This is always `sql#operationError`.
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    pub code: std::string::String,

    /// Additional information about the error encountered.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OperationError::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::OperationError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for OperationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __code,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance operation errors list wrapper.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationErrors {
    /// This is always `sql#operationErrors`.
    pub kind: std::string::String,

    /// The list of errors encountered while processing this operation.
    pub errors: std::vec::Vec<crate::model::OperationError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationErrors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationErrors::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::OperationErrors::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationErrors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationErrors"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationErrors {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationErrors")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationErrors;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationErrors")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OperationError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationErrors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance local user password validation policy
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PasswordValidationPolicy {
    /// Minimum number of characters allowed.
    pub min_length: std::option::Option<wkt::Int32Value>,

    /// The complexity of the password.
    pub complexity: crate::model::password_validation_policy::Complexity,

    /// Number of previous passwords that cannot be reused.
    pub reuse_interval: std::option::Option<wkt::Int32Value>,

    /// Disallow username as a part of the password.
    pub disallow_username_substring: std::option::Option<wkt::BoolValue>,

    /// Minimum interval after which the password can be changed. This flag is only
    /// supported for PostgreSQL.
    pub password_change_interval: std::option::Option<wkt::Duration>,

    /// Whether the password policy is enabled or not.
    pub enable_password_policy: std::option::Option<wkt::BoolValue>,

    /// This field is deprecated and will be removed in a future version of the
    /// API.
    #[deprecated]
    pub disallow_compromised_credentials: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_length][crate::model::PasswordValidationPolicy::min_length].
    pub fn set_min_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.min_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_length][crate::model::PasswordValidationPolicy::min_length].
    pub fn set_or_clear_min_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.min_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complexity][crate::model::PasswordValidationPolicy::complexity].
    pub fn set_complexity<
        T: std::convert::Into<crate::model::password_validation_policy::Complexity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.complexity = v.into();
        self
    }

    /// Sets the value of [reuse_interval][crate::model::PasswordValidationPolicy::reuse_interval].
    pub fn set_reuse_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.reuse_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reuse_interval][crate::model::PasswordValidationPolicy::reuse_interval].
    pub fn set_or_clear_reuse_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.reuse_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disallow_username_substring][crate::model::PasswordValidationPolicy::disallow_username_substring].
    pub fn set_disallow_username_substring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.disallow_username_substring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disallow_username_substring][crate::model::PasswordValidationPolicy::disallow_username_substring].
    pub fn set_or_clear_disallow_username_substring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.disallow_username_substring = v.map(|x| x.into());
        self
    }

    /// Sets the value of [password_change_interval][crate::model::PasswordValidationPolicy::password_change_interval].
    pub fn set_password_change_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.password_change_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [password_change_interval][crate::model::PasswordValidationPolicy::password_change_interval].
    pub fn set_or_clear_password_change_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.password_change_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_password_policy][crate::model::PasswordValidationPolicy::enable_password_policy].
    pub fn set_enable_password_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_password_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_password_policy][crate::model::PasswordValidationPolicy::enable_password_policy].
    pub fn set_or_clear_enable_password_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_password_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disallow_compromised_credentials][crate::model::PasswordValidationPolicy::disallow_compromised_credentials].
    #[deprecated]
    pub fn set_disallow_compromised_credentials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.disallow_compromised_credentials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disallow_compromised_credentials][crate::model::PasswordValidationPolicy::disallow_compromised_credentials].
    #[deprecated]
    pub fn set_or_clear_disallow_compromised_credentials<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.disallow_compromised_credentials = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordValidationPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PasswordValidationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_length,
            __complexity,
            __reuse_interval,
            __disallow_username_substring,
            __password_change_interval,
            __enable_password_policy,
            __disallow_compromised_credentials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PasswordValidationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minLength" => Ok(__FieldTag::__min_length),
                            "min_length" => Ok(__FieldTag::__min_length),
                            "complexity" => Ok(__FieldTag::__complexity),
                            "reuseInterval" => Ok(__FieldTag::__reuse_interval),
                            "reuse_interval" => Ok(__FieldTag::__reuse_interval),
                            "disallowUsernameSubstring" => {
                                Ok(__FieldTag::__disallow_username_substring)
                            }
                            "disallow_username_substring" => {
                                Ok(__FieldTag::__disallow_username_substring)
                            }
                            "passwordChangeInterval" => Ok(__FieldTag::__password_change_interval),
                            "password_change_interval" => {
                                Ok(__FieldTag::__password_change_interval)
                            }
                            "enablePasswordPolicy" => Ok(__FieldTag::__enable_password_policy),
                            "enable_password_policy" => Ok(__FieldTag::__enable_password_policy),
                            "disallowCompromisedCredentials" => {
                                Ok(__FieldTag::__disallow_compromised_credentials)
                            }
                            "disallow_compromised_credentials" => {
                                Ok(__FieldTag::__disallow_compromised_credentials)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PasswordValidationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PasswordValidationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_length => {
                            if !fields.insert(__FieldTag::__min_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_length",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__complexity => {
                            if !fields.insert(__FieldTag::__complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complexity",
                                ));
                            }
                            result.complexity = map
                                .next_value::<std::option::Option<
                                    crate::model::password_validation_policy::Complexity,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reuse_interval => {
                            if !fields.insert(__FieldTag::__reuse_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reuse_interval",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.reuse_interval = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__disallow_username_substring => {
                            if !fields.insert(__FieldTag::__disallow_username_substring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disallow_username_substring",
                                ));
                            }
                            result.disallow_username_substring =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__password_change_interval => {
                            if !fields.insert(__FieldTag::__password_change_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_change_interval",
                                ));
                            }
                            result.password_change_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__enable_password_policy => {
                            if !fields.insert(__FieldTag::__enable_password_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_password_policy",
                                ));
                            }
                            result.enable_password_policy =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__disallow_compromised_credentials => {
                            if !fields.insert(__FieldTag::__disallow_compromised_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disallow_compromised_credentials",
                                ));
                            }
                            result.disallow_compromised_credentials =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PasswordValidationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_length.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minLength", &__With(&self.min_length))?;
        }
        if !wkt::internal::is_default(&self.complexity) {
            state.serialize_entry("complexity", &self.complexity)?;
        }
        if self.reuse_interval.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("reuseInterval", &__With(&self.reuse_interval))?;
        }
        if self.disallow_username_substring.is_some() {
            state.serialize_entry(
                "disallowUsernameSubstring",
                &self.disallow_username_substring,
            )?;
        }
        if self.password_change_interval.is_some() {
            state.serialize_entry("passwordChangeInterval", &self.password_change_interval)?;
        }
        if self.enable_password_policy.is_some() {
            state.serialize_entry("enablePasswordPolicy", &self.enable_password_policy)?;
        }
        if self.disallow_compromised_credentials.is_some() {
            state.serialize_entry(
                "disallowCompromisedCredentials",
                &self.disallow_compromised_credentials,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PasswordValidationPolicy].
pub mod password_validation_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The complexity choices of the password.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Complexity {
        /// Complexity check is not specified.
        Unspecified,
        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric
        /// characters.
        Default,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Complexity::value] or
        /// [Complexity::name].
        UnknownValue(complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Complexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLEXITY_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("COMPLEXITY_DEFAULT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Complexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Complexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Complexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                _ => Self::UnknownValue(complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Complexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "COMPLEXITY_DEFAULT" => Self::Default,
                _ => Self::UnknownValue(complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Complexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Complexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Complexity>::new(
                ".google.cloud.sql.v1.PasswordValidationPolicy.Complexity",
            ))
        }
    }
}

/// Data cache configurations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataCacheConfig {
    /// Whether data cache is enabled for the instance.
    pub data_cache_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCacheConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_cache_enabled][crate::model::DataCacheConfig::data_cache_enabled].
    pub fn set_data_cache_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.data_cache_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCacheConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DataCacheConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataCacheConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_cache_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataCacheConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataCacheEnabled" => Ok(__FieldTag::__data_cache_enabled),
                            "data_cache_enabled" => Ok(__FieldTag::__data_cache_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataCacheConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataCacheConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_cache_enabled => {
                            if !fields.insert(__FieldTag::__data_cache_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_cache_enabled",
                                ));
                            }
                            result.data_cache_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataCacheConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.data_cache_enabled) {
            state.serialize_entry("dataCacheEnabled", &self.data_cache_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Database instance settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Settings {
    /// The version of instance settings. This is a required field for update
    /// method to make sure concurrent updates are handled properly. During update,
    /// use the most recent settingsVersion value for this instance and do not try
    /// to update this value.
    pub settings_version: std::option::Option<wkt::Int64Value>,

    /// The App Engine app IDs that can access this instance.
    /// (Deprecated) Applied to First Generation instances only.
    #[deprecated]
    pub authorized_gae_applications: std::vec::Vec<std::string::String>,

    /// The tier (or machine type) for this instance, for example
    /// `db-custom-1-3840`. WARNING: Changing this restarts the instance.
    pub tier: std::string::String,

    /// This is always `sql#settings`.
    pub kind: std::string::String,

    /// User-provided labels, represented as a dictionary where each label is a
    /// single key value pair.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data accessibility.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available)./
    ///
    /// For more information, see [Overview of the High Availability
    /// Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
    pub availability_type: crate::model::SqlAvailabilityType,

    /// The pricing plan for this instance. This can be either `PER_USE` or
    /// `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    pub pricing_plan: crate::model::SqlPricingPlan,

    /// The type of replication this instance uses. This can be either
    /// `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only
    /// applicable to First Generation instances.
    #[deprecated]
    pub replication_type: crate::model::SqlReplicationType,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is RUNNABLE. Valid values:
    ///
    /// * `ALWAYS`: The instance is on, and remains so even in the absence of
    ///   connection requests.
    /// * `NEVER`: The instance is off; it is not activated, even if a
    ///   connection request arrives.
    pub activation_policy: crate::model::settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled for Second Generation instances.
    pub ip_configuration: std::option::Option<crate::model::IpConfiguration>,

    /// Configuration to increase storage size automatically. The default value is
    /// true.
    pub storage_auto_resize: std::option::Option<wkt::BoolValue>,

    /// The location preference settings. This allows the instance to be located as
    /// near as possible to either an App Engine app or Compute Engine zone for
    /// better performance. App Engine co-location was only applicable to First
    /// Generation instances.
    pub location_preference: std::option::Option<crate::model::LocationPreference>,

    /// The database flags passed to the instance at startup.
    pub database_flags: std::vec::Vec<crate::model::DatabaseFlags>,

    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for
    /// First Generation instances.
    pub data_disk_type: crate::model::SqlDataDiskType,

    /// The maintenance window for this instance. This specifies when the instance
    /// can be restarted for maintenance purposes.
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// The daily backup configuration for the instance.
    pub backup_configuration: std::option::Option<crate::model::BackupConfiguration>,

    /// Configuration specific to read replica instances. Indicates whether
    /// replication is enabled or not. WARNING: Changing this restarts the
    /// instance.
    pub database_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// Configuration specific to read replica instances. Indicates whether
    /// database flags for crash-safe replication are enabled. This property was
    /// only applicable to First Generation instances.
    #[deprecated]
    pub crash_safe_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// The size of data disk, in GB. The data disk size minimum is 10GB.
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
    pub active_directory_config: std::option::Option<crate::model::SqlActiveDirectoryConfig>,

    /// The name of server Instance collation.
    pub collation: std::string::String,

    /// Deny maintenance periods
    pub deny_maintenance_periods: std::vec::Vec<crate::model::DenyMaintenancePeriod>,

    /// Insights configuration, for now relevant only for Postgres.
    pub insights_config: std::option::Option<crate::model::InsightsConfig>,

    /// The local user password validation policy of the instance.
    pub password_validation_policy: std::option::Option<crate::model::PasswordValidationPolicy>,

    /// SQL Server specific audit configuration.
    pub sql_server_audit_config: std::option::Option<crate::model::SqlServerAuditConfig>,

    /// Optional. The edition of the instance.
    pub edition: crate::model::settings::Edition,

    /// Specifies if connections must use Cloud SQL connectors.
    /// Option values include the following: `NOT_REQUIRED` (Cloud SQL instances
    /// can be connected without Cloud SQL
    /// Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL
    /// Connectors).
    ///
    /// Note that using REQUIRED disables all existing authorized networks. If
    /// this field is not specified when creating a new instance, NOT_REQUIRED is
    /// used. If this field is not specified when patching or updating an existing
    /// instance, it is left unchanged in the instance.
    pub connector_enforcement: crate::model::settings::ConnectorEnforcement,

    /// Configuration to protect against accidental instance deletion.
    pub deletion_protection_enabled: std::option::Option<wkt::BoolValue>,

    /// Server timezone, relevant only for Cloud SQL for SQL Server.
    pub time_zone: std::string::String,

    /// Specifies advanced machine configuration for the instances relevant only
    /// for SQL Server.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Configuration for data cache.
    pub data_cache_config: std::option::Option<crate::model::DataCacheConfig>,

    /// Optional. When this parameter is set to true, Cloud SQL instances can
    /// connect to Vertex AI to pass requests for real-time predictions and
    /// insights to the AI. The default value is false. This applies only to Cloud
    /// SQL for PostgreSQL instances.
    pub enable_google_ml_integration: std::option::Option<wkt::BoolValue>,

    /// Optional. By default, Cloud SQL instances have schema extraction disabled
    /// for Dataplex. When this parameter is set to true, schema extraction for
    /// Dataplex on Cloud SQL instances is activated.
    pub enable_dataplex_integration: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::Settings::settings_version].
    pub fn set_settings_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.settings_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings_version][crate::model::Settings::settings_version].
    pub fn set_or_clear_settings_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.settings_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorized_gae_applications][crate::model::Settings::authorized_gae_applications].
    #[deprecated]
    pub fn set_authorized_gae_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.authorized_gae_applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tier][crate::model::Settings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Settings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::Settings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [availability_type][crate::model::Settings::availability_type].
    pub fn set_availability_type<T: std::convert::Into<crate::model::SqlAvailabilityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [pricing_plan][crate::model::Settings::pricing_plan].
    pub fn set_pricing_plan<T: std::convert::Into<crate::model::SqlPricingPlan>>(
        mut self,
        v: T,
    ) -> Self {
        self.pricing_plan = v.into();
        self
    }

    /// Sets the value of [replication_type][crate::model::Settings::replication_type].
    #[deprecated]
    pub fn set_replication_type<T: std::convert::Into<crate::model::SqlReplicationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.replication_type = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::Settings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.storage_auto_resize_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_auto_resize_limit][crate::model::Settings::storage_auto_resize_limit].
    pub fn set_or_clear_storage_auto_resize_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.storage_auto_resize_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activation_policy][crate::model::Settings::activation_policy].
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::settings::SqlActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_configuration][crate::model::Settings::ip_configuration].
    pub fn set_ip_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpConfiguration>,
    {
        self.ip_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_configuration][crate::model::Settings::ip_configuration].
    pub fn set_or_clear_ip_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpConfiguration>,
    {
        self.ip_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_auto_resize][crate::model::Settings::storage_auto_resize].
    pub fn set_storage_auto_resize<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.storage_auto_resize = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_auto_resize][crate::model::Settings::storage_auto_resize].
    pub fn set_or_clear_storage_auto_resize<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.storage_auto_resize = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_preference][crate::model::Settings::location_preference].
    pub fn set_location_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocationPreference>,
    {
        self.location_preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location_preference][crate::model::Settings::location_preference].
    pub fn set_or_clear_location_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocationPreference>,
    {
        self.location_preference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_flags][crate::model::Settings::database_flags].
    pub fn set_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseFlags>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::Settings::data_disk_type].
    pub fn set_data_disk_type<T: std::convert::Into<crate::model::SqlDataDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::Settings::maintenance_window].
    pub fn set_maintenance_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_window][crate::model::Settings::maintenance_window].
    pub fn set_or_clear_maintenance_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.maintenance_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_configuration][crate::model::Settings::backup_configuration].
    pub fn set_backup_configuration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfiguration>,
    {
        self.backup_configuration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_configuration][crate::model::Settings::backup_configuration].
    pub fn set_or_clear_backup_configuration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupConfiguration>,
    {
        self.backup_configuration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_replication_enabled][crate::model::Settings::database_replication_enabled].
    pub fn set_database_replication_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.database_replication_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_replication_enabled][crate::model::Settings::database_replication_enabled].
    pub fn set_or_clear_database_replication_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.database_replication_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crash_safe_replication_enabled][crate::model::Settings::crash_safe_replication_enabled].
    #[deprecated]
    pub fn set_crash_safe_replication_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.crash_safe_replication_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crash_safe_replication_enabled][crate::model::Settings::crash_safe_replication_enabled].
    #[deprecated]
    pub fn set_or_clear_crash_safe_replication_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.crash_safe_replication_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::Settings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_disk_size_gb][crate::model::Settings::data_disk_size_gb].
    pub fn set_or_clear_data_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [active_directory_config][crate::model::Settings::active_directory_config].
    pub fn set_active_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlActiveDirectoryConfig>,
    {
        self.active_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [active_directory_config][crate::model::Settings::active_directory_config].
    pub fn set_or_clear_active_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlActiveDirectoryConfig>,
    {
        self.active_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [collation][crate::model::Settings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [deny_maintenance_periods][crate::model::Settings::deny_maintenance_periods].
    pub fn set_deny_maintenance_periods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DenyMaintenancePeriod>,
    {
        use std::iter::Iterator;
        self.deny_maintenance_periods = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [insights_config][crate::model::Settings::insights_config].
    pub fn set_insights_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insights_config][crate::model::Settings::insights_config].
    pub fn set_or_clear_insights_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [password_validation_policy][crate::model::Settings::password_validation_policy].
    pub fn set_password_validation_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PasswordValidationPolicy>,
    {
        self.password_validation_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [password_validation_policy][crate::model::Settings::password_validation_policy].
    pub fn set_or_clear_password_validation_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PasswordValidationPolicy>,
    {
        self.password_validation_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sql_server_audit_config][crate::model::Settings::sql_server_audit_config].
    pub fn set_sql_server_audit_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerAuditConfig>,
    {
        self.sql_server_audit_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_server_audit_config][crate::model::Settings::sql_server_audit_config].
    pub fn set_or_clear_sql_server_audit_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlServerAuditConfig>,
    {
        self.sql_server_audit_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [edition][crate::model::Settings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::settings::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [connector_enforcement][crate::model::Settings::connector_enforcement].
    pub fn set_connector_enforcement<
        T: std::convert::Into<crate::model::settings::ConnectorEnforcement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connector_enforcement = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Settings::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.deletion_protection_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection_enabled][crate::model::Settings::deletion_protection_enabled].
    pub fn set_or_clear_deletion_protection_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.deletion_protection_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::Settings::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::Settings::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::Settings::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_cache_config][crate::model::Settings::data_cache_config].
    pub fn set_data_cache_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataCacheConfig>,
    {
        self.data_cache_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_cache_config][crate::model::Settings::data_cache_config].
    pub fn set_or_clear_data_cache_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataCacheConfig>,
    {
        self.data_cache_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_google_ml_integration][crate::model::Settings::enable_google_ml_integration].
    pub fn set_enable_google_ml_integration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_google_ml_integration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_google_ml_integration][crate::model::Settings::enable_google_ml_integration].
    pub fn set_or_clear_enable_google_ml_integration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_google_ml_integration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_dataplex_integration][crate::model::Settings::enable_dataplex_integration].
    pub fn set_enable_dataplex_integration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_dataplex_integration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_dataplex_integration][crate::model::Settings::enable_dataplex_integration].
    pub fn set_or_clear_enable_dataplex_integration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_dataplex_integration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Settings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Settings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __settings_version,
            __authorized_gae_applications,
            __tier,
            __kind,
            __user_labels,
            __availability_type,
            __pricing_plan,
            __replication_type,
            __storage_auto_resize_limit,
            __activation_policy,
            __ip_configuration,
            __storage_auto_resize,
            __location_preference,
            __database_flags,
            __data_disk_type,
            __maintenance_window,
            __backup_configuration,
            __database_replication_enabled,
            __crash_safe_replication_enabled,
            __data_disk_size_gb,
            __active_directory_config,
            __collation,
            __deny_maintenance_periods,
            __insights_config,
            __password_validation_policy,
            __sql_server_audit_config,
            __edition,
            __connector_enforcement,
            __deletion_protection_enabled,
            __time_zone,
            __advanced_machine_features,
            __data_cache_config,
            __enable_google_ml_integration,
            __enable_dataplex_integration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Settings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "settingsVersion" => Ok(__FieldTag::__settings_version),
                            "settings_version" => Ok(__FieldTag::__settings_version),
                            "authorizedGaeApplications" => {
                                Ok(__FieldTag::__authorized_gae_applications)
                            }
                            "authorized_gae_applications" => {
                                Ok(__FieldTag::__authorized_gae_applications)
                            }
                            "tier" => Ok(__FieldTag::__tier),
                            "kind" => Ok(__FieldTag::__kind),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            "availabilityType" => Ok(__FieldTag::__availability_type),
                            "availability_type" => Ok(__FieldTag::__availability_type),
                            "pricingPlan" => Ok(__FieldTag::__pricing_plan),
                            "pricing_plan" => Ok(__FieldTag::__pricing_plan),
                            "replicationType" => Ok(__FieldTag::__replication_type),
                            "replication_type" => Ok(__FieldTag::__replication_type),
                            "storageAutoResizeLimit" => Ok(__FieldTag::__storage_auto_resize_limit),
                            "storage_auto_resize_limit" => {
                                Ok(__FieldTag::__storage_auto_resize_limit)
                            }
                            "activationPolicy" => Ok(__FieldTag::__activation_policy),
                            "activation_policy" => Ok(__FieldTag::__activation_policy),
                            "ipConfiguration" => Ok(__FieldTag::__ip_configuration),
                            "ip_configuration" => Ok(__FieldTag::__ip_configuration),
                            "storageAutoResize" => Ok(__FieldTag::__storage_auto_resize),
                            "storage_auto_resize" => Ok(__FieldTag::__storage_auto_resize),
                            "locationPreference" => Ok(__FieldTag::__location_preference),
                            "location_preference" => Ok(__FieldTag::__location_preference),
                            "databaseFlags" => Ok(__FieldTag::__database_flags),
                            "database_flags" => Ok(__FieldTag::__database_flags),
                            "dataDiskType" => Ok(__FieldTag::__data_disk_type),
                            "data_disk_type" => Ok(__FieldTag::__data_disk_type),
                            "maintenanceWindow" => Ok(__FieldTag::__maintenance_window),
                            "maintenance_window" => Ok(__FieldTag::__maintenance_window),
                            "backupConfiguration" => Ok(__FieldTag::__backup_configuration),
                            "backup_configuration" => Ok(__FieldTag::__backup_configuration),
                            "databaseReplicationEnabled" => {
                                Ok(__FieldTag::__database_replication_enabled)
                            }
                            "database_replication_enabled" => {
                                Ok(__FieldTag::__database_replication_enabled)
                            }
                            "crashSafeReplicationEnabled" => {
                                Ok(__FieldTag::__crash_safe_replication_enabled)
                            }
                            "crash_safe_replication_enabled" => {
                                Ok(__FieldTag::__crash_safe_replication_enabled)
                            }
                            "dataDiskSizeGb" => Ok(__FieldTag::__data_disk_size_gb),
                            "data_disk_size_gb" => Ok(__FieldTag::__data_disk_size_gb),
                            "activeDirectoryConfig" => Ok(__FieldTag::__active_directory_config),
                            "active_directory_config" => Ok(__FieldTag::__active_directory_config),
                            "collation" => Ok(__FieldTag::__collation),
                            "denyMaintenancePeriods" => Ok(__FieldTag::__deny_maintenance_periods),
                            "deny_maintenance_periods" => {
                                Ok(__FieldTag::__deny_maintenance_periods)
                            }
                            "insightsConfig" => Ok(__FieldTag::__insights_config),
                            "insights_config" => Ok(__FieldTag::__insights_config),
                            "passwordValidationPolicy" => {
                                Ok(__FieldTag::__password_validation_policy)
                            }
                            "password_validation_policy" => {
                                Ok(__FieldTag::__password_validation_policy)
                            }
                            "sqlServerAuditConfig" => Ok(__FieldTag::__sql_server_audit_config),
                            "sql_server_audit_config" => Ok(__FieldTag::__sql_server_audit_config),
                            "edition" => Ok(__FieldTag::__edition),
                            "connectorEnforcement" => Ok(__FieldTag::__connector_enforcement),
                            "connector_enforcement" => Ok(__FieldTag::__connector_enforcement),
                            "deletionProtectionEnabled" => {
                                Ok(__FieldTag::__deletion_protection_enabled)
                            }
                            "deletion_protection_enabled" => {
                                Ok(__FieldTag::__deletion_protection_enabled)
                            }
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "advancedMachineFeatures" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "advanced_machine_features" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "dataCacheConfig" => Ok(__FieldTag::__data_cache_config),
                            "data_cache_config" => Ok(__FieldTag::__data_cache_config),
                            "enableGoogleMlIntegration" => {
                                Ok(__FieldTag::__enable_google_ml_integration)
                            }
                            "enable_google_ml_integration" => {
                                Ok(__FieldTag::__enable_google_ml_integration)
                            }
                            "enableDataplexIntegration" => {
                                Ok(__FieldTag::__enable_dataplex_integration)
                            }
                            "enable_dataplex_integration" => {
                                Ok(__FieldTag::__enable_dataplex_integration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Settings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Settings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__settings_version => {
                            if !fields.insert(__FieldTag::__settings_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings_version",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.settings_version = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__authorized_gae_applications => {
                            if !fields.insert(__FieldTag::__authorized_gae_applications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_gae_applications",
                                ));
                            }
                            result.authorized_gae_applications = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_type => {
                            if !fields.insert(__FieldTag::__availability_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_type",
                                ));
                            }
                            result.availability_type = map.next_value::<std::option::Option<crate::model::SqlAvailabilityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pricing_plan => {
                            if !fields.insert(__FieldTag::__pricing_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pricing_plan",
                                ));
                            }
                            result.pricing_plan = map
                                .next_value::<std::option::Option<crate::model::SqlPricingPlan>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication_type => {
                            if !fields.insert(__FieldTag::__replication_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_type",
                                ));
                            }
                            result.replication_type = map.next_value::<std::option::Option<crate::model::SqlReplicationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_auto_resize_limit => {
                            if !fields.insert(__FieldTag::__storage_auto_resize_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_auto_resize_limit",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_auto_resize_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__activation_policy => {
                            if !fields.insert(__FieldTag::__activation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_policy",
                                ));
                            }
                            result.activation_policy =
                                map.next_value::<std::option::Option<
                                    crate::model::settings::SqlActivationPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_configuration => {
                            if !fields.insert(__FieldTag::__ip_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_configuration",
                                ));
                            }
                            result.ip_configuration = map
                                .next_value::<std::option::Option<crate::model::IpConfiguration>>(
                                )?;
                        }
                        __FieldTag::__storage_auto_resize => {
                            if !fields.insert(__FieldTag::__storage_auto_resize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_auto_resize",
                                ));
                            }
                            result.storage_auto_resize =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__location_preference => {
                            if !fields.insert(__FieldTag::__location_preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_preference",
                                ));
                            }
                            result.location_preference = map.next_value::<std::option::Option<crate::model::LocationPreference>>()?
                                ;
                        }
                        __FieldTag::__database_flags => {
                            if !fields.insert(__FieldTag::__database_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_flags",
                                ));
                            }
                            result.database_flags = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DatabaseFlags>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_disk_type => {
                            if !fields.insert(__FieldTag::__data_disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disk_type",
                                ));
                            }
                            result.data_disk_type = map
                                .next_value::<std::option::Option<crate::model::SqlDataDiskType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_window => {
                            if !fields.insert(__FieldTag::__maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_window",
                                ));
                            }
                            result.maintenance_window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__backup_configuration => {
                            if !fields.insert(__FieldTag::__backup_configuration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_configuration",
                                ));
                            }
                            result.backup_configuration = map.next_value::<std::option::Option<crate::model::BackupConfiguration>>()?
                                ;
                        }
                        __FieldTag::__database_replication_enabled => {
                            if !fields.insert(__FieldTag::__database_replication_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_replication_enabled",
                                ));
                            }
                            result.database_replication_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__crash_safe_replication_enabled => {
                            if !fields.insert(__FieldTag::__crash_safe_replication_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crash_safe_replication_enabled",
                                ));
                            }
                            result.crash_safe_replication_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__data_disk_size_gb => {
                            if !fields.insert(__FieldTag::__data_disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_disk_size_gb = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__active_directory_config => {
                            if !fields.insert(__FieldTag::__active_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_directory_config",
                                ));
                            }
                            result.active_directory_config = map.next_value::<std::option::Option<crate::model::SqlActiveDirectoryConfig>>()?
                                ;
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deny_maintenance_periods => {
                            if !fields.insert(__FieldTag::__deny_maintenance_periods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_maintenance_periods",
                                ));
                            }
                            result.deny_maintenance_periods = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DenyMaintenancePeriod>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insights_config => {
                            if !fields.insert(__FieldTag::__insights_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_config",
                                ));
                            }
                            result.insights_config = map
                                .next_value::<std::option::Option<crate::model::InsightsConfig>>(
                                )?;
                        }
                        __FieldTag::__password_validation_policy => {
                            if !fields.insert(__FieldTag::__password_validation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_validation_policy",
                                ));
                            }
                            result.password_validation_policy = map.next_value::<std::option::Option<crate::model::PasswordValidationPolicy>>()?
                                ;
                        }
                        __FieldTag::__sql_server_audit_config => {
                            if !fields.insert(__FieldTag::__sql_server_audit_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_server_audit_config",
                                ));
                            }
                            result.sql_server_audit_config = map.next_value::<std::option::Option<crate::model::SqlServerAuditConfig>>()?
                                ;
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map
                                .next_value::<std::option::Option<crate::model::settings::Edition>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connector_enforcement => {
                            if !fields.insert(__FieldTag::__connector_enforcement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connector_enforcement",
                                ));
                            }
                            result.connector_enforcement =
                                map.next_value::<std::option::Option<
                                    crate::model::settings::ConnectorEnforcement,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_protection_enabled => {
                            if !fields.insert(__FieldTag::__deletion_protection_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection_enabled",
                                ));
                            }
                            result.deletion_protection_enabled =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advanced_machine_features => {
                            if !fields.insert(__FieldTag::__advanced_machine_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_machine_features",
                                ));
                            }
                            result.advanced_machine_features = map.next_value::<std::option::Option<crate::model::AdvancedMachineFeatures>>()?
                                ;
                        }
                        __FieldTag::__data_cache_config => {
                            if !fields.insert(__FieldTag::__data_cache_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_cache_config",
                                ));
                            }
                            result.data_cache_config = map
                                .next_value::<std::option::Option<crate::model::DataCacheConfig>>(
                                )?;
                        }
                        __FieldTag::__enable_google_ml_integration => {
                            if !fields.insert(__FieldTag::__enable_google_ml_integration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_google_ml_integration",
                                ));
                            }
                            result.enable_google_ml_integration =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__enable_dataplex_integration => {
                            if !fields.insert(__FieldTag::__enable_dataplex_integration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_dataplex_integration",
                                ));
                            }
                            result.enable_dataplex_integration =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Settings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.settings_version.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("settingsVersion", &__With(&self.settings_version))?;
        }
        if !self.authorized_gae_applications.is_empty() {
            state.serialize_entry(
                "authorizedGaeApplications",
                &self.authorized_gae_applications,
            )?;
        }
        if !self.tier.is_empty() {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !wkt::internal::is_default(&self.availability_type) {
            state.serialize_entry("availabilityType", &self.availability_type)?;
        }
        if !wkt::internal::is_default(&self.pricing_plan) {
            state.serialize_entry("pricingPlan", &self.pricing_plan)?;
        }
        if !wkt::internal::is_default(&self.replication_type) {
            state.serialize_entry("replicationType", &self.replication_type)?;
        }
        if self.storage_auto_resize_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "storageAutoResizeLimit",
                &__With(&self.storage_auto_resize_limit),
            )?;
        }
        if !wkt::internal::is_default(&self.activation_policy) {
            state.serialize_entry("activationPolicy", &self.activation_policy)?;
        }
        if self.ip_configuration.is_some() {
            state.serialize_entry("ipConfiguration", &self.ip_configuration)?;
        }
        if self.storage_auto_resize.is_some() {
            state.serialize_entry("storageAutoResize", &self.storage_auto_resize)?;
        }
        if self.location_preference.is_some() {
            state.serialize_entry("locationPreference", &self.location_preference)?;
        }
        if !self.database_flags.is_empty() {
            state.serialize_entry("databaseFlags", &self.database_flags)?;
        }
        if !wkt::internal::is_default(&self.data_disk_type) {
            state.serialize_entry("dataDiskType", &self.data_disk_type)?;
        }
        if self.maintenance_window.is_some() {
            state.serialize_entry("maintenanceWindow", &self.maintenance_window)?;
        }
        if self.backup_configuration.is_some() {
            state.serialize_entry("backupConfiguration", &self.backup_configuration)?;
        }
        if self.database_replication_enabled.is_some() {
            state.serialize_entry(
                "databaseReplicationEnabled",
                &self.database_replication_enabled,
            )?;
        }
        if self.crash_safe_replication_enabled.is_some() {
            state.serialize_entry(
                "crashSafeReplicationEnabled",
                &self.crash_safe_replication_enabled,
            )?;
        }
        if self.data_disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataDiskSizeGb", &__With(&self.data_disk_size_gb))?;
        }
        if self.active_directory_config.is_some() {
            state.serialize_entry("activeDirectoryConfig", &self.active_directory_config)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !self.deny_maintenance_periods.is_empty() {
            state.serialize_entry("denyMaintenancePeriods", &self.deny_maintenance_periods)?;
        }
        if self.insights_config.is_some() {
            state.serialize_entry("insightsConfig", &self.insights_config)?;
        }
        if self.password_validation_policy.is_some() {
            state.serialize_entry("passwordValidationPolicy", &self.password_validation_policy)?;
        }
        if self.sql_server_audit_config.is_some() {
            state.serialize_entry("sqlServerAuditConfig", &self.sql_server_audit_config)?;
        }
        if !wkt::internal::is_default(&self.edition) {
            state.serialize_entry("edition", &self.edition)?;
        }
        if !wkt::internal::is_default(&self.connector_enforcement) {
            state.serialize_entry("connectorEnforcement", &self.connector_enforcement)?;
        }
        if self.deletion_protection_enabled.is_some() {
            state.serialize_entry(
                "deletionProtectionEnabled",
                &self.deletion_protection_enabled,
            )?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.data_cache_config.is_some() {
            state.serialize_entry("dataCacheConfig", &self.data_cache_config)?;
        }
        if self.enable_google_ml_integration.is_some() {
            state.serialize_entry(
                "enableGoogleMlIntegration",
                &self.enable_google_ml_integration,
            )?;
        }
        if self.enable_dataplex_integration.is_some() {
            state.serialize_entry(
                "enableDataplexIntegration",
                &self.enable_dataplex_integration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Settings].
pub mod settings {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when the instance is activated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlActivationPolicy {
        /// Unknown activation plan.
        Unspecified,
        /// The instance is always up and running.
        Always,
        /// The instance never starts.
        Never,
        /// The instance starts upon receiving requests.
        #[deprecated]
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlActivationPolicy::value] or
        /// [SqlActivationPolicy::name].
        UnknownValue(sql_activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::OnDemand => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                3 => Self::OnDemand,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::OnDemand => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlActivationPolicy>::new(
                ".google.cloud.sql.v1.Settings.SqlActivationPolicy",
            ))
        }
    }

    /// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified,
        /// The instance is an enterprise edition.
        Enterprise,
        /// The instance is an Enterprise Plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.cloud.sql.v1.Settings.Edition",
            ))
        }
    }

    /// The options for enforcing Cloud SQL connectors in the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectorEnforcement {
        /// The requirement for Cloud SQL connectors is unknown.
        Unspecified,
        /// Do not require Cloud SQL connectors.
        NotRequired,
        /// Require all connections to use Cloud SQL connectors, including the
        /// Cloud SQL Auth Proxy and Cloud SQL Java, Python, and Go connectors.
        /// Note: This disables all existing authorized networks.
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectorEnforcement::value] or
        /// [ConnectorEnforcement::name].
        UnknownValue(connector_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connector_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectorEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotRequired => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTOR_ENFORCEMENT_UNSPECIFIED"),
                Self::NotRequired => std::option::Option::Some("NOT_REQUIRED"),
                Self::Required => std::option::Option::Some("REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectorEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectorEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectorEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotRequired,
                2 => Self::Required,
                _ => Self::UnknownValue(connector_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectorEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTOR_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "NOT_REQUIRED" => Self::NotRequired,
                "REQUIRED" => Self::Required,
                _ => Self::UnknownValue(connector_enforcement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectorEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotRequired => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectorEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectorEnforcement>::new(
                ".google.cloud.sql.v1.Settings.ConnectorEnforcement",
            ))
        }
    }
}

/// Specifies options for controlling advanced machine features.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core.
    pub threads_per_core: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.threads_per_core = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AdvancedMachineFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedMachineFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threads_per_core,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedMachineFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threadsPerCore" => Ok(__FieldTag::__threads_per_core),
                            "threads_per_core" => Ok(__FieldTag::__threads_per_core),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedMachineFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedMachineFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threads_per_core => {
                            if !fields.insert(__FieldTag::__threads_per_core) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threads_per_core",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threads_per_core =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvancedMachineFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.threads_per_core) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("threadsPerCore", &__With(&self.threads_per_core))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCerts Resource
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCert {
    /// This is always `sql#sslCert`.
    pub kind: std::string::String,

    /// Serial number, as extracted from the certificate.
    pub cert_serial_number: std::string::String,

    /// PEM representation.
    pub cert: std::string::String,

    /// The time when the certificate was created in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// User supplied name.  Constrained to [a-zA-Z.-_ ]+.
    pub common_name: std::string::String,

    /// The time when the certificate expires in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Sha1 Fingerprint.
    pub sha1_fingerprint: std::string::String,

    /// Name of the database instance.
    pub instance: std::string::String,

    /// The URI of this resource.
    pub self_link: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCert {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCert::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [cert_serial_number][crate::model::SslCert::cert_serial_number].
    pub fn set_cert_serial_number<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cert_serial_number = v.into();
        self
    }

    /// Sets the value of [cert][crate::model::SslCert::cert].
    pub fn set_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SslCert::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SslCert::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [common_name][crate::model::SslCert::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::SslCert::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::SslCert::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SslCert::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SslCert::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::SslCert::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }
}

impl wkt::message::Message for SslCert {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCert"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCert {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __cert_serial_number,
            __cert,
            __create_time,
            __common_name,
            __expiration_time,
            __sha1_fingerprint,
            __instance,
            __self_link,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCert")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "certSerialNumber" => Ok(__FieldTag::__cert_serial_number),
                            "cert_serial_number" => Ok(__FieldTag::__cert_serial_number),
                            "cert" => Ok(__FieldTag::__cert),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "commonName" => Ok(__FieldTag::__common_name),
                            "common_name" => Ok(__FieldTag::__common_name),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "sha1Fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            "sha1_fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            "instance" => Ok(__FieldTag::__instance),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCert;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCert")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cert_serial_number => {
                            if !fields.insert(__FieldTag::__cert_serial_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_serial_number",
                                ));
                            }
                            result.cert_serial_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cert => {
                            if !fields.insert(__FieldTag::__cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert",
                                ));
                            }
                            result.cert = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__common_name => {
                            if !fields.insert(__FieldTag::__common_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_name",
                                ));
                            }
                            result.common_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__sha1_fingerprint => {
                            if !fields.insert(__FieldTag::__sha1_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha1_fingerprint",
                                ));
                            }
                            result.sha1_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCert {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.cert_serial_number.is_empty() {
            state.serialize_entry("certSerialNumber", &self.cert_serial_number)?;
        }
        if !self.cert.is_empty() {
            state.serialize_entry("cert", &self.cert)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.common_name.is_empty() {
            state.serialize_entry("commonName", &self.common_name)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self.sha1_fingerprint.is_empty() {
            state.serialize_entry("sha1Fingerprint", &self.sha1_fingerprint)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCertDetail.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCertDetail {
    /// The public information about the cert.
    pub cert_info: std::option::Option<crate::model::SslCert>,

    /// The private key for the client cert, in pem format.  Keep private in order
    /// to protect your security.
    pub cert_private_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cert_info][crate::model::SslCertDetail::cert_info].
    pub fn set_cert_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.cert_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cert_info][crate::model::SslCertDetail::cert_info].
    pub fn set_or_clear_cert_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.cert_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cert_private_key][crate::model::SslCertDetail::cert_private_key].
    pub fn set_cert_private_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cert_private_key = v.into();
        self
    }
}

impl wkt::message::Message for SslCertDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCertDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cert_info,
            __cert_private_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCertDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certInfo" => Ok(__FieldTag::__cert_info),
                            "cert_info" => Ok(__FieldTag::__cert_info),
                            "certPrivateKey" => Ok(__FieldTag::__cert_private_key),
                            "cert_private_key" => Ok(__FieldTag::__cert_private_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCertDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCertDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cert_info => {
                            if !fields.insert(__FieldTag::__cert_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_info",
                                ));
                            }
                            result.cert_info =
                                map.next_value::<std::option::Option<crate::model::SslCert>>()?;
                        }
                        __FieldTag::__cert_private_key => {
                            if !fields.insert(__FieldTag::__cert_private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_private_key",
                                ));
                            }
                            result.cert_private_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCertDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cert_info.is_some() {
            state.serialize_entry("certInfo", &self.cert_info)?;
        }
        if !self.cert_private_key.is_empty() {
            state.serialize_entry("certPrivateKey", &self.cert_private_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlActiveDirectoryConfig {
    /// This is always sql#activeDirectoryConfig.
    pub kind: std::string::String,

    /// The name of the domain (e.g., mydomain.com).
    pub domain: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlActiveDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlActiveDirectoryConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::SqlActiveDirectoryConfig::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for SqlActiveDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlActiveDirectoryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlActiveDirectoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlActiveDirectoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "domain" => Ok(__FieldTag::__domain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlActiveDirectoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlActiveDirectoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlActiveDirectoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SQL Server specific audit configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerAuditConfig {
    /// This is always sql#sqlServerAuditConfig
    pub kind: std::string::String,

    /// The name of the destination bucket (e.g., gs://mybucket).
    pub bucket: std::string::String,

    /// How long to keep generated audit files.
    pub retention_interval: std::option::Option<wkt::Duration>,

    /// How often to upload generated audit files.
    pub upload_interval: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerAuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlServerAuditConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::SqlServerAuditConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [retention_interval][crate::model::SqlServerAuditConfig::retention_interval].
    pub fn set_retention_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_interval][crate::model::SqlServerAuditConfig::retention_interval].
    pub fn set_or_clear_retention_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upload_interval][crate::model::SqlServerAuditConfig::upload_interval].
    pub fn set_upload_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.upload_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upload_interval][crate::model::SqlServerAuditConfig::upload_interval].
    pub fn set_or_clear_upload_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.upload_interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlServerAuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerAuditConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerAuditConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __bucket,
            __retention_interval,
            __upload_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerAuditConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "retentionInterval" => Ok(__FieldTag::__retention_interval),
                            "retention_interval" => Ok(__FieldTag::__retention_interval),
                            "uploadInterval" => Ok(__FieldTag::__upload_interval),
                            "upload_interval" => Ok(__FieldTag::__upload_interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerAuditConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerAuditConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_interval => {
                            if !fields.insert(__FieldTag::__retention_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_interval",
                                ));
                            }
                            result.retention_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__upload_interval => {
                            if !fields.insert(__FieldTag::__upload_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upload_interval",
                                ));
                            }
                            result.upload_interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerAuditConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if self.retention_interval.is_some() {
            state.serialize_entry("retentionInterval", &self.retention_interval)?;
        }
        if self.upload_interval.is_some() {
            state.serialize_entry("uploadInterval", &self.upload_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Acquire SSRS lease context.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AcquireSsrsLeaseContext {
    /// The username to be used as the setup login to connect to the database
    /// server for SSRS setup.
    pub setup_login: std::option::Option<std::string::String>,

    /// The username to be used as the service login to connect to the report
    /// database for SSRS setup.
    pub service_login: std::option::Option<std::string::String>,

    /// The report database to be used for SSRS setup.
    pub report_database: std::option::Option<std::string::String>,

    /// Lease duration needed for SSRS setup.
    pub duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcquireSsrsLeaseContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [setup_login][crate::model::AcquireSsrsLeaseContext::setup_login].
    pub fn set_setup_login<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.setup_login = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [setup_login][crate::model::AcquireSsrsLeaseContext::setup_login].
    pub fn set_or_clear_setup_login<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.setup_login = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_login][crate::model::AcquireSsrsLeaseContext::service_login].
    pub fn set_service_login<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service_login = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_login][crate::model::AcquireSsrsLeaseContext::service_login].
    pub fn set_or_clear_service_login<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service_login = v.map(|x| x.into());
        self
    }

    /// Sets the value of [report_database][crate::model::AcquireSsrsLeaseContext::report_database].
    pub fn set_report_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.report_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_database][crate::model::AcquireSsrsLeaseContext::report_database].
    pub fn set_or_clear_report_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.report_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::AcquireSsrsLeaseContext::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::AcquireSsrsLeaseContext::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AcquireSsrsLeaseContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AcquireSsrsLeaseContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AcquireSsrsLeaseContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __setup_login,
            __service_login,
            __report_database,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcquireSsrsLeaseContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "setupLogin" => Ok(__FieldTag::__setup_login),
                            "setup_login" => Ok(__FieldTag::__setup_login),
                            "serviceLogin" => Ok(__FieldTag::__service_login),
                            "service_login" => Ok(__FieldTag::__service_login),
                            "reportDatabase" => Ok(__FieldTag::__report_database),
                            "report_database" => Ok(__FieldTag::__report_database),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AcquireSsrsLeaseContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcquireSsrsLeaseContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__setup_login => {
                            if !fields.insert(__FieldTag::__setup_login) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for setup_login",
                                ));
                            }
                            result.setup_login =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__service_login => {
                            if !fields.insert(__FieldTag::__service_login) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_login",
                                ));
                            }
                            result.service_login =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__report_database => {
                            if !fields.insert(__FieldTag::__report_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_database",
                                ));
                            }
                            result.report_database =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AcquireSsrsLeaseContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.setup_login.is_some() {
            state.serialize_entry("setupLogin", &self.setup_login)?;
        }
        if self.service_login.is_some() {
            state.serialize_entry("serviceLogin", &self.service_login)?;
        }
        if self.report_database.is_some() {
            state.serialize_entry("reportDatabase", &self.report_database)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlSslCertsDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    pub sha1_fingerprint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsDeleteRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsDeleteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlSslCertsDeleteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __sha1_fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlSslCertsDeleteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "sha1Fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            "sha1_fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlSslCertsDeleteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlSslCertsDeleteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sha1_fingerprint => {
                            if !fields.insert(__FieldTag::__sha1_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha1_fingerprint",
                                ));
                            }
                            result.sha1_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlSslCertsDeleteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.sha1_fingerprint.is_empty() {
            state.serialize_entry("sha1Fingerprint", &self.sha1_fingerprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlSslCertsGetRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    pub sha1_fingerprint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsGetRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlSslCertsGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __sha1_fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlSslCertsGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "sha1Fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            "sha1_fingerprint" => Ok(__FieldTag::__sha1_fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlSslCertsGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlSslCertsGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sha1_fingerprint => {
                            if !fields.insert(__FieldTag::__sha1_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha1_fingerprint",
                                ));
                            }
                            result.sha1_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlSslCertsGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.sha1_fingerprint.is_empty() {
            state.serialize_entry("sha1Fingerprint", &self.sha1_fingerprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlSslCertsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::SslCertsInsertRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlSslCertsInsertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCertsInsertRequest>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlSslCertsInsertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCertsInsertRequest>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlSslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlSslCertsInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlSslCertsInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlSslCertsInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlSslCertsInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map.next_value::<std::option::Option<crate::model::SslCertsInsertRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlSslCertsInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlSslCertsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlSslCertsListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlSslCertsListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlSslCertsListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlSslCertsListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlSslCertsListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCerts insert request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCertsInsertRequest {
    /// User supplied name.  Must be a distinct name from the other certificates
    /// for this instance.
    pub common_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_name][crate::model::SslCertsInsertRequest::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCertsInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCertsInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonName" => Ok(__FieldTag::__common_name),
                            "common_name" => Ok(__FieldTag::__common_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCertsInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCertsInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_name => {
                            if !fields.insert(__FieldTag::__common_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_name",
                                ));
                            }
                            result.common_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCertsInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.common_name.is_empty() {
            state.serialize_entry("commonName", &self.common_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCert insert response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCertsInsertResponse {
    /// This is always `sql#sslCertsInsert`.
    pub kind: std::string::String,

    /// The operation to track the ssl certs insert request.
    pub operation: std::option::Option<crate::model::Operation>,

    /// The server Certificate Authority's certificate.  If this is missing you can
    /// force a new one to be generated by calling resetSslConfig method on
    /// instances resource.
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The new client certificate and private key.
    pub client_cert: std::option::Option<crate::model::SslCertDetail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsInsertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsInsertResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::SslCertsInsertResponse::operation].
    pub fn set_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Operation>,
    {
        self.operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation][crate::model::SslCertsInsertResponse::operation].
    pub fn set_or_clear_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Operation>,
    {
        self.operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::SslCertsInsertResponse::server_ca_cert].
    pub fn set_server_ca_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [server_ca_cert][crate::model::SslCertsInsertResponse::server_ca_cert].
    pub fn set_or_clear_server_ca_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCert>,
    {
        self.server_ca_cert = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_cert][crate::model::SslCertsInsertResponse::client_cert].
    pub fn set_client_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslCertDetail>,
    {
        self.client_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_cert][crate::model::SslCertsInsertResponse::client_cert].
    pub fn set_or_clear_client_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslCertDetail>,
    {
        self.client_cert = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SslCertsInsertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCertsInsertResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __operation,
            __server_ca_cert,
            __client_cert,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCertsInsertResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "operation" => Ok(__FieldTag::__operation),
                            "serverCaCert" => Ok(__FieldTag::__server_ca_cert),
                            "server_ca_cert" => Ok(__FieldTag::__server_ca_cert),
                            "clientCert" => Ok(__FieldTag::__client_cert),
                            "client_cert" => Ok(__FieldTag::__client_cert),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCertsInsertResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCertsInsertResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation =
                                map.next_value::<std::option::Option<crate::model::Operation>>()?;
                        }
                        __FieldTag::__server_ca_cert => {
                            if !fields.insert(__FieldTag::__server_ca_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ca_cert",
                                ));
                            }
                            result.server_ca_cert =
                                map.next_value::<std::option::Option<crate::model::SslCert>>()?;
                        }
                        __FieldTag::__client_cert => {
                            if !fields.insert(__FieldTag::__client_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_cert",
                                ));
                            }
                            result.client_cert = map
                                .next_value::<std::option::Option<crate::model::SslCertDetail>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCertsInsertResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.operation.is_some() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.server_ca_cert.is_some() {
            state.serialize_entry("serverCaCert", &self.server_ca_cert)?;
        }
        if self.client_cert.is_some() {
            state.serialize_entry("clientCert", &self.client_cert)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SslCerts list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslCertsListResponse {
    /// This is always `sql#sslCertsList`.
    pub kind: std::string::String,

    /// List of client certificates for the instance.
    pub items: std::vec::Vec<crate::model::SslCert>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::SslCertsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslCertsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsListResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslCertsListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslCertsListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslCertsListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslCertsListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SslCert>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslCertsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Tiers list request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlTiersListRequest {
    /// Project ID of the project for which to list tiers.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlTiersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlTiersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlTiersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlTiersListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlTiersListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlTiersListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlTiersListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlTiersListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlTiersListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Tiers list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TiersListResponse {
    /// This is always `sql#tiersList`.
    pub kind: std::string::String,

    /// List of tiers.
    pub items: std::vec::Vec<crate::model::Tier>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TiersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TiersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::TiersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tier>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TiersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TiersListResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TiersListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TiersListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TiersListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TiersListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tier>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TiersListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Google Cloud SQL service tier resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Tier {
    /// An identifier for the machine type, for example, `db-custom-1-3840`. For
    /// related information, see [Pricing](/sql/pricing).
    pub tier: std::string::String,

    /// The maximum RAM usage of this tier in bytes.
    pub ram: i64,

    /// This is always `sql#tier`.
    pub kind: std::string::String,

    /// The maximum disk size of this tier in bytes.
    pub disk_quota: i64,

    /// The applicable regions for this tier.
    pub region: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tier {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tier][crate::model::Tier::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [ram][crate::model::Tier::ram].
    pub fn set_ram<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ram = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Tier::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [disk_quota][crate::model::Tier::disk_quota].
    pub fn set_disk_quota<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_quota = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Tier::region].
    pub fn set_region<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.region = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tier {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Tier"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tier,
            __ram,
            __kind,
            __disk_quota,
            __region,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tier")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tier" => Ok(__FieldTag::__tier),
                            "RAM" => Ok(__FieldTag::__ram),
                            "kind" => Ok(__FieldTag::__kind),
                            "DiskQuota" => Ok(__FieldTag::__disk_quota),
                            "Disk_Quota" => Ok(__FieldTag::__disk_quota),
                            "region" => Ok(__FieldTag::__region),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tier;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tier")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ram => {
                            if !fields.insert(__FieldTag::__ram) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ram",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ram = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_quota => {
                            if !fields.insert(__FieldTag::__disk_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_quota",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_quota = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tier.is_empty() {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !wkt::internal::is_default(&self.ram) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("RAM", &__With(&self.ram))?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.disk_quota) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("DiskQuota", &__With(&self.disk_quota))?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlUsersDeleteRequest {
    /// Host of the user in the instance.
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Name of the user in the instance.
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersDeleteRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersDeleteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersDeleteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlUsersDeleteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host,
            __instance,
            __name,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlUsersDeleteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "host" => Ok(__FieldTag::__host),
                            "instance" => Ok(__FieldTag::__instance),
                            "name" => Ok(__FieldTag::__name),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlUsersDeleteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlUsersDeleteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlUsersDeleteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for Users Get RPC
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlUsersGetRequest {
    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// User of the instance.
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    /// Host of a user of the instance.
    pub host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersGetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [host][crate::model::SqlUsersGetRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersGetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlUsersGetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __name,
            __project,
            __host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlUsersGetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "name" => Ok(__FieldTag::__name),
                            "project" => Ok(__FieldTag::__project),
                            "host" => Ok(__FieldTag::__host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlUsersGetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlUsersGetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlUsersGetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlUsersInsertRequest {
    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::User>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersInsertRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlUsersInsertRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlUsersInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersInsertRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlUsersInsertRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlUsersInsertRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlUsersInsertRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlUsersInsertRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlUsersInsertRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlUsersListRequest {
    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlUsersListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __project,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlUsersListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlUsersListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlUsersListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlUsersListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlUsersUpdateRequest {
    /// Optional. Host of the user in the instance.
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    pub instance: std::string::String,

    /// Name of the user in the instance.
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    pub project: std::string::String,

    pub body: std::option::Option<crate::model::User>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersUpdateRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersUpdateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersUpdateRequest::body].
    pub fn set_body<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.body = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [body][crate::model::SqlUsersUpdateRequest::body].
    pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.body = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlUsersUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersUpdateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlUsersUpdateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host,
            __instance,
            __name,
            __project,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlUsersUpdateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "host" => Ok(__FieldTag::__host),
                            "instance" => Ok(__FieldTag::__instance),
                            "name" => Ok(__FieldTag::__name),
                            "project" => Ok(__FieldTag::__project),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlUsersUpdateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlUsersUpdateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlUsersUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.body.is_some() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// User level password validation policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserPasswordValidationPolicy {
    /// Number of failed login attempts allowed before user get locked.
    pub allowed_failed_attempts: i32,

    /// Expiration duration after password is updated.
    pub password_expiration_duration: std::option::Option<wkt::Duration>,

    /// If true, failed login attempts check will be enabled.
    pub enable_failed_attempts_check: bool,

    /// Output only. Read-only password status.
    pub status: std::option::Option<crate::model::PasswordStatus>,

    /// If true, the user must specify the current password before changing the
    /// password. This flag is supported only for MySQL.
    pub enable_password_verification: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserPasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_failed_attempts][crate::model::UserPasswordValidationPolicy::allowed_failed_attempts].
    pub fn set_allowed_failed_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.allowed_failed_attempts = v.into();
        self
    }

    /// Sets the value of [password_expiration_duration][crate::model::UserPasswordValidationPolicy::password_expiration_duration].
    pub fn set_password_expiration_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.password_expiration_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [password_expiration_duration][crate::model::UserPasswordValidationPolicy::password_expiration_duration].
    pub fn set_or_clear_password_expiration_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.password_expiration_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_failed_attempts_check][crate::model::UserPasswordValidationPolicy::enable_failed_attempts_check].
    pub fn set_enable_failed_attempts_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_failed_attempts_check = v.into();
        self
    }

    /// Sets the value of [status][crate::model::UserPasswordValidationPolicy::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PasswordStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::UserPasswordValidationPolicy::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PasswordStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_password_verification][crate::model::UserPasswordValidationPolicy::enable_password_verification].
    pub fn set_enable_password_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_password_verification = v.into();
        self
    }
}

impl wkt::message::Message for UserPasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UserPasswordValidationPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserPasswordValidationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_failed_attempts,
            __password_expiration_duration,
            __enable_failed_attempts_check,
            __status,
            __enable_password_verification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserPasswordValidationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedFailedAttempts" => Ok(__FieldTag::__allowed_failed_attempts),
                            "allowed_failed_attempts" => Ok(__FieldTag::__allowed_failed_attempts),
                            "passwordExpirationDuration" => {
                                Ok(__FieldTag::__password_expiration_duration)
                            }
                            "password_expiration_duration" => {
                                Ok(__FieldTag::__password_expiration_duration)
                            }
                            "enableFailedAttemptsCheck" => {
                                Ok(__FieldTag::__enable_failed_attempts_check)
                            }
                            "enable_failed_attempts_check" => {
                                Ok(__FieldTag::__enable_failed_attempts_check)
                            }
                            "status" => Ok(__FieldTag::__status),
                            "enablePasswordVerification" => {
                                Ok(__FieldTag::__enable_password_verification)
                            }
                            "enable_password_verification" => {
                                Ok(__FieldTag::__enable_password_verification)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserPasswordValidationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserPasswordValidationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_failed_attempts => {
                            if !fields.insert(__FieldTag::__allowed_failed_attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_failed_attempts",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.allowed_failed_attempts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__password_expiration_duration => {
                            if !fields.insert(__FieldTag::__password_expiration_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_expiration_duration",
                                ));
                            }
                            result.password_expiration_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__enable_failed_attempts_check => {
                            if !fields.insert(__FieldTag::__enable_failed_attempts_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_failed_attempts_check",
                                ));
                            }
                            result.enable_failed_attempts_check = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::PasswordStatus>>(
                                )?;
                        }
                        __FieldTag::__enable_password_verification => {
                            if !fields.insert(__FieldTag::__enable_password_verification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_password_verification",
                                ));
                            }
                            result.enable_password_verification = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserPasswordValidationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allowed_failed_attempts) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "allowedFailedAttempts",
                &__With(&self.allowed_failed_attempts),
            )?;
        }
        if self.password_expiration_duration.is_some() {
            state.serialize_entry(
                "passwordExpirationDuration",
                &self.password_expiration_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_failed_attempts_check) {
            state.serialize_entry(
                "enableFailedAttemptsCheck",
                &self.enable_failed_attempts_check,
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !wkt::internal::is_default(&self.enable_password_verification) {
            state.serialize_entry(
                "enablePasswordVerification",
                &self.enable_password_verification,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Read-only password status.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PasswordStatus {
    /// If true, user does not have login privileges.
    pub locked: bool,

    /// The expiration time of the current password.
    pub password_expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PasswordStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locked][crate::model::PasswordStatus::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [password_expiration_time][crate::model::PasswordStatus::password_expiration_time].
    pub fn set_password_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.password_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [password_expiration_time][crate::model::PasswordStatus::password_expiration_time].
    pub fn set_or_clear_password_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.password_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PasswordStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PasswordStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __locked,
            __password_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PasswordStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locked" => Ok(__FieldTag::__locked),
                            "passwordExpirationTime" => Ok(__FieldTag::__password_expiration_time),
                            "password_expiration_time" => {
                                Ok(__FieldTag::__password_expiration_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PasswordStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PasswordStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__locked => {
                            if !fields.insert(__FieldTag::__locked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locked",
                                ));
                            }
                            result.locked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password_expiration_time => {
                            if !fields.insert(__FieldTag::__password_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_expiration_time",
                                ));
                            }
                            result.password_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PasswordStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if self.password_expiration_time.is_some() {
            state.serialize_entry("passwordExpirationTime", &self.password_expiration_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Cloud SQL user resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct User {
    /// This is always `sql#user`.
    pub kind: std::string::String,

    /// The password for the user.
    pub password: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    pub etag: std::string::String,

    /// The name of the user in the Cloud SQL instance. Can be omitted for
    /// `update` because it is already specified in the URL.
    pub name: std::string::String,

    /// Optional. The host from which the user can connect. For `insert`
    /// operations, host defaults to an empty string. For `update`
    /// operations, host is specified as part of the request URL. The host name
    /// cannot be updated after insertion.  For a MySQL instance, it's required;
    /// for a PostgreSQL or SQL Server instance, it's optional.
    pub host: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    /// Can be omitted for `update` because it is already specified on the
    /// URL.
    pub instance: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable. Can be omitted for `update` because
    /// it is already specified on the URL.
    pub project: std::string::String,

    /// The user type. It determines the method to authenticate the user during
    /// login. The default is the database's built-in user type.
    pub r#type: crate::model::user::SqlUserType,

    /// User level password validation policy.
    pub password_policy: std::option::Option<crate::model::UserPasswordValidationPolicy>,

    /// Dual password status for the user.
    pub dual_password_type: std::option::Option<crate::model::user::DualPasswordType>,

    /// User details for specific database type
    pub user_details: std::option::Option<crate::model::user::UserDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::User::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::User::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host][crate::model::User::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::User::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::User::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::User::type].
    pub fn set_type<T: std::convert::Into<crate::model::user::SqlUserType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [password_policy][crate::model::User::password_policy].
    pub fn set_password_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserPasswordValidationPolicy>,
    {
        self.password_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [password_policy][crate::model::User::password_policy].
    pub fn set_or_clear_password_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserPasswordValidationPolicy>,
    {
        self.password_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dual_password_type][crate::model::User::dual_password_type].
    pub fn set_dual_password_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::user::DualPasswordType>,
    {
        self.dual_password_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dual_password_type][crate::model::User::dual_password_type].
    pub fn set_or_clear_dual_password_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::user::DualPasswordType>,
    {
        self.dual_password_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_details][crate::model::User::user_details].
    ///
    /// Note that all the setters affecting `user_details` are mutually
    /// exclusive.
    pub fn set_user_details<
        T: std::convert::Into<std::option::Option<crate::model::user::UserDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_details = v.into();
        self
    }

    /// The value of [user_details][crate::model::User::user_details]
    /// if it holds a `SqlserverUserDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlserver_user_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerUserDetails>> {
        #[allow(unreachable_patterns)]
        self.user_details.as_ref().and_then(|v| match v {
            crate::model::user::UserDetails::SqlserverUserDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_details][crate::model::User::user_details]
    /// to hold a `SqlserverUserDetails`.
    ///
    /// Note that all the setters affecting `user_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_user_details<
        T: std::convert::Into<std::boxed::Box<crate::model::SqlServerUserDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_details = std::option::Option::Some(
            crate::model::user::UserDetails::SqlserverUserDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.User"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __password,
            __etag,
            __name,
            __host,
            __instance,
            __project,
            __type,
            __sqlserver_user_details,
            __password_policy,
            __dual_password_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for User")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "password" => Ok(__FieldTag::__password),
                            "etag" => Ok(__FieldTag::__etag),
                            "name" => Ok(__FieldTag::__name),
                            "host" => Ok(__FieldTag::__host),
                            "instance" => Ok(__FieldTag::__instance),
                            "project" => Ok(__FieldTag::__project),
                            "type" => Ok(__FieldTag::__type),
                            "sqlserverUserDetails" => Ok(__FieldTag::__sqlserver_user_details),
                            "sqlserver_user_details" => Ok(__FieldTag::__sqlserver_user_details),
                            "passwordPolicy" => Ok(__FieldTag::__password_policy),
                            "password_policy" => Ok(__FieldTag::__password_policy),
                            "dualPasswordType" => Ok(__FieldTag::__dual_password_type),
                            "dual_password_type" => Ok(__FieldTag::__dual_password_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = User;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct User")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::user::SqlUserType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sqlserver_user_details => {
                            if !fields.insert(__FieldTag::__sqlserver_user_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sqlserver_user_details",
                                ));
                            }
                            if result.user_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `user_details`, a oneof with full ID .google.cloud.sql.v1.User.sqlserver_user_details, latest field was sqlserverUserDetails",
                                ));
                            }
                            result.user_details = std::option::Option::Some(
                                crate::model::user::UserDetails::SqlserverUserDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SqlServerUserDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__password_policy => {
                            if !fields.insert(__FieldTag::__password_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_policy",
                                ));
                            }
                            result.password_policy = map.next_value::<std::option::Option<crate::model::UserPasswordValidationPolicy>>()?
                                ;
                        }
                        __FieldTag::__dual_password_type => {
                            if !fields.insert(__FieldTag::__dual_password_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dual_password_type",
                                ));
                            }
                            result.dual_password_type = map.next_value::<std::option::Option<crate::model::user::DualPasswordType>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if let Some(value) = self.sqlserver_user_details() {
            state.serialize_entry("sqlserverUserDetails", value)?;
        }
        if self.password_policy.is_some() {
            state.serialize_entry("passwordPolicy", &self.password_policy)?;
        }
        if self.dual_password_type.is_some() {
            state.serialize_entry("dualPasswordType", &self.dual_password_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [User].
pub mod user {
    #[allow(unused_imports)]
    use super::*;

    /// The user type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlUserType {
        /// The database's built-in user type.
        BuiltIn,
        /// Cloud IAM user.
        CloudIamUser,
        /// Cloud IAM service account.
        CloudIamServiceAccount,
        /// Cloud IAM group non-login user.
        CloudIamGroup,
        /// Cloud IAM group login user.
        CloudIamGroupUser,
        /// Cloud IAM group login service account.
        CloudIamGroupServiceAccount,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlUserType::value] or
        /// [SqlUserType::name].
        UnknownValue(sql_user_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_user_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlUserType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::BuiltIn => std::option::Option::Some(0),
                Self::CloudIamUser => std::option::Option::Some(1),
                Self::CloudIamServiceAccount => std::option::Option::Some(2),
                Self::CloudIamGroup => std::option::Option::Some(3),
                Self::CloudIamGroupUser => std::option::Option::Some(4),
                Self::CloudIamGroupServiceAccount => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::BuiltIn => std::option::Option::Some("BUILT_IN"),
                Self::CloudIamUser => std::option::Option::Some("CLOUD_IAM_USER"),
                Self::CloudIamServiceAccount => {
                    std::option::Option::Some("CLOUD_IAM_SERVICE_ACCOUNT")
                }
                Self::CloudIamGroup => std::option::Option::Some("CLOUD_IAM_GROUP"),
                Self::CloudIamGroupUser => std::option::Option::Some("CLOUD_IAM_GROUP_USER"),
                Self::CloudIamGroupServiceAccount => {
                    std::option::Option::Some("CLOUD_IAM_GROUP_SERVICE_ACCOUNT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlUserType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlUserType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlUserType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::BuiltIn,
                1 => Self::CloudIamUser,
                2 => Self::CloudIamServiceAccount,
                3 => Self::CloudIamGroup,
                4 => Self::CloudIamGroupUser,
                5 => Self::CloudIamGroupServiceAccount,
                _ => Self::UnknownValue(sql_user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlUserType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BUILT_IN" => Self::BuiltIn,
                "CLOUD_IAM_USER" => Self::CloudIamUser,
                "CLOUD_IAM_SERVICE_ACCOUNT" => Self::CloudIamServiceAccount,
                "CLOUD_IAM_GROUP" => Self::CloudIamGroup,
                "CLOUD_IAM_GROUP_USER" => Self::CloudIamGroupUser,
                "CLOUD_IAM_GROUP_SERVICE_ACCOUNT" => Self::CloudIamGroupServiceAccount,
                _ => Self::UnknownValue(sql_user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlUserType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::BuiltIn => serializer.serialize_i32(0),
                Self::CloudIamUser => serializer.serialize_i32(1),
                Self::CloudIamServiceAccount => serializer.serialize_i32(2),
                Self::CloudIamGroup => serializer.serialize_i32(3),
                Self::CloudIamGroupUser => serializer.serialize_i32(4),
                Self::CloudIamGroupServiceAccount => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlUserType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlUserType>::new(
                ".google.cloud.sql.v1.User.SqlUserType",
            ))
        }
    }

    /// The type of retained password.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DualPasswordType {
        /// The default value.
        Unspecified,
        /// Do not update the user's dual password status.
        NoModifyDualPassword,
        /// No dual password usable for connecting using this user.
        NoDualPassword,
        /// Dual password usable for connecting using this user.
        DualPassword,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DualPasswordType::value] or
        /// [DualPasswordType::name].
        UnknownValue(dual_password_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dual_password_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DualPasswordType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoModifyDualPassword => std::option::Option::Some(1),
                Self::NoDualPassword => std::option::Option::Some(2),
                Self::DualPassword => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DUAL_PASSWORD_TYPE_UNSPECIFIED"),
                Self::NoModifyDualPassword => std::option::Option::Some("NO_MODIFY_DUAL_PASSWORD"),
                Self::NoDualPassword => std::option::Option::Some("NO_DUAL_PASSWORD"),
                Self::DualPassword => std::option::Option::Some("DUAL_PASSWORD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DualPasswordType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DualPasswordType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DualPasswordType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoModifyDualPassword,
                2 => Self::NoDualPassword,
                3 => Self::DualPassword,
                _ => Self::UnknownValue(dual_password_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DualPasswordType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DUAL_PASSWORD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_MODIFY_DUAL_PASSWORD" => Self::NoModifyDualPassword,
                "NO_DUAL_PASSWORD" => Self::NoDualPassword,
                "DUAL_PASSWORD" => Self::DualPassword,
                _ => Self::UnknownValue(dual_password_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DualPasswordType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoModifyDualPassword => serializer.serialize_i32(1),
                Self::NoDualPassword => serializer.serialize_i32(2),
                Self::DualPassword => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DualPasswordType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DualPasswordType>::new(
                ".google.cloud.sql.v1.User.DualPasswordType",
            ))
        }
    }

    /// User details for specific database type
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserDetails {
        SqlserverUserDetails(std::boxed::Box<crate::model::SqlServerUserDetails>),
    }
}

/// Represents a Sql Server user on the Cloud SQL instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlServerUserDetails {
    /// If the user has been disabled
    pub disabled: bool,

    /// The server roles for this user
    pub server_roles: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerUserDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::SqlServerUserDetails::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [server_roles][crate::model::SqlServerUserDetails::server_roles].
    pub fn set_server_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.server_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerUserDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerUserDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlServerUserDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            __server_roles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlServerUserDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            "serverRoles" => Ok(__FieldTag::__server_roles),
                            "server_roles" => Ok(__FieldTag::__server_roles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlServerUserDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlServerUserDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_roles => {
                            if !fields.insert(__FieldTag::__server_roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_roles",
                                ));
                            }
                            result.server_roles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlServerUserDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self.server_roles.is_empty() {
            state.serialize_entry("serverRoles", &self.server_roles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// User list response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UsersListResponse {
    /// This is always `sql#usersList`.
    pub kind: std::string::String,

    /// List of user resources in the instance.
    pub items: std::vec::Vec<crate::model::User>,

    /// Unused.
    #[deprecated]
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::UsersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::UsersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::UsersListResponse::next_page_token].
    #[deprecated]
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for UsersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UsersListResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsersListResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kind,
            __items,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsersListResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kind" => Ok(__FieldTag::__kind),
                            "items" => Ok(__FieldTag::__items),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsersListResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsersListResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::User>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsersListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The status of a backup run.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupRunStatus {
    /// The status of the run is unknown.
    Unspecified,
    /// The backup operation was enqueued.
    Enqueued,
    /// The backup is overdue across a given backup window. Indicates a
    /// problem. Example: Long-running operation in progress during
    /// the whole window.
    Overdue,
    /// The backup is in progress.
    Running,
    /// The backup failed.
    Failed,
    /// The backup was successful.
    Successful,
    /// The backup was skipped (without problems) for a given backup
    /// window. Example: Instance was idle.
    Skipped,
    /// The backup is about to be deleted.
    DeletionPending,
    /// The backup deletion failed.
    DeletionFailed,
    /// The backup has been deleted.
    Deleted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupRunStatus::value] or
    /// [SqlBackupRunStatus::name].
    UnknownValue(sql_backup_run_status::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_run_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupRunStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enqueued => std::option::Option::Some(1),
            Self::Overdue => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Failed => std::option::Option::Some(4),
            Self::Successful => std::option::Option::Some(5),
            Self::Skipped => std::option::Option::Some(6),
            Self::DeletionPending => std::option::Option::Some(7),
            Self::DeletionFailed => std::option::Option::Some(8),
            Self::Deleted => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_RUN_STATUS_UNSPECIFIED"),
            Self::Enqueued => std::option::Option::Some("ENQUEUED"),
            Self::Overdue => std::option::Option::Some("OVERDUE"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Successful => std::option::Option::Some("SUCCESSFUL"),
            Self::Skipped => std::option::Option::Some("SKIPPED"),
            Self::DeletionPending => std::option::Option::Some("DELETION_PENDING"),
            Self::DeletionFailed => std::option::Option::Some("DELETION_FAILED"),
            Self::Deleted => std::option::Option::Some("DELETED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupRunStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupRunStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupRunStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enqueued,
            2 => Self::Overdue,
            3 => Self::Running,
            4 => Self::Failed,
            5 => Self::Successful,
            6 => Self::Skipped,
            7 => Self::DeletionPending,
            8 => Self::DeletionFailed,
            9 => Self::Deleted,
            _ => Self::UnknownValue(sql_backup_run_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlBackupRunStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_RUN_STATUS_UNSPECIFIED" => Self::Unspecified,
            "ENQUEUED" => Self::Enqueued,
            "OVERDUE" => Self::Overdue,
            "RUNNING" => Self::Running,
            "FAILED" => Self::Failed,
            "SUCCESSFUL" => Self::Successful,
            "SKIPPED" => Self::Skipped,
            "DELETION_PENDING" => Self::DeletionPending,
            "DELETION_FAILED" => Self::DeletionFailed,
            "DELETED" => Self::Deleted,
            _ => Self::UnknownValue(sql_backup_run_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlBackupRunStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enqueued => serializer.serialize_i32(1),
            Self::Overdue => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Failed => serializer.serialize_i32(4),
            Self::Successful => serializer.serialize_i32(5),
            Self::Skipped => serializer.serialize_i32(6),
            Self::DeletionPending => serializer.serialize_i32(7),
            Self::DeletionFailed => serializer.serialize_i32(8),
            Self::Deleted => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupRunStatus>::new(
            ".google.cloud.sql.v1.SqlBackupRunStatus",
        ))
    }
}

/// Defines the supported backup kinds.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupKind {
    /// This is an unknown BackupKind.
    Unspecified,
    /// The snapshot based backups
    Snapshot,
    /// Physical backups
    Physical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupKind::value] or
    /// [SqlBackupKind::name].
    UnknownValue(sql_backup_kind::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Snapshot => std::option::Option::Some(1),
            Self::Physical => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_KIND_UNSPECIFIED"),
            Self::Snapshot => std::option::Option::Some("SNAPSHOT"),
            Self::Physical => std::option::Option::Some("PHYSICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Snapshot,
            2 => Self::Physical,
            _ => Self::UnknownValue(sql_backup_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlBackupKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_KIND_UNSPECIFIED" => Self::Unspecified,
            "SNAPSHOT" => Self::Snapshot,
            "PHYSICAL" => Self::Physical,
            _ => Self::UnknownValue(sql_backup_kind::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlBackupKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Snapshot => serializer.serialize_i32(1),
            Self::Physical => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupKind>::new(
            ".google.cloud.sql.v1.SqlBackupKind",
        ))
    }
}

/// Type of backup (i.e. automated, on demand, etc).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupRunType {
    /// This is an unknown BackupRun type.
    Unspecified,
    /// The backup schedule automatically triggers a backup.
    Automated,
    /// The user manually triggers a backup.
    OnDemand,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupRunType::value] or
    /// [SqlBackupRunType::name].
    UnknownValue(sql_backup_run_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_run_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupRunType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Automated => std::option::Option::Some(1),
            Self::OnDemand => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_RUN_TYPE_UNSPECIFIED"),
            Self::Automated => std::option::Option::Some("AUTOMATED"),
            Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupRunType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupRunType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupRunType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Automated,
            2 => Self::OnDemand,
            _ => Self::UnknownValue(sql_backup_run_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlBackupRunType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_RUN_TYPE_UNSPECIFIED" => Self::Unspecified,
            "AUTOMATED" => Self::Automated,
            "ON_DEMAND" => Self::OnDemand,
            _ => Self::UnknownValue(sql_backup_run_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlBackupRunType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Automated => serializer.serialize_i32(1),
            Self::OnDemand => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupRunType>::new(
            ".google.cloud.sql.v1.SqlBackupRunType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlFlagType {
    /// This is an unknown flag type.
    Unspecified,
    /// Boolean type flag.
    Boolean,
    /// String type flag.
    String,
    /// Integer type flag.
    Integer,
    /// Flag type used for a server startup option.
    None,
    /// Type introduced specially for MySQL TimeZone offset. Accept a string value
    /// with the format [-12:59, 13:00].
    MysqlTimezoneOffset,
    /// Float type flag.
    Float,
    /// Comma-separated list of the strings in a SqlFlagType enum.
    RepeatedString,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlFlagType::value] or
    /// [SqlFlagType::name].
    UnknownValue(sql_flag_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_flag_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlFlagType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Boolean => std::option::Option::Some(1),
            Self::String => std::option::Option::Some(2),
            Self::Integer => std::option::Option::Some(3),
            Self::None => std::option::Option::Some(4),
            Self::MysqlTimezoneOffset => std::option::Option::Some(5),
            Self::Float => std::option::Option::Some(6),
            Self::RepeatedString => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_FLAG_TYPE_UNSPECIFIED"),
            Self::Boolean => std::option::Option::Some("BOOLEAN"),
            Self::String => std::option::Option::Some("STRING"),
            Self::Integer => std::option::Option::Some("INTEGER"),
            Self::None => std::option::Option::Some("NONE"),
            Self::MysqlTimezoneOffset => std::option::Option::Some("MYSQL_TIMEZONE_OFFSET"),
            Self::Float => std::option::Option::Some("FLOAT"),
            Self::RepeatedString => std::option::Option::Some("REPEATED_STRING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlFlagType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlFlagType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlFlagType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Boolean,
            2 => Self::String,
            3 => Self::Integer,
            4 => Self::None,
            5 => Self::MysqlTimezoneOffset,
            6 => Self::Float,
            7 => Self::RepeatedString,
            _ => Self::UnknownValue(sql_flag_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlFlagType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_FLAG_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BOOLEAN" => Self::Boolean,
            "STRING" => Self::String,
            "INTEGER" => Self::Integer,
            "NONE" => Self::None,
            "MYSQL_TIMEZONE_OFFSET" => Self::MysqlTimezoneOffset,
            "FLOAT" => Self::Float,
            "REPEATED_STRING" => Self::RepeatedString,
            _ => Self::UnknownValue(sql_flag_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlFlagType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Boolean => serializer.serialize_i32(1),
            Self::String => serializer.serialize_i32(2),
            Self::Integer => serializer.serialize_i32(3),
            Self::None => serializer.serialize_i32(4),
            Self::MysqlTimezoneOffset => serializer.serialize_i32(5),
            Self::Float => serializer.serialize_i32(6),
            Self::RepeatedString => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFlagType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlFlagType>::new(
            ".google.cloud.sql.v1.SqlFlagType",
        ))
    }
}

/// External Sync parallel level.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ExternalSyncParallelLevel {
    /// Unknown sync parallel level. Will be defaulted to OPTIMAL.
    Unspecified,
    /// Minimal parallel level.
    Min,
    /// Optimal parallel level.
    Optimal,
    /// Maximum parallel level.
    Max,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ExternalSyncParallelLevel::value] or
    /// [ExternalSyncParallelLevel::name].
    UnknownValue(external_sync_parallel_level::UnknownValue),
}

#[doc(hidden)]
pub mod external_sync_parallel_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ExternalSyncParallelLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Min => std::option::Option::Some(1),
            Self::Optimal => std::option::Option::Some(2),
            Self::Max => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED")
            }
            Self::Min => std::option::Option::Some("MIN"),
            Self::Optimal => std::option::Option::Some("OPTIMAL"),
            Self::Max => std::option::Option::Some("MAX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ExternalSyncParallelLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ExternalSyncParallelLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ExternalSyncParallelLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Min,
            2 => Self::Optimal,
            3 => Self::Max,
            _ => Self::UnknownValue(external_sync_parallel_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ExternalSyncParallelLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "MIN" => Self::Min,
            "OPTIMAL" => Self::Optimal,
            "MAX" => Self::Max,
            _ => Self::UnknownValue(external_sync_parallel_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ExternalSyncParallelLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Min => serializer.serialize_i32(1),
            Self::Optimal => serializer.serialize_i32(2),
            Self::Max => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ExternalSyncParallelLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<ExternalSyncParallelLevel>::new(
                ".google.cloud.sql.v1.ExternalSyncParallelLevel",
            ),
        )
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlInstanceType {
    /// This is an unknown Cloud SQL instance type.
    Unspecified,
    /// A regular Cloud SQL instance that is not replicating from a primary
    /// instance.
    CloudSqlInstance,
    /// An instance running on the customer's premises that is not managed by
    /// Cloud SQL.
    OnPremisesInstance,
    /// A Cloud SQL instance acting as a read-replica.
    ReadReplicaInstance,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlInstanceType::value] or
    /// [SqlInstanceType::name].
    UnknownValue(sql_instance_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_instance_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlInstanceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CloudSqlInstance => std::option::Option::Some(1),
            Self::OnPremisesInstance => std::option::Option::Some(2),
            Self::ReadReplicaInstance => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_INSTANCE_TYPE_UNSPECIFIED"),
            Self::CloudSqlInstance => std::option::Option::Some("CLOUD_SQL_INSTANCE"),
            Self::OnPremisesInstance => std::option::Option::Some("ON_PREMISES_INSTANCE"),
            Self::ReadReplicaInstance => std::option::Option::Some("READ_REPLICA_INSTANCE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlInstanceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlInstanceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlInstanceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CloudSqlInstance,
            2 => Self::OnPremisesInstance,
            3 => Self::ReadReplicaInstance,
            _ => Self::UnknownValue(sql_instance_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlInstanceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "CLOUD_SQL_INSTANCE" => Self::CloudSqlInstance,
            "ON_PREMISES_INSTANCE" => Self::OnPremisesInstance,
            "READ_REPLICA_INSTANCE" => Self::ReadReplicaInstance,
            _ => Self::UnknownValue(sql_instance_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlInstanceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CloudSqlInstance => serializer.serialize_i32(1),
            Self::OnPremisesInstance => serializer.serialize_i32(2),
            Self::ReadReplicaInstance => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlInstanceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlInstanceType>::new(
            ".google.cloud.sql.v1.SqlInstanceType",
        ))
    }
}

/// The suspension reason of the database instance if the state is SUSPENDED.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlSuspensionReason {
    /// This is an unknown suspension reason.
    Unspecified,
    /// The instance is suspended due to billing issues (for example:, GCP account
    /// issue)
    BillingIssue,
    /// The instance is suspended due to illegal content (for example:, child
    /// pornography, copyrighted material, etc.).
    LegalIssue,
    /// The instance is causing operational issues (for example:, causing the
    /// database to crash).
    OperationalIssue,
    /// The KMS key used by the instance is either revoked or denied access to
    KmsKeyIssue,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlSuspensionReason::value] or
    /// [SqlSuspensionReason::name].
    UnknownValue(sql_suspension_reason::UnknownValue),
}

#[doc(hidden)]
pub mod sql_suspension_reason {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlSuspensionReason {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BillingIssue => std::option::Option::Some(2),
            Self::LegalIssue => std::option::Option::Some(3),
            Self::OperationalIssue => std::option::Option::Some(4),
            Self::KmsKeyIssue => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_SUSPENSION_REASON_UNSPECIFIED"),
            Self::BillingIssue => std::option::Option::Some("BILLING_ISSUE"),
            Self::LegalIssue => std::option::Option::Some("LEGAL_ISSUE"),
            Self::OperationalIssue => std::option::Option::Some("OPERATIONAL_ISSUE"),
            Self::KmsKeyIssue => std::option::Option::Some("KMS_KEY_ISSUE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlSuspensionReason {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlSuspensionReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlSuspensionReason {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BillingIssue,
            3 => Self::LegalIssue,
            4 => Self::OperationalIssue,
            5 => Self::KmsKeyIssue,
            _ => Self::UnknownValue(sql_suspension_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlSuspensionReason {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_SUSPENSION_REASON_UNSPECIFIED" => Self::Unspecified,
            "BILLING_ISSUE" => Self::BillingIssue,
            "LEGAL_ISSUE" => Self::LegalIssue,
            "OPERATIONAL_ISSUE" => Self::OperationalIssue,
            "KMS_KEY_ISSUE" => Self::KmsKeyIssue,
            _ => Self::UnknownValue(sql_suspension_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlSuspensionReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BillingIssue => serializer.serialize_i32(2),
            Self::LegalIssue => serializer.serialize_i32(3),
            Self::OperationalIssue => serializer.serialize_i32(4),
            Self::KmsKeyIssue => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlSuspensionReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlSuspensionReason>::new(
            ".google.cloud.sql.v1.SqlSuspensionReason",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlFileType {
    /// Unknown file type.
    Unspecified,
    /// File containing SQL statements.
    Sql,
    /// File in CSV format.
    Csv,
    Bak,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlFileType::value] or
    /// [SqlFileType::name].
    UnknownValue(sql_file_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_file_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlFileType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Sql => std::option::Option::Some(1),
            Self::Csv => std::option::Option::Some(2),
            Self::Bak => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_FILE_TYPE_UNSPECIFIED"),
            Self::Sql => std::option::Option::Some("SQL"),
            Self::Csv => std::option::Option::Some("CSV"),
            Self::Bak => std::option::Option::Some("BAK"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlFileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlFileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlFileType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Sql,
            2 => Self::Csv,
            4 => Self::Bak,
            _ => Self::UnknownValue(sql_file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlFileType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SQL" => Self::Sql,
            "CSV" => Self::Csv,
            "BAK" => Self::Bak,
            _ => Self::UnknownValue(sql_file_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlFileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Sql => serializer.serialize_i32(1),
            Self::Csv => serializer.serialize_i32(2),
            Self::Bak => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlFileType>::new(
            ".google.cloud.sql.v1.SqlFileType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BakType {
    /// Default type.
    Unspecified,
    /// Full backup.
    Full,
    /// Differential backup.
    Diff,
    /// Transaction Log backup
    Tlog,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BakType::value] or
    /// [BakType::name].
    UnknownValue(bak_type::UnknownValue),
}

#[doc(hidden)]
pub mod bak_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BakType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(1),
            Self::Diff => std::option::Option::Some(2),
            Self::Tlog => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BAK_TYPE_UNSPECIFIED"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Diff => std::option::Option::Some("DIFF"),
            Self::Tlog => std::option::Option::Some("TLOG"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BakType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BakType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BakType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Full,
            2 => Self::Diff,
            3 => Self::Tlog,
            _ => Self::UnknownValue(bak_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BakType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BAK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "FULL" => Self::Full,
            "DIFF" => Self::Diff,
            "TLOG" => Self::Tlog,
            _ => Self::UnknownValue(bak_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BakType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(1),
            Self::Diff => serializer.serialize_i32(2),
            Self::Tlog => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BakType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BakType>::new(
            ".google.cloud.sql.v1.BakType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackendType {
    /// This is an unknown backend type for instance.
    Unspecified,
    /// V1 speckle instance.
    #[deprecated]
    FirstGen,
    /// V2 speckle instance.
    SecondGen,
    /// On premises instance.
    External,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackendType::value] or
    /// [SqlBackendType::name].
    UnknownValue(sql_backend_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backend_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackendType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FirstGen => std::option::Option::Some(1),
            Self::SecondGen => std::option::Option::Some(2),
            Self::External => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKEND_TYPE_UNSPECIFIED"),
            Self::FirstGen => std::option::Option::Some("FIRST_GEN"),
            Self::SecondGen => std::option::Option::Some("SECOND_GEN"),
            Self::External => std::option::Option::Some("EXTERNAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackendType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackendType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackendType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FirstGen,
            2 => Self::SecondGen,
            3 => Self::External,
            _ => Self::UnknownValue(sql_backend_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlBackendType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKEND_TYPE_UNSPECIFIED" => Self::Unspecified,
            "FIRST_GEN" => Self::FirstGen,
            "SECOND_GEN" => Self::SecondGen,
            "EXTERNAL" => Self::External,
            _ => Self::UnknownValue(sql_backend_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlBackendType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FirstGen => serializer.serialize_i32(1),
            Self::SecondGen => serializer.serialize_i32(2),
            Self::External => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackendType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackendType>::new(
            ".google.cloud.sql.v1.SqlBackendType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlIpAddressType {
    /// This is an unknown IP address type.
    Unspecified,
    /// IP address the customer is supposed to connect to. Usually this is the
    /// load balancer's IP address
    Primary,
    /// Source IP address of the connection a read replica establishes to its
    /// external primary instance. This IP address can be allowlisted by the
    /// customer in case it has a firewall that filters incoming connection to its
    /// on premises primary instance.
    Outgoing,
    /// Private IP used when using private IPs and network peering.
    Private,
    /// V1 IP of a migrated instance. We want the user to
    /// decommission this IP as soon as the migration is complete.
    /// Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
    Migrated1StGen,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlIpAddressType::value] or
    /// [SqlIpAddressType::name].
    UnknownValue(sql_ip_address_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_ip_address_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlIpAddressType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Primary => std::option::Option::Some(1),
            Self::Outgoing => std::option::Option::Some(2),
            Self::Private => std::option::Option::Some(3),
            Self::Migrated1StGen => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_IP_ADDRESS_TYPE_UNSPECIFIED"),
            Self::Primary => std::option::Option::Some("PRIMARY"),
            Self::Outgoing => std::option::Option::Some("OUTGOING"),
            Self::Private => std::option::Option::Some("PRIVATE"),
            Self::Migrated1StGen => std::option::Option::Some("MIGRATED_1ST_GEN"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlIpAddressType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlIpAddressType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlIpAddressType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Primary,
            2 => Self::Outgoing,
            3 => Self::Private,
            4 => Self::Migrated1StGen,
            _ => Self::UnknownValue(sql_ip_address_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlIpAddressType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PRIMARY" => Self::Primary,
            "OUTGOING" => Self::Outgoing,
            "PRIVATE" => Self::Private,
            "MIGRATED_1ST_GEN" => Self::Migrated1StGen,
            _ => Self::UnknownValue(sql_ip_address_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlIpAddressType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Primary => serializer.serialize_i32(1),
            Self::Outgoing => serializer.serialize_i32(2),
            Self::Private => serializer.serialize_i32(3),
            Self::Migrated1StGen => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlIpAddressType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlIpAddressType>::new(
            ".google.cloud.sql.v1.SqlIpAddressType",
        ))
    }
}

/// The database engine type and version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlDatabaseVersion {
    /// This is an unknown database version.
    Unspecified,
    /// The database version is MySQL 5.1.
    #[deprecated]
    Mysql51,
    /// The database version is MySQL 5.5.
    #[deprecated]
    Mysql55,
    /// The database version is MySQL 5.6.
    Mysql56,
    /// The database version is MySQL 5.7.
    Mysql57,
    /// The database version is SQL Server 2017 Standard.
    Sqlserver2017Standard,
    /// The database version is SQL Server 2017 Enterprise.
    Sqlserver2017Enterprise,
    /// The database version is SQL Server 2017 Express.
    Sqlserver2017Express,
    /// The database version is SQL Server 2017 Web.
    Sqlserver2017Web,
    /// The database version is PostgreSQL 9.6.
    Postgres96,
    /// The database version is PostgreSQL 10.
    Postgres10,
    /// The database version is PostgreSQL 11.
    Postgres11,
    /// The database version is PostgreSQL 12.
    Postgres12,
    /// The database version is PostgreSQL 13.
    Postgres13,
    /// The database version is PostgreSQL 14.
    Postgres14,
    /// The database version is PostgreSQL 15.
    Postgres15,
    /// The database version is PostgreSQL 16.
    Postgres16,
    /// The database version is MySQL 8.
    Mysql80,
    /// The database major version is MySQL 8.0 and the minor version is 18.
    Mysql8018,
    /// The database major version is MySQL 8.0 and the minor version is 26.
    Mysql8026,
    /// The database major version is MySQL 8.0 and the minor version is 27.
    Mysql8027,
    /// The database major version is MySQL 8.0 and the minor version is 28.
    Mysql8028,
    /// The database major version is MySQL 8.0 and the minor version is 29.
    #[deprecated]
    Mysql8029,
    /// The database major version is MySQL 8.0 and the minor version is 30.
    Mysql8030,
    /// The database major version is MySQL 8.0 and the minor version is 31.
    Mysql8031,
    /// The database major version is MySQL 8.0 and the minor version is 32.
    Mysql8032,
    /// The database major version is MySQL 8.0 and the minor version is 33.
    Mysql8033,
    /// The database major version is MySQL 8.0 and the minor version is 34.
    Mysql8034,
    /// The database major version is MySQL 8.0 and the minor version is 35.
    Mysql8035,
    /// The database major version is MySQL 8.0 and the minor version is 36.
    Mysql8036,
    /// The database major version is MySQL 8.0 and the minor version is 37.
    Mysql8037,
    /// The database major version is MySQL 8.0 and the minor version is 38.
    Mysql8038,
    /// The database major version is MySQL 8.0 and the minor version is 39.
    Mysql8039,
    /// The database major version is MySQL 8.0 and the minor version is 40.
    Mysql8040,
    /// The database version is MySQL 8.4.
    Mysql84,
    /// The database version is MySQL 8.4 and the patch version is 0.
    Mysql840,
    /// The database version is SQL Server 2019 Standard.
    Sqlserver2019Standard,
    /// The database version is SQL Server 2019 Enterprise.
    Sqlserver2019Enterprise,
    /// The database version is SQL Server 2019 Express.
    Sqlserver2019Express,
    /// The database version is SQL Server 2019 Web.
    Sqlserver2019Web,
    /// The database version is SQL Server 2022 Standard.
    Sqlserver2022Standard,
    /// The database version is SQL Server 2022 Enterprise.
    Sqlserver2022Enterprise,
    /// The database version is SQL Server 2022 Express.
    Sqlserver2022Express,
    /// The database version is SQL Server 2022 Web.
    Sqlserver2022Web,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlDatabaseVersion::value] or
    /// [SqlDatabaseVersion::name].
    UnknownValue(sql_database_version::UnknownValue),
}

#[doc(hidden)]
pub mod sql_database_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlDatabaseVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Mysql51 => std::option::Option::Some(2),
            Self::Mysql55 => std::option::Option::Some(3),
            Self::Mysql56 => std::option::Option::Some(5),
            Self::Mysql57 => std::option::Option::Some(6),
            Self::Sqlserver2017Standard => std::option::Option::Some(11),
            Self::Sqlserver2017Enterprise => std::option::Option::Some(14),
            Self::Sqlserver2017Express => std::option::Option::Some(15),
            Self::Sqlserver2017Web => std::option::Option::Some(16),
            Self::Postgres96 => std::option::Option::Some(9),
            Self::Postgres10 => std::option::Option::Some(18),
            Self::Postgres11 => std::option::Option::Some(10),
            Self::Postgres12 => std::option::Option::Some(19),
            Self::Postgres13 => std::option::Option::Some(23),
            Self::Postgres14 => std::option::Option::Some(110),
            Self::Postgres15 => std::option::Option::Some(172),
            Self::Postgres16 => std::option::Option::Some(272),
            Self::Mysql80 => std::option::Option::Some(20),
            Self::Mysql8018 => std::option::Option::Some(41),
            Self::Mysql8026 => std::option::Option::Some(85),
            Self::Mysql8027 => std::option::Option::Some(111),
            Self::Mysql8028 => std::option::Option::Some(132),
            Self::Mysql8029 => std::option::Option::Some(148),
            Self::Mysql8030 => std::option::Option::Some(174),
            Self::Mysql8031 => std::option::Option::Some(197),
            Self::Mysql8032 => std::option::Option::Some(213),
            Self::Mysql8033 => std::option::Option::Some(238),
            Self::Mysql8034 => std::option::Option::Some(239),
            Self::Mysql8035 => std::option::Option::Some(240),
            Self::Mysql8036 => std::option::Option::Some(241),
            Self::Mysql8037 => std::option::Option::Some(355),
            Self::Mysql8038 => std::option::Option::Some(356),
            Self::Mysql8039 => std::option::Option::Some(357),
            Self::Mysql8040 => std::option::Option::Some(358),
            Self::Mysql84 => std::option::Option::Some(398),
            Self::Mysql840 => std::option::Option::Some(399),
            Self::Sqlserver2019Standard => std::option::Option::Some(26),
            Self::Sqlserver2019Enterprise => std::option::Option::Some(27),
            Self::Sqlserver2019Express => std::option::Option::Some(28),
            Self::Sqlserver2019Web => std::option::Option::Some(29),
            Self::Sqlserver2022Standard => std::option::Option::Some(199),
            Self::Sqlserver2022Enterprise => std::option::Option::Some(200),
            Self::Sqlserver2022Express => std::option::Option::Some(201),
            Self::Sqlserver2022Web => std::option::Option::Some(202),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_DATABASE_VERSION_UNSPECIFIED"),
            Self::Mysql51 => std::option::Option::Some("MYSQL_5_1"),
            Self::Mysql55 => std::option::Option::Some("MYSQL_5_5"),
            Self::Mysql56 => std::option::Option::Some("MYSQL_5_6"),
            Self::Mysql57 => std::option::Option::Some("MYSQL_5_7"),
            Self::Sqlserver2017Standard => std::option::Option::Some("SQLSERVER_2017_STANDARD"),
            Self::Sqlserver2017Enterprise => std::option::Option::Some("SQLSERVER_2017_ENTERPRISE"),
            Self::Sqlserver2017Express => std::option::Option::Some("SQLSERVER_2017_EXPRESS"),
            Self::Sqlserver2017Web => std::option::Option::Some("SQLSERVER_2017_WEB"),
            Self::Postgres96 => std::option::Option::Some("POSTGRES_9_6"),
            Self::Postgres10 => std::option::Option::Some("POSTGRES_10"),
            Self::Postgres11 => std::option::Option::Some("POSTGRES_11"),
            Self::Postgres12 => std::option::Option::Some("POSTGRES_12"),
            Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
            Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
            Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
            Self::Postgres16 => std::option::Option::Some("POSTGRES_16"),
            Self::Mysql80 => std::option::Option::Some("MYSQL_8_0"),
            Self::Mysql8018 => std::option::Option::Some("MYSQL_8_0_18"),
            Self::Mysql8026 => std::option::Option::Some("MYSQL_8_0_26"),
            Self::Mysql8027 => std::option::Option::Some("MYSQL_8_0_27"),
            Self::Mysql8028 => std::option::Option::Some("MYSQL_8_0_28"),
            Self::Mysql8029 => std::option::Option::Some("MYSQL_8_0_29"),
            Self::Mysql8030 => std::option::Option::Some("MYSQL_8_0_30"),
            Self::Mysql8031 => std::option::Option::Some("MYSQL_8_0_31"),
            Self::Mysql8032 => std::option::Option::Some("MYSQL_8_0_32"),
            Self::Mysql8033 => std::option::Option::Some("MYSQL_8_0_33"),
            Self::Mysql8034 => std::option::Option::Some("MYSQL_8_0_34"),
            Self::Mysql8035 => std::option::Option::Some("MYSQL_8_0_35"),
            Self::Mysql8036 => std::option::Option::Some("MYSQL_8_0_36"),
            Self::Mysql8037 => std::option::Option::Some("MYSQL_8_0_37"),
            Self::Mysql8038 => std::option::Option::Some("MYSQL_8_0_38"),
            Self::Mysql8039 => std::option::Option::Some("MYSQL_8_0_39"),
            Self::Mysql8040 => std::option::Option::Some("MYSQL_8_0_40"),
            Self::Mysql84 => std::option::Option::Some("MYSQL_8_4"),
            Self::Mysql840 => std::option::Option::Some("MYSQL_8_4_0"),
            Self::Sqlserver2019Standard => std::option::Option::Some("SQLSERVER_2019_STANDARD"),
            Self::Sqlserver2019Enterprise => std::option::Option::Some("SQLSERVER_2019_ENTERPRISE"),
            Self::Sqlserver2019Express => std::option::Option::Some("SQLSERVER_2019_EXPRESS"),
            Self::Sqlserver2019Web => std::option::Option::Some("SQLSERVER_2019_WEB"),
            Self::Sqlserver2022Standard => std::option::Option::Some("SQLSERVER_2022_STANDARD"),
            Self::Sqlserver2022Enterprise => std::option::Option::Some("SQLSERVER_2022_ENTERPRISE"),
            Self::Sqlserver2022Express => std::option::Option::Some("SQLSERVER_2022_EXPRESS"),
            Self::Sqlserver2022Web => std::option::Option::Some("SQLSERVER_2022_WEB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlDatabaseVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlDatabaseVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlDatabaseVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::Mysql51,
            3 => Self::Mysql55,
            5 => Self::Mysql56,
            6 => Self::Mysql57,
            9 => Self::Postgres96,
            10 => Self::Postgres11,
            11 => Self::Sqlserver2017Standard,
            14 => Self::Sqlserver2017Enterprise,
            15 => Self::Sqlserver2017Express,
            16 => Self::Sqlserver2017Web,
            18 => Self::Postgres10,
            19 => Self::Postgres12,
            20 => Self::Mysql80,
            23 => Self::Postgres13,
            26 => Self::Sqlserver2019Standard,
            27 => Self::Sqlserver2019Enterprise,
            28 => Self::Sqlserver2019Express,
            29 => Self::Sqlserver2019Web,
            41 => Self::Mysql8018,
            85 => Self::Mysql8026,
            110 => Self::Postgres14,
            111 => Self::Mysql8027,
            132 => Self::Mysql8028,
            148 => Self::Mysql8029,
            172 => Self::Postgres15,
            174 => Self::Mysql8030,
            197 => Self::Mysql8031,
            199 => Self::Sqlserver2022Standard,
            200 => Self::Sqlserver2022Enterprise,
            201 => Self::Sqlserver2022Express,
            202 => Self::Sqlserver2022Web,
            213 => Self::Mysql8032,
            238 => Self::Mysql8033,
            239 => Self::Mysql8034,
            240 => Self::Mysql8035,
            241 => Self::Mysql8036,
            272 => Self::Postgres16,
            355 => Self::Mysql8037,
            356 => Self::Mysql8038,
            357 => Self::Mysql8039,
            358 => Self::Mysql8040,
            398 => Self::Mysql84,
            399 => Self::Mysql840,
            _ => Self::UnknownValue(sql_database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlDatabaseVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
            "MYSQL_5_1" => Self::Mysql51,
            "MYSQL_5_5" => Self::Mysql55,
            "MYSQL_5_6" => Self::Mysql56,
            "MYSQL_5_7" => Self::Mysql57,
            "SQLSERVER_2017_STANDARD" => Self::Sqlserver2017Standard,
            "SQLSERVER_2017_ENTERPRISE" => Self::Sqlserver2017Enterprise,
            "SQLSERVER_2017_EXPRESS" => Self::Sqlserver2017Express,
            "SQLSERVER_2017_WEB" => Self::Sqlserver2017Web,
            "POSTGRES_9_6" => Self::Postgres96,
            "POSTGRES_10" => Self::Postgres10,
            "POSTGRES_11" => Self::Postgres11,
            "POSTGRES_12" => Self::Postgres12,
            "POSTGRES_13" => Self::Postgres13,
            "POSTGRES_14" => Self::Postgres14,
            "POSTGRES_15" => Self::Postgres15,
            "POSTGRES_16" => Self::Postgres16,
            "MYSQL_8_0" => Self::Mysql80,
            "MYSQL_8_0_18" => Self::Mysql8018,
            "MYSQL_8_0_26" => Self::Mysql8026,
            "MYSQL_8_0_27" => Self::Mysql8027,
            "MYSQL_8_0_28" => Self::Mysql8028,
            "MYSQL_8_0_29" => Self::Mysql8029,
            "MYSQL_8_0_30" => Self::Mysql8030,
            "MYSQL_8_0_31" => Self::Mysql8031,
            "MYSQL_8_0_32" => Self::Mysql8032,
            "MYSQL_8_0_33" => Self::Mysql8033,
            "MYSQL_8_0_34" => Self::Mysql8034,
            "MYSQL_8_0_35" => Self::Mysql8035,
            "MYSQL_8_0_36" => Self::Mysql8036,
            "MYSQL_8_0_37" => Self::Mysql8037,
            "MYSQL_8_0_38" => Self::Mysql8038,
            "MYSQL_8_0_39" => Self::Mysql8039,
            "MYSQL_8_0_40" => Self::Mysql8040,
            "MYSQL_8_4" => Self::Mysql84,
            "MYSQL_8_4_0" => Self::Mysql840,
            "SQLSERVER_2019_STANDARD" => Self::Sqlserver2019Standard,
            "SQLSERVER_2019_ENTERPRISE" => Self::Sqlserver2019Enterprise,
            "SQLSERVER_2019_EXPRESS" => Self::Sqlserver2019Express,
            "SQLSERVER_2019_WEB" => Self::Sqlserver2019Web,
            "SQLSERVER_2022_STANDARD" => Self::Sqlserver2022Standard,
            "SQLSERVER_2022_ENTERPRISE" => Self::Sqlserver2022Enterprise,
            "SQLSERVER_2022_EXPRESS" => Self::Sqlserver2022Express,
            "SQLSERVER_2022_WEB" => Self::Sqlserver2022Web,
            _ => Self::UnknownValue(sql_database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlDatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Mysql51 => serializer.serialize_i32(2),
            Self::Mysql55 => serializer.serialize_i32(3),
            Self::Mysql56 => serializer.serialize_i32(5),
            Self::Mysql57 => serializer.serialize_i32(6),
            Self::Sqlserver2017Standard => serializer.serialize_i32(11),
            Self::Sqlserver2017Enterprise => serializer.serialize_i32(14),
            Self::Sqlserver2017Express => serializer.serialize_i32(15),
            Self::Sqlserver2017Web => serializer.serialize_i32(16),
            Self::Postgres96 => serializer.serialize_i32(9),
            Self::Postgres10 => serializer.serialize_i32(18),
            Self::Postgres11 => serializer.serialize_i32(10),
            Self::Postgres12 => serializer.serialize_i32(19),
            Self::Postgres13 => serializer.serialize_i32(23),
            Self::Postgres14 => serializer.serialize_i32(110),
            Self::Postgres15 => serializer.serialize_i32(172),
            Self::Postgres16 => serializer.serialize_i32(272),
            Self::Mysql80 => serializer.serialize_i32(20),
            Self::Mysql8018 => serializer.serialize_i32(41),
            Self::Mysql8026 => serializer.serialize_i32(85),
            Self::Mysql8027 => serializer.serialize_i32(111),
            Self::Mysql8028 => serializer.serialize_i32(132),
            Self::Mysql8029 => serializer.serialize_i32(148),
            Self::Mysql8030 => serializer.serialize_i32(174),
            Self::Mysql8031 => serializer.serialize_i32(197),
            Self::Mysql8032 => serializer.serialize_i32(213),
            Self::Mysql8033 => serializer.serialize_i32(238),
            Self::Mysql8034 => serializer.serialize_i32(239),
            Self::Mysql8035 => serializer.serialize_i32(240),
            Self::Mysql8036 => serializer.serialize_i32(241),
            Self::Mysql8037 => serializer.serialize_i32(355),
            Self::Mysql8038 => serializer.serialize_i32(356),
            Self::Mysql8039 => serializer.serialize_i32(357),
            Self::Mysql8040 => serializer.serialize_i32(358),
            Self::Mysql84 => serializer.serialize_i32(398),
            Self::Mysql840 => serializer.serialize_i32(399),
            Self::Sqlserver2019Standard => serializer.serialize_i32(26),
            Self::Sqlserver2019Enterprise => serializer.serialize_i32(27),
            Self::Sqlserver2019Express => serializer.serialize_i32(28),
            Self::Sqlserver2019Web => serializer.serialize_i32(29),
            Self::Sqlserver2022Standard => serializer.serialize_i32(199),
            Self::Sqlserver2022Enterprise => serializer.serialize_i32(200),
            Self::Sqlserver2022Express => serializer.serialize_i32(201),
            Self::Sqlserver2022Web => serializer.serialize_i32(202),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDatabaseVersion>::new(
            ".google.cloud.sql.v1.SqlDatabaseVersion",
        ))
    }
}

/// The pricing plan for this instance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlPricingPlan {
    /// This is an unknown pricing plan for this instance.
    Unspecified,
    /// The instance is billed at a monthly flat rate.
    Package,
    /// The instance is billed per usage.
    PerUse,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlPricingPlan::value] or
    /// [SqlPricingPlan::name].
    UnknownValue(sql_pricing_plan::UnknownValue),
}

#[doc(hidden)]
pub mod sql_pricing_plan {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlPricingPlan {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Package => std::option::Option::Some(1),
            Self::PerUse => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_PRICING_PLAN_UNSPECIFIED"),
            Self::Package => std::option::Option::Some("PACKAGE"),
            Self::PerUse => std::option::Option::Some("PER_USE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlPricingPlan {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlPricingPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlPricingPlan {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Package,
            2 => Self::PerUse,
            _ => Self::UnknownValue(sql_pricing_plan::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlPricingPlan {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_PRICING_PLAN_UNSPECIFIED" => Self::Unspecified,
            "PACKAGE" => Self::Package,
            "PER_USE" => Self::PerUse,
            _ => Self::UnknownValue(sql_pricing_plan::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlPricingPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Package => serializer.serialize_i32(1),
            Self::PerUse => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlPricingPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlPricingPlan>::new(
            ".google.cloud.sql.v1.SqlPricingPlan",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlReplicationType {
    /// This is an unknown replication type for a Cloud SQL instance.
    Unspecified,
    /// The synchronous replication mode for First Generation instances. It is the
    /// default value.
    Synchronous,
    /// The asynchronous replication mode for First Generation instances. It
    /// provides a slight performance gain, but if an outage occurs while this
    /// option is set to asynchronous, you can lose up to a few seconds of updates
    /// to your data.
    Asynchronous,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlReplicationType::value] or
    /// [SqlReplicationType::name].
    UnknownValue(sql_replication_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_replication_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlReplicationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Synchronous => std::option::Option::Some(1),
            Self::Asynchronous => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_REPLICATION_TYPE_UNSPECIFIED"),
            Self::Synchronous => std::option::Option::Some("SYNCHRONOUS"),
            Self::Asynchronous => std::option::Option::Some("ASYNCHRONOUS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlReplicationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlReplicationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlReplicationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Synchronous,
            2 => Self::Asynchronous,
            _ => Self::UnknownValue(sql_replication_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlReplicationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_REPLICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SYNCHRONOUS" => Self::Synchronous,
            "ASYNCHRONOUS" => Self::Asynchronous,
            _ => Self::UnknownValue(sql_replication_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlReplicationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Synchronous => serializer.serialize_i32(1),
            Self::Asynchronous => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlReplicationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlReplicationType>::new(
            ".google.cloud.sql.v1.SqlReplicationType",
        ))
    }
}

/// The type of disk that is used for a v2 instance to use.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlDataDiskType {
    /// This is an unknown data disk type.
    Unspecified,
    /// An SSD data disk.
    PdSsd,
    /// An HDD data disk.
    PdHdd,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[deprecated]
    ObsoleteLocalSsd,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlDataDiskType::value] or
    /// [SqlDataDiskType::name].
    UnknownValue(sql_data_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_data_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlDataDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PdSsd => std::option::Option::Some(1),
            Self::PdHdd => std::option::Option::Some(2),
            Self::ObsoleteLocalSsd => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
            Self::PdSsd => std::option::Option::Some("PD_SSD"),
            Self::PdHdd => std::option::Option::Some("PD_HDD"),
            Self::ObsoleteLocalSsd => std::option::Option::Some("OBSOLETE_LOCAL_SSD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlDataDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlDataDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlDataDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PdSsd,
            2 => Self::PdHdd,
            3 => Self::ObsoleteLocalSsd,
            _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlDataDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PD_SSD" => Self::PdSsd,
            "PD_HDD" => Self::PdHdd,
            "OBSOLETE_LOCAL_SSD" => Self::ObsoleteLocalSsd,
            _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlDataDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PdSsd => serializer.serialize_i32(1),
            Self::PdHdd => serializer.serialize_i32(2),
            Self::ObsoleteLocalSsd => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDataDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDataDiskType>::new(
            ".google.cloud.sql.v1.SqlDataDiskType",
        ))
    }
}

/// The availability type of the given Cloud SQL instance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlAvailabilityType {
    /// This is an unknown Availability type.
    Unspecified,
    /// Zonal available instance.
    Zonal,
    /// Regional available instance.
    Regional,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlAvailabilityType::value] or
    /// [SqlAvailabilityType::name].
    UnknownValue(sql_availability_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_availability_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlAvailabilityType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Zonal => std::option::Option::Some(1),
            Self::Regional => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_AVAILABILITY_TYPE_UNSPECIFIED"),
            Self::Zonal => std::option::Option::Some("ZONAL"),
            Self::Regional => std::option::Option::Some("REGIONAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlAvailabilityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlAvailabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlAvailabilityType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Zonal,
            2 => Self::Regional,
            _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlAvailabilityType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ZONAL" => Self::Zonal,
            "REGIONAL" => Self::Regional,
            _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlAvailabilityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Zonal => serializer.serialize_i32(1),
            Self::Regional => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlAvailabilityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlAvailabilityType>::new(
            ".google.cloud.sql.v1.SqlAvailabilityType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlUpdateTrack {
    /// This is an unknown maintenance timing preference.
    Unspecified,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 7 to 14 days
    /// after the notification is sent out. Also referred to as `Week 1` (Console)
    /// and `preview` (gcloud CLI).
    Canary,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 15 to 21 days
    /// after the notification is sent out. Also referred to as `Week 2` (Console)
    /// and `production` (gcloud CLI).
    Stable,
    /// For instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 35 to 42 days
    /// after the notification is sent out.
    Week5,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlUpdateTrack::value] or
    /// [SqlUpdateTrack::name].
    UnknownValue(sql_update_track::UnknownValue),
}

#[doc(hidden)]
pub mod sql_update_track {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlUpdateTrack {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Canary => std::option::Option::Some(1),
            Self::Stable => std::option::Option::Some(2),
            Self::Week5 => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_UPDATE_TRACK_UNSPECIFIED"),
            Self::Canary => std::option::Option::Some("canary"),
            Self::Stable => std::option::Option::Some("stable"),
            Self::Week5 => std::option::Option::Some("week5"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlUpdateTrack {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlUpdateTrack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlUpdateTrack {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Canary,
            2 => Self::Stable,
            3 => Self::Week5,
            _ => Self::UnknownValue(sql_update_track::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SqlUpdateTrack {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_UPDATE_TRACK_UNSPECIFIED" => Self::Unspecified,
            "canary" => Self::Canary,
            "stable" => Self::Stable,
            "week5" => Self::Week5,
            _ => Self::UnknownValue(sql_update_track::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SqlUpdateTrack {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Canary => serializer.serialize_i32(1),
            Self::Stable => serializer.serialize_i32(2),
            Self::Week5 => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlUpdateTrack {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlUpdateTrack>::new(
            ".google.cloud.sql.v1.SqlUpdateTrack",
        ))
    }
}
