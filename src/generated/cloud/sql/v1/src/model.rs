// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

/// Backup runs delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsDeleteRequest {

    /// The ID of the backup run to delete. To find a backup run ID, use the
    /// [list](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/backupRuns/list)
    /// method.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsDeleteRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsDeleteRequest"
    }
}

/// Backup runs get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsGetRequest {

    /// The ID of this backup run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsGetRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsGetRequest"
    }
}

/// Backup runs insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsInsertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::BackupRun>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlBackupRunsInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::BackupRun>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsInsertRequest"
    }
}

/// Backup runs list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsListRequest {

    /// Cloud SQL instance ID, or "-" for all instances. This does not include
    /// the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Maximum number of backup runs per response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_results: i32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlBackupRunsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlBackupRunsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlBackupRunsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsListRequest"
    }
}

/// A BackupRun resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRun {

    /// This is always `sql#backupRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The status of this run.
    pub status: crate::model::SqlBackupRunStatus,

    /// The time the run was enqueued in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enqueued_time: std::option::Option<wkt::Timestamp>,

    /// The identifier for this backup run. Unique only for a specific Cloud SQL
    /// instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// The time the backup operation actually started in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the backup operation completed in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Information about why the backup operation failed. This is only present if
    /// the run has the FAILED status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::OperationError>,

    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
    /// This field defaults to "ON_DEMAND" and is ignored, when specified for
    /// insert requests.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlBackupRunType,

    /// The description of this run, only applicable to on-demand backups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The start time of the backup window during which this the backup was
    /// attempted in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for
    /// example `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window_start_time: std::option::Option<wkt::Timestamp>,

    /// Name of the database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Location of the backups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Encryption configuration specific to a backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_configuration: std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Encryption status specific to a backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    pub backup_kind: crate::model::SqlBackupKind,

    /// Backup time zone to prevent restores to an instance with
    /// a different time zone. Now relevant only for SQL Server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    /// Output only. The maximum chargeable bytes for the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_chargeable_bytes: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRun::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [status][crate::model::BackupRun::status].
    pub fn set_status<T: std::convert::Into<crate::model::SqlBackupRunStatus>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [enqueued_time][crate::model::BackupRun::enqueued_time].
    pub fn set_enqueued_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.enqueued_time = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BackupRun::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackupRun::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BackupRun::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BackupRun::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<crate::model::OperationError>>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BackupRun::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlBackupRunType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupRun::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [window_start_time][crate::model::BackupRun::window_start_time].
    pub fn set_window_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.window_start_time = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::BackupRun::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::BackupRun::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [location][crate::model::BackupRun::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::BackupRun::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionConfiguration>>>(mut self, v: T) -> Self {
        self.disk_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::BackupRun::disk_encryption_status].
    pub fn set_disk_encryption_status<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionStatus>>>(mut self, v: T) -> Self {
        self.disk_encryption_status = v.into();
        self
    }

    /// Sets the value of [backup_kind][crate::model::BackupRun::backup_kind].
    pub fn set_backup_kind<T: std::convert::Into<crate::model::SqlBackupKind>>(mut self, v: T) -> Self {
        self.backup_kind = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::BackupRun::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [max_chargeable_bytes][crate::model::BackupRun::max_chargeable_bytes].
    pub fn set_max_chargeable_bytes<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.max_chargeable_bytes = v.into();
        self
    }
}

impl wkt::message::Message for BackupRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRun"
    }
}

/// Backup run list results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRunsListResponse {

    /// This is always `sql#backupRunsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// A list of backup runs in reverse chronological order of the enqueued time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::BackupRun>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRunsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRunsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::BackupRunsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::BackupRunsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupRun>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BackupRunsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRunsListResponse"
    }
}

/// Connect settings retrieval request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectSettingsRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GetConnectSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GetConnectSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GetConnectSettingsRequest::read_time].
    pub fn set_read_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.read_time = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GetConnectSettingsRequest"
    }
}

/// Connect settings retrieval response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectSettings {

    /// This is always `sql#connectSettings`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// SSL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The assigned IP addresses for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// The cloud region for the instance. For example, `us-central1`,
    /// `europe-west1`. The region cannot be changed after instance creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The database engine type and version. The `databaseVersion`
    /// field cannot be changed after instance creation.
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
    /// or `MYSQL_5_6`.
    /// PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11`, `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
    /// SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
    /// `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
    /// `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// Whether PSC connectivity is enabled for this instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub psc_enabled: bool,

    /// The dns name of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_name: std::string::String,

    /// Specify what type of CA is used for the server certificate.
    pub server_ca_mode: crate::model::connect_settings::CaMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ConnectSettings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::ConnectSettings::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ConnectSettings::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::ConnectSettings::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::ConnectSettings::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(mut self, v: T) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [psc_enabled][crate::model::ConnectSettings::psc_enabled].
    pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.psc_enabled = v.into();
        self
    }

    /// Sets the value of [dns_name][crate::model::ConnectSettings::dns_name].
    pub fn set_dns_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_name = v.into();
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::ConnectSettings::server_ca_mode].
    pub fn set_server_ca_mode<T: std::convert::Into<crate::model::connect_settings::CaMode>>(mut self, v: T) -> Self {
        self.server_ca_mode = v.into();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::ConnectSettings::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConnectSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ConnectSettings"
    }
}

/// Defines additional types related to [ConnectSettings].
pub mod connect_settings {
    #[allow(unused_imports)]
    use super::*;


    /// Various Certificate Authority (CA) modes for certificate signing.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaMode::value] or
        /// [CaMode::name].
        UnknownValue(ca_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManagedInternalCa => std::option::Option::Some(1),
                Self::GoogleManagedCasCa => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_MODE_UNSPECIFIED"),
                Self::GoogleManagedInternalCa => std::option::Option::Some("GOOGLE_MANAGED_INTERNAL_CA"),
                Self::GoogleManagedCasCa => std::option::Option::Some("GOOGLE_MANAGED_CAS_CA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManagedInternalCa,
                2 => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for CaMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_MODE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED_INTERNAL_CA" => Self::GoogleManagedInternalCa,
                "GOOGLE_MANAGED_CAS_CA" => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManagedInternalCa => serializer.serialize_i32(1),
                Self::GoogleManagedCasCa => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaMode>::new(
                ".google.cloud.sql.v1.ConnectSettings.CaMode"))
        }
    }
}

/// Ephemeral certificate creation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateEphemeralCertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// PEM encoded public key to include in the signed certificate.
    #[serde(rename = "public_key")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// Optional. Access token to include in the signed certificate.
    #[serde(rename = "access_token")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// Optional. If set, it will contain the cert valid duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub valid_duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GenerateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GenerateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateEphemeralCertRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::GenerateEphemeralCertRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GenerateEphemeralCertRequest::read_time].
    pub fn set_read_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.read_time = v.into();
        self
    }

    /// Sets the value of [valid_duration][crate::model::GenerateEphemeralCertRequest::valid_duration].
    pub fn set_valid_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.valid_duration = v.into();
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertRequest"
    }
}

/// Ephemeral certificate creation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateEphemeralCertResponse {

    /// Generated cert
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ephemeral_cert: std::option::Option<crate::model::SslCert>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateEphemeralCertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ephemeral_cert][crate::model::GenerateEphemeralCertResponse::ephemeral_cert].
    pub fn set_ephemeral_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.ephemeral_cert = v.into();
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertResponse"
    }
}

/// Database delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesDeleteRequest {

    /// Name of the database to be deleted in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesDeleteRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesDeleteRequest"
    }
}

/// Database get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesGetRequest {

    /// Name of the database in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesGetRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesGetRequest"
    }
}

/// Database insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesInsertRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::Database>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::Database>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesInsertRequest"
    }
}

/// Database list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesListRequest"
    }
}

/// Database update request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesUpdateRequest {

    /// Name of the database to be updated in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::Database>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlDatabasesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesUpdateRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::Database>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesUpdateRequest"
    }
}

/// Database list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabasesListResponse {

    /// This is always `sql#databasesList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of database resources in the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Database>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabasesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabasesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::DatabasesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabasesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabasesListResponse"
    }
}

/// Flags list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlFlagsListRequest {

    /// Database type and version you want to retrieve flags for. By default, this
    /// method returns flags for all database types and versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlFlagsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::SqlFlagsListRequest::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }
}

impl wkt::message::Message for SqlFlagsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlFlagsListRequest"
    }
}

/// Flags list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FlagsListResponse {

    /// This is always `sql#flagsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of flags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Flag>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FlagsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::FlagsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::FlagsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Flag>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FlagsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FlagsListResponse"
    }
}

/// A flag resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Flag {

    /// This is the name of the flag. Flag names always use underscores, not
    /// hyphens, for example: `max_allowed_packet`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of the flag. Flags are typed to being `BOOLEAN`, `STRING`,
    /// `INTEGER` or `NONE`. `NONE` is used for flags that do not take a
    /// value, such as `skip_grant_tables`.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlFlagType,

    /// The database version this flag applies to. Can be
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_8_0_18`, `MYSQL_8_0_26`, `MYSQL_5_7`,
    /// or `MYSQL_5_6`. PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12`. SQL Server instances:
    /// `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`,
    /// `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    /// See [the complete
    /// list](/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub applies_to: std::vec::Vec<crate::model::SqlDatabaseVersion>,

    /// For `STRING` flags, a list of strings that the value can be set to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_string_values: std::vec::Vec<std::string::String>,

    /// For `INTEGER` flags, the minimum allowed value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub min_value: std::option::Option<wkt::Int64Value>,

    /// For `INTEGER` flags, the maximum allowed value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_value: std::option::Option<wkt::Int64Value>,

    /// Indicates whether changing this flag will trigger a database restart. Only
    /// applicable to Second Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requires_restart: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#flag`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Whether or not the flag is considered in beta.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub in_beta: std::option::Option<wkt::BoolValue>,

    /// Use this field if only certain integers are accepted. Can be combined
    /// with min_value and max_value to add additional values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub allowed_int_values: std::vec::Vec<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Flag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Flag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Flag::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlFlagType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [min_value][crate::model::Flag::min_value].
    pub fn set_min_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.min_value = v.into();
        self
    }

    /// Sets the value of [max_value][crate::model::Flag::max_value].
    pub fn set_max_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.max_value = v.into();
        self
    }

    /// Sets the value of [requires_restart][crate::model::Flag::requires_restart].
    pub fn set_requires_restart<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.requires_restart = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Flag::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [in_beta][crate::model::Flag::in_beta].
    pub fn set_in_beta<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.in_beta = v.into();
        self
    }

    /// Sets the value of [applies_to][crate::model::Flag::applies_to].
    pub fn set_applies_to<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlDatabaseVersion>
    {
        use std::iter::Iterator;
        self.applies_to = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allowed_string_values][crate::model::Flag::allowed_string_values].
    pub fn set_allowed_string_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.allowed_string_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allowed_int_values][crate::model::Flag::allowed_int_values].
    pub fn set_allowed_int_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>
    {
        use std::iter::Iterator;
        self.allowed_int_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Flag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Flag"
    }
}

/// Instance add server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAddServerCaRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAddServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAddServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAddServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAddServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAddServerCaRequest"
    }
}

/// Instance clone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesCloneRequest {

    /// The ID of the Cloud SQL instance to be cloned (source). This does not
    /// include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the source as well as the clone Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesCloneRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCloneRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCloneRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCloneRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesCloneRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCloneRequest"
    }
}

/// Instance delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDeleteRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDeleteRequest"
    }
}

/// Instance demote master request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDemoteMasterRequest {

    /// Cloud SQL instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesDemoteMasterRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteMasterRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteMasterRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteMasterRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesDemoteMasterRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteMasterRequest"
    }
}

/// Instance demote request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDemoteRequest {

    /// Required. Cloud SQL instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Required. The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesDemoteRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesDemoteRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteRequest"
    }
}

/// Instance export request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesExportRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be exported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesExportRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesExportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesExportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesExportRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesExportRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesExportRequest"
    }
}

/// Instance failover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesFailoverRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesFailoverRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesFailoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesFailoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesFailoverRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesFailoverRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesFailoverRequest"
    }
}

/// Instance get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetRequest"
    }
}

/// Instance import request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesImportRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesImportRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesImportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesImportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesImportRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesImportRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesImportRequest"
    }
}

/// Instance insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesInsertRequest {

    /// Project ID of the project to which the newly created Cloud SQL instances
    /// should belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlInstancesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesInsertRequest"
    }
}

/// Instance list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesListRequest {

    /// A filter expression that filters resources listed in the response.
    /// The expression is in the form of field:value. For example,
    /// 'instanceType:CLOUD_SQL_INSTANCE'. Fields can be nested as needed as per
    /// their JSON representation, such as 'settings.userLabels.auto_start:true'.
    ///
    /// Multiple filter queries are space-separated. For example.
    /// 'state:RUNNABLE instanceType:CLOUD_SQL_INSTANCE'. By default, each
    /// expression is an AND expression. However, you can include AND and OR
    /// expressions explicitly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of instances to return. The service may return fewer
    /// than this value.
    /// If unspecified, at most 500 instances are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project for which to list Cloud SQL instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::SqlInstancesListRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlInstancesListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlInstancesListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListRequest"
    }
}

/// Instance list server CAs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesListServerCasRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesListServerCasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesListServerCasRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListServerCasRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListServerCasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListServerCasRequest"
    }
}

/// Instance patch request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPatchRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPatchRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPatchRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPatchRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPatchRequest"
    }
}

/// Instance promote replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPromoteReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Set to true to invoke a replica failover to the designated DR
    /// replica. As part of replica failover, the promote operation attempts
    /// to add the original primary instance as a replica of the promoted
    /// DR replica when the original primary instance comes back online.
    /// If set to false or not specified, then the original primary
    /// instance becomes an independent Cloud SQL primary instance.
    /// Only applicable to MySQL.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failover: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPromoteReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPromoteReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPromoteReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [failover][crate::model::SqlInstancesPromoteReplicaRequest::failover].
    pub fn set_failover<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.failover = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPromoteReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPromoteReplicaRequest"
    }
}

/// Instance switchover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesSwitchoverRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Optional. (MySQL only) Cloud SQL instance operations timeout, which is a
    /// sum of all database operations. Default value is 10 minutes and can be
    /// modified to a maximum value of 24 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub db_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesSwitchoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesSwitchoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesSwitchoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [db_timeout][crate::model::SqlInstancesSwitchoverRequest::db_timeout].
    pub fn set_db_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.db_timeout = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesSwitchoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesSwitchoverRequest"
    }
}

/// Instance reset SSL config request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesResetSslConfigRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesResetSslConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetSslConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetSslConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetSslConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetSslConfigRequest"
    }
}

/// Instance restart request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRestartRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be restarted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRestartRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestartRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestartRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRestartRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestartRequest"
    }
}

/// Instance restore backup request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRestoreBackupRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesRestoreBackupRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestoreBackupRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestoreBackupRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRestoreBackupRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesRestoreBackupRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestoreBackupRequest"
    }
}

/// Instance rotate server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRotateServerCaRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesRotateServerCaRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRotateServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRotateServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRotateServerCaRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesRotateServerCaRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRotateServerCaRequest"
    }
}

/// Instance start replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStartReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStartReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStartReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartReplicaRequest"
    }
}

/// Instance stop replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStopReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStopReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStopReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStopReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStopReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStopReplicaRequest"
    }
}

/// Instance truncate log request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesTruncateLogRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesTruncateLogRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesTruncateLogRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesTruncateLogRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesTruncateLogRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesTruncateLogRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesTruncateLogRequest"
    }
}

/// Instance perform disk shrink request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPerformDiskShrinkRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Perform disk shrink context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::PerformDiskShrinkContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesPerformDiskShrinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPerformDiskShrinkRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPerformDiskShrinkRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPerformDiskShrinkRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::PerformDiskShrinkContext>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPerformDiskShrinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPerformDiskShrinkRequest"
    }
}

/// Instance update request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesUpdateRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesUpdateRequest"
    }
}

/// Instance reschedule maintenance request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRescheduleMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRescheduleMaintenanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRescheduleMaintenanceRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRescheduleMaintenanceRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequest"
    }
}

/// Instance reencrypt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReencryptRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Reencrypt body that users request
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesReencryptRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReencryptRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReencryptRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesReencryptRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesReencryptRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReencryptRequest"
    }
}

/// Database Instance reencrypt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesReencryptRequest {

    /// Configuration specific to backup re-encryption
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_reencryption_config: std::option::Option<crate::model::BackupReencryptionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_reencryption_config][crate::model::InstancesReencryptRequest::backup_reencryption_config].
    pub fn set_backup_reencryption_config<T: std::convert::Into<std::option::Option<crate::model::BackupReencryptionConfig>>>(mut self, v: T) -> Self {
        self.backup_reencryption_config = v.into();
        self
    }
}

impl wkt::message::Message for InstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesReencryptRequest"
    }
}

/// Backup Reencryption Config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupReencryptionConfig {

    /// Backup re-encryption limit
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_limit: std::option::Option<i32>,

    /// Type of backups users want to re-encrypt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_type: std::option::Option<crate::model::backup_reencryption_config::BackupType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupReencryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_limit][crate::model::BackupReencryptionConfig::backup_limit].
    pub fn set_backup_limit<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.backup_limit = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::BackupReencryptionConfig::backup_type].
    pub fn set_backup_type<T: std::convert::Into<std::option::Option<crate::model::backup_reencryption_config::BackupType>>>(mut self, v: T) -> Self {
        self.backup_type = v.into();
        self
    }
}

impl wkt::message::Message for BackupReencryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupReencryptionConfig"
    }
}

/// Defines additional types related to [BackupReencryptionConfig].
pub mod backup_reencryption_config {
    #[allow(unused_imports)]
    use super::*;


    /// Backup type for re-encryption
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// Unknown backup type, will be defaulted to AUTOMATIC backup type
        Unspecified,
        /// Reencrypt automatic backups
        Automated,
        /// Reencrypt on-demand backups
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automated => std::option::Option::Some(1),
                Self::OnDemand => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automated,
                2 => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATED" => Self::Automated,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(backup_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automated => serializer.serialize_i32(1),
                Self::OnDemand => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.sql.v1.BackupReencryptionConfig.BackupType"))
        }
    }
}

/// Instance get disk shrink config request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetDiskShrinkConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetDiskShrinkConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetDiskShrinkConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigRequest"
    }
}

/// Instance verify external sync settings request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Flag to enable verifying connection only
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub verify_connection_only: bool,

    /// External sync mode
    pub sync_mode: crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Optional. Flag to verify settings required by replication setup only
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub verify_replication_only: bool,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type: crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    /// Optional. Parallel level for initial data sync. Only applicable for
    /// PostgreSQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesVerifyExternalSyncSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [verify_connection_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_connection_only].
    pub fn set_verify_connection_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_connection_only = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_mode].
    pub fn set_sync_mode<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>(mut self, v: T) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [verify_replication_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_replication_only].
    pub fn set_verify_replication_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_replication_only = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::migration_type].
    pub fn set_migration_type<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>(mut self, v: T) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<T: std::convert::Into<crate::model::ExternalSyncParallelLevel>>(mut self, v: T) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config].
    ///
    /// Note that all the setters affecting `sync_config` are mutually
    /// exclusive.
    pub fn set_sync_config<T: std::convert::Into<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig>>>(mut self, v: T) -> Self
    {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_sync_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>>(mut self, v: T) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest"
    }
}

/// Defines additional types related to [SqlInstancesVerifyExternalSyncSettingsRequest].
pub mod sql_instances_verify_external_sync_settings_request {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExternalSyncMode {
        /// Unknown external sync mode, will be defaulted to ONLINE mode
        Unspecified,
        /// Online external sync will set up replication after initial data external
        /// sync
        Online,
        /// Offline external sync only dumps and loads a one-time snapshot of
        /// the primary instance's data
        Offline,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExternalSyncMode::value] or
        /// [ExternalSyncMode::name].
        UnknownValue(external_sync_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod external_sync_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExternalSyncMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Online => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXTERNAL_SYNC_MODE_UNSPECIFIED"),
                Self::Online => std::option::Option::Some("ONLINE"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExternalSyncMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExternalSyncMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExternalSyncMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Online,
                2 => Self::Offline,
                _ => Self::UnknownValue(external_sync_mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ExternalSyncMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXTERNAL_SYNC_MODE_UNSPECIFIED" => Self::Unspecified,
                "ONLINE" => Self::Online,
                "OFFLINE" => Self::Offline,
                _ => Self::UnknownValue(external_sync_mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ExternalSyncMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Online => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExternalSyncMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExternalSyncMode>::new(
                ".google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest.ExternalSyncMode"))
        }
    }

    /// MigrationType determines whether the migration is a physical file-based
    /// migration or a logical dump file-based migration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationType {
        /// Default value is a logical dump file-based migration
        Unspecified,
        /// Logical dump file-based migration
        Logical,
        /// Physical file-based migration
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MigrationType::value] or
        /// [MigrationType::name].
        UnknownValue(migration_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod migration_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MigrationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Logical => std::option::Option::Some(1),
                Self::Physical => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIGRATION_TYPE_UNSPECIFIED"),
                Self::Logical => std::option::Option::Some("LOGICAL"),
                Self::Physical => std::option::Option::Some("PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MigrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MigrationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MigrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Logical,
                2 => Self::Physical,
                _ => Self::UnknownValue(migration_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for MigrationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LOGICAL" => Self::Logical,
                "PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(migration_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for MigrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Logical => serializer.serialize_i32(1),
                Self::Physical => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationType>::new(
                ".google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest.MigrationType"))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// Optional. MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance start external sync request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStartExternalSyncRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// External sync mode.
    pub sync_mode: crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Whether to skip the verification step (VESS).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_verification: bool,

    /// Optional. Parallel level for initial data sync. Currently only applicable
    /// for MySQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type: crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::sql_instances_start_external_sync_request::SyncConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesStartExternalSyncRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartExternalSyncRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartExternalSyncRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesStartExternalSyncRequest::sync_mode].
    pub fn set_sync_mode<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>(mut self, v: T) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [skip_verification][crate::model::SqlInstancesStartExternalSyncRequest::skip_verification].
    pub fn set_skip_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_verification = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesStartExternalSyncRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<T: std::convert::Into<crate::model::ExternalSyncParallelLevel>>(mut self, v: T) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesStartExternalSyncRequest::migration_type].
    pub fn set_migration_type<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>(mut self, v: T) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config].
    ///
    /// Note that all the setters affecting `sync_config` are mutually
    /// exclusive.
    pub fn set_sync_config<T: std::convert::Into<std::option::Option<crate::model::sql_instances_start_external_sync_request::SyncConfig>>>(mut self, v: T) -> Self
    {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql_sync_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>>(mut self, v: T) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesStartExternalSyncRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartExternalSyncRequest"
    }
}

/// Defines additional types related to [SqlInstancesStartExternalSyncRequest].
pub mod sql_instances_start_external_sync_request {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance reset replica size request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesResetReplicaSizeRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesResetReplicaSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetReplicaSizeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetReplicaSizeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetReplicaSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetReplicaSizeRequest"
    }
}

/// Instance create ephemeral certificate request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesCreateEphemeralCertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SslCertsCreateEphemeralRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesCreateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCreateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCreateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCreateEphemeralCertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SslCertsCreateEphemeralRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesCreateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCreateEphemeralCertRequest"
    }
}

/// Database instance clone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesCloneRequest {

    /// Contains details about the clone operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clone_context: std::option::Option<crate::model::CloneContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_context][crate::model::InstancesCloneRequest::clone_context].
    pub fn set_clone_context<T: std::convert::Into<std::option::Option<crate::model::CloneContext>>>(mut self, v: T) -> Self {
        self.clone_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesCloneRequest"
    }
}

/// Database demote primary instance request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesDemoteMasterRequest {

    /// Contains details about the demoteMaster operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub demote_master_context: std::option::Option<crate::model::DemoteMasterContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_master_context][crate::model::InstancesDemoteMasterRequest::demote_master_context].
    pub fn set_demote_master_context<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterContext>>>(mut self, v: T) -> Self {
        self.demote_master_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteMasterRequest"
    }
}

/// This request is used to demote an existing standalone instance to be a
/// Cloud SQL read replica for an external database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesDemoteRequest {

    /// Required. Contains details about the demote operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub demote_context: std::option::Option<crate::model::DemoteContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_context][crate::model::InstancesDemoteRequest::demote_context].
    pub fn set_demote_context<T: std::convert::Into<std::option::Option<crate::model::DemoteContext>>>(mut self, v: T) -> Self {
        self.demote_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteRequest"
    }
}

/// Database instance export request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesExportRequest {

    /// Contains details about the export operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_context: std::option::Option<crate::model::ExportContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_context][crate::model::InstancesExportRequest::export_context].
    pub fn set_export_context<T: std::convert::Into<std::option::Option<crate::model::ExportContext>>>(mut self, v: T) -> Self {
        self.export_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesExportRequest"
    }
}

/// Instance failover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesFailoverRequest {

    /// Failover Context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_context: std::option::Option<crate::model::FailoverContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [failover_context][crate::model::InstancesFailoverRequest::failover_context].
    pub fn set_failover_context<T: std::convert::Into<std::option::Option<crate::model::FailoverContext>>>(mut self, v: T) -> Self {
        self.failover_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesFailoverRequest"
    }
}

/// SslCerts create ephemeral certificate request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsCreateEphemeralRequest {

    /// PEM encoded public key to include in the signed certificate.
    #[serde(rename = "public_key")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// Access token to include in the signed certificate.
    #[serde(rename = "access_token")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsCreateEphemeralRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_key][crate::model::SslCertsCreateEphemeralRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::SslCertsCreateEphemeralRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsCreateEphemeralRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsCreateEphemeralRequest"
    }
}

/// Database instance import request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesImportRequest {

    /// Contains details about the import operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_context: std::option::Option<crate::model::ImportContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_context][crate::model::InstancesImportRequest::import_context].
    pub fn set_import_context<T: std::convert::Into<std::option::Option<crate::model::ImportContext>>>(mut self, v: T) -> Self {
        self.import_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesImportRequest"
    }
}

/// Database instances list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesListResponse {

    /// This is always `sql#instancesList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of warnings that occurred while handling the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<crate::model::ApiWarning>,

    /// List of database instance resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::DatabaseInstance>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::InstancesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstancesListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::InstancesListResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ApiWarning>
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::InstancesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseInstance>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstancesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListResponse"
    }
}

/// Instances ListServerCas response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesListServerCasResponse {

    /// List of server CA certificates for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certs: std::vec::Vec<crate::model::SslCert>,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_version: std::string::String,

    /// This is always `sql#instancesListServerCas`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesListServerCasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [active_version][crate::model::InstancesListServerCasResponse::active_version].
    pub fn set_active_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.active_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::InstancesListServerCasResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [certs][crate::model::InstancesListServerCasResponse::certs].
    pub fn set_certs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>
    {
        use std::iter::Iterator;
        self.certs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstancesListServerCasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListServerCasResponse"
    }
}

/// Database instance restore backup request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesRestoreBackupRequest {

    /// Parameters required to perform the restore backup operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_backup_context: std::option::Option<crate::model::RestoreBackupContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_backup_context][crate::model::InstancesRestoreBackupRequest::restore_backup_context].
    pub fn set_restore_backup_context<T: std::convert::Into<std::option::Option<crate::model::RestoreBackupContext>>>(mut self, v: T) -> Self {
        self.restore_backup_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRestoreBackupRequest"
    }
}

/// Rotate server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesRotateServerCaRequest {

    /// Contains details about the rotate server CA operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rotate_server_ca_context: std::option::Option<crate::model::RotateServerCaContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rotate_server_ca_context][crate::model::InstancesRotateServerCaRequest::rotate_server_ca_context].
    pub fn set_rotate_server_ca_context<T: std::convert::Into<std::option::Option<crate::model::RotateServerCaContext>>>(mut self, v: T) -> Self {
        self.rotate_server_ca_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRotateServerCaRequest"
    }
}

/// Instance truncate log request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesTruncateLogRequest {

    /// Contains details about the truncate log operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub truncate_log_context: std::option::Option<crate::model::TruncateLogContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [truncate_log_context][crate::model::InstancesTruncateLogRequest::truncate_log_context].
    pub fn set_truncate_log_context<T: std::convert::Into<std::option::Option<crate::model::TruncateLogContext>>>(mut self, v: T) -> Self {
        self.truncate_log_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesTruncateLogRequest"
    }
}

/// Request to acquire a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesAcquireSsrsLeaseRequest {

    /// Contains details about the acquire SSRS lease operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::InstancesAcquireSsrsLeaseRequest::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T: std::convert::Into<std::option::Option<crate::model::AcquireSsrsLeaseContext>>>(mut self, v: T) -> Self {
        self.acquire_ssrs_lease_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesAcquireSsrsLeaseRequest"
    }
}

/// Instance verify external sync settings response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsResponse {

    /// This is always `sql#migrationSettingErrorList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of migration violations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,

    /// List of migration warnings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesVerifyExternalSyncSettingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsResponse"
    }
}

/// Instance get disk shrink config response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigResponse {

    /// This is always `sql#getDiskShrinkConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The minimum size to which a disk can be shrunk in GigaBytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub minimal_target_size_gb: i64,

    /// Additional message to customers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetDiskShrinkConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetDiskShrinkConfigResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [minimal_target_size_gb][crate::model::SqlInstancesGetDiskShrinkConfigResponse::minimal_target_size_gb].
    pub fn set_minimal_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.minimal_target_size_gb = v.into();
        self
    }

    /// Sets the value of [message][crate::model::SqlInstancesGetDiskShrinkConfigResponse::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigResponse"
    }
}

/// Instance get latest recovery time request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetLatestRecoveryTimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeRequest"
    }
}

/// Instance get latest recovery time response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeResponse {

    /// This is always `sql#getLatestRecoveryTime`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Timestamp, identifies the latest recovery time of the source instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_recovery_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesGetLatestRecoveryTimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [latest_recovery_time][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::latest_recovery_time].
    pub fn set_latest_recovery_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.latest_recovery_time = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeResponse"
    }
}

/// Database instance clone context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloneContext {

    /// This is always `sql#cloneContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pitr_timestamp_ms: i64,

    /// Name of the Cloud SQL instance to be created as a clone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_instance_name: std::string::String,

    /// Binary log coordinates, if specified, identify the position up to which the
    /// source instance is cloned. If not specified, the source instance is
    /// cloned up to the most recent binary log coordinates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bin_log_coordinates: std::option::Option<crate::model::BinLogCoordinates>,

    /// Timestamp, if specified, identifies the time to which the source instance
    /// is cloned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub point_in_time: std::option::Option<wkt::Timestamp>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the cloned instance
    /// ip will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Reserved for future use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// (SQL Server only) Clone only the specified databases from the source
    /// instance. Clone all databases if empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_names: std::vec::Vec<std::string::String>,

    /// Optional. Copy clone and point-in-time recovery clone of an instance to the
    /// specified zone. If no zone is specified, clone to the same primary zone as
    /// the source instance. This field applies to all DB types.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preferred_zone: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::CloneContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [pitr_timestamp_ms][crate::model::CloneContext::pitr_timestamp_ms].
    pub fn set_pitr_timestamp_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pitr_timestamp_ms = v.into();
        self
    }

    /// Sets the value of [destination_instance_name][crate::model::CloneContext::destination_instance_name].
    pub fn set_destination_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_instance_name = v.into();
        self
    }

    /// Sets the value of [bin_log_coordinates][crate::model::CloneContext::bin_log_coordinates].
    pub fn set_bin_log_coordinates<T: std::convert::Into<std::option::Option<crate::model::BinLogCoordinates>>>(mut self, v: T) -> Self {
        self.bin_log_coordinates = v.into();
        self
    }

    /// Sets the value of [point_in_time][crate::model::CloneContext::point_in_time].
    pub fn set_point_in_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.point_in_time = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::CloneContext::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [preferred_zone][crate::model::CloneContext::preferred_zone].
    pub fn set_preferred_zone<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.preferred_zone = v.into();
        self
    }

    /// Sets the value of [database_names][crate::model::CloneContext::database_names].
    pub fn set_database_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.database_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloneContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.CloneContext"
    }
}

/// Binary log coordinates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BinLogCoordinates {

    /// Name of the binary log file for a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bin_log_file_name: std::string::String,

    /// Position (offset) within the binary log file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub bin_log_position: i64,

    /// This is always `sql#binLogCoordinates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinLogCoordinates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bin_log_file_name][crate::model::BinLogCoordinates::bin_log_file_name].
    pub fn set_bin_log_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bin_log_file_name = v.into();
        self
    }

    /// Sets the value of [bin_log_position][crate::model::BinLogCoordinates::bin_log_position].
    pub fn set_bin_log_position<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bin_log_position = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BinLogCoordinates::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BinLogCoordinates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BinLogCoordinates"
    }
}

/// A Cloud SQL instance resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseInstance {

    /// This is always `sql#instance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The current serving state of the Cloud SQL instance.
    pub state: crate::model::database_instance::SqlInstanceState,

    /// The database engine type and version. The `databaseVersion` field cannot
    /// be changed after instance creation.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// The user settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::Settings>,

    /// This field is deprecated and will be removed from a future version of the
    /// API. Use the `settings.settingsVersion` field instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name and status of the failover replica.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_replica: std::option::Option<crate::model::database_instance::SqlFailoverReplica>,

    /// The name of the instance which will act as primary in the replication
    /// setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_instance_name: std::string::String,

    /// The replicas of the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replica_names: std::vec::Vec<std::string::String>,

    /// The maximum disk size of the instance in bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    #[deprecated]
    pub max_disk_size: std::option::Option<wkt::Int64Value>,

    /// The current disk usage of the instance in bytes. This property has been
    /// deprecated. Use the
    /// "cloudsql.googleapis.com/database/disk/bytes_used" metric in Cloud
    /// Monitoring API instead. Please see [this
    /// announcement](https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ)
    /// for details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    #[deprecated]
    pub current_disk_size: std::option::Option<wkt::Int64Value>,

    /// The assigned IP addresses for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// SSL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The instance type.
    pub instance_type: crate::model::SqlInstanceType,

    /// The project ID of the project containing the Cloud SQL instance. The Google
    /// apps domain is prefixed if applicable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The IPv6 address assigned to the instance.
    /// (Deprecated) This property was applicable only
    /// to First Generation instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub ipv6_address: std::string::String,

    /// The service account email address assigned to the instance.\This
    /// property is read-only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email_address: std::string::String,

    /// Configuration specific to on-premises instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub on_premises_configuration: std::option::Option<crate::model::OnPremisesConfiguration>,

    /// Configuration specific to failover replicas and read replicas.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_configuration: std::option::Option<crate::model::ReplicaConfiguration>,

    /// The backend type.
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    ///
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// If the instance state is SUSPENDED, the reason for the suspension.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suspension_reason: std::vec::Vec<crate::model::SqlSuspensionReason>,

    /// Connection name of the Cloud SQL instance used in connection strings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Name of the Cloud SQL instance. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The geographical region of the Cloud SQL instance.
    ///
    /// It can be one of the
    /// [regions](https://cloud.google.com/sql/docs/mysql/locations#location-r)
    /// where Cloud SQL operates:
    ///
    /// For example,  `asia-east1`, `europe-west1`, and  `us-central1`.
    /// The default value is `us-central1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The Compute Engine zone that the instance is currently serving from. This
    /// value could be different from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary zone. WARNING:
    /// Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gce_zone: std::string::String,

    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional instance. This value could be different
    /// from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary/failover zone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_gce_zone: std::string::String,

    /// Disk encryption configuration specific to an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_configuration: std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Disk encryption status specific to an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Initial root password. Use only on creation. You must set root passwords
    /// before you can connect to PostgreSQL instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_password: std::string::String,

    /// The start time of any upcoming scheduled maintenance for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_maintenance: std::option::Option<crate::model::database_instance::SqlScheduledMaintenance>,

    /// This status indicates whether the instance satisfies PZS.
    ///
    /// The status is reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Stores the current database version running on the instance
    /// including minor version such as `MYSQL_8_0_18`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_installed_version: std::string::String,

    /// This field represents the report generated by the proactive database
    /// wellness job for OutOfDisk issues.
    ///
    /// * Writers:
    /// * the proactive database wellness job for OOD.
    /// * Readers:
    /// * the proactive database wellness job
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub out_of_disk_report: std::option::Option<crate::model::database_instance::SqlOutOfDiskReport>,

    /// Output only. The time when the instance was created in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. List all maintenance versions applicable on the instance
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub available_maintenance_versions: std::vec::Vec<std::string::String>,

    /// The current software version on the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub maintenance_version: std::string::String,

    /// Output only. All database versions that are available for upgrade.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub upgradable_database_versions: std::vec::Vec<crate::model::AvailableDatabaseVersion>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_network_architecture: std::option::Option<crate::model::database_instance::SqlNetworkArchitecture>,

    /// Output only. The link to service attachment of PSC instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_service_attachment_link: std::option::Option<std::string::String>,

    /// Output only. The dns name of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_name: std::option::Option<std::string::String>,

    /// Output only. DEPRECATED: please use write_endpoint instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub primary_dns_name: std::option::Option<std::string::String>,

    /// Output only. The dns name of the primary instance in a replication group.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_endpoint: std::option::Option<std::string::String>,

    /// Optional. A primary instance and disaster recovery (DR) replica pair.
    /// A DR replica is a cross-region replica that you designate
    /// for failover in the event that the primary instance
    /// experiences regional failure. Only applicable to MySQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_cluster: std::option::Option<crate::model::ReplicationCluster>,

    /// Gemini instance configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gemini_config: std::option::Option<crate::model::GeminiInstanceConfig>,

    /// Output only. This status indicates whether the instance satisfies PZI.
    ///
    /// The status is reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<wkt::BoolValue>,

    /// Input only. Whether Cloud SQL is enabled to switch storing point-in-time
    /// recovery log files from a data disk to Cloud Storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub switch_transaction_logs_to_cloud_storage_enabled: std::option::Option<wkt::BoolValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabaseInstance::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatabaseInstance::state].
    pub fn set_state<T: std::convert::Into<crate::model::database_instance::SqlInstanceState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::DatabaseInstance::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::DatabaseInstance::settings].
    pub fn set_settings<T: std::convert::Into<std::option::Option<crate::model::Settings>>>(mut self, v: T) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatabaseInstance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [failover_replica][crate::model::DatabaseInstance::failover_replica].
    pub fn set_failover_replica<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlFailoverReplica>>>(mut self, v: T) -> Self {
        self.failover_replica = v.into();
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DatabaseInstance::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [max_disk_size][crate::model::DatabaseInstance::max_disk_size].
    #[deprecated]
    pub fn set_max_disk_size<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.max_disk_size = v.into();
        self
    }

    /// Sets the value of [current_disk_size][crate::model::DatabaseInstance::current_disk_size].
    #[deprecated]
    pub fn set_current_disk_size<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.current_disk_size = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::DatabaseInstance::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::DatabaseInstance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::SqlInstanceType>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [project][crate::model::DatabaseInstance::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [ipv6_address][crate::model::DatabaseInstance::ipv6_address].
    #[deprecated]
    pub fn set_ipv6_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ipv6_address = v.into();
        self
    }

    /// Sets the value of [service_account_email_address][crate::model::DatabaseInstance::service_account_email_address].
    pub fn set_service_account_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account_email_address = v.into();
        self
    }

    /// Sets the value of [on_premises_configuration][crate::model::DatabaseInstance::on_premises_configuration].
    pub fn set_on_premises_configuration<T: std::convert::Into<std::option::Option<crate::model::OnPremisesConfiguration>>>(mut self, v: T) -> Self {
        self.on_premises_configuration = v.into();
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DatabaseInstance::replica_configuration].
    pub fn set_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::ReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.replica_configuration = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::DatabaseInstance::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(mut self, v: T) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::DatabaseInstance::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [connection_name][crate::model::DatabaseInstance::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DatabaseInstance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DatabaseInstance::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::DatabaseInstance::gce_zone].
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [secondary_gce_zone][crate::model::DatabaseInstance::secondary_gce_zone].
    pub fn set_secondary_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_gce_zone = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::DatabaseInstance::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionConfiguration>>>(mut self, v: T) -> Self {
        self.disk_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::DatabaseInstance::disk_encryption_status].
    pub fn set_disk_encryption_status<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionStatus>>>(mut self, v: T) -> Self {
        self.disk_encryption_status = v.into();
        self
    }

    /// Sets the value of [root_password][crate::model::DatabaseInstance::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [scheduled_maintenance][crate::model::DatabaseInstance::scheduled_maintenance].
    pub fn set_scheduled_maintenance<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlScheduledMaintenance>>>(mut self, v: T) -> Self {
        self.scheduled_maintenance = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DatabaseInstance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [database_installed_version][crate::model::DatabaseInstance::database_installed_version].
    pub fn set_database_installed_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_installed_version = v.into();
        self
    }

    /// Sets the value of [out_of_disk_report][crate::model::DatabaseInstance::out_of_disk_report].
    pub fn set_out_of_disk_report<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlOutOfDiskReport>>>(mut self, v: T) -> Self {
        self.out_of_disk_report = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DatabaseInstance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [maintenance_version][crate::model::DatabaseInstance::maintenance_version].
    pub fn set_maintenance_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintenance_version = v.into();
        self
    }

    /// Sets the value of [sql_network_architecture][crate::model::DatabaseInstance::sql_network_architecture].
    pub fn set_sql_network_architecture<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlNetworkArchitecture>>>(mut self, v: T) -> Self {
        self.sql_network_architecture = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_link][crate::model::DatabaseInstance::psc_service_attachment_link].
    pub fn set_psc_service_attachment_link<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.psc_service_attachment_link = v.into();
        self
    }

    /// Sets the value of [dns_name][crate::model::DatabaseInstance::dns_name].
    pub fn set_dns_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.dns_name = v.into();
        self
    }

    /// Sets the value of [primary_dns_name][crate::model::DatabaseInstance::primary_dns_name].
    #[deprecated]
    pub fn set_primary_dns_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.primary_dns_name = v.into();
        self
    }

    /// Sets the value of [write_endpoint][crate::model::DatabaseInstance::write_endpoint].
    pub fn set_write_endpoint<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.write_endpoint = v.into();
        self
    }

    /// Sets the value of [replication_cluster][crate::model::DatabaseInstance::replication_cluster].
    pub fn set_replication_cluster<T: std::convert::Into<std::option::Option<crate::model::ReplicationCluster>>>(mut self, v: T) -> Self {
        self.replication_cluster = v.into();
        self
    }

    /// Sets the value of [gemini_config][crate::model::DatabaseInstance::gemini_config].
    pub fn set_gemini_config<T: std::convert::Into<std::option::Option<crate::model::GeminiInstanceConfig>>>(mut self, v: T) -> Self {
        self.gemini_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DatabaseInstance::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [switch_transaction_logs_to_cloud_storage_enabled][crate::model::DatabaseInstance::switch_transaction_logs_to_cloud_storage_enabled].
    pub fn set_switch_transaction_logs_to_cloud_storage_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.switch_transaction_logs_to_cloud_storage_enabled = v.into();
        self
    }

    /// Sets the value of [replica_names][crate::model::DatabaseInstance::replica_names].
    pub fn set_replica_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.replica_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::DatabaseInstance::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suspension_reason][crate::model::DatabaseInstance::suspension_reason].
    pub fn set_suspension_reason<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlSuspensionReason>
    {
        use std::iter::Iterator;
        self.suspension_reason = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_maintenance_versions][crate::model::DatabaseInstance::available_maintenance_versions].
    pub fn set_available_maintenance_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.available_maintenance_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upgradable_database_versions][crate::model::DatabaseInstance::upgradable_database_versions].
    pub fn set_upgradable_database_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AvailableDatabaseVersion>
    {
        use std::iter::Iterator;
        self.upgradable_database_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance"
    }
}

/// Defines additional types related to [DatabaseInstance].
pub mod database_instance {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlFailoverReplica {

        /// The name of the failover replica. If specified at instance creation, a
        /// failover replica is created for the instance. The name
        /// doesn't include the project ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The availability status of the failover replica. A false status indicates
        /// that the failover replica is out of sync. The primary instance can only
        /// failover to the failover replica when the status is true.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub available: std::option::Option<wkt::BoolValue>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlFailoverReplica {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::database_instance::SqlFailoverReplica::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [available][crate::model::database_instance::SqlFailoverReplica::available].
        pub fn set_available<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.available = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlFailoverReplica {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlFailoverReplica"
        }
    }

    /// Any scheduled maintenance for this instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlScheduledMaintenance {

        /// The start time of any upcoming scheduled maintenance for this instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[deprecated]
        pub can_defer: bool,

        /// If the scheduled maintenance can be rescheduled.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub can_reschedule: bool,

        /// Maintenance cannot be rescheduled to start beyond this deadline.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_deadline_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlScheduledMaintenance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::database_instance::SqlScheduledMaintenance::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [can_defer][crate::model::database_instance::SqlScheduledMaintenance::can_defer].
        #[deprecated]
        pub fn set_can_defer<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_defer = v.into();
            self
        }

        /// Sets the value of [can_reschedule][crate::model::database_instance::SqlScheduledMaintenance::can_reschedule].
        pub fn set_can_reschedule<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_reschedule = v.into();
            self
        }

        /// Sets the value of [schedule_deadline_time][crate::model::database_instance::SqlScheduledMaintenance::schedule_deadline_time].
        pub fn set_schedule_deadline_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.schedule_deadline_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlScheduledMaintenance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlScheduledMaintenance"
        }
    }

    /// This message wraps up the information written by out-of-disk detection job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlOutOfDiskReport {

        /// This field represents the state generated by the proactive database
        /// wellness job for OutOfDisk issues.
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        /// * the proactive database wellness job
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sql_out_of_disk_state: std::option::Option<crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState>,

        /// The minimum recommended increase size in GigaBytes
        /// This field is consumed by the frontend
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sql_min_recommended_increase_size_gb: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlOutOfDiskReport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_out_of_disk_state][crate::model::database_instance::SqlOutOfDiskReport::sql_out_of_disk_state].
        pub fn set_sql_out_of_disk_state<T: std::convert::Into<std::option::Option<crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState>>>(mut self, v: T) -> Self {
            self.sql_out_of_disk_state = v.into();
            self
        }

        /// Sets the value of [sql_min_recommended_increase_size_gb][crate::model::database_instance::SqlOutOfDiskReport::sql_min_recommended_increase_size_gb].
        pub fn set_sql_min_recommended_increase_size_gb<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
            self.sql_min_recommended_increase_size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlOutOfDiskReport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlOutOfDiskReport"
        }
    }

    /// Defines additional types related to [SqlOutOfDiskReport].
    pub mod sql_out_of_disk_report {
        #[allow(unused_imports)]
        use super::*;


        /// This enum lists all possible states regarding out-of-disk issues.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SqlOutOfDiskState {
            /// Unspecified state
            Unspecified,
            /// The instance has plenty space on data disk
            Normal,
            /// Data disk is almost used up. It is shutdown to prevent data
            /// corruption.
            SoftShutdown,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SqlOutOfDiskState::value] or
            /// [SqlOutOfDiskState::name].
            UnknownValue(sql_out_of_disk_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sql_out_of_disk_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SqlOutOfDiskState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Normal => std::option::Option::Some(1),
                    Self::SoftShutdown => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SQL_OUT_OF_DISK_STATE_UNSPECIFIED"),
                    Self::Normal => std::option::Option::Some("NORMAL"),
                    Self::SoftShutdown => std::option::Option::Some("SOFT_SHUTDOWN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SqlOutOfDiskState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SqlOutOfDiskState {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SqlOutOfDiskState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Normal,
                    2 => Self::SoftShutdown,
                    _ => Self::UnknownValue(sql_out_of_disk_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for SqlOutOfDiskState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" => Self::Unspecified,
                    "NORMAL" => Self::Normal,
                    "SOFT_SHUTDOWN" => Self::SoftShutdown,
                    _ => Self::UnknownValue(sql_out_of_disk_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for SqlOutOfDiskState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Normal => serializer.serialize_i32(1),
                    Self::SoftShutdown => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SqlOutOfDiskState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOutOfDiskState>::new(
                    ".google.cloud.sql.v1.DatabaseInstance.SqlOutOfDiskReport.SqlOutOfDiskState"))
            }
        }
    }

    /// The current serving state of the database instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlInstanceState {
        /// The state of the instance is unknown.
        Unspecified,
        /// The instance is running, or has been stopped by owner.
        Runnable,
        /// The instance is not available, for example due to problems with billing.
        Suspended,
        /// The instance is being deleted.
        PendingDelete,
        /// The instance is being created.
        PendingCreate,
        /// The instance is down for maintenance.
        Maintenance,
        /// The creation of the instance failed or a fatal error occurred during
        /// maintenance.
        Failed,
        /// Deprecated
        #[deprecated]
        OnlineMaintenance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlInstanceState::value] or
        /// [SqlInstanceState::name].
        UnknownValue(sql_instance_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlInstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Runnable => std::option::Option::Some(1),
                Self::Suspended => std::option::Option::Some(2),
                Self::PendingDelete => std::option::Option::Some(3),
                Self::PendingCreate => std::option::Option::Some(4),
                Self::Maintenance => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::OnlineMaintenance => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_INSTANCE_STATE_UNSPECIFIED"),
                Self::Runnable => std::option::Option::Some("RUNNABLE"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::PendingDelete => std::option::Option::Some("PENDING_DELETE"),
                Self::PendingCreate => std::option::Option::Some("PENDING_CREATE"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::OnlineMaintenance => std::option::Option::Some("ONLINE_MAINTENANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlInstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlInstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlInstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Runnable,
                2 => Self::Suspended,
                3 => Self::PendingDelete,
                4 => Self::PendingCreate,
                5 => Self::Maintenance,
                6 => Self::Failed,
                7 => Self::OnlineMaintenance,
                _ => Self::UnknownValue(sql_instance_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlInstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_INSTANCE_STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNABLE" => Self::Runnable,
                "SUSPENDED" => Self::Suspended,
                "PENDING_DELETE" => Self::PendingDelete,
                "PENDING_CREATE" => Self::PendingCreate,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "ONLINE_MAINTENANCE" => Self::OnlineMaintenance,
                _ => Self::UnknownValue(sql_instance_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlInstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Runnable => serializer.serialize_i32(1),
                Self::Suspended => serializer.serialize_i32(2),
                Self::PendingDelete => serializer.serialize_i32(3),
                Self::PendingCreate => serializer.serialize_i32(4),
                Self::Maintenance => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::OnlineMaintenance => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlInstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlInstanceState>::new(
                ".google.cloud.sql.v1.DatabaseInstance.SqlInstanceState"))
        }
    }

    /// The SQL network architecture for the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlNetworkArchitecture {
        Unspecified,
        /// The instance uses the new network architecture.
        NewNetworkArchitecture,
        /// The instance uses the old network architecture.
        OldNetworkArchitecture,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlNetworkArchitecture::value] or
        /// [SqlNetworkArchitecture::name].
        UnknownValue(sql_network_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_network_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlNetworkArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NewNetworkArchitecture => std::option::Option::Some(1),
                Self::OldNetworkArchitecture => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_NETWORK_ARCHITECTURE_UNSPECIFIED"),
                Self::NewNetworkArchitecture => std::option::Option::Some("NEW_NETWORK_ARCHITECTURE"),
                Self::OldNetworkArchitecture => std::option::Option::Some("OLD_NETWORK_ARCHITECTURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlNetworkArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlNetworkArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlNetworkArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NewNetworkArchitecture,
                2 => Self::OldNetworkArchitecture,
                _ => Self::UnknownValue(sql_network_architecture::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlNetworkArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "NEW_NETWORK_ARCHITECTURE" => Self::NewNetworkArchitecture,
                "OLD_NETWORK_ARCHITECTURE" => Self::OldNetworkArchitecture,
                _ => Self::UnknownValue(sql_network_architecture::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlNetworkArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NewNetworkArchitecture => serializer.serialize_i32(1),
                Self::OldNetworkArchitecture => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlNetworkArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlNetworkArchitecture>::new(
                ".google.cloud.sql.v1.DatabaseInstance.SqlNetworkArchitecture"))
        }
    }
}

/// Gemini instance configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GeminiInstanceConfig {

    /// Output only. Whether Gemini is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entitled: std::option::Option<bool>,

    /// Output only. Whether the vacuum management is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_vacuum_mgmt_enabled: std::option::Option<bool>,

    /// Output only. Whether canceling the out-of-memory (OOM) session is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oom_session_cancel_enabled: std::option::Option<bool>,

    /// Output only. Whether the active query is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_query_enabled: std::option::Option<bool>,

    /// Output only. Whether the index advisor is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_advisor_enabled: std::option::Option<bool>,

    /// Output only. Whether the flag recommender is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub flag_recommender_enabled: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GeminiInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitled][crate::model::GeminiInstanceConfig::entitled].
    pub fn set_entitled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.entitled = v.into();
        self
    }

    /// Sets the value of [google_vacuum_mgmt_enabled][crate::model::GeminiInstanceConfig::google_vacuum_mgmt_enabled].
    pub fn set_google_vacuum_mgmt_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.google_vacuum_mgmt_enabled = v.into();
        self
    }

    /// Sets the value of [oom_session_cancel_enabled][crate::model::GeminiInstanceConfig::oom_session_cancel_enabled].
    pub fn set_oom_session_cancel_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.oom_session_cancel_enabled = v.into();
        self
    }

    /// Sets the value of [active_query_enabled][crate::model::GeminiInstanceConfig::active_query_enabled].
    pub fn set_active_query_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.active_query_enabled = v.into();
        self
    }

    /// Sets the value of [index_advisor_enabled][crate::model::GeminiInstanceConfig::index_advisor_enabled].
    pub fn set_index_advisor_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.index_advisor_enabled = v.into();
        self
    }

    /// Sets the value of [flag_recommender_enabled][crate::model::GeminiInstanceConfig::flag_recommender_enabled].
    pub fn set_flag_recommender_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.flag_recommender_enabled = v.into();
        self
    }
}

impl wkt::message::Message for GeminiInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GeminiInstanceConfig"
    }
}

/// A primary instance and disaster recovery (DR) replica pair.
/// A DR replica is a cross-region replica that you designate for failover in
/// the event that the primary instance experiences regional failure.
/// Only applicable to MySQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationCluster {

    /// Output only. If set, it indicates this instance has a private service
    /// access (PSA) dns endpoint that is pointing to the primary instance of the
    /// cluster. If this instance is the primary, the dns should be pointing to
    /// this instance. After Switchover or Replica failover, this DNS endpoint
    /// points to the promoted instance. This is a read-only field, returned to the
    /// user as information. This field can exist even if a standalone instance
    /// does not yet have a replica, or had a DR replica that was deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psa_write_endpoint: std::string::String,

    /// Optional. If the instance is a primary instance, then this field identifies
    /// the disaster recovery (DR) replica. A DR replica is an optional
    /// configuration for Enterprise Plus edition instances. If the instance is a
    /// read replica, then the field is not set. Set this field to a replica name
    /// to designate a DR replica for a primary instance. Remove the replica name
    /// to remove the DR replica designation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub failover_dr_replica_name: std::string::String,

    /// Output only. Read-only field that indicates whether the replica is a DR
    /// replica. This field is not set if the instance is a primary instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dr_replica: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psa_write_endpoint][crate::model::ReplicationCluster::psa_write_endpoint].
    pub fn set_psa_write_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_write_endpoint = v.into();
        self
    }

    /// Sets the value of [failover_dr_replica_name][crate::model::ReplicationCluster::failover_dr_replica_name].
    pub fn set_failover_dr_replica_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failover_dr_replica_name = v.into();
        self
    }

    /// Sets the value of [dr_replica][crate::model::ReplicationCluster::dr_replica].
    pub fn set_dr_replica<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dr_replica = v.into();
        self
    }
}

impl wkt::message::Message for ReplicationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicationCluster"
    }
}

/// An available database version. It can be a major or a minor version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvailableDatabaseVersion {

    /// The version's major version name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub major_version: std::option::Option<std::string::String>,

    /// The database version name. For MySQL 8.0, this string provides the database
    /// major and minor version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// The database version's display name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_name: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvailableDatabaseVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [major_version][crate::model::AvailableDatabaseVersion::major_version].
    pub fn set_major_version<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.major_version = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AvailableDatabaseVersion::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AvailableDatabaseVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for AvailableDatabaseVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AvailableDatabaseVersion"
    }
}

/// Reschedule options for maintenance windows.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequestBody {

    /// Required. The type of the reschedule the user wants.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reschedule: std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesRescheduleMaintenanceRequestBody {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reschedule][crate::model::SqlInstancesRescheduleMaintenanceRequestBody::reschedule].
    pub fn set_reschedule<T: std::convert::Into<std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule>>>(mut self, v: T) -> Self {
        self.reschedule = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequestBody {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody"
    }
}

/// Defines additional types related to [SqlInstancesRescheduleMaintenanceRequestBody].
pub mod sql_instances_reschedule_maintenance_request_body {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Reschedule {

        /// Required. The type of the reschedule.
        pub reschedule_type: crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType,

        /// Optional. Timestamp when the maintenance shall be rescheduled to if
        /// reschedule_type=SPECIFIC_TIME, in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
        /// `2012-11-15T16:19:00.094Z`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Reschedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reschedule_type][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::reschedule_type].
        pub fn set_reschedule_type<T: std::convert::Into<crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType>>(mut self, v: T) -> Self {
            self.reschedule_type = v.into();
            self
        }

        /// Sets the value of [schedule_time][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::schedule_time].
        pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.schedule_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Reschedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody.Reschedule"
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RescheduleType {
        Unspecified,
        /// Reschedules maintenance to happen now (within 5 minutes).
        Immediate,
        /// Reschedules maintenance to occur within one week from the originally
        /// scheduled day and time.
        NextAvailableWindow,
        /// Reschedules maintenance to a specific time and day.
        SpecificTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RescheduleType::value] or
        /// [RescheduleType::name].
        UnknownValue(reschedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reschedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RescheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediate => std::option::Option::Some(1),
                Self::NextAvailableWindow => std::option::Option::Some(2),
                Self::SpecificTime => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESCHEDULE_TYPE_UNSPECIFIED"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::NextAvailableWindow => std::option::Option::Some("NEXT_AVAILABLE_WINDOW"),
                Self::SpecificTime => std::option::Option::Some("SPECIFIC_TIME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RescheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediate,
                2 => Self::NextAvailableWindow,
                3 => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for RescheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATE" => Self::Immediate,
                "NEXT_AVAILABLE_WINDOW" => Self::NextAvailableWindow,
                "SPECIFIC_TIME" => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for RescheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediate => serializer.serialize_i32(1),
                Self::NextAvailableWindow => serializer.serialize_i32(2),
                Self::SpecificTime => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RescheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RescheduleType>::new(
                ".google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody.RescheduleType"))
        }
    }
}

/// Database instance demote primary instance context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterContext {

    /// This is always `sql#demoteMasterContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Verify the GTID consistency for demote operation. Default value:
    /// `True`. Setting this flag to `false` enables you to bypass the GTID
    /// consistency check between on-premises primary instance and Cloud SQL
    /// instance during the demotion operation but also exposes you to the risk of
    /// future replication failures. Change the value only if you know the reason
    /// for the GTID divergence and are confident that doing so will not cause any
    /// replication issues.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_gtid_consistency: std::option::Option<wkt::BoolValue>,

    /// The name of the instance which will act as on-premises primary instance
    /// in the replication setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_instance_name: std::string::String,

    /// Configuration specific to read-replicas replicating from the on-premises
    /// primary instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_configuration: std::option::Option<crate::model::DemoteMasterConfiguration>,

    /// Flag to skip replication setup on the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_replication_setup: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [verify_gtid_consistency][crate::model::DemoteMasterContext::verify_gtid_consistency].
    pub fn set_verify_gtid_consistency<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.verify_gtid_consistency = v.into();
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DemoteMasterContext::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DemoteMasterContext::replica_configuration].
    pub fn set_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterConfiguration>>>(mut self, v: T) -> Self {
        self.replica_configuration = v.into();
        self
    }

    /// Sets the value of [skip_replication_setup][crate::model::DemoteMasterContext::skip_replication_setup].
    pub fn set_skip_replication_setup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_replication_setup = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterContext"
    }
}

/// This context is used to demote an existing standalone instance to be
/// a Cloud SQL read replica for an external database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteContext {

    /// This is always `sql#demoteContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Required. The name of the instance which acts as the on-premises primary
    /// instance in the replication setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_representative_instance_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [source_representative_instance_name][crate::model::DemoteContext::source_representative_instance_name].
    pub fn set_source_representative_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_representative_instance_name = v.into();
        self
    }
}

impl wkt::message::Message for DemoteContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteContext"
    }
}

/// Database instance failover context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailoverContext {

    /// The current settings version of this instance. Request will be rejected if
    /// this version doesn't match the current settings version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub settings_version: i64,

    /// This is always `sql#failoverContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::FailoverContext::settings_version].
    pub fn set_settings_version<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.settings_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::FailoverContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for FailoverContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FailoverContext"
    }
}

/// Database instance restore from backup context.
/// Backup context contains source instance id and project id.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreBackupContext {

    /// This is always `sql#restoreBackupContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The ID of the backup run to restore from.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_run_id: i64,

    /// The ID of the instance that the backup was taken from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// The full project ID of the source instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreBackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RestoreBackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [backup_run_id][crate::model::RestoreBackupContext::backup_run_id].
    pub fn set_backup_run_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_run_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::RestoreBackupContext::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [project][crate::model::RestoreBackupContext::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for RestoreBackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RestoreBackupContext"
    }
}

/// Instance rotate server CA context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RotateServerCaContext {

    /// This is always `sql#rotateServerCaContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The fingerprint of the next version to be rotated to. If left unspecified,
    /// will be rotated to the most recently added server CA version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RotateServerCaContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RotateServerCaContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_version][crate::model::RotateServerCaContext::next_version].
    pub fn set_next_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_version = v.into();
        self
    }
}

impl wkt::message::Message for RotateServerCaContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RotateServerCaContext"
    }
}

/// Database Instance truncate log context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TruncateLogContext {

    /// This is always `sql#truncateLogContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The type of log to truncate. Valid values are `MYSQL_GENERAL_TABLE` and
    /// `MYSQL_SLOW_TABLE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TruncateLogContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TruncateLogContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [log_type][crate::model::TruncateLogContext::log_type].
    pub fn set_log_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_type = v.into();
        self
    }
}

impl wkt::message::Message for TruncateLogContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TruncateLogContext"
    }
}

/// External primary instance migration setting error/warning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlExternalSyncSettingError {

    /// Can be `sql#externalSyncSettingError` or
    /// `sql#externalSyncSettingWarning`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    #[serde(rename = "type")]
    pub r#type: crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType,

    /// Additional information about the error encountered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlExternalSyncSettingError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlExternalSyncSettingError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlExternalSyncSettingError::type].
    pub fn set_type<T: std::convert::Into<crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::SqlExternalSyncSettingError::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for SqlExternalSyncSettingError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlExternalSyncSettingError"
    }
}

/// Defines additional types related to [SqlExternalSyncSettingError].
pub mod sql_external_sync_setting_error {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlExternalSyncSettingErrorType {
        Unspecified,
        ConnectionFailure,
        BinlogNotEnabled,
        IncompatibleDatabaseVersion,
        ReplicaAlreadySetup,
        /// The replication user is missing privileges that are required.
        InsufficientPrivilege,
        /// Unsupported migration type.
        UnsupportedMigrationType,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses,
        /// Extensions installed are either not supported or having unsupported
        /// versions.
        UnsupportedExtensions,
        /// The value of parameter rds.logical_replication is not set to 1.
        InvalidRdsLogicalReplication,
        /// The primary instance logging setup doesn't allow EM sync.
        InvalidLoggingSetup,
        /// The primary instance database parameter setup doesn't allow EM sync.
        InvalidDbParam,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode,
        /// SQL Server Agent is not running.
        SqlserverAgentNotRunning,
        /// The table definition is not support due to missing primary key or replica
        /// identity, applicable for postgres.
        UnsupportedTableDefinition,
        /// The customer has a definer that will break EM setup.
        UnsupportedDefiner,
        /// SQL Server @@SERVERNAME does not match actual host name.
        SqlserverServernameMismatch,
        /// The primary instance has been setup and will fail the setup.
        PrimaryAlreadySetup,
        /// The primary instance has unsupported binary log format.
        UnsupportedBinlogFormat,
        /// The primary instance's binary log retention setting.
        BinlogRetentionSetting,
        /// The primary instance has tables with unsupported storage engine.
        UnsupportedStorageEngine,
        /// Source has tables with limited support
        /// eg: PostgreSQL tables without primary keys.
        LimitedSupportTables,
        /// The replica instance contains existing data.
        ExistingDataInReplica,
        /// The replication user is missing privileges that are optional.
        MissingOptionalPrivileges,
        /// Additional BACKUP_ADMIN privilege is granted to the replication user
        /// which may lock source MySQL 8 instance for DDLs during initial sync.
        RiskyBackupAdminPrivilege,
        /// The Cloud Storage bucket is missing necessary permissions.
        InsufficientGcsPermissions,
        /// The Cloud Storage bucket has an error in the file or contains invalid
        /// file information.
        InvalidFileInfo,
        /// The source instance has unsupported database settings for migration.
        UnsupportedDatabaseSettings,
        /// The replication user is missing parallel import specific privileges.
        /// (e.g. LOCK TABLES) for MySQL.
        MysqlParallelImportInsufficientPrivilege,
        /// The global variable local_infile is off on external server replica.
        LocalInfileOff,
        /// This code instructs customers to turn on point-in-time recovery manually
        /// for the instance after promoting the Cloud SQL for PostgreSQL instance.
        TurnOnPitrAfterPromote,
        /// The minor version of replica database is incompatible with the source.
        IncompatibleDatabaseMinorVersion,
        /// This warning message indicates that Cloud SQL uses the maximum number of
        /// subscriptions to migrate data from the source to the destination.
        SourceMaxSubscriptions,
        /// Unable to verify definers on the source for MySQL.
        UnableToVerifyDefiners,
        /// If a time out occurs while the subscription counts are calculated, then
        /// this value is set to 1. Otherwise, this value is set to 2.
        SubscriptionCalculationStatus,
        /// Count of subscriptions needed to sync source data for PostgreSQL
        /// database.
        PgSubscriptionCount,
        /// Final parallel level that is used to do migration.
        PgSyncParallelLevel,
        /// The disk size of the replica instance is smaller than the data size of
        /// the source instance.
        InsufficientDiskSize,
        /// The data size of the source instance is greater than 1 TB, the number of
        /// cores of the replica instance is less than 8, and the memory of the
        /// replica is less than 32 GB.
        InsufficientMachineTier,
        /// The warning message indicates the unsupported extensions will not be
        /// migrated to the destination.
        UnsupportedExtensionsNotMigrated,
        /// The warning message indicates the pg_cron extension and settings will not
        /// be migrated to the destination.
        ExtensionsNotMigrated,
        /// The error message indicates that pg_cron flags are enabled on the
        /// destination which is not supported during the migration.
        PgCronFlagEnabledInReplica,
        /// This error message indicates that the specified extensions are not
        /// enabled on destination instance. For example, before you can migrate
        /// data to the destination instance, you must enable the PGAudit extension
        /// on the instance.
        ExtensionsNotEnabledInReplica,
        /// The source database has generated columns that can't be migrated. Please
        /// change them to regular columns before migration.
        UnsupportedColumns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlExternalSyncSettingErrorType::value] or
        /// [SqlExternalSyncSettingErrorType::name].
        UnknownValue(sql_external_sync_setting_error_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_external_sync_setting_error_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlExternalSyncSettingErrorType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectionFailure => std::option::Option::Some(1),
                Self::BinlogNotEnabled => std::option::Option::Some(2),
                Self::IncompatibleDatabaseVersion => std::option::Option::Some(3),
                Self::ReplicaAlreadySetup => std::option::Option::Some(4),
                Self::InsufficientPrivilege => std::option::Option::Some(5),
                Self::UnsupportedMigrationType => std::option::Option::Some(6),
                Self::NoPglogicalInstalled => std::option::Option::Some(7),
                Self::PglogicalNodeAlreadyExists => std::option::Option::Some(8),
                Self::InvalidWalLevel => std::option::Option::Some(9),
                Self::InvalidSharedPreloadLibrary => std::option::Option::Some(10),
                Self::InsufficientMaxReplicationSlots => std::option::Option::Some(11),
                Self::InsufficientMaxWalSenders => std::option::Option::Some(12),
                Self::InsufficientMaxWorkerProcesses => std::option::Option::Some(13),
                Self::UnsupportedExtensions => std::option::Option::Some(14),
                Self::InvalidRdsLogicalReplication => std::option::Option::Some(15),
                Self::InvalidLoggingSetup => std::option::Option::Some(16),
                Self::InvalidDbParam => std::option::Option::Some(17),
                Self::UnsupportedGtidMode => std::option::Option::Some(18),
                Self::SqlserverAgentNotRunning => std::option::Option::Some(19),
                Self::UnsupportedTableDefinition => std::option::Option::Some(20),
                Self::UnsupportedDefiner => std::option::Option::Some(21),
                Self::SqlserverServernameMismatch => std::option::Option::Some(22),
                Self::PrimaryAlreadySetup => std::option::Option::Some(23),
                Self::UnsupportedBinlogFormat => std::option::Option::Some(24),
                Self::BinlogRetentionSetting => std::option::Option::Some(25),
                Self::UnsupportedStorageEngine => std::option::Option::Some(26),
                Self::LimitedSupportTables => std::option::Option::Some(27),
                Self::ExistingDataInReplica => std::option::Option::Some(28),
                Self::MissingOptionalPrivileges => std::option::Option::Some(29),
                Self::RiskyBackupAdminPrivilege => std::option::Option::Some(30),
                Self::InsufficientGcsPermissions => std::option::Option::Some(31),
                Self::InvalidFileInfo => std::option::Option::Some(32),
                Self::UnsupportedDatabaseSettings => std::option::Option::Some(33),
                Self::MysqlParallelImportInsufficientPrivilege => std::option::Option::Some(34),
                Self::LocalInfileOff => std::option::Option::Some(35),
                Self::TurnOnPitrAfterPromote => std::option::Option::Some(36),
                Self::IncompatibleDatabaseMinorVersion => std::option::Option::Some(37),
                Self::SourceMaxSubscriptions => std::option::Option::Some(38),
                Self::UnableToVerifyDefiners => std::option::Option::Some(39),
                Self::SubscriptionCalculationStatus => std::option::Option::Some(40),
                Self::PgSubscriptionCount => std::option::Option::Some(41),
                Self::PgSyncParallelLevel => std::option::Option::Some(42),
                Self::InsufficientDiskSize => std::option::Option::Some(43),
                Self::InsufficientMachineTier => std::option::Option::Some(44),
                Self::UnsupportedExtensionsNotMigrated => std::option::Option::Some(45),
                Self::ExtensionsNotMigrated => std::option::Option::Some(46),
                Self::PgCronFlagEnabledInReplica => std::option::Option::Some(47),
                Self::ExtensionsNotEnabledInReplica => std::option::Option::Some(48),
                Self::UnsupportedColumns => std::option::Option::Some(49),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED"),
                Self::ConnectionFailure => std::option::Option::Some("CONNECTION_FAILURE"),
                Self::BinlogNotEnabled => std::option::Option::Some("BINLOG_NOT_ENABLED"),
                Self::IncompatibleDatabaseVersion => std::option::Option::Some("INCOMPATIBLE_DATABASE_VERSION"),
                Self::ReplicaAlreadySetup => std::option::Option::Some("REPLICA_ALREADY_SETUP"),
                Self::InsufficientPrivilege => std::option::Option::Some("INSUFFICIENT_PRIVILEGE"),
                Self::UnsupportedMigrationType => std::option::Option::Some("UNSUPPORTED_MIGRATION_TYPE"),
                Self::NoPglogicalInstalled => std::option::Option::Some("NO_PGLOGICAL_INSTALLED"),
                Self::PglogicalNodeAlreadyExists => std::option::Option::Some("PGLOGICAL_NODE_ALREADY_EXISTS"),
                Self::InvalidWalLevel => std::option::Option::Some("INVALID_WAL_LEVEL"),
                Self::InvalidSharedPreloadLibrary => std::option::Option::Some("INVALID_SHARED_PRELOAD_LIBRARY"),
                Self::InsufficientMaxReplicationSlots => std::option::Option::Some("INSUFFICIENT_MAX_REPLICATION_SLOTS"),
                Self::InsufficientMaxWalSenders => std::option::Option::Some("INSUFFICIENT_MAX_WAL_SENDERS"),
                Self::InsufficientMaxWorkerProcesses => std::option::Option::Some("INSUFFICIENT_MAX_WORKER_PROCESSES"),
                Self::UnsupportedExtensions => std::option::Option::Some("UNSUPPORTED_EXTENSIONS"),
                Self::InvalidRdsLogicalReplication => std::option::Option::Some("INVALID_RDS_LOGICAL_REPLICATION"),
                Self::InvalidLoggingSetup => std::option::Option::Some("INVALID_LOGGING_SETUP"),
                Self::InvalidDbParam => std::option::Option::Some("INVALID_DB_PARAM"),
                Self::UnsupportedGtidMode => std::option::Option::Some("UNSUPPORTED_GTID_MODE"),
                Self::SqlserverAgentNotRunning => std::option::Option::Some("SQLSERVER_AGENT_NOT_RUNNING"),
                Self::UnsupportedTableDefinition => std::option::Option::Some("UNSUPPORTED_TABLE_DEFINITION"),
                Self::UnsupportedDefiner => std::option::Option::Some("UNSUPPORTED_DEFINER"),
                Self::SqlserverServernameMismatch => std::option::Option::Some("SQLSERVER_SERVERNAME_MISMATCH"),
                Self::PrimaryAlreadySetup => std::option::Option::Some("PRIMARY_ALREADY_SETUP"),
                Self::UnsupportedBinlogFormat => std::option::Option::Some("UNSUPPORTED_BINLOG_FORMAT"),
                Self::BinlogRetentionSetting => std::option::Option::Some("BINLOG_RETENTION_SETTING"),
                Self::UnsupportedStorageEngine => std::option::Option::Some("UNSUPPORTED_STORAGE_ENGINE"),
                Self::LimitedSupportTables => std::option::Option::Some("LIMITED_SUPPORT_TABLES"),
                Self::ExistingDataInReplica => std::option::Option::Some("EXISTING_DATA_IN_REPLICA"),
                Self::MissingOptionalPrivileges => std::option::Option::Some("MISSING_OPTIONAL_PRIVILEGES"),
                Self::RiskyBackupAdminPrivilege => std::option::Option::Some("RISKY_BACKUP_ADMIN_PRIVILEGE"),
                Self::InsufficientGcsPermissions => std::option::Option::Some("INSUFFICIENT_GCS_PERMISSIONS"),
                Self::InvalidFileInfo => std::option::Option::Some("INVALID_FILE_INFO"),
                Self::UnsupportedDatabaseSettings => std::option::Option::Some("UNSUPPORTED_DATABASE_SETTINGS"),
                Self::MysqlParallelImportInsufficientPrivilege => std::option::Option::Some("MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE"),
                Self::LocalInfileOff => std::option::Option::Some("LOCAL_INFILE_OFF"),
                Self::TurnOnPitrAfterPromote => std::option::Option::Some("TURN_ON_PITR_AFTER_PROMOTE"),
                Self::IncompatibleDatabaseMinorVersion => std::option::Option::Some("INCOMPATIBLE_DATABASE_MINOR_VERSION"),
                Self::SourceMaxSubscriptions => std::option::Option::Some("SOURCE_MAX_SUBSCRIPTIONS"),
                Self::UnableToVerifyDefiners => std::option::Option::Some("UNABLE_TO_VERIFY_DEFINERS"),
                Self::SubscriptionCalculationStatus => std::option::Option::Some("SUBSCRIPTION_CALCULATION_STATUS"),
                Self::PgSubscriptionCount => std::option::Option::Some("PG_SUBSCRIPTION_COUNT"),
                Self::PgSyncParallelLevel => std::option::Option::Some("PG_SYNC_PARALLEL_LEVEL"),
                Self::InsufficientDiskSize => std::option::Option::Some("INSUFFICIENT_DISK_SIZE"),
                Self::InsufficientMachineTier => std::option::Option::Some("INSUFFICIENT_MACHINE_TIER"),
                Self::UnsupportedExtensionsNotMigrated => std::option::Option::Some("UNSUPPORTED_EXTENSIONS_NOT_MIGRATED"),
                Self::ExtensionsNotMigrated => std::option::Option::Some("EXTENSIONS_NOT_MIGRATED"),
                Self::PgCronFlagEnabledInReplica => std::option::Option::Some("PG_CRON_FLAG_ENABLED_IN_REPLICA"),
                Self::ExtensionsNotEnabledInReplica => std::option::Option::Some("EXTENSIONS_NOT_ENABLED_IN_REPLICA"),
                Self::UnsupportedColumns => std::option::Option::Some("UNSUPPORTED_COLUMNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlExternalSyncSettingErrorType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlExternalSyncSettingErrorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlExternalSyncSettingErrorType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectionFailure,
                2 => Self::BinlogNotEnabled,
                3 => Self::IncompatibleDatabaseVersion,
                4 => Self::ReplicaAlreadySetup,
                5 => Self::InsufficientPrivilege,
                6 => Self::UnsupportedMigrationType,
                7 => Self::NoPglogicalInstalled,
                8 => Self::PglogicalNodeAlreadyExists,
                9 => Self::InvalidWalLevel,
                10 => Self::InvalidSharedPreloadLibrary,
                11 => Self::InsufficientMaxReplicationSlots,
                12 => Self::InsufficientMaxWalSenders,
                13 => Self::InsufficientMaxWorkerProcesses,
                14 => Self::UnsupportedExtensions,
                15 => Self::InvalidRdsLogicalReplication,
                16 => Self::InvalidLoggingSetup,
                17 => Self::InvalidDbParam,
                18 => Self::UnsupportedGtidMode,
                19 => Self::SqlserverAgentNotRunning,
                20 => Self::UnsupportedTableDefinition,
                21 => Self::UnsupportedDefiner,
                22 => Self::SqlserverServernameMismatch,
                23 => Self::PrimaryAlreadySetup,
                24 => Self::UnsupportedBinlogFormat,
                25 => Self::BinlogRetentionSetting,
                26 => Self::UnsupportedStorageEngine,
                27 => Self::LimitedSupportTables,
                28 => Self::ExistingDataInReplica,
                29 => Self::MissingOptionalPrivileges,
                30 => Self::RiskyBackupAdminPrivilege,
                31 => Self::InsufficientGcsPermissions,
                32 => Self::InvalidFileInfo,
                33 => Self::UnsupportedDatabaseSettings,
                34 => Self::MysqlParallelImportInsufficientPrivilege,
                35 => Self::LocalInfileOff,
                36 => Self::TurnOnPitrAfterPromote,
                37 => Self::IncompatibleDatabaseMinorVersion,
                38 => Self::SourceMaxSubscriptions,
                39 => Self::UnableToVerifyDefiners,
                40 => Self::SubscriptionCalculationStatus,
                41 => Self::PgSubscriptionCount,
                42 => Self::PgSyncParallelLevel,
                43 => Self::InsufficientDiskSize,
                44 => Self::InsufficientMachineTier,
                45 => Self::UnsupportedExtensionsNotMigrated,
                46 => Self::ExtensionsNotMigrated,
                47 => Self::PgCronFlagEnabledInReplica,
                48 => Self::ExtensionsNotEnabledInReplica,
                49 => Self::UnsupportedColumns,
                _ => Self::UnknownValue(sql_external_sync_setting_error_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlExternalSyncSettingErrorType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONNECTION_FAILURE" => Self::ConnectionFailure,
                "BINLOG_NOT_ENABLED" => Self::BinlogNotEnabled,
                "INCOMPATIBLE_DATABASE_VERSION" => Self::IncompatibleDatabaseVersion,
                "REPLICA_ALREADY_SETUP" => Self::ReplicaAlreadySetup,
                "INSUFFICIENT_PRIVILEGE" => Self::InsufficientPrivilege,
                "UNSUPPORTED_MIGRATION_TYPE" => Self::UnsupportedMigrationType,
                "NO_PGLOGICAL_INSTALLED" => Self::NoPglogicalInstalled,
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Self::PglogicalNodeAlreadyExists,
                "INVALID_WAL_LEVEL" => Self::InvalidWalLevel,
                "INVALID_SHARED_PRELOAD_LIBRARY" => Self::InvalidSharedPreloadLibrary,
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => Self::InsufficientMaxReplicationSlots,
                "INSUFFICIENT_MAX_WAL_SENDERS" => Self::InsufficientMaxWalSenders,
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => Self::InsufficientMaxWorkerProcesses,
                "UNSUPPORTED_EXTENSIONS" => Self::UnsupportedExtensions,
                "INVALID_RDS_LOGICAL_REPLICATION" => Self::InvalidRdsLogicalReplication,
                "INVALID_LOGGING_SETUP" => Self::InvalidLoggingSetup,
                "INVALID_DB_PARAM" => Self::InvalidDbParam,
                "UNSUPPORTED_GTID_MODE" => Self::UnsupportedGtidMode,
                "SQLSERVER_AGENT_NOT_RUNNING" => Self::SqlserverAgentNotRunning,
                "UNSUPPORTED_TABLE_DEFINITION" => Self::UnsupportedTableDefinition,
                "UNSUPPORTED_DEFINER" => Self::UnsupportedDefiner,
                "SQLSERVER_SERVERNAME_MISMATCH" => Self::SqlserverServernameMismatch,
                "PRIMARY_ALREADY_SETUP" => Self::PrimaryAlreadySetup,
                "UNSUPPORTED_BINLOG_FORMAT" => Self::UnsupportedBinlogFormat,
                "BINLOG_RETENTION_SETTING" => Self::BinlogRetentionSetting,
                "UNSUPPORTED_STORAGE_ENGINE" => Self::UnsupportedStorageEngine,
                "LIMITED_SUPPORT_TABLES" => Self::LimitedSupportTables,
                "EXISTING_DATA_IN_REPLICA" => Self::ExistingDataInReplica,
                "MISSING_OPTIONAL_PRIVILEGES" => Self::MissingOptionalPrivileges,
                "RISKY_BACKUP_ADMIN_PRIVILEGE" => Self::RiskyBackupAdminPrivilege,
                "INSUFFICIENT_GCS_PERMISSIONS" => Self::InsufficientGcsPermissions,
                "INVALID_FILE_INFO" => Self::InvalidFileInfo,
                "UNSUPPORTED_DATABASE_SETTINGS" => Self::UnsupportedDatabaseSettings,
                "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => Self::MysqlParallelImportInsufficientPrivilege,
                "LOCAL_INFILE_OFF" => Self::LocalInfileOff,
                "TURN_ON_PITR_AFTER_PROMOTE" => Self::TurnOnPitrAfterPromote,
                "INCOMPATIBLE_DATABASE_MINOR_VERSION" => Self::IncompatibleDatabaseMinorVersion,
                "SOURCE_MAX_SUBSCRIPTIONS" => Self::SourceMaxSubscriptions,
                "UNABLE_TO_VERIFY_DEFINERS" => Self::UnableToVerifyDefiners,
                "SUBSCRIPTION_CALCULATION_STATUS" => Self::SubscriptionCalculationStatus,
                "PG_SUBSCRIPTION_COUNT" => Self::PgSubscriptionCount,
                "PG_SYNC_PARALLEL_LEVEL" => Self::PgSyncParallelLevel,
                "INSUFFICIENT_DISK_SIZE" => Self::InsufficientDiskSize,
                "INSUFFICIENT_MACHINE_TIER" => Self::InsufficientMachineTier,
                "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED" => Self::UnsupportedExtensionsNotMigrated,
                "EXTENSIONS_NOT_MIGRATED" => Self::ExtensionsNotMigrated,
                "PG_CRON_FLAG_ENABLED_IN_REPLICA" => Self::PgCronFlagEnabledInReplica,
                "EXTENSIONS_NOT_ENABLED_IN_REPLICA" => Self::ExtensionsNotEnabledInReplica,
                "UNSUPPORTED_COLUMNS" => Self::UnsupportedColumns,
                _ => Self::UnknownValue(sql_external_sync_setting_error_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlExternalSyncSettingErrorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectionFailure => serializer.serialize_i32(1),
                Self::BinlogNotEnabled => serializer.serialize_i32(2),
                Self::IncompatibleDatabaseVersion => serializer.serialize_i32(3),
                Self::ReplicaAlreadySetup => serializer.serialize_i32(4),
                Self::InsufficientPrivilege => serializer.serialize_i32(5),
                Self::UnsupportedMigrationType => serializer.serialize_i32(6),
                Self::NoPglogicalInstalled => serializer.serialize_i32(7),
                Self::PglogicalNodeAlreadyExists => serializer.serialize_i32(8),
                Self::InvalidWalLevel => serializer.serialize_i32(9),
                Self::InvalidSharedPreloadLibrary => serializer.serialize_i32(10),
                Self::InsufficientMaxReplicationSlots => serializer.serialize_i32(11),
                Self::InsufficientMaxWalSenders => serializer.serialize_i32(12),
                Self::InsufficientMaxWorkerProcesses => serializer.serialize_i32(13),
                Self::UnsupportedExtensions => serializer.serialize_i32(14),
                Self::InvalidRdsLogicalReplication => serializer.serialize_i32(15),
                Self::InvalidLoggingSetup => serializer.serialize_i32(16),
                Self::InvalidDbParam => serializer.serialize_i32(17),
                Self::UnsupportedGtidMode => serializer.serialize_i32(18),
                Self::SqlserverAgentNotRunning => serializer.serialize_i32(19),
                Self::UnsupportedTableDefinition => serializer.serialize_i32(20),
                Self::UnsupportedDefiner => serializer.serialize_i32(21),
                Self::SqlserverServernameMismatch => serializer.serialize_i32(22),
                Self::PrimaryAlreadySetup => serializer.serialize_i32(23),
                Self::UnsupportedBinlogFormat => serializer.serialize_i32(24),
                Self::BinlogRetentionSetting => serializer.serialize_i32(25),
                Self::UnsupportedStorageEngine => serializer.serialize_i32(26),
                Self::LimitedSupportTables => serializer.serialize_i32(27),
                Self::ExistingDataInReplica => serializer.serialize_i32(28),
                Self::MissingOptionalPrivileges => serializer.serialize_i32(29),
                Self::RiskyBackupAdminPrivilege => serializer.serialize_i32(30),
                Self::InsufficientGcsPermissions => serializer.serialize_i32(31),
                Self::InvalidFileInfo => serializer.serialize_i32(32),
                Self::UnsupportedDatabaseSettings => serializer.serialize_i32(33),
                Self::MysqlParallelImportInsufficientPrivilege => serializer.serialize_i32(34),
                Self::LocalInfileOff => serializer.serialize_i32(35),
                Self::TurnOnPitrAfterPromote => serializer.serialize_i32(36),
                Self::IncompatibleDatabaseMinorVersion => serializer.serialize_i32(37),
                Self::SourceMaxSubscriptions => serializer.serialize_i32(38),
                Self::UnableToVerifyDefiners => serializer.serialize_i32(39),
                Self::SubscriptionCalculationStatus => serializer.serialize_i32(40),
                Self::PgSubscriptionCount => serializer.serialize_i32(41),
                Self::PgSyncParallelLevel => serializer.serialize_i32(42),
                Self::InsufficientDiskSize => serializer.serialize_i32(43),
                Self::InsufficientMachineTier => serializer.serialize_i32(44),
                Self::UnsupportedExtensionsNotMigrated => serializer.serialize_i32(45),
                Self::ExtensionsNotMigrated => serializer.serialize_i32(46),
                Self::PgCronFlagEnabledInReplica => serializer.serialize_i32(47),
                Self::ExtensionsNotEnabledInReplica => serializer.serialize_i32(48),
                Self::UnsupportedColumns => serializer.serialize_i32(49),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlExternalSyncSettingErrorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlExternalSyncSettingErrorType>::new(
                ".google.cloud.sql.v1.SqlExternalSyncSettingError.SqlExternalSyncSettingErrorType"))
        }
    }
}

/// On-premises instance configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OnPremisesConfiguration {

    /// The host and port of the on-premises instance in host:port format
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_port: std::string::String,

    /// This is always `sql#onPremisesConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The username for connecting to on-premises instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for connecting to on-premises instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// The dump file to create the Cloud SQL replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_file_path: std::string::String,

    /// The reference to Cloud SQL instance if the source is Cloud SQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_instance: std::option::Option<crate::model::InstanceReference>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OnPremisesConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::OnPremisesConfiguration::host_port].
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::OnPremisesConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OnPremisesConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OnPremisesConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::OnPremisesConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::OnPremisesConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::OnPremisesConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [dump_file_path][crate::model::OnPremisesConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::OnPremisesConfiguration::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::option::Option<crate::model::InstanceReference>>>(mut self, v: T) -> Self {
        self.source_instance = v.into();
        self
    }
}

impl wkt::message::Message for OnPremisesConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OnPremisesConfiguration"
    }
}

/// Read-replica configuration for connecting to the primary instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaConfiguration {

    /// This is always `sql#replicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mysql_replica_configuration: std::option::Option<crate::model::MySqlReplicaConfiguration>,

    /// Specifies if the replica is the failover target. If the field is set to
    /// `true`, the replica will be designated as a failover replica. In case the
    /// primary instance fails, the replica instance will be promoted as the new
    /// primary instance. Only one replica can be specified as failover target, and
    /// the replica has to be in different zone with the primary instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_target: std::option::Option<wkt::BoolValue>,

    /// Optional. Specifies if a SQL Server replica is a cascadable replica. A
    /// cascadable replica is a SQL Server cross region replica that supports
    /// replica(s) under it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cascadable_replica: std::option::Option<wkt::BoolValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::ReplicaConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::MySqlReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.mysql_replica_configuration = v.into();
        self
    }

    /// Sets the value of [failover_target][crate::model::ReplicaConfiguration::failover_target].
    pub fn set_failover_target<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.failover_target = v.into();
        self
    }

    /// Sets the value of [cascadable_replica][crate::model::ReplicaConfiguration::cascadable_replica].
    pub fn set_cascadable_replica<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.cascadable_replica = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicaConfiguration"
    }
}

/// Request to acquire a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseRequest {

    /// Required. Cloud SQL instance ID. This doesn't include the project ID. It's
    /// composed of lowercase letters, numbers, and hyphens, and it must start with
    /// a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Project ID of the project that contains the instance (Example:
    /// project-id).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Required. The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesAcquireSsrsLeaseRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAcquireSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAcquireSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesAcquireSsrsLeaseRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesAcquireSsrsLeaseRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseRequest"
    }
}

/// Response for the acquire SSRS lease request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseResponse {

    /// The unique identifier for this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesAcquireSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesAcquireSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseResponse"
    }
}

/// Request to release a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseRequest {

    /// Required. The Cloud SQL instance ID. This doesn't include the project ID.
    /// The instance ID contains lowercase letters, numbers, and hyphens, and it
    /// must start with a letter. This ID can have a maximum length of 98
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. The project ID that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReleaseSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReleaseSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReleaseSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseRequest"
    }
}

/// Response for the release SSRS lease request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseResponse {

    /// The unique identifier for this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlInstancesReleaseSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesReleaseSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseResponse"
    }
}

/// Operations get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsGetRequest {

    /// Instance operation ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsGetRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsGetRequest"
    }
}

/// Operations list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Maximum number of operations per response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlOperationsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlOperationsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlOperationsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsListRequest"
    }
}

/// Operations list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationsListResponse {

    /// This is always `sql#operationsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of operation resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Operation>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::OperationsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationsListResponse"
    }
}

/// Operations cancel request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsCancelRequest {

    /// Instance operation ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlOperationsCancelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsCancelRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsCancelRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsCancelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsCancelRequest"
    }
}

/// An entry for an Access Control list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AclEntry {

    /// The allowlisted value for the access control list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// The time when this access control entry expires in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A label to identify this entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// This is always `sql#aclEntry`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::AclEntry::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AclEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::AclEntry::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for AclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AclEntry"
    }
}

/// An Admin API warning message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiWarning {

    /// Code to uniquely identify the warning type.
    pub code: crate::model::api_warning::SqlApiWarningCode,

    /// The warning message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The region name for REGION_UNREACHABLE warning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApiWarning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ApiWarning::code].
    pub fn set_code<T: std::convert::Into<crate::model::api_warning::SqlApiWarningCode>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ApiWarning::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ApiWarning::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for ApiWarning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ApiWarning"
    }
}

/// Defines additional types related to [ApiWarning].
pub mod api_warning {
    #[allow(unused_imports)]
    use super::*;


    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlApiWarningCode {
        /// An unknown or unset warning type from Cloud SQL API.
        Unspecified,
        /// Warning when one or more regions are not reachable.  The returned result
        /// set may be incomplete.
        RegionUnreachable,
        /// Warning when user provided maxResults parameter exceeds the limit.  The
        /// returned result set may be incomplete.
        MaxResultsExceedsLimit,
        /// Warning when user tries to create/update a user with credentials that
        /// have previously been compromised by a public data breach.
        CompromisedCredentials,
        /// Warning when the operation succeeds but some non-critical workflow state
        /// failed.
        InternalStateFailure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlApiWarningCode::value] or
        /// [SqlApiWarningCode::name].
        UnknownValue(sql_api_warning_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_api_warning_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlApiWarningCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RegionUnreachable => std::option::Option::Some(1),
                Self::MaxResultsExceedsLimit => std::option::Option::Some(2),
                Self::CompromisedCredentials => std::option::Option::Some(3),
                Self::InternalStateFailure => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_API_WARNING_CODE_UNSPECIFIED"),
                Self::RegionUnreachable => std::option::Option::Some("REGION_UNREACHABLE"),
                Self::MaxResultsExceedsLimit => std::option::Option::Some("MAX_RESULTS_EXCEEDS_LIMIT"),
                Self::CompromisedCredentials => std::option::Option::Some("COMPROMISED_CREDENTIALS"),
                Self::InternalStateFailure => std::option::Option::Some("INTERNAL_STATE_FAILURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlApiWarningCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlApiWarningCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlApiWarningCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RegionUnreachable,
                2 => Self::MaxResultsExceedsLimit,
                3 => Self::CompromisedCredentials,
                4 => Self::InternalStateFailure,
                _ => Self::UnknownValue(sql_api_warning_code::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlApiWarningCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_API_WARNING_CODE_UNSPECIFIED" => Self::Unspecified,
                "REGION_UNREACHABLE" => Self::RegionUnreachable,
                "MAX_RESULTS_EXCEEDS_LIMIT" => Self::MaxResultsExceedsLimit,
                "COMPROMISED_CREDENTIALS" => Self::CompromisedCredentials,
                "INTERNAL_STATE_FAILURE" => Self::InternalStateFailure,
                _ => Self::UnknownValue(sql_api_warning_code::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlApiWarningCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RegionUnreachable => serializer.serialize_i32(1),
                Self::MaxResultsExceedsLimit => serializer.serialize_i32(2),
                Self::CompromisedCredentials => serializer.serialize_i32(3),
                Self::InternalStateFailure => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlApiWarningCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlApiWarningCode>::new(
                ".google.cloud.sql.v1.ApiWarning.SqlApiWarningCode"))
        }
    }
}

/// We currently only support backup retention by specifying the number
/// of backups we will retain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRetentionSettings {

    /// The unit that 'retained_backups' represents.
    pub retention_unit: crate::model::backup_retention_settings::RetentionUnit,

    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retained_backups: std::option::Option<wkt::Int32Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupRetentionSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_unit][crate::model::BackupRetentionSettings::retention_unit].
    pub fn set_retention_unit<T: std::convert::Into<crate::model::backup_retention_settings::RetentionUnit>>(mut self, v: T) -> Self {
        self.retention_unit = v.into();
        self
    }

    /// Sets the value of [retained_backups][crate::model::BackupRetentionSettings::retained_backups].
    pub fn set_retained_backups<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.retained_backups = v.into();
        self
    }
}

impl wkt::message::Message for BackupRetentionSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRetentionSettings"
    }
}

/// Defines additional types related to [BackupRetentionSettings].
pub mod backup_retention_settings {
    #[allow(unused_imports)]
    use super::*;


    /// The units that retained_backups specifies, we only support COUNT.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetentionUnit {
        /// Backup retention unit is unspecified, will be treated as COUNT.
        Unspecified,
        /// Retention will be by count, eg. "retain the most recent 7 backups".
        Count,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetentionUnit::value] or
        /// [RetentionUnit::name].
        UnknownValue(retention_unit::UnknownValue),
    }

    #[doc(hidden)]
    pub mod retention_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RetentionUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Count => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETENTION_UNIT_UNSPECIFIED"),
                Self::Count => std::option::Option::Some("COUNT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RetentionUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RetentionUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RetentionUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Count,
                _ => Self::UnknownValue(retention_unit::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for RetentionUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETENTION_UNIT_UNSPECIFIED" => Self::Unspecified,
                "COUNT" => Self::Count,
                _ => Self::UnknownValue(retention_unit::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for RetentionUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Count => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetentionUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetentionUnit>::new(
                ".google.cloud.sql.v1.BackupRetentionSettings.RetentionUnit"))
        }
    }
}

/// Database instance backup configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupConfiguration {

    /// Start time for the daily backup configuration in UTC timezone in the 24
    /// hour format - `HH:MM`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_time: std::string::String,

    /// Whether this configuration is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#backupConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// (MySQL only) Whether binary log is enabled. If backup configuration is
    /// disabled, binarylog must be disabled as well.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_log_enabled: std::option::Option<wkt::BoolValue>,

    /// Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_log_archiving_enabled: std::option::Option<wkt::BoolValue>,

    /// Location of the backup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Whether point in time recovery is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub point_in_time_recovery_enabled: std::option::Option<wkt::BoolValue>,

    /// Backup retention settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_retention_settings: std::option::Option<crate::model::BackupRetentionSettings>,

    /// The number of days of transaction logs we retain for point in time
    /// restore, from 1-7.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_log_retention_days: std::option::Option<wkt::Int32Value>,

    /// Output only. This value contains the storage location of transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transactional_log_storage_state: std::option::Option<crate::model::backup_configuration::TransactionalLogStorageState>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BackupConfiguration::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::BackupConfiguration::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BackupConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [binary_log_enabled][crate::model::BackupConfiguration::binary_log_enabled].
    pub fn set_binary_log_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.binary_log_enabled = v.into();
        self
    }

    /// Sets the value of [replication_log_archiving_enabled][crate::model::BackupConfiguration::replication_log_archiving_enabled].
    pub fn set_replication_log_archiving_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.replication_log_archiving_enabled = v.into();
        self
    }

    /// Sets the value of [location][crate::model::BackupConfiguration::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [point_in_time_recovery_enabled][crate::model::BackupConfiguration::point_in_time_recovery_enabled].
    pub fn set_point_in_time_recovery_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.point_in_time_recovery_enabled = v.into();
        self
    }

    /// Sets the value of [backup_retention_settings][crate::model::BackupConfiguration::backup_retention_settings].
    pub fn set_backup_retention_settings<T: std::convert::Into<std::option::Option<crate::model::BackupRetentionSettings>>>(mut self, v: T) -> Self {
        self.backup_retention_settings = v.into();
        self
    }

    /// Sets the value of [transaction_log_retention_days][crate::model::BackupConfiguration::transaction_log_retention_days].
    pub fn set_transaction_log_retention_days<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.transaction_log_retention_days = v.into();
        self
    }

    /// Sets the value of [transactional_log_storage_state][crate::model::BackupConfiguration::transactional_log_storage_state].
    pub fn set_transactional_log_storage_state<T: std::convert::Into<std::option::Option<crate::model::backup_configuration::TransactionalLogStorageState>>>(mut self, v: T) -> Self {
        self.transactional_log_storage_state = v.into();
        self
    }
}

impl wkt::message::Message for BackupConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupConfiguration"
    }
}

/// Defines additional types related to [BackupConfiguration].
pub mod backup_configuration {
    #[allow(unused_imports)]
    use super::*;


    /// This value contains the storage location of the transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransactionalLogStorageState {
        /// Unspecified.
        Unspecified,
        /// The transaction logs used for PITR for the instance are stored
        /// on a data disk.
        Disk,
        /// The transaction logs used for PITR for the instance are switching from
        /// being stored on a data disk to being stored in Cloud Storage.
        /// Only applicable to MySQL.
        SwitchingToCloudStorage,
        /// The transaction logs used for PITR for the instance are now stored
        /// in Cloud Storage. Previously, they were stored on a data disk.
        /// Only applicable to MySQL.
        SwitchedToCloudStorage,
        /// The transaction logs used for PITR for the instance are stored in
        /// Cloud Storage. Only applicable to MySQL and PostgreSQL.
        CloudStorage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransactionalLogStorageState::value] or
        /// [TransactionalLogStorageState::name].
        UnknownValue(transactional_log_storage_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transactional_log_storage_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransactionalLogStorageState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disk => std::option::Option::Some(1),
                Self::SwitchingToCloudStorage => std::option::Option::Some(2),
                Self::SwitchedToCloudStorage => std::option::Option::Some(3),
                Self::CloudStorage => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED"),
                Self::Disk => std::option::Option::Some("DISK"),
                Self::SwitchingToCloudStorage => std::option::Option::Some("SWITCHING_TO_CLOUD_STORAGE"),
                Self::SwitchedToCloudStorage => std::option::Option::Some("SWITCHED_TO_CLOUD_STORAGE"),
                Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransactionalLogStorageState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransactionalLogStorageState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransactionalLogStorageState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disk,
                2 => Self::SwitchingToCloudStorage,
                3 => Self::SwitchedToCloudStorage,
                4 => Self::CloudStorage,
                _ => Self::UnknownValue(transactional_log_storage_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for TransactionalLogStorageState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED" => Self::Unspecified,
                "DISK" => Self::Disk,
                "SWITCHING_TO_CLOUD_STORAGE" => Self::SwitchingToCloudStorage,
                "SWITCHED_TO_CLOUD_STORAGE" => Self::SwitchedToCloudStorage,
                "CLOUD_STORAGE" => Self::CloudStorage,
                _ => Self::UnknownValue(transactional_log_storage_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for TransactionalLogStorageState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disk => serializer.serialize_i32(1),
                Self::SwitchingToCloudStorage => serializer.serialize_i32(2),
                Self::SwitchedToCloudStorage => serializer.serialize_i32(3),
                Self::CloudStorage => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionalLogStorageState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransactionalLogStorageState>::new(
                ".google.cloud.sql.v1.BackupConfiguration.TransactionalLogStorageState"))
        }
    }
}

/// Perform disk shrink context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PerformDiskShrinkContext {

    /// The target disk shrink size in GigaBytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub target_size_gb: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PerformDiskShrinkContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_size_gb][crate::model::PerformDiskShrinkContext::target_size_gb].
    pub fn set_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.target_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for PerformDiskShrinkContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PerformDiskShrinkContext"
    }
}

/// Backup context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupContext {

    /// The identifier of the backup.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_id: i64,

    /// This is always `sql#backupContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_id][crate::model::BackupContext::backup_id].
    pub fn set_backup_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupContext"
    }
}

/// Represents a SQL database on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Database {

    /// This is always `sql#database`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The Cloud SQL charset value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// The Cloud SQL collation value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name of the database in the Cloud SQL instance. This does not include
    /// the project ID or instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub database_details: std::option::Option<crate::model::database::DatabaseDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Database::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::Database::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Database::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [project][crate::model::Database::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [database_details][crate::model::Database::database_details].
    ///
    /// Note that all the setters affecting `database_details` are mutually
    /// exclusive.
    pub fn set_database_details<T: std::convert::Into<std::option::Option<crate::model::database::DatabaseDetails>>>(mut self, v: T) -> Self
    {
        self.database_details = v.into();
        self
    }

    /// The value of [database_details][crate::model::Database::database_details]
    /// if it holds a `SqlserverDatabaseDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlserver_database_details(&self) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerDatabaseDetails>> {
        #[allow(unreachable_patterns)]
        self.database_details.as_ref().and_then(|v| match v {
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [database_details][crate::model::Database::database_details]
    /// to hold a `SqlserverDatabaseDetails`.
    ///
    /// Note that all the setters affecting `database_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_database_details<T: std::convert::Into<std::boxed::Box<crate::model::SqlServerDatabaseDetails>>>(mut self, v: T) -> Self {
        self.database_details = std::option::Option::Some(
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Database"
    }
}

/// Defines additional types related to [Database].
pub mod database {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DatabaseDetails {
        SqlserverDatabaseDetails(std::boxed::Box<crate::model::SqlServerDatabaseDetails>),
    }
}

/// Represents a Sql Server database on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerDatabaseDetails {

    /// The version of SQL Server with which the database is to be made compatible
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub compatibility_level: i32,

    /// The recovery model of a SQL Server database
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recovery_model: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerDatabaseDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compatibility_level][crate::model::SqlServerDatabaseDetails::compatibility_level].
    pub fn set_compatibility_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compatibility_level = v.into();
        self
    }

    /// Sets the value of [recovery_model][crate::model::SqlServerDatabaseDetails::recovery_model].
    pub fn set_recovery_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recovery_model = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerDatabaseDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerDatabaseDetails"
    }
}

/// Database flags for Cloud SQL instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseFlags {

    /// The name of the flag. These flags are passed at instance startup, so
    /// include both server options and system variables. Flags are
    /// specified with underscores, not hyphens. For more information, see
    /// [Configuring Database Flags](https://cloud.google.com/sql/docs/mysql/flags)
    /// in the Cloud SQL documentation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatabaseFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseFlags"
    }
}

/// MySQL-specific external server sync settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlSyncConfig {

    /// Flags to use for the initial dump.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub initial_sync_flags: std::vec::Vec<crate::model::SyncFlags>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlSyncConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_sync_flags][crate::model::MySqlSyncConfig::initial_sync_flags].
    pub fn set_initial_sync_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SyncFlags>
    {
        use std::iter::Iterator;
        self.initial_sync_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MySqlSyncConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlSyncConfig"
    }
}

/// Initial sync flags for certain Cloud SQL APIs.
/// Currently used for the MySQL external server initial dump.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFlags {

    /// The name of the flag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value of the flag. This field must be omitted if the flag
    /// doesn't take a value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SyncFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::SyncFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for SyncFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SyncFlags"
    }
}

/// Reference to another Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceReference {

    /// The name of the Cloud SQL instance being referenced.
    /// This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The region of the Cloud SQL instance being referenced.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The project ID of the Cloud SQL instance being referenced.
    /// The default is the same project ID as the instance references it.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::InstanceReference::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [project][crate::model::InstanceReference::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstanceReference"
    }
}

/// Read-replica configuration for connecting to the on-premises primary
/// instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterConfiguration {

    /// This is always `sql#demoteMasterConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mysql_replica_configuration: std::option::Option<crate::model::DemoteMasterMySqlReplicaConfiguration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::DemoteMasterConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterMySqlReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.mysql_replica_configuration = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterConfiguration"
    }
}

/// Read-replica configuration specific to MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterMySqlReplicaConfiguration {

    /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The username for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate. The format of the replica's
    /// private key can be either PKCS #1 or PKCS #8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DemoteMasterMySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterMySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::DemoteMasterMySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::DemoteMasterMySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::DemoteMasterMySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterMySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterMySqlReplicaConfiguration"
    }
}

/// Database instance export context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportContext {

    /// The path to the file in Google Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails. If
    /// `fileType` is `SQL` and the filename ends with .gz,
    /// the contents are compressed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Databases to be exported. <br /> `MySQL instances:` If
    /// `fileType` is `SQL` and no database is specified, all
    /// databases are exported, except for the `mysql` system database.
    /// If `fileType` is `CSV`, you can specify one database,
    /// either by using this property or by using the
    /// `csvExportOptions.selectQuery` property, which takes precedence
    /// over this property. <br /> `PostgreSQL instances:` You must specify
    /// one database to be exported. If `fileType` is `CSV`,
    /// this database must match the one specified in the
    /// `csvExportOptions.selectQuery` property. <br /> `SQL Server
    /// instances:` You must specify one database to be exported, and the
    /// `fileType` must be `BAK`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub databases: std::vec::Vec<std::string::String>,

    /// This is always `sql#exportContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Options for exporting data as SQL statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_export_options: std::option::Option<crate::model::export_context::SqlExportOptions>,

    /// Options for exporting data as CSV. `MySQL` and `PostgreSQL`
    /// instances only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub csv_export_options: std::option::Option<crate::model::export_context::SqlCsvExportOptions>,

    /// The file type for the specified uri.
    pub file_type: crate::model::SqlFileType,

    /// Option for export offload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub offload: std::option::Option<wkt::BoolValue>,

    /// Options for exporting data as BAK files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bak_export_options: std::option::Option<crate::model::export_context::SqlBakExportOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ExportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ExportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [sql_export_options][crate::model::ExportContext::sql_export_options].
    pub fn set_sql_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlExportOptions>>>(mut self, v: T) -> Self {
        self.sql_export_options = v.into();
        self
    }

    /// Sets the value of [csv_export_options][crate::model::ExportContext::csv_export_options].
    pub fn set_csv_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlCsvExportOptions>>>(mut self, v: T) -> Self {
        self.csv_export_options = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ExportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [offload][crate::model::ExportContext::offload].
    pub fn set_offload<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.offload = v.into();
        self
    }

    /// Sets the value of [bak_export_options][crate::model::ExportContext::bak_export_options].
    pub fn set_bak_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlBakExportOptions>>>(mut self, v: T) -> Self {
        self.bak_export_options = v.into();
        self
    }

    /// Sets the value of [databases][crate::model::ExportContext::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ExportContext"
    }
}

/// Defines additional types related to [ExportContext].
pub mod export_context {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlCsvExportOptions {

        /// The select query used to extract the data.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub select_query: std::string::String,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub lines_terminated_by: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlCsvExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [select_query][crate::model::export_context::SqlCsvExportOptions::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::export_context::SqlCsvExportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::export_context::SqlCsvExportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::export_context::SqlCsvExportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::export_context::SqlCsvExportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.lines_terminated_by = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlCsvExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlCsvExportOptions"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlExportOptions {

        /// Tables to export, or that were exported, from the specified database. If
        /// you specify tables, specify one and only one database. For PostgreSQL
        /// instances, you can specify only one table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub tables: std::vec::Vec<std::string::String>,

        /// Export only schemas.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schema_only: std::option::Option<wkt::BoolValue>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mysql_export_options: std::option::Option<crate::model::export_context::sql_export_options::MysqlExportOptions>,

        /// Optional. The number of threads to use for parallel export.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the export should be parallel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub postgres_export_options: std::option::Option<crate::model::export_context::sql_export_options::PostgresExportOptions>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema_only][crate::model::export_context::SqlExportOptions::schema_only].
        pub fn set_schema_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.schema_only = v.into();
            self
        }

        /// Sets the value of [mysql_export_options][crate::model::export_context::SqlExportOptions::mysql_export_options].
        pub fn set_mysql_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::sql_export_options::MysqlExportOptions>>>(mut self, v: T) -> Self {
            self.mysql_export_options = v.into();
            self
        }

        /// Sets the value of [threads][crate::model::export_context::SqlExportOptions::threads].
        pub fn set_threads<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.threads = v.into();
            self
        }

        /// Sets the value of [parallel][crate::model::export_context::SqlExportOptions::parallel].
        pub fn set_parallel<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.parallel = v.into();
            self
        }

        /// Sets the value of [postgres_export_options][crate::model::export_context::SqlExportOptions::postgres_export_options].
        pub fn set_postgres_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::sql_export_options::PostgresExportOptions>>>(mut self, v: T) -> Self {
            self.postgres_export_options = v.into();
            self
        }

        /// Sets the value of [tables][crate::model::export_context::SqlExportOptions::tables].
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SqlExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions"
        }
    }

    /// Defines additional types related to [SqlExportOptions].
    pub mod sql_export_options {
        #[allow(unused_imports)]
        use super::*;


        /// Options for exporting from MySQL.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MysqlExportOptions {

            /// Option to include SQL statement required to set up replication. If set
            /// to `1`, the dump file includes a CHANGE MASTER TO statement with the
            /// binary log coordinates, and --set-gtid-purged is set to ON. If set to
            /// `2`, the CHANGE MASTER TO statement is written as a SQL comment and
            /// has no effect. If set to any value other than `1`, --set-gtid-purged
            /// is set to OFF.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub master_data: std::option::Option<wkt::Int32Value>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MysqlExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [master_data][crate::model::export_context::sql_export_options::MysqlExportOptions::master_data].
            pub fn set_master_data<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
                self.master_data = v.into();
                self
            }
        }

        impl wkt::message::Message for MysqlExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.MysqlExportOptions"
            }
        }

        /// Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PostgresExportOptions {

            /// Optional. Use this option to include DROP \<object\> SQL statements.
            /// These statements are used to delete database objects before running the
            /// import operation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. Option to include an IF EXISTS SQL statement with each DROP
            /// statement produced by clean.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub if_exists: std::option::Option<wkt::BoolValue>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PostgresExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::export_context::sql_export_options::PostgresExportOptions::clean].
            pub fn set_clean<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.clean = v.into();
                self
            }

            /// Sets the value of [if_exists][crate::model::export_context::sql_export_options::PostgresExportOptions::if_exists].
            pub fn set_if_exists<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.if_exists = v.into();
                self
            }
        }

        impl wkt::message::Message for PostgresExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.PostgresExportOptions"
            }
        }
    }

    /// Options for exporting BAK files (SQL Server-only)
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlBakExportOptions {

        /// Whether or not the export should be striped.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Option for specifying how many stripes to use for the export.
        /// If blank, and the value of the striped field is true,
        /// the number of stripes is automatically chosen.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stripe_count: std::option::Option<wkt::Int32Value>,

        /// Type of this bak file will be export, FULL or DIFF, SQL Server only
        pub bak_type: crate::model::BakType,

        /// Deprecated: copy_only is deprecated. Use differential_base instead
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[deprecated]
        pub copy_only: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup can be used as a differential base
        /// copy_only backup can not be served as differential base
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub differential_base: std::option::Option<wkt::BoolValue>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlBakExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [striped][crate::model::export_context::SqlBakExportOptions::striped].
        pub fn set_striped<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.striped = v.into();
            self
        }

        /// Sets the value of [stripe_count][crate::model::export_context::SqlBakExportOptions::stripe_count].
        pub fn set_stripe_count<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.stripe_count = v.into();
            self
        }

        /// Sets the value of [bak_type][crate::model::export_context::SqlBakExportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [copy_only][crate::model::export_context::SqlBakExportOptions::copy_only].
        #[deprecated]
        pub fn set_copy_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.copy_only = v.into();
            self
        }

        /// Sets the value of [differential_base][crate::model::export_context::SqlBakExportOptions::differential_base].
        pub fn set_differential_base<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.differential_base = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlBakExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlBakExportOptions"
        }
    }
}

/// Database instance import context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportContext {

    /// Path to the import file in Cloud Storage, in the form
    /// `gs://bucketName/fileName`. Compressed gzip files (.gz) are supported
    /// when `fileType` is `SQL`. The instance must have
    /// write permissions to the bucket and read access to the file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The target database for the import. If `fileType` is `SQL`, this field
    /// is required only if the import file does not specify a database, and is
    /// overridden by any database specification in the import file. If
    /// `fileType` is `CSV`, one database must be specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// This is always `sql#importContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The file type for the specified uri.\`SQL`: The file
    /// contains SQL statements. \`CSV`: The file contains CSV data.
    pub file_type: crate::model::SqlFileType,

    /// Options for importing data as CSV.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub csv_import_options: std::option::Option<crate::model::import_context::SqlCsvImportOptions>,

    /// The PostgreSQL user for this import operation. PostgreSQL instances only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_user: std::string::String,

    /// Import parameters specific to SQL Server .BAK files
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bak_import_options: std::option::Option<crate::model::import_context::SqlBakImportOptions>,

    /// Optional. Options for importing data from SQL statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_import_options: std::option::Option<crate::model::import_context::SqlImportOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ImportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ImportContext::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ImportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ImportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [csv_import_options][crate::model::ImportContext::csv_import_options].
    pub fn set_csv_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlCsvImportOptions>>>(mut self, v: T) -> Self {
        self.csv_import_options = v.into();
        self
    }

    /// Sets the value of [import_user][crate::model::ImportContext::import_user].
    pub fn set_import_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_user = v.into();
        self
    }

    /// Sets the value of [bak_import_options][crate::model::ImportContext::bak_import_options].
    pub fn set_bak_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlBakImportOptions>>>(mut self, v: T) -> Self {
        self.bak_import_options = v.into();
        self
    }

    /// Sets the value of [sql_import_options][crate::model::ImportContext::sql_import_options].
    pub fn set_sql_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlImportOptions>>>(mut self, v: T) -> Self {
        self.sql_import_options = v.into();
        self
    }
}

impl wkt::message::Message for ImportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ImportContext"
    }
}

/// Defines additional types related to [ImportContext].
pub mod import_context {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlImportOptions {

        /// Optional. The number of threads to use for parallel import.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the import should be parallel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for importing from a Cloud SQL for PostgreSQL instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub postgres_import_options: std::option::Option<crate::model::import_context::sql_import_options::PostgresImportOptions>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threads][crate::model::import_context::SqlImportOptions::threads].
        pub fn set_threads<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.threads = v.into();
            self
        }

        /// Sets the value of [parallel][crate::model::import_context::SqlImportOptions::parallel].
        pub fn set_parallel<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.parallel = v.into();
            self
        }

        /// Sets the value of [postgres_import_options][crate::model::import_context::SqlImportOptions::postgres_import_options].
        pub fn set_postgres_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::sql_import_options::PostgresImportOptions>>>(mut self, v: T) -> Self {
            self.postgres_import_options = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions"
        }
    }

    /// Defines additional types related to [SqlImportOptions].
    pub mod sql_import_options {
        #[allow(unused_imports)]
        use super::*;


        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PostgresImportOptions {

            /// Optional. The --clean flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. The --if-exists flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub if_exists: std::option::Option<wkt::BoolValue>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PostgresImportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::import_context::sql_import_options::PostgresImportOptions::clean].
            pub fn set_clean<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.clean = v.into();
                self
            }

            /// Sets the value of [if_exists][crate::model::import_context::sql_import_options::PostgresImportOptions::if_exists].
            pub fn set_if_exists<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.if_exists = v.into();
                self
            }
        }

        impl wkt::message::Message for PostgresImportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions.PostgresImportOptions"
            }
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlCsvImportOptions {

        /// The table to which CSV data is imported.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        /// The columns to which CSV data is imported. If not specified, all columns
        /// of the database table are loaded with CSV data.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub columns: std::vec::Vec<std::string::String>,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub lines_terminated_by: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlCsvImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::import_context::SqlCsvImportOptions::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::import_context::SqlCsvImportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::import_context::SqlCsvImportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::import_context::SqlCsvImportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::import_context::SqlCsvImportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.lines_terminated_by = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::import_context::SqlCsvImportOptions::columns].
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SqlCsvImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlCsvImportOptions"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlBakImportOptions {

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub encryption_options: std::option::Option<crate::model::import_context::sql_bak_import_options::EncryptionOptions>,

        /// Whether or not the backup set being restored is striped.
        /// Applies only to Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing will restore database
        /// with NORECOVERY option
        /// Applies only to Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub no_recovery: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing request will just bring database
        /// online without downloading Bak content only one of "no_recovery" and
        /// "recovery_only" can be true otherwise error will return. Applies only to
        /// Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub recovery_only: std::option::Option<wkt::BoolValue>,

        /// Type of the bak content, FULL or DIFF
        pub bak_type: crate::model::BakType,

        /// Optional. The timestamp when the import should stop. This timestamp is in
        /// the [RFC 3339](https://tools.ietf.org/html/rfc3339) format (for example,
        /// `2023-10-01T16:19:00.094`). This field is equivalent to the STOPAT
        /// keyword and applies to Cloud SQL for SQL Server only.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stop_at: std::option::Option<wkt::Timestamp>,

        /// Optional. The marked transaction where the import should stop. This field
        /// is equivalent to the STOPATMARK keyword and applies to Cloud SQL for SQL
        /// Server only.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub stop_at_mark: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlBakImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encryption_options][crate::model::import_context::SqlBakImportOptions::encryption_options].
        pub fn set_encryption_options<T: std::convert::Into<std::option::Option<crate::model::import_context::sql_bak_import_options::EncryptionOptions>>>(mut self, v: T) -> Self {
            self.encryption_options = v.into();
            self
        }

        /// Sets the value of [striped][crate::model::import_context::SqlBakImportOptions::striped].
        pub fn set_striped<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.striped = v.into();
            self
        }

        /// Sets the value of [no_recovery][crate::model::import_context::SqlBakImportOptions::no_recovery].
        pub fn set_no_recovery<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.no_recovery = v.into();
            self
        }

        /// Sets the value of [recovery_only][crate::model::import_context::SqlBakImportOptions::recovery_only].
        pub fn set_recovery_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.recovery_only = v.into();
            self
        }

        /// Sets the value of [bak_type][crate::model::import_context::SqlBakImportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [stop_at][crate::model::import_context::SqlBakImportOptions::stop_at].
        pub fn set_stop_at<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.stop_at = v.into();
            self
        }

        /// Sets the value of [stop_at_mark][crate::model::import_context::SqlBakImportOptions::stop_at_mark].
        pub fn set_stop_at_mark<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stop_at_mark = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlBakImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions"
        }
    }

    /// Defines additional types related to [SqlBakImportOptions].
    pub mod sql_bak_import_options {
        #[allow(unused_imports)]
        use super::*;


        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EncryptionOptions {

            /// Path to the Certificate (.cer) in Cloud Storage, in the form
            /// `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub cert_path: std::string::String,

            /// Path to the Certificate Private Key (.pvk)  in Cloud Storage, in the
            /// form `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub pvk_path: std::string::String,

            /// Password that encrypts the private key
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub pvk_password: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cert_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::cert_path].
            pub fn set_cert_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.cert_path = v.into();
                self
            }

            /// Sets the value of [pvk_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_path].
            pub fn set_pvk_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.pvk_path = v.into();
                self
            }

            /// Sets the value of [pvk_password][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_password].
            pub fn set_pvk_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.pvk_password = v.into();
                self
            }
        }

        impl wkt::message::Message for EncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions.EncryptionOptions"
            }
        }
    }
}

/// IP Management configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IpConfiguration {

    /// Whether the instance is assigned a public IP address or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ipv4_enabled: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_network: std::string::String,

    /// Use `ssl_mode` instead.
    ///
    /// Whether SSL/TLS connections over IP are enforced.
    /// If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections.
    /// For SSL/TLS connections, the client certificate won't be verified. If
    /// set to true, then only allow connections encrypted with SSL/TLS and with
    /// valid client certificates. If you want to enforce SSL/TLS without enforcing
    /// the requirement for valid client certificates, then use the `ssl_mode` flag
    /// instead of the `require_ssl` flag.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. In 'CIDR' notation, also known as 'slash' notation (for
    /// example: `157.197.200.0/24`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<crate::model::AclEntry>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the instance ip
    /// will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// `[a-z]([-a-z0-9]*[a-z0-9])?.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// Controls connectivity to private IP instances from Google services,
    /// such as BigQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_private_path_for_google_cloud_services: std::option::Option<wkt::BoolValue>,

    /// Specify how SSL/TLS is enforced in database connections. If you must use
    /// the `require_ssl` flag for backward compatibility, then only the following
    /// value pairs are valid:
    ///
    /// For PostgreSQL and MySQL:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`
    /// * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true`
    ///
    /// For SQL Server:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=true`
    ///
    /// The value of `ssl_mode` has priority over the value of `require_ssl`.
    ///
    /// For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and
    /// `require_ssl=false`, `ssl_mode=ENCRYPTED_ONLY` means accept only SSL
    /// connections, while `require_ssl=false` means accept both non-SSL
    /// and SSL connections. In this case, MySQL and PostgreSQL databases respect
    /// `ssl_mode` and accepts only SSL connections.
    pub ssl_mode: crate::model::ip_configuration::SslMode,

    /// PSC settings for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_config: std::option::Option<crate::model::PscConfig>,

    /// Specify what type of CA is used for the server certificate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_mode: std::option::Option<crate::model::ip_configuration::CaMode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ipv4_enabled][crate::model::IpConfiguration::ipv4_enabled].
    pub fn set_ipv4_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.ipv4_enabled = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::IpConfiguration::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::IpConfiguration::require_ssl].
    pub fn set_require_ssl<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.require_ssl = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::IpConfiguration::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [enable_private_path_for_google_cloud_services][crate::model::IpConfiguration::enable_private_path_for_google_cloud_services].
    pub fn set_enable_private_path_for_google_cloud_services<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_private_path_for_google_cloud_services = v.into();
        self
    }

    /// Sets the value of [ssl_mode][crate::model::IpConfiguration::ssl_mode].
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ip_configuration::SslMode>>(mut self, v: T) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::IpConfiguration::psc_config].
    pub fn set_psc_config<T: std::convert::Into<std::option::Option<crate::model::PscConfig>>>(mut self, v: T) -> Self {
        self.psc_config = v.into();
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::IpConfiguration::server_ca_mode].
    pub fn set_server_ca_mode<T: std::convert::Into<std::option::Option<crate::model::ip_configuration::CaMode>>>(mut self, v: T) -> Self {
        self.server_ca_mode = v.into();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::IpConfiguration::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AclEntry>
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IpConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpConfiguration"
    }
}

/// Defines additional types related to [IpConfiguration].
pub mod ip_configuration {
    #[allow(unused_imports)]
    use super::*;


    /// The SSL options for database connections.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslMode {
        /// The SSL mode is unknown.
        Unspecified,
        /// Allow non-SSL/non-TLS and SSL/TLS connections.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        AllowUnencryptedAndEncrypted,
        /// Only allow connections encrypted with SSL/TLS.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        EncryptedOnly,
        /// Only allow connections encrypted with SSL/TLS and with valid
        /// client certificates.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be true or
        /// cleared to avoid the conflict between values of two flags.
        /// PostgreSQL clients or users that connect using IAM database
        /// authentication must use either the
        /// [Cloud SQL Auth
        /// Proxy](https://cloud.google.com/sql/docs/postgres/connect-auth-proxy) or
        /// [Cloud SQL
        /// Connectors](https://cloud.google.com/sql/docs/postgres/connect-connectors)
        /// to enforce client identity verification.
        ///
        /// Only applicable to MySQL and PostgreSQL. Not applicable to SQL Server.
        TrustedClientCertificateRequired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslMode::value] or
        /// [SslMode::name].
        UnknownValue(ssl_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllowUnencryptedAndEncrypted => std::option::Option::Some(1),
                Self::EncryptedOnly => std::option::Option::Some(2),
                Self::TrustedClientCertificateRequired => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MODE_UNSPECIFIED"),
                Self::AllowUnencryptedAndEncrypted => std::option::Option::Some("ALLOW_UNENCRYPTED_AND_ENCRYPTED"),
                Self::EncryptedOnly => std::option::Option::Some("ENCRYPTED_ONLY"),
                Self::TrustedClientCertificateRequired => std::option::Option::Some("TRUSTED_CLIENT_CERTIFICATE_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllowUnencryptedAndEncrypted,
                2 => Self::EncryptedOnly,
                3 => Self::TrustedClientCertificateRequired,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SslMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MODE_UNSPECIFIED" => Self::Unspecified,
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => Self::AllowUnencryptedAndEncrypted,
                "ENCRYPTED_ONLY" => Self::EncryptedOnly,
                "TRUSTED_CLIENT_CERTIFICATE_REQUIRED" => Self::TrustedClientCertificateRequired,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SslMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllowUnencryptedAndEncrypted => serializer.serialize_i32(1),
                Self::EncryptedOnly => serializer.serialize_i32(2),
                Self::TrustedClientCertificateRequired => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslMode>::new(
                ".google.cloud.sql.v1.IpConfiguration.SslMode"))
        }
    }

    /// Various Certificate Authority (CA) modes for certificate signing.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaMode::value] or
        /// [CaMode::name].
        UnknownValue(ca_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleManagedInternalCa => std::option::Option::Some(1),
                Self::GoogleManagedCasCa => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_MODE_UNSPECIFIED"),
                Self::GoogleManagedInternalCa => std::option::Option::Some("GOOGLE_MANAGED_INTERNAL_CA"),
                Self::GoogleManagedCasCa => std::option::Option::Some("GOOGLE_MANAGED_CAS_CA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleManagedInternalCa,
                2 => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for CaMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_MODE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_MANAGED_INTERNAL_CA" => Self::GoogleManagedInternalCa,
                "GOOGLE_MANAGED_CAS_CA" => Self::GoogleManagedCasCa,
                _ => Self::UnknownValue(ca_mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleManagedInternalCa => serializer.serialize_i32(1),
                Self::GoogleManagedCasCa => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaMode>::new(
                ".google.cloud.sql.v1.IpConfiguration.CaMode"))
        }
    }
}

/// PSC settings for a Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConfig {

    /// Whether PSC connectivity is enabled for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_enabled: std::option::Option<bool>,

    /// Optional. The list of consumer projects that are allow-listed for PSC
    /// connections to this instance. This instance can be connected to with PSC
    /// from any network in these projects.
    ///
    /// Each consumer project in this list may be represented by a project number
    /// (numeric) or by a project id (alphanumeric).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_consumer_projects: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_enabled][crate::model::PscConfig::psc_enabled].
    pub fn set_psc_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.psc_enabled = v.into();
        self
    }

    /// Sets the value of [allowed_consumer_projects][crate::model::PscConfig::allowed_consumer_projects].
    pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PscConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PscConfig"
    }
}

/// Preferred location. This specifies where a Cloud SQL instance is located.
/// Note that if the preferred location is not available, the instance will be
/// located as close as possible within the region. Only one location may be
/// specified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationPreference {

    /// The App Engine application to follow, it must be in the same region as the
    /// Cloud SQL instance. WARNING: Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub follow_gae_application: std::string::String,

    /// The preferred Compute Engine zone (for example: us-central1-a,
    /// us-central1-b, etc.). WARNING: Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// The preferred Compute Engine zone for the secondary/failover
    /// (for example: us-central1-a, us-central1-b, etc.).
    /// To disable this field, set it to 'no_secondary_zone'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_zone: std::string::String,

    /// This is always `sql#locationPreference`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationPreference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [follow_gae_application][crate::model::LocationPreference::follow_gae_application].
    #[deprecated]
    pub fn set_follow_gae_application<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.follow_gae_application = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::LocationPreference::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::LocationPreference::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::LocationPreference::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for LocationPreference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.LocationPreference"
    }
}

/// Maintenance window. This specifies when a Cloud SQL instance is
/// restarted for system maintenance purposes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {

    /// Hour of day - 0 to 23. Specify in the UTC time zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hour: std::option::Option<wkt::Int32Value>,

    /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
    /// `SATURDAY`, or `SUNDAY`. Specify in the UTC time zone.
    /// Returned in output as an integer, 1 to 7, where `1` equals Monday.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub day: std::option::Option<wkt::Int32Value>,

    /// Maintenance timing settings: `canary`, `stable`, or `week5`.
    /// For more information, see [About maintenance on Cloud SQL
    /// instances](https://cloud.google.com/sql/docs/mysql/maintenance).
    pub update_track: crate::model::SqlUpdateTrack,

    /// This is always `sql#maintenanceWindow`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hour][crate::model::MaintenanceWindow::hour].
    pub fn set_hour<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.hour = v.into();
        self
    }

    /// Sets the value of [day][crate::model::MaintenanceWindow::day].
    pub fn set_day<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [update_track][crate::model::MaintenanceWindow::update_track].
    pub fn set_update_track<T: std::convert::Into<crate::model::SqlUpdateTrack>>(mut self, v: T) -> Self {
        self.update_track = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::MaintenanceWindow::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MaintenanceWindow"
    }
}

/// Deny maintenance Periods. This specifies a date range during when all CSA
/// rollout will be denied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DenyMaintenancePeriod {

    /// "deny maintenance period" start date. If the year of the start date is
    /// empty, the year of the end date also must be empty. In this case, it means
    /// the deny maintenance period recurs every year. The date is in format
    /// yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_date: std::string::String,

    /// "deny maintenance period" end date. If the year of the end date is empty,
    /// the year of the start date also must be empty. In this case, it means the
    /// no maintenance interval recurs every year. The date is in format yyyy-mm-dd
    /// i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub end_date: std::string::String,

    /// Time in UTC when the "deny maintenance period" starts on start_date and
    /// ends on end_date. The time is in format: HH:mm:SS, i.e., 00:00:00
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DenyMaintenancePeriod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_date][crate::model::DenyMaintenancePeriod::start_date].
    pub fn set_start_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_date = v.into();
        self
    }

    /// Sets the value of [end_date][crate::model::DenyMaintenancePeriod::end_date].
    pub fn set_end_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_date = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DenyMaintenancePeriod::time].
    pub fn set_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time = v.into();
        self
    }
}

impl wkt::message::Message for DenyMaintenancePeriod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DenyMaintenancePeriod"
    }
}

/// Insights configuration. This specifies when Cloud SQL Insights feature is
/// enabled and optional configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightsConfig {

    /// Whether Query Insights feature is enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub query_insights_enabled: bool,

    /// Whether Query Insights will record client address when enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub record_client_address: bool,

    /// Whether Query Insights will record application tags from query when
    /// enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub record_application_tags: bool,

    /// Maximum query length stored in bytes. Default value: 1024 bytes.
    /// Range: 256-4500 bytes. Query length more than this field value will be
    /// truncated to this value. When unset, query length will be the default
    /// value. Changing query length will restart the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_string_length: std::option::Option<wkt::Int32Value>,

    /// Number of query execution plans captured by Insights per minute
    /// for all queries combined. Default is 5.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_plans_per_minute: std::option::Option<wkt::Int32Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_insights_enabled][crate::model::InsightsConfig::query_insights_enabled].
    pub fn set_query_insights_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.query_insights_enabled = v.into();
        self
    }

    /// Sets the value of [record_client_address][crate::model::InsightsConfig::record_client_address].
    pub fn set_record_client_address<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_client_address = v.into();
        self
    }

    /// Sets the value of [record_application_tags][crate::model::InsightsConfig::record_application_tags].
    pub fn set_record_application_tags<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_application_tags = v.into();
        self
    }

    /// Sets the value of [query_string_length][crate::model::InsightsConfig::query_string_length].
    pub fn set_query_string_length<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.query_string_length = v.into();
        self
    }

    /// Sets the value of [query_plans_per_minute][crate::model::InsightsConfig::query_plans_per_minute].
    pub fn set_query_plans_per_minute<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.query_plans_per_minute = v.into();
        self
    }
}

impl wkt::message::Message for InsightsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InsightsConfig"
    }
}

/// Read-replica configuration specific to MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlReplicaConfiguration {

    /// Path to a SQL dump file in Google Cloud Storage from which the replica
    /// instance is to be created. The URI is in the form gs://bucketName/fileName.
    /// Compressed gzip files (.gz) are also supported.
    /// Dumps have the binlog co-ordinates from which replication
    /// begins. This can be accomplished by setting --master-data to 1 when using
    /// mysqldump.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_file_path: std::string::String,

    /// The username for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Seconds to wait between connect retries. MySQL's default is 60 seconds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connect_retry_interval: std::option::Option<wkt::Int32Value>,

    /// Interval in milliseconds between replication heartbeats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub master_heartbeat_period: std::option::Option<wkt::Int64Value>,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// A list of permissible ciphers to use for SSL encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_cipher: std::string::String,

    /// Whether or not to check the primary instance's Common Name value in the
    /// certificate that it sends during the SSL handshake.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_server_certificate: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#mysqlReplicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dump_file_path][crate::model::MySqlReplicaConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [connect_retry_interval][crate::model::MySqlReplicaConfiguration::connect_retry_interval].
    pub fn set_connect_retry_interval<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.connect_retry_interval = v.into();
        self
    }

    /// Sets the value of [master_heartbeat_period][crate::model::MySqlReplicaConfiguration::master_heartbeat_period].
    pub fn set_master_heartbeat_period<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.master_heartbeat_period = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::MySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::MySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [ssl_cipher][crate::model::MySqlReplicaConfiguration::ssl_cipher].
    pub fn set_ssl_cipher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_cipher = v.into();
        self
    }

    /// Sets the value of [verify_server_certificate][crate::model::MySqlReplicaConfiguration::verify_server_certificate].
    pub fn set_verify_server_certificate<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.verify_server_certificate = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::MySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlReplicaConfiguration"
    }
}

/// Disk encryption configuration for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEncryptionConfiguration {

    /// Resource name of KMS key for disk encryption
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// This is always `sql#diskEncryptionConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::DiskEncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionConfiguration"
    }
}

/// Disk encryption status for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEncryptionStatus {

    /// KMS key version used to encrypt the Cloud SQL instance resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    /// This is always `sql#diskEncryptionStatus`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskEncryptionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::DiskEncryptionStatus::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionStatus::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionStatus"
    }
}

/// Database instance IP mapping
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IpMapping {

    /// The type of this IP address. A `PRIMARY` address is a public address that
    /// can accept incoming connections. A `PRIVATE` address is a private address
    /// that can accept incoming connections. An `OUTGOING` address is the source
    /// address of connections originating from the instance, if supported.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlIpAddressType,

    /// The IP address assigned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// The due time for this IP to be retired in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`. This field is only available when
    /// the IP is scheduled to be retired.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_to_retire: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::IpMapping::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlIpAddressType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::IpMapping::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [time_to_retire][crate::model::IpMapping::time_to_retire].
    pub fn set_time_to_retire<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.time_to_retire = v.into();
        self
    }
}

impl wkt::message::Message for IpMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpMapping"
    }
}

/// An Operation resource.&nbsp;For successful operations that return an
/// Operation resource, only the fields relevant to the operation are populated
/// in the resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Operation {

    /// This is always `sql#operation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_link: std::string::String,

    /// The status of an operation.
    pub status: crate::model::operation::SqlOperationStatus,

    /// The email address of the user who initiated this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// The time this operation was enqueued in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation actually started in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation finished in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// If errors occurred during processing of this operation, this field will be
    /// populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::OperationErrors>,

    /// An Admin API warning message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_warning: std::option::Option<crate::model::ApiWarning>,

    /// The type of the operation. Valid values are:
    ///
    /// * `CREATE`
    /// * `DELETE`
    /// * `UPDATE`
    /// * `RESTART`
    /// * `IMPORT`
    /// * `EXPORT`
    /// * `BACKUP_VOLUME`
    /// * `RESTORE_VOLUME`
    /// * `CREATE_USER`
    /// * `DELETE_USER`
    /// * `CREATE_DATABASE`
    /// * `DELETE_DATABASE`
    pub operation_type: crate::model::operation::SqlOperationType,

    /// The context for import operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_context: std::option::Option<crate::model::ImportContext>,

    /// The context for export operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_context: std::option::Option<crate::model::ExportContext>,

    /// The context for backup operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_context: std::option::Option<crate::model::BackupContext>,

    /// An identifier that uniquely identifies the operation. You can use this
    /// identifier to retrieve the Operations resource that has information about
    /// the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Name of the database instance related to this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_id: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// The project ID of the target instance related to this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_project: std::string::String,

    /// The context for acquire SSRS lease operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Operation::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_link = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::SqlOperationStatus>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Operation::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_insert_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.insert_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<crate::model::OperationErrors>>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [api_warning][crate::model::Operation::api_warning].
    pub fn set_api_warning<T: std::convert::Into<std::option::Option<crate::model::ApiWarning>>>(mut self, v: T) -> Self {
        self.api_warning = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation::SqlOperationType>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [import_context][crate::model::Operation::import_context].
    pub fn set_import_context<T: std::convert::Into<std::option::Option<crate::model::ImportContext>>>(mut self, v: T) -> Self {
        self.import_context = v.into();
        self
    }

    /// Sets the value of [export_context][crate::model::Operation::export_context].
    pub fn set_export_context<T: std::convert::Into<std::option::Option<crate::model::ExportContext>>>(mut self, v: T) -> Self {
        self.export_context = v.into();
        self
    }

    /// Sets the value of [backup_context][crate::model::Operation::backup_context].
    pub fn set_backup_context<T: std::convert::Into<std::option::Option<crate::model::BackupContext>>>(mut self, v: T) -> Self {
        self.backup_context = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::Operation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::Operation::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::Operation::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T: std::convert::Into<std::option::Option<crate::model::AcquireSsrsLeaseContext>>>(mut self, v: T) -> Self {
        self.acquire_ssrs_lease_context = v.into();
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Operation"
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;


    /// The type of Cloud SQL operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlOperationType {
        /// Unknown operation type.
        Unspecified,
        /// Imports data into a Cloud SQL instance.
        Import,
        /// Exports data from a Cloud SQL instance to a Cloud Storage
        /// bucket.
        Export,
        /// Creates a new Cloud SQL instance.
        Create,
        /// Updates the settings of a Cloud SQL instance.
        Update,
        /// Deletes a Cloud SQL instance.
        Delete,
        /// Restarts the Cloud SQL instance.
        Restart,
        #[deprecated]
        Backup,
        #[deprecated]
        Snapshot,
        /// Performs instance backup.
        BackupVolume,
        /// Deletes an instance backup.
        DeleteVolume,
        /// Restores an instance backup.
        RestoreVolume,
        /// Injects a privileged user in mysql for MOB instances.
        InjectUser,
        /// Clones a Cloud SQL instance.
        Clone,
        /// Stops replication on a Cloud SQL read replica instance.
        StopReplica,
        /// Starts replication on a Cloud SQL read replica instance.
        StartReplica,
        /// Promotes a Cloud SQL replica instance.
        PromoteReplica,
        /// Creates a Cloud SQL replica instance.
        CreateReplica,
        /// Creates a new user in a Cloud SQL instance.
        CreateUser,
        /// Deletes a user from a Cloud SQL instance.
        DeleteUser,
        /// Updates an existing user in a Cloud SQL instance.
        UpdateUser,
        /// Creates a database in the Cloud SQL instance.
        CreateDatabase,
        /// Deletes a database in the Cloud SQL instance.
        DeleteDatabase,
        /// Updates a database in the Cloud SQL instance.
        UpdateDatabase,
        /// Performs failover of an HA-enabled Cloud SQL
        /// failover replica.
        Failover,
        /// Deletes the backup taken by a backup run.
        DeleteBackup,
        RecreateReplica,
        /// Truncates a general or slow log table in MySQL.
        TruncateLog,
        /// Demotes the stand-alone instance to be a Cloud SQL
        /// read replica for an external database server.
        DemoteMaster,
        /// Indicates that the instance is currently in maintenance. Maintenance
        /// typically causes the instance to be unavailable for 1-3 minutes.
        Maintenance,
        /// This field is deprecated, and will be removed in future version of API.
        #[deprecated]
        EnablePrivateIp,
        #[deprecated]
        DeferMaintenance,
        /// Creates clone instance.
        #[deprecated]
        CreateClone,
        /// Reschedule maintenance to another time.
        RescheduleMaintenance,
        /// Starts external sync of a Cloud SQL EM replica to an external primary
        /// instance.
        StartExternalSync,
        /// Recovers logs from an instance's old data disk.
        LogCleanup,
        /// Performs auto-restart of an HA-enabled Cloud SQL database for auto
        /// recovery.
        AutoRestart,
        /// Re-encrypts CMEK instances with latest key version.
        Reencrypt,
        /// Switches the roles of the primary and replica pair. The target instance
        /// should be the replica.
        Switchover,
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        AcquireSsrsLease,
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        ReleaseSsrsLease,
        /// Reconfigures old primary after a promote replica operation. Effect of a
        /// promote operation to the old primary is executed in this operation,
        /// asynchronously from the promote replica operation executed to the
        /// replica.
        ReconfigureOldPrimary,
        /// Indicates that the instance, its read replicas, and its cascading
        /// replicas are in maintenance. Maintenance typically gets initiated on
        /// groups of replicas first, followed by the primary instance. For each
        /// instance, maintenance typically causes the instance to be unavailable for
        /// 1-3 minutes.
        ClusterMaintenance,
        /// Indicates that the instance (and any of its replicas) are currently in
        /// maintenance. This is initiated as a self-service request by using SSM.
        /// Maintenance typically causes the instance to be unavailable for 1-3
        /// minutes.
        SelfServiceMaintenance,
        /// Switches a primary instance to a replica. This operation runs as part of
        /// a switchover operation to the original primary instance.
        SwitchoverToReplica,
        /// Updates the major version of a Cloud SQL instance.
        MajorVersionUpgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlOperationType::value] or
        /// [SqlOperationType::name].
        UnknownValue(sql_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Import => std::option::Option::Some(1),
                Self::Export => std::option::Option::Some(2),
                Self::Create => std::option::Option::Some(3),
                Self::Update => std::option::Option::Some(4),
                Self::Delete => std::option::Option::Some(5),
                Self::Restart => std::option::Option::Some(6),
                Self::Backup => std::option::Option::Some(7),
                Self::Snapshot => std::option::Option::Some(8),
                Self::BackupVolume => std::option::Option::Some(9),
                Self::DeleteVolume => std::option::Option::Some(10),
                Self::RestoreVolume => std::option::Option::Some(11),
                Self::InjectUser => std::option::Option::Some(12),
                Self::Clone => std::option::Option::Some(14),
                Self::StopReplica => std::option::Option::Some(15),
                Self::StartReplica => std::option::Option::Some(16),
                Self::PromoteReplica => std::option::Option::Some(17),
                Self::CreateReplica => std::option::Option::Some(18),
                Self::CreateUser => std::option::Option::Some(19),
                Self::DeleteUser => std::option::Option::Some(20),
                Self::UpdateUser => std::option::Option::Some(21),
                Self::CreateDatabase => std::option::Option::Some(22),
                Self::DeleteDatabase => std::option::Option::Some(23),
                Self::UpdateDatabase => std::option::Option::Some(24),
                Self::Failover => std::option::Option::Some(25),
                Self::DeleteBackup => std::option::Option::Some(26),
                Self::RecreateReplica => std::option::Option::Some(27),
                Self::TruncateLog => std::option::Option::Some(28),
                Self::DemoteMaster => std::option::Option::Some(29),
                Self::Maintenance => std::option::Option::Some(30),
                Self::EnablePrivateIp => std::option::Option::Some(31),
                Self::DeferMaintenance => std::option::Option::Some(32),
                Self::CreateClone => std::option::Option::Some(33),
                Self::RescheduleMaintenance => std::option::Option::Some(34),
                Self::StartExternalSync => std::option::Option::Some(35),
                Self::LogCleanup => std::option::Option::Some(36),
                Self::AutoRestart => std::option::Option::Some(37),
                Self::Reencrypt => std::option::Option::Some(38),
                Self::Switchover => std::option::Option::Some(39),
                Self::AcquireSsrsLease => std::option::Option::Some(42),
                Self::ReleaseSsrsLease => std::option::Option::Some(43),
                Self::ReconfigureOldPrimary => std::option::Option::Some(44),
                Self::ClusterMaintenance => std::option::Option::Some(45),
                Self::SelfServiceMaintenance => std::option::Option::Some(46),
                Self::SwitchoverToReplica => std::option::Option::Some(47),
                Self::MajorVersionUpgrade => std::option::Option::Some(48),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_OPERATION_TYPE_UNSPECIFIED"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::Export => std::option::Option::Some("EXPORT"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::Backup => std::option::Option::Some("BACKUP"),
                Self::Snapshot => std::option::Option::Some("SNAPSHOT"),
                Self::BackupVolume => std::option::Option::Some("BACKUP_VOLUME"),
                Self::DeleteVolume => std::option::Option::Some("DELETE_VOLUME"),
                Self::RestoreVolume => std::option::Option::Some("RESTORE_VOLUME"),
                Self::InjectUser => std::option::Option::Some("INJECT_USER"),
                Self::Clone => std::option::Option::Some("CLONE"),
                Self::StopReplica => std::option::Option::Some("STOP_REPLICA"),
                Self::StartReplica => std::option::Option::Some("START_REPLICA"),
                Self::PromoteReplica => std::option::Option::Some("PROMOTE_REPLICA"),
                Self::CreateReplica => std::option::Option::Some("CREATE_REPLICA"),
                Self::CreateUser => std::option::Option::Some("CREATE_USER"),
                Self::DeleteUser => std::option::Option::Some("DELETE_USER"),
                Self::UpdateUser => std::option::Option::Some("UPDATE_USER"),
                Self::CreateDatabase => std::option::Option::Some("CREATE_DATABASE"),
                Self::DeleteDatabase => std::option::Option::Some("DELETE_DATABASE"),
                Self::UpdateDatabase => std::option::Option::Some("UPDATE_DATABASE"),
                Self::Failover => std::option::Option::Some("FAILOVER"),
                Self::DeleteBackup => std::option::Option::Some("DELETE_BACKUP"),
                Self::RecreateReplica => std::option::Option::Some("RECREATE_REPLICA"),
                Self::TruncateLog => std::option::Option::Some("TRUNCATE_LOG"),
                Self::DemoteMaster => std::option::Option::Some("DEMOTE_MASTER"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::EnablePrivateIp => std::option::Option::Some("ENABLE_PRIVATE_IP"),
                Self::DeferMaintenance => std::option::Option::Some("DEFER_MAINTENANCE"),
                Self::CreateClone => std::option::Option::Some("CREATE_CLONE"),
                Self::RescheduleMaintenance => std::option::Option::Some("RESCHEDULE_MAINTENANCE"),
                Self::StartExternalSync => std::option::Option::Some("START_EXTERNAL_SYNC"),
                Self::LogCleanup => std::option::Option::Some("LOG_CLEANUP"),
                Self::AutoRestart => std::option::Option::Some("AUTO_RESTART"),
                Self::Reencrypt => std::option::Option::Some("REENCRYPT"),
                Self::Switchover => std::option::Option::Some("SWITCHOVER"),
                Self::AcquireSsrsLease => std::option::Option::Some("ACQUIRE_SSRS_LEASE"),
                Self::ReleaseSsrsLease => std::option::Option::Some("RELEASE_SSRS_LEASE"),
                Self::ReconfigureOldPrimary => std::option::Option::Some("RECONFIGURE_OLD_PRIMARY"),
                Self::ClusterMaintenance => std::option::Option::Some("CLUSTER_MAINTENANCE"),
                Self::SelfServiceMaintenance => std::option::Option::Some("SELF_SERVICE_MAINTENANCE"),
                Self::SwitchoverToReplica => std::option::Option::Some("SWITCHOVER_TO_REPLICA"),
                Self::MajorVersionUpgrade => std::option::Option::Some("MAJOR_VERSION_UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Import,
                2 => Self::Export,
                3 => Self::Create,
                4 => Self::Update,
                5 => Self::Delete,
                6 => Self::Restart,
                7 => Self::Backup,
                8 => Self::Snapshot,
                9 => Self::BackupVolume,
                10 => Self::DeleteVolume,
                11 => Self::RestoreVolume,
                12 => Self::InjectUser,
                14 => Self::Clone,
                15 => Self::StopReplica,
                16 => Self::StartReplica,
                17 => Self::PromoteReplica,
                18 => Self::CreateReplica,
                19 => Self::CreateUser,
                20 => Self::DeleteUser,
                21 => Self::UpdateUser,
                22 => Self::CreateDatabase,
                23 => Self::DeleteDatabase,
                24 => Self::UpdateDatabase,
                25 => Self::Failover,
                26 => Self::DeleteBackup,
                27 => Self::RecreateReplica,
                28 => Self::TruncateLog,
                29 => Self::DemoteMaster,
                30 => Self::Maintenance,
                31 => Self::EnablePrivateIp,
                32 => Self::DeferMaintenance,
                33 => Self::CreateClone,
                34 => Self::RescheduleMaintenance,
                35 => Self::StartExternalSync,
                36 => Self::LogCleanup,
                37 => Self::AutoRestart,
                38 => Self::Reencrypt,
                39 => Self::Switchover,
                42 => Self::AcquireSsrsLease,
                43 => Self::ReleaseSsrsLease,
                44 => Self::ReconfigureOldPrimary,
                45 => Self::ClusterMaintenance,
                46 => Self::SelfServiceMaintenance,
                47 => Self::SwitchoverToReplica,
                48 => Self::MajorVersionUpgrade,
                _ => Self::UnknownValue(sql_operation_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT" => Self::Import,
                "EXPORT" => Self::Export,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "RESTART" => Self::Restart,
                "BACKUP" => Self::Backup,
                "SNAPSHOT" => Self::Snapshot,
                "BACKUP_VOLUME" => Self::BackupVolume,
                "DELETE_VOLUME" => Self::DeleteVolume,
                "RESTORE_VOLUME" => Self::RestoreVolume,
                "INJECT_USER" => Self::InjectUser,
                "CLONE" => Self::Clone,
                "STOP_REPLICA" => Self::StopReplica,
                "START_REPLICA" => Self::StartReplica,
                "PROMOTE_REPLICA" => Self::PromoteReplica,
                "CREATE_REPLICA" => Self::CreateReplica,
                "CREATE_USER" => Self::CreateUser,
                "DELETE_USER" => Self::DeleteUser,
                "UPDATE_USER" => Self::UpdateUser,
                "CREATE_DATABASE" => Self::CreateDatabase,
                "DELETE_DATABASE" => Self::DeleteDatabase,
                "UPDATE_DATABASE" => Self::UpdateDatabase,
                "FAILOVER" => Self::Failover,
                "DELETE_BACKUP" => Self::DeleteBackup,
                "RECREATE_REPLICA" => Self::RecreateReplica,
                "TRUNCATE_LOG" => Self::TruncateLog,
                "DEMOTE_MASTER" => Self::DemoteMaster,
                "MAINTENANCE" => Self::Maintenance,
                "ENABLE_PRIVATE_IP" => Self::EnablePrivateIp,
                "DEFER_MAINTENANCE" => Self::DeferMaintenance,
                "CREATE_CLONE" => Self::CreateClone,
                "RESCHEDULE_MAINTENANCE" => Self::RescheduleMaintenance,
                "START_EXTERNAL_SYNC" => Self::StartExternalSync,
                "LOG_CLEANUP" => Self::LogCleanup,
                "AUTO_RESTART" => Self::AutoRestart,
                "REENCRYPT" => Self::Reencrypt,
                "SWITCHOVER" => Self::Switchover,
                "ACQUIRE_SSRS_LEASE" => Self::AcquireSsrsLease,
                "RELEASE_SSRS_LEASE" => Self::ReleaseSsrsLease,
                "RECONFIGURE_OLD_PRIMARY" => Self::ReconfigureOldPrimary,
                "CLUSTER_MAINTENANCE" => Self::ClusterMaintenance,
                "SELF_SERVICE_MAINTENANCE" => Self::SelfServiceMaintenance,
                "SWITCHOVER_TO_REPLICA" => Self::SwitchoverToReplica,
                "MAJOR_VERSION_UPGRADE" => Self::MajorVersionUpgrade,
                _ => Self::UnknownValue(sql_operation_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Import => serializer.serialize_i32(1),
                Self::Export => serializer.serialize_i32(2),
                Self::Create => serializer.serialize_i32(3),
                Self::Update => serializer.serialize_i32(4),
                Self::Delete => serializer.serialize_i32(5),
                Self::Restart => serializer.serialize_i32(6),
                Self::Backup => serializer.serialize_i32(7),
                Self::Snapshot => serializer.serialize_i32(8),
                Self::BackupVolume => serializer.serialize_i32(9),
                Self::DeleteVolume => serializer.serialize_i32(10),
                Self::RestoreVolume => serializer.serialize_i32(11),
                Self::InjectUser => serializer.serialize_i32(12),
                Self::Clone => serializer.serialize_i32(14),
                Self::StopReplica => serializer.serialize_i32(15),
                Self::StartReplica => serializer.serialize_i32(16),
                Self::PromoteReplica => serializer.serialize_i32(17),
                Self::CreateReplica => serializer.serialize_i32(18),
                Self::CreateUser => serializer.serialize_i32(19),
                Self::DeleteUser => serializer.serialize_i32(20),
                Self::UpdateUser => serializer.serialize_i32(21),
                Self::CreateDatabase => serializer.serialize_i32(22),
                Self::DeleteDatabase => serializer.serialize_i32(23),
                Self::UpdateDatabase => serializer.serialize_i32(24),
                Self::Failover => serializer.serialize_i32(25),
                Self::DeleteBackup => serializer.serialize_i32(26),
                Self::RecreateReplica => serializer.serialize_i32(27),
                Self::TruncateLog => serializer.serialize_i32(28),
                Self::DemoteMaster => serializer.serialize_i32(29),
                Self::Maintenance => serializer.serialize_i32(30),
                Self::EnablePrivateIp => serializer.serialize_i32(31),
                Self::DeferMaintenance => serializer.serialize_i32(32),
                Self::CreateClone => serializer.serialize_i32(33),
                Self::RescheduleMaintenance => serializer.serialize_i32(34),
                Self::StartExternalSync => serializer.serialize_i32(35),
                Self::LogCleanup => serializer.serialize_i32(36),
                Self::AutoRestart => serializer.serialize_i32(37),
                Self::Reencrypt => serializer.serialize_i32(38),
                Self::Switchover => serializer.serialize_i32(39),
                Self::AcquireSsrsLease => serializer.serialize_i32(42),
                Self::ReleaseSsrsLease => serializer.serialize_i32(43),
                Self::ReconfigureOldPrimary => serializer.serialize_i32(44),
                Self::ClusterMaintenance => serializer.serialize_i32(45),
                Self::SelfServiceMaintenance => serializer.serialize_i32(46),
                Self::SwitchoverToReplica => serializer.serialize_i32(47),
                Self::MajorVersionUpgrade => serializer.serialize_i32(48),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOperationType>::new(
                ".google.cloud.sql.v1.Operation.SqlOperationType"))
        }
    }

    /// The status of an operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlOperationStatus {
        /// The state of the operation is unknown.
        Unspecified,
        /// The operation has been queued, but has not started yet.
        Pending,
        /// The operation is running.
        Running,
        /// The operation completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlOperationStatus::value] or
        /// [SqlOperationStatus::name].
        UnknownValue(sql_operation_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_operation_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlOperationStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_OPERATION_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlOperationStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlOperationStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlOperationStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(sql_operation_status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlOperationStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_OPERATION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(sql_operation_status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlOperationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlOperationStatus>::new(
                ".google.cloud.sql.v1.Operation.SqlOperationStatus"))
        }
    }
}

/// Database instance operation error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationError {

    /// This is always `sql#operationError`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// Additional information about the error encountered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OperationError::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::OperationError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for OperationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationError"
    }
}

/// Database instance operation errors list wrapper.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationErrors {

    /// This is always `sql#operationErrors`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The list of errors encountered while processing this operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::OperationError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationErrors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationErrors::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::OperationErrors::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationError>
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationErrors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationErrors"
    }
}

/// Database instance local user password validation policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PasswordValidationPolicy {

    /// Minimum number of characters allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_length: std::option::Option<wkt::Int32Value>,

    /// The complexity of the password.
    pub complexity: crate::model::password_validation_policy::Complexity,

    /// Number of previous passwords that cannot be reused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reuse_interval: std::option::Option<wkt::Int32Value>,

    /// Disallow username as a part of the password.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disallow_username_substring: std::option::Option<wkt::BoolValue>,

    /// Minimum interval after which the password can be changed. This flag is only
    /// supported for PostgreSQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_change_interval: std::option::Option<wkt::Duration>,

    /// Whether the password policy is enabled or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_password_policy: std::option::Option<wkt::BoolValue>,

    /// This field is deprecated and will be removed in a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub disallow_compromised_credentials: std::option::Option<wkt::BoolValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_length][crate::model::PasswordValidationPolicy::min_length].
    pub fn set_min_length<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.min_length = v.into();
        self
    }

    /// Sets the value of [complexity][crate::model::PasswordValidationPolicy::complexity].
    pub fn set_complexity<T: std::convert::Into<crate::model::password_validation_policy::Complexity>>(mut self, v: T) -> Self {
        self.complexity = v.into();
        self
    }

    /// Sets the value of [reuse_interval][crate::model::PasswordValidationPolicy::reuse_interval].
    pub fn set_reuse_interval<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.reuse_interval = v.into();
        self
    }

    /// Sets the value of [disallow_username_substring][crate::model::PasswordValidationPolicy::disallow_username_substring].
    pub fn set_disallow_username_substring<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.disallow_username_substring = v.into();
        self
    }

    /// Sets the value of [password_change_interval][crate::model::PasswordValidationPolicy::password_change_interval].
    pub fn set_password_change_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.password_change_interval = v.into();
        self
    }

    /// Sets the value of [enable_password_policy][crate::model::PasswordValidationPolicy::enable_password_policy].
    pub fn set_enable_password_policy<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_password_policy = v.into();
        self
    }

    /// Sets the value of [disallow_compromised_credentials][crate::model::PasswordValidationPolicy::disallow_compromised_credentials].
    #[deprecated]
    pub fn set_disallow_compromised_credentials<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.disallow_compromised_credentials = v.into();
        self
    }
}

impl wkt::message::Message for PasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordValidationPolicy"
    }
}

/// Defines additional types related to [PasswordValidationPolicy].
pub mod password_validation_policy {
    #[allow(unused_imports)]
    use super::*;


    /// The complexity choices of the password.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Complexity {
        /// Complexity check is not specified.
        Unspecified,
        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric
        /// characters.
        Default,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Complexity::value] or
        /// [Complexity::name].
        UnknownValue(complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Complexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLEXITY_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("COMPLEXITY_DEFAULT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Complexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Complexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Complexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                _ => Self::UnknownValue(complexity::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Complexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "COMPLEXITY_DEFAULT" => Self::Default,
                _ => Self::UnknownValue(complexity::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Complexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Complexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Complexity>::new(
                ".google.cloud.sql.v1.PasswordValidationPolicy.Complexity"))
        }
    }
}

/// Data cache configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataCacheConfig {

    /// Whether data cache is enabled for the instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub data_cache_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataCacheConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_cache_enabled][crate::model::DataCacheConfig::data_cache_enabled].
    pub fn set_data_cache_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.data_cache_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCacheConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DataCacheConfig"
    }
}

/// Database instance settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {

    /// The version of instance settings. This is a required field for update
    /// method to make sure concurrent updates are handled properly. During update,
    /// use the most recent settingsVersion value for this instance and do not try
    /// to update this value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub settings_version: std::option::Option<wkt::Int64Value>,

    /// The App Engine app IDs that can access this instance.
    /// (Deprecated) Applied to First Generation instances only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[deprecated]
    pub authorized_gae_applications: std::vec::Vec<std::string::String>,

    /// The tier (or machine type) for this instance, for example
    /// `db-custom-1-3840`. WARNING: Changing this restarts the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// This is always `sql#settings`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// User-provided labels, represented as a dictionary where each label is a
    /// single key value pair.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data accessibility.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available)./
    ///
    /// For more information, see [Overview of the High Availability
    /// Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
    pub availability_type: crate::model::SqlAvailabilityType,

    /// The pricing plan for this instance. This can be either `PER_USE` or
    /// `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    pub pricing_plan: crate::model::SqlPricingPlan,

    /// The type of replication this instance uses. This can be either
    /// `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only
    /// applicable to First Generation instances.
    #[deprecated]
    pub replication_type: crate::model::SqlReplicationType,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is RUNNABLE. Valid values:
    ///
    /// * `ALWAYS`: The instance is on, and remains so even in the absence of
    ///   connection requests.
    /// * `NEVER`: The instance is off; it is not activated, even if a
    ///   connection request arrives.
    pub activation_policy: crate::model::settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled for Second Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_configuration: std::option::Option<crate::model::IpConfiguration>,

    /// Configuration to increase storage size automatically. The default value is
    /// true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_auto_resize: std::option::Option<wkt::BoolValue>,

    /// The location preference settings. This allows the instance to be located as
    /// near as possible to either an App Engine app or Compute Engine zone for
    /// better performance. App Engine co-location was only applicable to First
    /// Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location_preference: std::option::Option<crate::model::LocationPreference>,

    /// The database flags passed to the instance at startup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_flags: std::vec::Vec<crate::model::DatabaseFlags>,

    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for
    /// First Generation instances.
    pub data_disk_type: crate::model::SqlDataDiskType,

    /// The maintenance window for this instance. This specifies when the instance
    /// can be restarted for maintenance purposes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// The daily backup configuration for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_configuration: std::option::Option<crate::model::BackupConfiguration>,

    /// Configuration specific to read replica instances. Indicates whether
    /// replication is enabled or not. WARNING: Changing this restarts the
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// Configuration specific to read replica instances. Indicates whether
    /// database flags for crash-safe replication are enabled. This property was
    /// only applicable to First Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub crash_safe_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// The size of data disk, in GB. The data disk size minimum is 10GB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_directory_config: std::option::Option<crate::model::SqlActiveDirectoryConfig>,

    /// The name of server Instance collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Deny maintenance periods
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deny_maintenance_periods: std::vec::Vec<crate::model::DenyMaintenancePeriod>,

    /// Insights configuration, for now relevant only for Postgres.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insights_config: std::option::Option<crate::model::InsightsConfig>,

    /// The local user password validation policy of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_validation_policy: std::option::Option<crate::model::PasswordValidationPolicy>,

    /// SQL Server specific audit configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_server_audit_config: std::option::Option<crate::model::SqlServerAuditConfig>,

    /// Optional. The edition of the instance.
    pub edition: crate::model::settings::Edition,

    /// Specifies if connections must use Cloud SQL connectors.
    /// Option values include the following: `NOT_REQUIRED` (Cloud SQL instances
    /// can be connected without Cloud SQL
    /// Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL
    /// Connectors).
    ///
    /// Note that using REQUIRED disables all existing authorized networks. If
    /// this field is not specified when creating a new instance, NOT_REQUIRED is
    /// used. If this field is not specified when patching or updating an existing
    /// instance, it is left unchanged in the instance.
    pub connector_enforcement: crate::model::settings::ConnectorEnforcement,

    /// Configuration to protect against accidental instance deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection_enabled: std::option::Option<wkt::BoolValue>,

    /// Server timezone, relevant only for Cloud SQL for SQL Server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    /// Specifies advanced machine configuration for the instances relevant only
    /// for SQL Server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Configuration for data cache.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_cache_config: std::option::Option<crate::model::DataCacheConfig>,

    /// Optional. When this parameter is set to true, Cloud SQL instances can
    /// connect to Vertex AI to pass requests for real-time predictions and
    /// insights to the AI. The default value is false. This applies only to Cloud
    /// SQL for PostgreSQL instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_google_ml_integration: std::option::Option<wkt::BoolValue>,

    /// Optional. By default, Cloud SQL instances have schema extraction disabled
    /// for Dataplex. When this parameter is set to true, schema extraction for
    /// Dataplex on Cloud SQL instances is activated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_dataplex_integration: std::option::Option<wkt::BoolValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::Settings::settings_version].
    pub fn set_settings_version<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.settings_version = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Settings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Settings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::Settings::availability_type].
    pub fn set_availability_type<T: std::convert::Into<crate::model::SqlAvailabilityType>>(mut self, v: T) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [pricing_plan][crate::model::Settings::pricing_plan].
    pub fn set_pricing_plan<T: std::convert::Into<crate::model::SqlPricingPlan>>(mut self, v: T) -> Self {
        self.pricing_plan = v.into();
        self
    }

    /// Sets the value of [replication_type][crate::model::Settings::replication_type].
    #[deprecated]
    pub fn set_replication_type<T: std::convert::Into<crate::model::SqlReplicationType>>(mut self, v: T) -> Self {
        self.replication_type = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::Settings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.storage_auto_resize_limit = v.into();
        self
    }

    /// Sets the value of [activation_policy][crate::model::Settings::activation_policy].
    pub fn set_activation_policy<T: std::convert::Into<crate::model::settings::SqlActivationPolicy>>(mut self, v: T) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_configuration][crate::model::Settings::ip_configuration].
    pub fn set_ip_configuration<T: std::convert::Into<std::option::Option<crate::model::IpConfiguration>>>(mut self, v: T) -> Self {
        self.ip_configuration = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize][crate::model::Settings::storage_auto_resize].
    pub fn set_storage_auto_resize<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.storage_auto_resize = v.into();
        self
    }

    /// Sets the value of [location_preference][crate::model::Settings::location_preference].
    pub fn set_location_preference<T: std::convert::Into<std::option::Option<crate::model::LocationPreference>>>(mut self, v: T) -> Self {
        self.location_preference = v.into();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::Settings::data_disk_type].
    pub fn set_data_disk_type<T: std::convert::Into<crate::model::SqlDataDiskType>>(mut self, v: T) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::Settings::maintenance_window].
    pub fn set_maintenance_window<T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>>(mut self, v: T) -> Self {
        self.maintenance_window = v.into();
        self
    }

    /// Sets the value of [backup_configuration][crate::model::Settings::backup_configuration].
    pub fn set_backup_configuration<T: std::convert::Into<std::option::Option<crate::model::BackupConfiguration>>>(mut self, v: T) -> Self {
        self.backup_configuration = v.into();
        self
    }

    /// Sets the value of [database_replication_enabled][crate::model::Settings::database_replication_enabled].
    pub fn set_database_replication_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.database_replication_enabled = v.into();
        self
    }

    /// Sets the value of [crash_safe_replication_enabled][crate::model::Settings::crash_safe_replication_enabled].
    #[deprecated]
    pub fn set_crash_safe_replication_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.crash_safe_replication_enabled = v.into();
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::Settings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.data_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [active_directory_config][crate::model::Settings::active_directory_config].
    pub fn set_active_directory_config<T: std::convert::Into<std::option::Option<crate::model::SqlActiveDirectoryConfig>>>(mut self, v: T) -> Self {
        self.active_directory_config = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Settings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [insights_config][crate::model::Settings::insights_config].
    pub fn set_insights_config<T: std::convert::Into<std::option::Option<crate::model::InsightsConfig>>>(mut self, v: T) -> Self {
        self.insights_config = v.into();
        self
    }

    /// Sets the value of [password_validation_policy][crate::model::Settings::password_validation_policy].
    pub fn set_password_validation_policy<T: std::convert::Into<std::option::Option<crate::model::PasswordValidationPolicy>>>(mut self, v: T) -> Self {
        self.password_validation_policy = v.into();
        self
    }

    /// Sets the value of [sql_server_audit_config][crate::model::Settings::sql_server_audit_config].
    pub fn set_sql_server_audit_config<T: std::convert::Into<std::option::Option<crate::model::SqlServerAuditConfig>>>(mut self, v: T) -> Self {
        self.sql_server_audit_config = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::Settings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::settings::Edition>>(mut self, v: T) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [connector_enforcement][crate::model::Settings::connector_enforcement].
    pub fn set_connector_enforcement<T: std::convert::Into<crate::model::settings::ConnectorEnforcement>>(mut self, v: T) -> Self {
        self.connector_enforcement = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Settings::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.deletion_protection_enabled = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::Settings::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::Settings::advanced_machine_features].
    pub fn set_advanced_machine_features<T: std::convert::Into<std::option::Option<crate::model::AdvancedMachineFeatures>>>(mut self, v: T) -> Self {
        self.advanced_machine_features = v.into();
        self
    }

    /// Sets the value of [data_cache_config][crate::model::Settings::data_cache_config].
    pub fn set_data_cache_config<T: std::convert::Into<std::option::Option<crate::model::DataCacheConfig>>>(mut self, v: T) -> Self {
        self.data_cache_config = v.into();
        self
    }

    /// Sets the value of [enable_google_ml_integration][crate::model::Settings::enable_google_ml_integration].
    pub fn set_enable_google_ml_integration<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_google_ml_integration = v.into();
        self
    }

    /// Sets the value of [enable_dataplex_integration][crate::model::Settings::enable_dataplex_integration].
    pub fn set_enable_dataplex_integration<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_dataplex_integration = v.into();
        self
    }

    /// Sets the value of [authorized_gae_applications][crate::model::Settings::authorized_gae_applications].
    #[deprecated]
    pub fn set_authorized_gae_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.authorized_gae_applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [database_flags][crate::model::Settings::database_flags].
    pub fn set_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseFlags>
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny_maintenance_periods][crate::model::Settings::deny_maintenance_periods].
    pub fn set_deny_maintenance_periods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DenyMaintenancePeriod>
    {
        use std::iter::Iterator;
        self.deny_maintenance_periods = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::Settings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Settings"
    }
}

/// Defines additional types related to [Settings].
pub mod settings {
    #[allow(unused_imports)]
    use super::*;


    /// Specifies when the instance is activated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlActivationPolicy {
        /// Unknown activation plan.
        Unspecified,
        /// The instance is always up and running.
        Always,
        /// The instance never starts.
        Never,
        /// The instance starts upon receiving requests.
        #[deprecated]
        OnDemand,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlActivationPolicy::value] or
        /// [SqlActivationPolicy::name].
        UnknownValue(sql_activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::OnDemand => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                3 => Self::OnDemand,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                "ON_DEMAND" => Self::OnDemand,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::OnDemand => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlActivationPolicy>::new(
                ".google.cloud.sql.v1.Settings.SqlActivationPolicy"))
        }
    }

    /// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified,
        /// The instance is an enterprise edition.
        Enterprise,
        /// The instance is an Enterprise Plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.cloud.sql.v1.Settings.Edition"))
        }
    }

    /// The options for enforcing Cloud SQL connectors in the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectorEnforcement {
        /// The requirement for Cloud SQL connectors is unknown.
        Unspecified,
        /// Do not require Cloud SQL connectors.
        NotRequired,
        /// Require all connections to use Cloud SQL connectors, including the
        /// Cloud SQL Auth Proxy and Cloud SQL Java, Python, and Go connectors.
        /// Note: This disables all existing authorized networks.
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectorEnforcement::value] or
        /// [ConnectorEnforcement::name].
        UnknownValue(connector_enforcement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connector_enforcement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectorEnforcement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotRequired => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTOR_ENFORCEMENT_UNSPECIFIED"),
                Self::NotRequired => std::option::Option::Some("NOT_REQUIRED"),
                Self::Required => std::option::Option::Some("REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectorEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectorEnforcement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectorEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotRequired,
                2 => Self::Required,
                _ => Self::UnknownValue(connector_enforcement::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ConnectorEnforcement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTOR_ENFORCEMENT_UNSPECIFIED" => Self::Unspecified,
                "NOT_REQUIRED" => Self::NotRequired,
                "REQUIRED" => Self::Required,
                _ => Self::UnknownValue(connector_enforcement::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ConnectorEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotRequired => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectorEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectorEnforcement>::new(
                ".google.cloud.sql.v1.Settings.ConnectorEnforcement"))
        }
    }
}

/// Specifies options for controlling advanced machine features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {

    /// The number of threads per physical core.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub threads_per_core: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.threads_per_core = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AdvancedMachineFeatures"
    }
}

/// SslCerts Resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCert {

    /// This is always `sql#sslCert`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Serial number, as extracted from the certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert_serial_number: std::string::String,

    /// PEM representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert: std::string::String,

    /// The time when the certificate was created in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// User supplied name.  Constrained to [a-zA-Z.-_ ]+.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub common_name: std::string::String,

    /// The time when the certificate expires in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Sha1 Fingerprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,

    /// Name of the database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCert {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCert::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [cert_serial_number][crate::model::SslCert::cert_serial_number].
    pub fn set_cert_serial_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert_serial_number = v.into();
        self
    }

    /// Sets the value of [cert][crate::model::SslCert::cert].
    pub fn set_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SslCert::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [common_name][crate::model::SslCert::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::SslCert::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SslCert::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SslCert::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::SslCert::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }
}

impl wkt::message::Message for SslCert {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCert"
    }
}

/// SslCertDetail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertDetail {

    /// The public information about the cert.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cert_info: std::option::Option<crate::model::SslCert>,

    /// The private key for the client cert, in pem format.  Keep private in order
    /// to protect your security.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert_private_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cert_info][crate::model::SslCertDetail::cert_info].
    pub fn set_cert_info<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.cert_info = v.into();
        self
    }

    /// Sets the value of [cert_private_key][crate::model::SslCertDetail::cert_private_key].
    pub fn set_cert_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert_private_key = v.into();
        self
    }
}

impl wkt::message::Message for SslCertDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertDetail"
    }
}

/// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlActiveDirectoryConfig {

    /// This is always sql#activeDirectoryConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The name of the domain (e.g., mydomain.com).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlActiveDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlActiveDirectoryConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::SqlActiveDirectoryConfig::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for SqlActiveDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlActiveDirectoryConfig"
    }
}

/// SQL Server specific audit configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerAuditConfig {

    /// This is always sql#sqlServerAuditConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The name of the destination bucket (e.g., gs://mybucket).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// How long to keep generated audit files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention_interval: std::option::Option<wkt::Duration>,

    /// How often to upload generated audit files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_interval: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerAuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlServerAuditConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::SqlServerAuditConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [retention_interval][crate::model::SqlServerAuditConfig::retention_interval].
    pub fn set_retention_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.retention_interval = v.into();
        self
    }

    /// Sets the value of [upload_interval][crate::model::SqlServerAuditConfig::upload_interval].
    pub fn set_upload_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.upload_interval = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerAuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerAuditConfig"
    }
}

/// Acquire SSRS lease context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcquireSsrsLeaseContext {

    /// The username to be used as the setup login to connect to the database
    /// server for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub setup_login: std::option::Option<std::string::String>,

    /// The username to be used as the service login to connect to the report
    /// database for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_login: std::option::Option<std::string::String>,

    /// The report database to be used for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_database: std::option::Option<std::string::String>,

    /// Lease duration needed for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcquireSsrsLeaseContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [setup_login][crate::model::AcquireSsrsLeaseContext::setup_login].
    pub fn set_setup_login<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.setup_login = v.into();
        self
    }

    /// Sets the value of [service_login][crate::model::AcquireSsrsLeaseContext::service_login].
    pub fn set_service_login<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.service_login = v.into();
        self
    }

    /// Sets the value of [report_database][crate::model::AcquireSsrsLeaseContext::report_database].
    pub fn set_report_database<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.report_database = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::AcquireSsrsLeaseContext::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.duration = v.into();
        self
    }
}

impl wkt::message::Message for AcquireSsrsLeaseContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AcquireSsrsLeaseContext"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsDeleteRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsDeleteRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsDeleteRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsGetRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsGetRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsGetRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsInsertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SslCertsInsertRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlSslCertsInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SslCertsInsertRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsInsertRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlSslCertsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsListRequest"
    }
}

/// SslCerts insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsInsertRequest {

    /// User supplied name.  Must be a distinct name from the other certificates
    /// for this instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub common_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_name][crate::model::SslCertsInsertRequest::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertRequest"
    }
}

/// SslCert insert response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsInsertResponse {

    /// This is always `sql#sslCertsInsert`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The operation to track the ssl certs insert request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::Operation>,

    /// The server Certificate Authority's certificate.  If this is missing you can
    /// force a new one to be generated by calling resetSslConfig method on
    /// instances resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The new client certificate and private key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_cert: std::option::Option<crate::model::SslCertDetail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsInsertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsInsertResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::SslCertsInsertResponse::operation].
    pub fn set_operation<T: std::convert::Into<std::option::Option<crate::model::Operation>>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::SslCertsInsertResponse::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [client_cert][crate::model::SslCertsInsertResponse::client_cert].
    pub fn set_client_cert<T: std::convert::Into<std::option::Option<crate::model::SslCertDetail>>>(mut self, v: T) -> Self {
        self.client_cert = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsInsertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertResponse"
    }
}

/// SslCerts list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsListResponse {

    /// This is always `sql#sslCertsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of client certificates for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::SslCert>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslCertsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::SslCertsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslCertsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsListResponse"
    }
}

/// Tiers list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlTiersListRequest {

    /// Project ID of the project for which to list tiers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlTiersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlTiersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlTiersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlTiersListRequest"
    }
}

/// Tiers list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TiersListResponse {

    /// This is always `sql#tiersList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of tiers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Tier>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TiersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TiersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::TiersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tier>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TiersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TiersListResponse"
    }
}

/// A Google Cloud SQL service tier resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tier {

    /// An identifier for the machine type, for example, `db-custom-1-3840`. For
    /// related information, see [Pricing](/sql/pricing).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// The maximum RAM usage of this tier in bytes.
    #[serde(rename = "RAM")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub ram: i64,

    /// This is always `sql#tier`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The maximum disk size of this tier in bytes.
    #[serde(rename = "DiskQuota")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_quota: i64,

    /// The applicable regions for this tier.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub region: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tier {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tier][crate::model::Tier::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [ram][crate::model::Tier::ram].
    pub fn set_ram<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ram = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Tier::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [disk_quota][crate::model::Tier::disk_quota].
    pub fn set_disk_quota<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_quota = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Tier::region].
    pub fn set_region<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.region = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tier {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Tier"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersDeleteRequest {

    /// Host of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Name of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersDeleteRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersDeleteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersDeleteRequest"
    }
}

/// Request message for Users Get RPC
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersGetRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// User of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Host of a user of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersGetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [host][crate::model::SqlUsersGetRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersGetRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersInsertRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::User>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::User>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersInsertRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersListRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersListRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersUpdateRequest {

    /// Optional. Host of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Name of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::User>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlUsersUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersUpdateRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersUpdateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::User>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersUpdateRequest"
    }
}

/// User level password validation policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserPasswordValidationPolicy {

    /// Number of failed login attempts allowed before user get locked.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allowed_failed_attempts: i32,

    /// Expiration duration after password is updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_expiration_duration: std::option::Option<wkt::Duration>,

    /// If true, failed login attempts check will be enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_failed_attempts_check: bool,

    /// Output only. Read-only password status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::PasswordStatus>,

    /// If true, the user must specify the current password before changing the
    /// password. This flag is supported only for MySQL.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_password_verification: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserPasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_failed_attempts][crate::model::UserPasswordValidationPolicy::allowed_failed_attempts].
    pub fn set_allowed_failed_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.allowed_failed_attempts = v.into();
        self
    }

    /// Sets the value of [password_expiration_duration][crate::model::UserPasswordValidationPolicy::password_expiration_duration].
    pub fn set_password_expiration_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.password_expiration_duration = v.into();
        self
    }

    /// Sets the value of [enable_failed_attempts_check][crate::model::UserPasswordValidationPolicy::enable_failed_attempts_check].
    pub fn set_enable_failed_attempts_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_failed_attempts_check = v.into();
        self
    }

    /// Sets the value of [status][crate::model::UserPasswordValidationPolicy::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::PasswordStatus>>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [enable_password_verification][crate::model::UserPasswordValidationPolicy::enable_password_verification].
    pub fn set_enable_password_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_password_verification = v.into();
        self
    }
}

impl wkt::message::Message for UserPasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UserPasswordValidationPolicy"
    }
}

/// Read-only password status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PasswordStatus {

    /// If true, user does not have login privileges.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub locked: bool,

    /// The expiration time of the current password.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_expiration_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PasswordStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locked][crate::model::PasswordStatus::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [password_expiration_time][crate::model::PasswordStatus::password_expiration_time].
    pub fn set_password_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.password_expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for PasswordStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordStatus"
    }
}

/// A Cloud SQL user resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct User {

    /// This is always `sql#user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The password for the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name of the user in the Cloud SQL instance. Can be omitted for
    /// `update` because it is already specified in the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The host from which the user can connect. For `insert`
    /// operations, host defaults to an empty string. For `update`
    /// operations, host is specified as part of the request URL. The host name
    /// cannot be updated after insertion.  For a MySQL instance, it's required;
    /// for a PostgreSQL or SQL Server instance, it's optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    /// Can be omitted for `update` because it is already specified on the
    /// URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable. Can be omitted for `update` because
    /// it is already specified on the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The user type. It determines the method to authenticate the user during
    /// login. The default is the database's built-in user type.
    #[serde(rename = "type")]
    pub r#type: crate::model::user::SqlUserType,

    /// User level password validation policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_policy: std::option::Option<crate::model::UserPasswordValidationPolicy>,

    /// Dual password status for the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dual_password_type: std::option::Option<crate::model::user::DualPasswordType>,

    /// User details for specific database type
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub user_details: std::option::Option<crate::model::user::UserDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::User::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::User::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host][crate::model::User::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::User::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::User::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::User::type].
    pub fn set_type<T: std::convert::Into<crate::model::user::SqlUserType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [password_policy][crate::model::User::password_policy].
    pub fn set_password_policy<T: std::convert::Into<std::option::Option<crate::model::UserPasswordValidationPolicy>>>(mut self, v: T) -> Self {
        self.password_policy = v.into();
        self
    }

    /// Sets the value of [dual_password_type][crate::model::User::dual_password_type].
    pub fn set_dual_password_type<T: std::convert::Into<std::option::Option<crate::model::user::DualPasswordType>>>(mut self, v: T) -> Self {
        self.dual_password_type = v.into();
        self
    }

    /// Sets the value of [user_details][crate::model::User::user_details].
    ///
    /// Note that all the setters affecting `user_details` are mutually
    /// exclusive.
    pub fn set_user_details<T: std::convert::Into<std::option::Option<crate::model::user::UserDetails>>>(mut self, v: T) -> Self
    {
        self.user_details = v.into();
        self
    }

    /// The value of [user_details][crate::model::User::user_details]
    /// if it holds a `SqlserverUserDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sqlserver_user_details(&self) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerUserDetails>> {
        #[allow(unreachable_patterns)]
        self.user_details.as_ref().and_then(|v| match v {
            crate::model::user::UserDetails::SqlserverUserDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_details][crate::model::User::user_details]
    /// to hold a `SqlserverUserDetails`.
    ///
    /// Note that all the setters affecting `user_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_user_details<T: std::convert::Into<std::boxed::Box<crate::model::SqlServerUserDetails>>>(mut self, v: T) -> Self {
        self.user_details = std::option::Option::Some(
            crate::model::user::UserDetails::SqlserverUserDetails(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.User"
    }
}

/// Defines additional types related to [User].
pub mod user {
    #[allow(unused_imports)]
    use super::*;


    /// The user type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlUserType {
        /// The database's built-in user type.
        BuiltIn,
        /// Cloud IAM user.
        CloudIamUser,
        /// Cloud IAM service account.
        CloudIamServiceAccount,
        /// Cloud IAM group non-login user.
        CloudIamGroup,
        /// Cloud IAM group login user.
        CloudIamGroupUser,
        /// Cloud IAM group login service account.
        CloudIamGroupServiceAccount,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlUserType::value] or
        /// [SqlUserType::name].
        UnknownValue(sql_user_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_user_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlUserType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::BuiltIn => std::option::Option::Some(0),
                Self::CloudIamUser => std::option::Option::Some(1),
                Self::CloudIamServiceAccount => std::option::Option::Some(2),
                Self::CloudIamGroup => std::option::Option::Some(3),
                Self::CloudIamGroupUser => std::option::Option::Some(4),
                Self::CloudIamGroupServiceAccount => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::BuiltIn => std::option::Option::Some("BUILT_IN"),
                Self::CloudIamUser => std::option::Option::Some("CLOUD_IAM_USER"),
                Self::CloudIamServiceAccount => std::option::Option::Some("CLOUD_IAM_SERVICE_ACCOUNT"),
                Self::CloudIamGroup => std::option::Option::Some("CLOUD_IAM_GROUP"),
                Self::CloudIamGroupUser => std::option::Option::Some("CLOUD_IAM_GROUP_USER"),
                Self::CloudIamGroupServiceAccount => std::option::Option::Some("CLOUD_IAM_GROUP_SERVICE_ACCOUNT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlUserType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlUserType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlUserType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::BuiltIn,
                1 => Self::CloudIamUser,
                2 => Self::CloudIamServiceAccount,
                3 => Self::CloudIamGroup,
                4 => Self::CloudIamGroupUser,
                5 => Self::CloudIamGroupServiceAccount,
                _ => Self::UnknownValue(sql_user_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for SqlUserType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BUILT_IN" => Self::BuiltIn,
                "CLOUD_IAM_USER" => Self::CloudIamUser,
                "CLOUD_IAM_SERVICE_ACCOUNT" => Self::CloudIamServiceAccount,
                "CLOUD_IAM_GROUP" => Self::CloudIamGroup,
                "CLOUD_IAM_GROUP_USER" => Self::CloudIamGroupUser,
                "CLOUD_IAM_GROUP_SERVICE_ACCOUNT" => Self::CloudIamGroupServiceAccount,
                _ => Self::UnknownValue(sql_user_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for SqlUserType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::BuiltIn => serializer.serialize_i32(0),
                Self::CloudIamUser => serializer.serialize_i32(1),
                Self::CloudIamServiceAccount => serializer.serialize_i32(2),
                Self::CloudIamGroup => serializer.serialize_i32(3),
                Self::CloudIamGroupUser => serializer.serialize_i32(4),
                Self::CloudIamGroupServiceAccount => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlUserType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlUserType>::new(
                ".google.cloud.sql.v1.User.SqlUserType"))
        }
    }

    /// The type of retained password.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DualPasswordType {
        /// The default value.
        Unspecified,
        /// Do not update the user's dual password status.
        NoModifyDualPassword,
        /// No dual password usable for connecting using this user.
        NoDualPassword,
        /// Dual password usable for connecting using this user.
        DualPassword,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DualPasswordType::value] or
        /// [DualPasswordType::name].
        UnknownValue(dual_password_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dual_password_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DualPasswordType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoModifyDualPassword => std::option::Option::Some(1),
                Self::NoDualPassword => std::option::Option::Some(2),
                Self::DualPassword => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DUAL_PASSWORD_TYPE_UNSPECIFIED"),
                Self::NoModifyDualPassword => std::option::Option::Some("NO_MODIFY_DUAL_PASSWORD"),
                Self::NoDualPassword => std::option::Option::Some("NO_DUAL_PASSWORD"),
                Self::DualPassword => std::option::Option::Some("DUAL_PASSWORD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DualPasswordType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DualPasswordType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DualPasswordType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoModifyDualPassword,
                2 => Self::NoDualPassword,
                3 => Self::DualPassword,
                _ => Self::UnknownValue(dual_password_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for DualPasswordType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DUAL_PASSWORD_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_MODIFY_DUAL_PASSWORD" => Self::NoModifyDualPassword,
                "NO_DUAL_PASSWORD" => Self::NoDualPassword,
                "DUAL_PASSWORD" => Self::DualPassword,
                _ => Self::UnknownValue(dual_password_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for DualPasswordType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoModifyDualPassword => serializer.serialize_i32(1),
                Self::NoDualPassword => serializer.serialize_i32(2),
                Self::DualPassword => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DualPasswordType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DualPasswordType>::new(
                ".google.cloud.sql.v1.User.DualPasswordType"))
        }
    }

    /// User details for specific database type
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum UserDetails {
        SqlserverUserDetails(std::boxed::Box<crate::model::SqlServerUserDetails>),
    }
}

/// Represents a Sql Server user on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerUserDetails {

    /// If the user has been disabled
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// The server roles for this user
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub server_roles: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlServerUserDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::SqlServerUserDetails::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [server_roles][crate::model::SqlServerUserDetails::server_roles].
    pub fn set_server_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.server_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerUserDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerUserDetails"
    }
}

/// User list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsersListResponse {

    /// This is always `sql#usersList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of user resources in the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::User>,

    /// Unused.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::UsersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::UsersListResponse::next_page_token].
    #[deprecated]
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::UsersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UsersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UsersListResponse"
    }
}

/// The status of a backup run.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupRunStatus {
    /// The status of the run is unknown.
    Unspecified,
    /// The backup operation was enqueued.
    Enqueued,
    /// The backup is overdue across a given backup window. Indicates a
    /// problem. Example: Long-running operation in progress during
    /// the whole window.
    Overdue,
    /// The backup is in progress.
    Running,
    /// The backup failed.
    Failed,
    /// The backup was successful.
    Successful,
    /// The backup was skipped (without problems) for a given backup
    /// window. Example: Instance was idle.
    Skipped,
    /// The backup is about to be deleted.
    DeletionPending,
    /// The backup deletion failed.
    DeletionFailed,
    /// The backup has been deleted.
    Deleted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupRunStatus::value] or
    /// [SqlBackupRunStatus::name].
    UnknownValue(sql_backup_run_status::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_run_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupRunStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enqueued => std::option::Option::Some(1),
            Self::Overdue => std::option::Option::Some(2),
            Self::Running => std::option::Option::Some(3),
            Self::Failed => std::option::Option::Some(4),
            Self::Successful => std::option::Option::Some(5),
            Self::Skipped => std::option::Option::Some(6),
            Self::DeletionPending => std::option::Option::Some(7),
            Self::DeletionFailed => std::option::Option::Some(8),
            Self::Deleted => std::option::Option::Some(9),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_RUN_STATUS_UNSPECIFIED"),
            Self::Enqueued => std::option::Option::Some("ENQUEUED"),
            Self::Overdue => std::option::Option::Some("OVERDUE"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::Successful => std::option::Option::Some("SUCCESSFUL"),
            Self::Skipped => std::option::Option::Some("SKIPPED"),
            Self::DeletionPending => std::option::Option::Some("DELETION_PENDING"),
            Self::DeletionFailed => std::option::Option::Some("DELETION_FAILED"),
            Self::Deleted => std::option::Option::Some("DELETED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupRunStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupRunStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupRunStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enqueued,
            2 => Self::Overdue,
            3 => Self::Running,
            4 => Self::Failed,
            5 => Self::Successful,
            6 => Self::Skipped,
            7 => Self::DeletionPending,
            8 => Self::DeletionFailed,
            9 => Self::Deleted,
            _ => Self::UnknownValue(sql_backup_run_status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlBackupRunStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_RUN_STATUS_UNSPECIFIED" => Self::Unspecified,
            "ENQUEUED" => Self::Enqueued,
            "OVERDUE" => Self::Overdue,
            "RUNNING" => Self::Running,
            "FAILED" => Self::Failed,
            "SUCCESSFUL" => Self::Successful,
            "SKIPPED" => Self::Skipped,
            "DELETION_PENDING" => Self::DeletionPending,
            "DELETION_FAILED" => Self::DeletionFailed,
            "DELETED" => Self::Deleted,
            _ => Self::UnknownValue(sql_backup_run_status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlBackupRunStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enqueued => serializer.serialize_i32(1),
            Self::Overdue => serializer.serialize_i32(2),
            Self::Running => serializer.serialize_i32(3),
            Self::Failed => serializer.serialize_i32(4),
            Self::Successful => serializer.serialize_i32(5),
            Self::Skipped => serializer.serialize_i32(6),
            Self::DeletionPending => serializer.serialize_i32(7),
            Self::DeletionFailed => serializer.serialize_i32(8),
            Self::Deleted => serializer.serialize_i32(9),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupRunStatus>::new(
            ".google.cloud.sql.v1.SqlBackupRunStatus"))
    }
}

/// Defines the supported backup kinds.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupKind {
    /// This is an unknown BackupKind.
    Unspecified,
    /// The snapshot based backups
    Snapshot,
    /// Physical backups
    Physical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupKind::value] or
    /// [SqlBackupKind::name].
    UnknownValue(sql_backup_kind::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_kind {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupKind {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Snapshot => std::option::Option::Some(1),
            Self::Physical => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_KIND_UNSPECIFIED"),
            Self::Snapshot => std::option::Option::Some("SNAPSHOT"),
            Self::Physical => std::option::Option::Some("PHYSICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupKind {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Snapshot,
            2 => Self::Physical,
            _ => Self::UnknownValue(sql_backup_kind::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlBackupKind {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_KIND_UNSPECIFIED" => Self::Unspecified,
            "SNAPSHOT" => Self::Snapshot,
            "PHYSICAL" => Self::Physical,
            _ => Self::UnknownValue(sql_backup_kind::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlBackupKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Snapshot => serializer.serialize_i32(1),
            Self::Physical => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupKind>::new(
            ".google.cloud.sql.v1.SqlBackupKind"))
    }
}

/// Type of backup (i.e. automated, on demand, etc).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackupRunType {
    /// This is an unknown BackupRun type.
    Unspecified,
    /// The backup schedule automatically triggers a backup.
    Automated,
    /// The user manually triggers a backup.
    OnDemand,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackupRunType::value] or
    /// [SqlBackupRunType::name].
    UnknownValue(sql_backup_run_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backup_run_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackupRunType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Automated => std::option::Option::Some(1),
            Self::OnDemand => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKUP_RUN_TYPE_UNSPECIFIED"),
            Self::Automated => std::option::Option::Some("AUTOMATED"),
            Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackupRunType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackupRunType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackupRunType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Automated,
            2 => Self::OnDemand,
            _ => Self::UnknownValue(sql_backup_run_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlBackupRunType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKUP_RUN_TYPE_UNSPECIFIED" => Self::Unspecified,
            "AUTOMATED" => Self::Automated,
            "ON_DEMAND" => Self::OnDemand,
            _ => Self::UnknownValue(sql_backup_run_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlBackupRunType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Automated => serializer.serialize_i32(1),
            Self::OnDemand => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackupRunType>::new(
            ".google.cloud.sql.v1.SqlBackupRunType"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlFlagType {
    /// This is an unknown flag type.
    Unspecified,
    /// Boolean type flag.
    Boolean,
    /// String type flag.
    String,
    /// Integer type flag.
    Integer,
    /// Flag type used for a server startup option.
    None,
    /// Type introduced specially for MySQL TimeZone offset. Accept a string value
    /// with the format [-12:59, 13:00].
    MysqlTimezoneOffset,
    /// Float type flag.
    Float,
    /// Comma-separated list of the strings in a SqlFlagType enum.
    RepeatedString,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlFlagType::value] or
    /// [SqlFlagType::name].
    UnknownValue(sql_flag_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_flag_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlFlagType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Boolean => std::option::Option::Some(1),
            Self::String => std::option::Option::Some(2),
            Self::Integer => std::option::Option::Some(3),
            Self::None => std::option::Option::Some(4),
            Self::MysqlTimezoneOffset => std::option::Option::Some(5),
            Self::Float => std::option::Option::Some(6),
            Self::RepeatedString => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_FLAG_TYPE_UNSPECIFIED"),
            Self::Boolean => std::option::Option::Some("BOOLEAN"),
            Self::String => std::option::Option::Some("STRING"),
            Self::Integer => std::option::Option::Some("INTEGER"),
            Self::None => std::option::Option::Some("NONE"),
            Self::MysqlTimezoneOffset => std::option::Option::Some("MYSQL_TIMEZONE_OFFSET"),
            Self::Float => std::option::Option::Some("FLOAT"),
            Self::RepeatedString => std::option::Option::Some("REPEATED_STRING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlFlagType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlFlagType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlFlagType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Boolean,
            2 => Self::String,
            3 => Self::Integer,
            4 => Self::None,
            5 => Self::MysqlTimezoneOffset,
            6 => Self::Float,
            7 => Self::RepeatedString,
            _ => Self::UnknownValue(sql_flag_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlFlagType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_FLAG_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BOOLEAN" => Self::Boolean,
            "STRING" => Self::String,
            "INTEGER" => Self::Integer,
            "NONE" => Self::None,
            "MYSQL_TIMEZONE_OFFSET" => Self::MysqlTimezoneOffset,
            "FLOAT" => Self::Float,
            "REPEATED_STRING" => Self::RepeatedString,
            _ => Self::UnknownValue(sql_flag_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlFlagType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Boolean => serializer.serialize_i32(1),
            Self::String => serializer.serialize_i32(2),
            Self::Integer => serializer.serialize_i32(3),
            Self::None => serializer.serialize_i32(4),
            Self::MysqlTimezoneOffset => serializer.serialize_i32(5),
            Self::Float => serializer.serialize_i32(6),
            Self::RepeatedString => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFlagType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlFlagType>::new(
            ".google.cloud.sql.v1.SqlFlagType"))
    }
}

/// External Sync parallel level.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ExternalSyncParallelLevel {
    /// Unknown sync parallel level. Will be defaulted to OPTIMAL.
    Unspecified,
    /// Minimal parallel level.
    Min,
    /// Optimal parallel level.
    Optimal,
    /// Maximum parallel level.
    Max,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ExternalSyncParallelLevel::value] or
    /// [ExternalSyncParallelLevel::name].
    UnknownValue(external_sync_parallel_level::UnknownValue),
}

#[doc(hidden)]
pub mod external_sync_parallel_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ExternalSyncParallelLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Min => std::option::Option::Some(1),
            Self::Optimal => std::option::Option::Some(2),
            Self::Max => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED"),
            Self::Min => std::option::Option::Some("MIN"),
            Self::Optimal => std::option::Option::Some("OPTIMAL"),
            Self::Max => std::option::Option::Some("MAX"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ExternalSyncParallelLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ExternalSyncParallelLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ExternalSyncParallelLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Min,
            2 => Self::Optimal,
            3 => Self::Max,
            _ => Self::UnknownValue(external_sync_parallel_level::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for ExternalSyncParallelLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "MIN" => Self::Min,
            "OPTIMAL" => Self::Optimal,
            "MAX" => Self::Max,
            _ => Self::UnknownValue(external_sync_parallel_level::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for ExternalSyncParallelLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Min => serializer.serialize_i32(1),
            Self::Optimal => serializer.serialize_i32(2),
            Self::Max => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ExternalSyncParallelLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExternalSyncParallelLevel>::new(
            ".google.cloud.sql.v1.ExternalSyncParallelLevel"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlInstanceType {
    /// This is an unknown Cloud SQL instance type.
    Unspecified,
    /// A regular Cloud SQL instance that is not replicating from a primary
    /// instance.
    CloudSqlInstance,
    /// An instance running on the customer's premises that is not managed by
    /// Cloud SQL.
    OnPremisesInstance,
    /// A Cloud SQL instance acting as a read-replica.
    ReadReplicaInstance,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlInstanceType::value] or
    /// [SqlInstanceType::name].
    UnknownValue(sql_instance_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_instance_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlInstanceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CloudSqlInstance => std::option::Option::Some(1),
            Self::OnPremisesInstance => std::option::Option::Some(2),
            Self::ReadReplicaInstance => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_INSTANCE_TYPE_UNSPECIFIED"),
            Self::CloudSqlInstance => std::option::Option::Some("CLOUD_SQL_INSTANCE"),
            Self::OnPremisesInstance => std::option::Option::Some("ON_PREMISES_INSTANCE"),
            Self::ReadReplicaInstance => std::option::Option::Some("READ_REPLICA_INSTANCE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlInstanceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlInstanceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlInstanceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CloudSqlInstance,
            2 => Self::OnPremisesInstance,
            3 => Self::ReadReplicaInstance,
            _ => Self::UnknownValue(sql_instance_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlInstanceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "CLOUD_SQL_INSTANCE" => Self::CloudSqlInstance,
            "ON_PREMISES_INSTANCE" => Self::OnPremisesInstance,
            "READ_REPLICA_INSTANCE" => Self::ReadReplicaInstance,
            _ => Self::UnknownValue(sql_instance_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlInstanceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CloudSqlInstance => serializer.serialize_i32(1),
            Self::OnPremisesInstance => serializer.serialize_i32(2),
            Self::ReadReplicaInstance => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlInstanceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlInstanceType>::new(
            ".google.cloud.sql.v1.SqlInstanceType"))
    }
}

/// The suspension reason of the database instance if the state is SUSPENDED.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlSuspensionReason {
    /// This is an unknown suspension reason.
    Unspecified,
    /// The instance is suspended due to billing issues (for example:, GCP account
    /// issue)
    BillingIssue,
    /// The instance is suspended due to illegal content (for example:, child
    /// pornography, copyrighted material, etc.).
    LegalIssue,
    /// The instance is causing operational issues (for example:, causing the
    /// database to crash).
    OperationalIssue,
    /// The KMS key used by the instance is either revoked or denied access to
    KmsKeyIssue,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlSuspensionReason::value] or
    /// [SqlSuspensionReason::name].
    UnknownValue(sql_suspension_reason::UnknownValue),
}

#[doc(hidden)]
pub mod sql_suspension_reason {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlSuspensionReason {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BillingIssue => std::option::Option::Some(2),
            Self::LegalIssue => std::option::Option::Some(3),
            Self::OperationalIssue => std::option::Option::Some(4),
            Self::KmsKeyIssue => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_SUSPENSION_REASON_UNSPECIFIED"),
            Self::BillingIssue => std::option::Option::Some("BILLING_ISSUE"),
            Self::LegalIssue => std::option::Option::Some("LEGAL_ISSUE"),
            Self::OperationalIssue => std::option::Option::Some("OPERATIONAL_ISSUE"),
            Self::KmsKeyIssue => std::option::Option::Some("KMS_KEY_ISSUE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlSuspensionReason {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlSuspensionReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlSuspensionReason {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BillingIssue,
            3 => Self::LegalIssue,
            4 => Self::OperationalIssue,
            5 => Self::KmsKeyIssue,
            _ => Self::UnknownValue(sql_suspension_reason::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlSuspensionReason {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_SUSPENSION_REASON_UNSPECIFIED" => Self::Unspecified,
            "BILLING_ISSUE" => Self::BillingIssue,
            "LEGAL_ISSUE" => Self::LegalIssue,
            "OPERATIONAL_ISSUE" => Self::OperationalIssue,
            "KMS_KEY_ISSUE" => Self::KmsKeyIssue,
            _ => Self::UnknownValue(sql_suspension_reason::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlSuspensionReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BillingIssue => serializer.serialize_i32(2),
            Self::LegalIssue => serializer.serialize_i32(3),
            Self::OperationalIssue => serializer.serialize_i32(4),
            Self::KmsKeyIssue => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlSuspensionReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlSuspensionReason>::new(
            ".google.cloud.sql.v1.SqlSuspensionReason"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlFileType {
    /// Unknown file type.
    Unspecified,
    /// File containing SQL statements.
    Sql,
    /// File in CSV format.
    Csv,
    Bak,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlFileType::value] or
    /// [SqlFileType::name].
    UnknownValue(sql_file_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_file_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlFileType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Sql => std::option::Option::Some(1),
            Self::Csv => std::option::Option::Some(2),
            Self::Bak => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_FILE_TYPE_UNSPECIFIED"),
            Self::Sql => std::option::Option::Some("SQL"),
            Self::Csv => std::option::Option::Some("CSV"),
            Self::Bak => std::option::Option::Some("BAK"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlFileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlFileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlFileType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Sql,
            2 => Self::Csv,
            4 => Self::Bak,
            _ => Self::UnknownValue(sql_file_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlFileType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SQL" => Self::Sql,
            "CSV" => Self::Csv,
            "BAK" => Self::Bak,
            _ => Self::UnknownValue(sql_file_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlFileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Sql => serializer.serialize_i32(1),
            Self::Csv => serializer.serialize_i32(2),
            Self::Bak => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlFileType>::new(
            ".google.cloud.sql.v1.SqlFileType"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BakType {
    /// Default type.
    Unspecified,
    /// Full backup.
    Full,
    /// Differential backup.
    Diff,
    /// Transaction Log backup
    Tlog,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BakType::value] or
    /// [BakType::name].
    UnknownValue(bak_type::UnknownValue),
}

#[doc(hidden)]
pub mod bak_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BakType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(1),
            Self::Diff => std::option::Option::Some(2),
            Self::Tlog => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BAK_TYPE_UNSPECIFIED"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Diff => std::option::Option::Some("DIFF"),
            Self::Tlog => std::option::Option::Some("TLOG"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BakType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BakType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BakType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Full,
            2 => Self::Diff,
            3 => Self::Tlog,
            _ => Self::UnknownValue(bak_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for BakType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BAK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "FULL" => Self::Full,
            "DIFF" => Self::Diff,
            "TLOG" => Self::Tlog,
            _ => Self::UnknownValue(bak_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for BakType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(1),
            Self::Diff => serializer.serialize_i32(2),
            Self::Tlog => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BakType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BakType>::new(
            ".google.cloud.sql.v1.BakType"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlBackendType {
    /// This is an unknown backend type for instance.
    Unspecified,
    /// V1 speckle instance.
    #[deprecated]
    FirstGen,
    /// V2 speckle instance.
    SecondGen,
    /// On premises instance.
    External,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlBackendType::value] or
    /// [SqlBackendType::name].
    UnknownValue(sql_backend_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_backend_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlBackendType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FirstGen => std::option::Option::Some(1),
            Self::SecondGen => std::option::Option::Some(2),
            Self::External => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_BACKEND_TYPE_UNSPECIFIED"),
            Self::FirstGen => std::option::Option::Some("FIRST_GEN"),
            Self::SecondGen => std::option::Option::Some("SECOND_GEN"),
            Self::External => std::option::Option::Some("EXTERNAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlBackendType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlBackendType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlBackendType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FirstGen,
            2 => Self::SecondGen,
            3 => Self::External,
            _ => Self::UnknownValue(sql_backend_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlBackendType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_BACKEND_TYPE_UNSPECIFIED" => Self::Unspecified,
            "FIRST_GEN" => Self::FirstGen,
            "SECOND_GEN" => Self::SecondGen,
            "EXTERNAL" => Self::External,
            _ => Self::UnknownValue(sql_backend_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlBackendType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FirstGen => serializer.serialize_i32(1),
            Self::SecondGen => serializer.serialize_i32(2),
            Self::External => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackendType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlBackendType>::new(
            ".google.cloud.sql.v1.SqlBackendType"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlIpAddressType {
    /// This is an unknown IP address type.
    Unspecified,
    /// IP address the customer is supposed to connect to. Usually this is the
    /// load balancer's IP address
    Primary,
    /// Source IP address of the connection a read replica establishes to its
    /// external primary instance. This IP address can be allowlisted by the
    /// customer in case it has a firewall that filters incoming connection to its
    /// on premises primary instance.
    Outgoing,
    /// Private IP used when using private IPs and network peering.
    Private,
    /// V1 IP of a migrated instance. We want the user to
    /// decommission this IP as soon as the migration is complete.
    /// Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
    Migrated1StGen,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlIpAddressType::value] or
    /// [SqlIpAddressType::name].
    UnknownValue(sql_ip_address_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_ip_address_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlIpAddressType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Primary => std::option::Option::Some(1),
            Self::Outgoing => std::option::Option::Some(2),
            Self::Private => std::option::Option::Some(3),
            Self::Migrated1StGen => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_IP_ADDRESS_TYPE_UNSPECIFIED"),
            Self::Primary => std::option::Option::Some("PRIMARY"),
            Self::Outgoing => std::option::Option::Some("OUTGOING"),
            Self::Private => std::option::Option::Some("PRIVATE"),
            Self::Migrated1StGen => std::option::Option::Some("MIGRATED_1ST_GEN"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlIpAddressType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlIpAddressType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlIpAddressType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Primary,
            2 => Self::Outgoing,
            3 => Self::Private,
            4 => Self::Migrated1StGen,
            _ => Self::UnknownValue(sql_ip_address_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlIpAddressType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PRIMARY" => Self::Primary,
            "OUTGOING" => Self::Outgoing,
            "PRIVATE" => Self::Private,
            "MIGRATED_1ST_GEN" => Self::Migrated1StGen,
            _ => Self::UnknownValue(sql_ip_address_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlIpAddressType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Primary => serializer.serialize_i32(1),
            Self::Outgoing => serializer.serialize_i32(2),
            Self::Private => serializer.serialize_i32(3),
            Self::Migrated1StGen => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlIpAddressType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlIpAddressType>::new(
            ".google.cloud.sql.v1.SqlIpAddressType"))
    }
}

/// The database engine type and version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlDatabaseVersion {
    /// This is an unknown database version.
    Unspecified,
    /// The database version is MySQL 5.1.
    #[deprecated]
    Mysql51,
    /// The database version is MySQL 5.5.
    #[deprecated]
    Mysql55,
    /// The database version is MySQL 5.6.
    Mysql56,
    /// The database version is MySQL 5.7.
    Mysql57,
    /// The database version is SQL Server 2017 Standard.
    Sqlserver2017Standard,
    /// The database version is SQL Server 2017 Enterprise.
    Sqlserver2017Enterprise,
    /// The database version is SQL Server 2017 Express.
    Sqlserver2017Express,
    /// The database version is SQL Server 2017 Web.
    Sqlserver2017Web,
    /// The database version is PostgreSQL 9.6.
    Postgres96,
    /// The database version is PostgreSQL 10.
    Postgres10,
    /// The database version is PostgreSQL 11.
    Postgres11,
    /// The database version is PostgreSQL 12.
    Postgres12,
    /// The database version is PostgreSQL 13.
    Postgres13,
    /// The database version is PostgreSQL 14.
    Postgres14,
    /// The database version is PostgreSQL 15.
    Postgres15,
    /// The database version is PostgreSQL 16.
    Postgres16,
    /// The database version is MySQL 8.
    Mysql80,
    /// The database major version is MySQL 8.0 and the minor version is 18.
    Mysql8018,
    /// The database major version is MySQL 8.0 and the minor version is 26.
    Mysql8026,
    /// The database major version is MySQL 8.0 and the minor version is 27.
    Mysql8027,
    /// The database major version is MySQL 8.0 and the minor version is 28.
    Mysql8028,
    /// The database major version is MySQL 8.0 and the minor version is 29.
    #[deprecated]
    Mysql8029,
    /// The database major version is MySQL 8.0 and the minor version is 30.
    Mysql8030,
    /// The database major version is MySQL 8.0 and the minor version is 31.
    Mysql8031,
    /// The database major version is MySQL 8.0 and the minor version is 32.
    Mysql8032,
    /// The database major version is MySQL 8.0 and the minor version is 33.
    Mysql8033,
    /// The database major version is MySQL 8.0 and the minor version is 34.
    Mysql8034,
    /// The database major version is MySQL 8.0 and the minor version is 35.
    Mysql8035,
    /// The database major version is MySQL 8.0 and the minor version is 36.
    Mysql8036,
    /// The database major version is MySQL 8.0 and the minor version is 37.
    Mysql8037,
    /// The database major version is MySQL 8.0 and the minor version is 38.
    Mysql8038,
    /// The database major version is MySQL 8.0 and the minor version is 39.
    Mysql8039,
    /// The database major version is MySQL 8.0 and the minor version is 40.
    Mysql8040,
    /// The database version is MySQL 8.4.
    Mysql84,
    /// The database version is MySQL 8.4 and the patch version is 0.
    Mysql840,
    /// The database version is SQL Server 2019 Standard.
    Sqlserver2019Standard,
    /// The database version is SQL Server 2019 Enterprise.
    Sqlserver2019Enterprise,
    /// The database version is SQL Server 2019 Express.
    Sqlserver2019Express,
    /// The database version is SQL Server 2019 Web.
    Sqlserver2019Web,
    /// The database version is SQL Server 2022 Standard.
    Sqlserver2022Standard,
    /// The database version is SQL Server 2022 Enterprise.
    Sqlserver2022Enterprise,
    /// The database version is SQL Server 2022 Express.
    Sqlserver2022Express,
    /// The database version is SQL Server 2022 Web.
    Sqlserver2022Web,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlDatabaseVersion::value] or
    /// [SqlDatabaseVersion::name].
    UnknownValue(sql_database_version::UnknownValue),
}

#[doc(hidden)]
pub mod sql_database_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlDatabaseVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Mysql51 => std::option::Option::Some(2),
            Self::Mysql55 => std::option::Option::Some(3),
            Self::Mysql56 => std::option::Option::Some(5),
            Self::Mysql57 => std::option::Option::Some(6),
            Self::Sqlserver2017Standard => std::option::Option::Some(11),
            Self::Sqlserver2017Enterprise => std::option::Option::Some(14),
            Self::Sqlserver2017Express => std::option::Option::Some(15),
            Self::Sqlserver2017Web => std::option::Option::Some(16),
            Self::Postgres96 => std::option::Option::Some(9),
            Self::Postgres10 => std::option::Option::Some(18),
            Self::Postgres11 => std::option::Option::Some(10),
            Self::Postgres12 => std::option::Option::Some(19),
            Self::Postgres13 => std::option::Option::Some(23),
            Self::Postgres14 => std::option::Option::Some(110),
            Self::Postgres15 => std::option::Option::Some(172),
            Self::Postgres16 => std::option::Option::Some(272),
            Self::Mysql80 => std::option::Option::Some(20),
            Self::Mysql8018 => std::option::Option::Some(41),
            Self::Mysql8026 => std::option::Option::Some(85),
            Self::Mysql8027 => std::option::Option::Some(111),
            Self::Mysql8028 => std::option::Option::Some(132),
            Self::Mysql8029 => std::option::Option::Some(148),
            Self::Mysql8030 => std::option::Option::Some(174),
            Self::Mysql8031 => std::option::Option::Some(197),
            Self::Mysql8032 => std::option::Option::Some(213),
            Self::Mysql8033 => std::option::Option::Some(238),
            Self::Mysql8034 => std::option::Option::Some(239),
            Self::Mysql8035 => std::option::Option::Some(240),
            Self::Mysql8036 => std::option::Option::Some(241),
            Self::Mysql8037 => std::option::Option::Some(355),
            Self::Mysql8038 => std::option::Option::Some(356),
            Self::Mysql8039 => std::option::Option::Some(357),
            Self::Mysql8040 => std::option::Option::Some(358),
            Self::Mysql84 => std::option::Option::Some(398),
            Self::Mysql840 => std::option::Option::Some(399),
            Self::Sqlserver2019Standard => std::option::Option::Some(26),
            Self::Sqlserver2019Enterprise => std::option::Option::Some(27),
            Self::Sqlserver2019Express => std::option::Option::Some(28),
            Self::Sqlserver2019Web => std::option::Option::Some(29),
            Self::Sqlserver2022Standard => std::option::Option::Some(199),
            Self::Sqlserver2022Enterprise => std::option::Option::Some(200),
            Self::Sqlserver2022Express => std::option::Option::Some(201),
            Self::Sqlserver2022Web => std::option::Option::Some(202),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_DATABASE_VERSION_UNSPECIFIED"),
            Self::Mysql51 => std::option::Option::Some("MYSQL_5_1"),
            Self::Mysql55 => std::option::Option::Some("MYSQL_5_5"),
            Self::Mysql56 => std::option::Option::Some("MYSQL_5_6"),
            Self::Mysql57 => std::option::Option::Some("MYSQL_5_7"),
            Self::Sqlserver2017Standard => std::option::Option::Some("SQLSERVER_2017_STANDARD"),
            Self::Sqlserver2017Enterprise => std::option::Option::Some("SQLSERVER_2017_ENTERPRISE"),
            Self::Sqlserver2017Express => std::option::Option::Some("SQLSERVER_2017_EXPRESS"),
            Self::Sqlserver2017Web => std::option::Option::Some("SQLSERVER_2017_WEB"),
            Self::Postgres96 => std::option::Option::Some("POSTGRES_9_6"),
            Self::Postgres10 => std::option::Option::Some("POSTGRES_10"),
            Self::Postgres11 => std::option::Option::Some("POSTGRES_11"),
            Self::Postgres12 => std::option::Option::Some("POSTGRES_12"),
            Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
            Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
            Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
            Self::Postgres16 => std::option::Option::Some("POSTGRES_16"),
            Self::Mysql80 => std::option::Option::Some("MYSQL_8_0"),
            Self::Mysql8018 => std::option::Option::Some("MYSQL_8_0_18"),
            Self::Mysql8026 => std::option::Option::Some("MYSQL_8_0_26"),
            Self::Mysql8027 => std::option::Option::Some("MYSQL_8_0_27"),
            Self::Mysql8028 => std::option::Option::Some("MYSQL_8_0_28"),
            Self::Mysql8029 => std::option::Option::Some("MYSQL_8_0_29"),
            Self::Mysql8030 => std::option::Option::Some("MYSQL_8_0_30"),
            Self::Mysql8031 => std::option::Option::Some("MYSQL_8_0_31"),
            Self::Mysql8032 => std::option::Option::Some("MYSQL_8_0_32"),
            Self::Mysql8033 => std::option::Option::Some("MYSQL_8_0_33"),
            Self::Mysql8034 => std::option::Option::Some("MYSQL_8_0_34"),
            Self::Mysql8035 => std::option::Option::Some("MYSQL_8_0_35"),
            Self::Mysql8036 => std::option::Option::Some("MYSQL_8_0_36"),
            Self::Mysql8037 => std::option::Option::Some("MYSQL_8_0_37"),
            Self::Mysql8038 => std::option::Option::Some("MYSQL_8_0_38"),
            Self::Mysql8039 => std::option::Option::Some("MYSQL_8_0_39"),
            Self::Mysql8040 => std::option::Option::Some("MYSQL_8_0_40"),
            Self::Mysql84 => std::option::Option::Some("MYSQL_8_4"),
            Self::Mysql840 => std::option::Option::Some("MYSQL_8_4_0"),
            Self::Sqlserver2019Standard => std::option::Option::Some("SQLSERVER_2019_STANDARD"),
            Self::Sqlserver2019Enterprise => std::option::Option::Some("SQLSERVER_2019_ENTERPRISE"),
            Self::Sqlserver2019Express => std::option::Option::Some("SQLSERVER_2019_EXPRESS"),
            Self::Sqlserver2019Web => std::option::Option::Some("SQLSERVER_2019_WEB"),
            Self::Sqlserver2022Standard => std::option::Option::Some("SQLSERVER_2022_STANDARD"),
            Self::Sqlserver2022Enterprise => std::option::Option::Some("SQLSERVER_2022_ENTERPRISE"),
            Self::Sqlserver2022Express => std::option::Option::Some("SQLSERVER_2022_EXPRESS"),
            Self::Sqlserver2022Web => std::option::Option::Some("SQLSERVER_2022_WEB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlDatabaseVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlDatabaseVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlDatabaseVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::Mysql51,
            3 => Self::Mysql55,
            5 => Self::Mysql56,
            6 => Self::Mysql57,
            9 => Self::Postgres96,
            10 => Self::Postgres11,
            11 => Self::Sqlserver2017Standard,
            14 => Self::Sqlserver2017Enterprise,
            15 => Self::Sqlserver2017Express,
            16 => Self::Sqlserver2017Web,
            18 => Self::Postgres10,
            19 => Self::Postgres12,
            20 => Self::Mysql80,
            23 => Self::Postgres13,
            26 => Self::Sqlserver2019Standard,
            27 => Self::Sqlserver2019Enterprise,
            28 => Self::Sqlserver2019Express,
            29 => Self::Sqlserver2019Web,
            41 => Self::Mysql8018,
            85 => Self::Mysql8026,
            110 => Self::Postgres14,
            111 => Self::Mysql8027,
            132 => Self::Mysql8028,
            148 => Self::Mysql8029,
            172 => Self::Postgres15,
            174 => Self::Mysql8030,
            197 => Self::Mysql8031,
            199 => Self::Sqlserver2022Standard,
            200 => Self::Sqlserver2022Enterprise,
            201 => Self::Sqlserver2022Express,
            202 => Self::Sqlserver2022Web,
            213 => Self::Mysql8032,
            238 => Self::Mysql8033,
            239 => Self::Mysql8034,
            240 => Self::Mysql8035,
            241 => Self::Mysql8036,
            272 => Self::Postgres16,
            355 => Self::Mysql8037,
            356 => Self::Mysql8038,
            357 => Self::Mysql8039,
            358 => Self::Mysql8040,
            398 => Self::Mysql84,
            399 => Self::Mysql840,
            _ => Self::UnknownValue(sql_database_version::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlDatabaseVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
            "MYSQL_5_1" => Self::Mysql51,
            "MYSQL_5_5" => Self::Mysql55,
            "MYSQL_5_6" => Self::Mysql56,
            "MYSQL_5_7" => Self::Mysql57,
            "SQLSERVER_2017_STANDARD" => Self::Sqlserver2017Standard,
            "SQLSERVER_2017_ENTERPRISE" => Self::Sqlserver2017Enterprise,
            "SQLSERVER_2017_EXPRESS" => Self::Sqlserver2017Express,
            "SQLSERVER_2017_WEB" => Self::Sqlserver2017Web,
            "POSTGRES_9_6" => Self::Postgres96,
            "POSTGRES_10" => Self::Postgres10,
            "POSTGRES_11" => Self::Postgres11,
            "POSTGRES_12" => Self::Postgres12,
            "POSTGRES_13" => Self::Postgres13,
            "POSTGRES_14" => Self::Postgres14,
            "POSTGRES_15" => Self::Postgres15,
            "POSTGRES_16" => Self::Postgres16,
            "MYSQL_8_0" => Self::Mysql80,
            "MYSQL_8_0_18" => Self::Mysql8018,
            "MYSQL_8_0_26" => Self::Mysql8026,
            "MYSQL_8_0_27" => Self::Mysql8027,
            "MYSQL_8_0_28" => Self::Mysql8028,
            "MYSQL_8_0_29" => Self::Mysql8029,
            "MYSQL_8_0_30" => Self::Mysql8030,
            "MYSQL_8_0_31" => Self::Mysql8031,
            "MYSQL_8_0_32" => Self::Mysql8032,
            "MYSQL_8_0_33" => Self::Mysql8033,
            "MYSQL_8_0_34" => Self::Mysql8034,
            "MYSQL_8_0_35" => Self::Mysql8035,
            "MYSQL_8_0_36" => Self::Mysql8036,
            "MYSQL_8_0_37" => Self::Mysql8037,
            "MYSQL_8_0_38" => Self::Mysql8038,
            "MYSQL_8_0_39" => Self::Mysql8039,
            "MYSQL_8_0_40" => Self::Mysql8040,
            "MYSQL_8_4" => Self::Mysql84,
            "MYSQL_8_4_0" => Self::Mysql840,
            "SQLSERVER_2019_STANDARD" => Self::Sqlserver2019Standard,
            "SQLSERVER_2019_ENTERPRISE" => Self::Sqlserver2019Enterprise,
            "SQLSERVER_2019_EXPRESS" => Self::Sqlserver2019Express,
            "SQLSERVER_2019_WEB" => Self::Sqlserver2019Web,
            "SQLSERVER_2022_STANDARD" => Self::Sqlserver2022Standard,
            "SQLSERVER_2022_ENTERPRISE" => Self::Sqlserver2022Enterprise,
            "SQLSERVER_2022_EXPRESS" => Self::Sqlserver2022Express,
            "SQLSERVER_2022_WEB" => Self::Sqlserver2022Web,
            _ => Self::UnknownValue(sql_database_version::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlDatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Mysql51 => serializer.serialize_i32(2),
            Self::Mysql55 => serializer.serialize_i32(3),
            Self::Mysql56 => serializer.serialize_i32(5),
            Self::Mysql57 => serializer.serialize_i32(6),
            Self::Sqlserver2017Standard => serializer.serialize_i32(11),
            Self::Sqlserver2017Enterprise => serializer.serialize_i32(14),
            Self::Sqlserver2017Express => serializer.serialize_i32(15),
            Self::Sqlserver2017Web => serializer.serialize_i32(16),
            Self::Postgres96 => serializer.serialize_i32(9),
            Self::Postgres10 => serializer.serialize_i32(18),
            Self::Postgres11 => serializer.serialize_i32(10),
            Self::Postgres12 => serializer.serialize_i32(19),
            Self::Postgres13 => serializer.serialize_i32(23),
            Self::Postgres14 => serializer.serialize_i32(110),
            Self::Postgres15 => serializer.serialize_i32(172),
            Self::Postgres16 => serializer.serialize_i32(272),
            Self::Mysql80 => serializer.serialize_i32(20),
            Self::Mysql8018 => serializer.serialize_i32(41),
            Self::Mysql8026 => serializer.serialize_i32(85),
            Self::Mysql8027 => serializer.serialize_i32(111),
            Self::Mysql8028 => serializer.serialize_i32(132),
            Self::Mysql8029 => serializer.serialize_i32(148),
            Self::Mysql8030 => serializer.serialize_i32(174),
            Self::Mysql8031 => serializer.serialize_i32(197),
            Self::Mysql8032 => serializer.serialize_i32(213),
            Self::Mysql8033 => serializer.serialize_i32(238),
            Self::Mysql8034 => serializer.serialize_i32(239),
            Self::Mysql8035 => serializer.serialize_i32(240),
            Self::Mysql8036 => serializer.serialize_i32(241),
            Self::Mysql8037 => serializer.serialize_i32(355),
            Self::Mysql8038 => serializer.serialize_i32(356),
            Self::Mysql8039 => serializer.serialize_i32(357),
            Self::Mysql8040 => serializer.serialize_i32(358),
            Self::Mysql84 => serializer.serialize_i32(398),
            Self::Mysql840 => serializer.serialize_i32(399),
            Self::Sqlserver2019Standard => serializer.serialize_i32(26),
            Self::Sqlserver2019Enterprise => serializer.serialize_i32(27),
            Self::Sqlserver2019Express => serializer.serialize_i32(28),
            Self::Sqlserver2019Web => serializer.serialize_i32(29),
            Self::Sqlserver2022Standard => serializer.serialize_i32(199),
            Self::Sqlserver2022Enterprise => serializer.serialize_i32(200),
            Self::Sqlserver2022Express => serializer.serialize_i32(201),
            Self::Sqlserver2022Web => serializer.serialize_i32(202),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDatabaseVersion>::new(
            ".google.cloud.sql.v1.SqlDatabaseVersion"))
    }
}

/// The pricing plan for this instance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlPricingPlan {
    /// This is an unknown pricing plan for this instance.
    Unspecified,
    /// The instance is billed at a monthly flat rate.
    Package,
    /// The instance is billed per usage.
    PerUse,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlPricingPlan::value] or
    /// [SqlPricingPlan::name].
    UnknownValue(sql_pricing_plan::UnknownValue),
}

#[doc(hidden)]
pub mod sql_pricing_plan {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlPricingPlan {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Package => std::option::Option::Some(1),
            Self::PerUse => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_PRICING_PLAN_UNSPECIFIED"),
            Self::Package => std::option::Option::Some("PACKAGE"),
            Self::PerUse => std::option::Option::Some("PER_USE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlPricingPlan {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlPricingPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlPricingPlan {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Package,
            2 => Self::PerUse,
            _ => Self::UnknownValue(sql_pricing_plan::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlPricingPlan {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_PRICING_PLAN_UNSPECIFIED" => Self::Unspecified,
            "PACKAGE" => Self::Package,
            "PER_USE" => Self::PerUse,
            _ => Self::UnknownValue(sql_pricing_plan::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlPricingPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Package => serializer.serialize_i32(1),
            Self::PerUse => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlPricingPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlPricingPlan>::new(
            ".google.cloud.sql.v1.SqlPricingPlan"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlReplicationType {
    /// This is an unknown replication type for a Cloud SQL instance.
    Unspecified,
    /// The synchronous replication mode for First Generation instances. It is the
    /// default value.
    Synchronous,
    /// The asynchronous replication mode for First Generation instances. It
    /// provides a slight performance gain, but if an outage occurs while this
    /// option is set to asynchronous, you can lose up to a few seconds of updates
    /// to your data.
    Asynchronous,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlReplicationType::value] or
    /// [SqlReplicationType::name].
    UnknownValue(sql_replication_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_replication_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlReplicationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Synchronous => std::option::Option::Some(1),
            Self::Asynchronous => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_REPLICATION_TYPE_UNSPECIFIED"),
            Self::Synchronous => std::option::Option::Some("SYNCHRONOUS"),
            Self::Asynchronous => std::option::Option::Some("ASYNCHRONOUS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlReplicationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlReplicationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlReplicationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Synchronous,
            2 => Self::Asynchronous,
            _ => Self::UnknownValue(sql_replication_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlReplicationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_REPLICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SYNCHRONOUS" => Self::Synchronous,
            "ASYNCHRONOUS" => Self::Asynchronous,
            _ => Self::UnknownValue(sql_replication_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlReplicationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Synchronous => serializer.serialize_i32(1),
            Self::Asynchronous => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlReplicationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlReplicationType>::new(
            ".google.cloud.sql.v1.SqlReplicationType"))
    }
}

/// The type of disk that is used for a v2 instance to use.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlDataDiskType {
    /// This is an unknown data disk type.
    Unspecified,
    /// An SSD data disk.
    PdSsd,
    /// An HDD data disk.
    PdHdd,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[deprecated]
    ObsoleteLocalSsd,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlDataDiskType::value] or
    /// [SqlDataDiskType::name].
    UnknownValue(sql_data_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_data_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlDataDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PdSsd => std::option::Option::Some(1),
            Self::PdHdd => std::option::Option::Some(2),
            Self::ObsoleteLocalSsd => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
            Self::PdSsd => std::option::Option::Some("PD_SSD"),
            Self::PdHdd => std::option::Option::Some("PD_HDD"),
            Self::ObsoleteLocalSsd => std::option::Option::Some("OBSOLETE_LOCAL_SSD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlDataDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlDataDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlDataDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PdSsd,
            2 => Self::PdHdd,
            3 => Self::ObsoleteLocalSsd,
            _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlDataDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PD_SSD" => Self::PdSsd,
            "PD_HDD" => Self::PdHdd,
            "OBSOLETE_LOCAL_SSD" => Self::ObsoleteLocalSsd,
            _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlDataDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PdSsd => serializer.serialize_i32(1),
            Self::PdHdd => serializer.serialize_i32(2),
            Self::ObsoleteLocalSsd => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDataDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDataDiskType>::new(
            ".google.cloud.sql.v1.SqlDataDiskType"))
    }
}

/// The availability type of the given Cloud SQL instance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlAvailabilityType {
    /// This is an unknown Availability type.
    Unspecified,
    /// Zonal available instance.
    Zonal,
    /// Regional available instance.
    Regional,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlAvailabilityType::value] or
    /// [SqlAvailabilityType::name].
    UnknownValue(sql_availability_type::UnknownValue),
}

#[doc(hidden)]
pub mod sql_availability_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlAvailabilityType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Zonal => std::option::Option::Some(1),
            Self::Regional => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_AVAILABILITY_TYPE_UNSPECIFIED"),
            Self::Zonal => std::option::Option::Some("ZONAL"),
            Self::Regional => std::option::Option::Some("REGIONAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlAvailabilityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlAvailabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlAvailabilityType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Zonal,
            2 => Self::Regional,
            _ => Self::UnknownValue(sql_availability_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlAvailabilityType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "ZONAL" => Self::Zonal,
            "REGIONAL" => Self::Regional,
            _ => Self::UnknownValue(sql_availability_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlAvailabilityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Zonal => serializer.serialize_i32(1),
            Self::Regional => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlAvailabilityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlAvailabilityType>::new(
            ".google.cloud.sql.v1.SqlAvailabilityType"))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SqlUpdateTrack {
    /// This is an unknown maintenance timing preference.
    Unspecified,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 7 to 14 days
    /// after the notification is sent out. Also referred to as `Week 1` (Console)
    /// and `preview` (gcloud CLI).
    Canary,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 15 to 21 days
    /// after the notification is sent out. Also referred to as `Week 2` (Console)
    /// and `production` (gcloud CLI).
    Stable,
    /// For instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 35 to 42 days
    /// after the notification is sent out.
    Week5,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SqlUpdateTrack::value] or
    /// [SqlUpdateTrack::name].
    UnknownValue(sql_update_track::UnknownValue),
}

#[doc(hidden)]
pub mod sql_update_track {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SqlUpdateTrack {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Canary => std::option::Option::Some(1),
            Self::Stable => std::option::Option::Some(2),
            Self::Week5 => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SQL_UPDATE_TRACK_UNSPECIFIED"),
            Self::Canary => std::option::Option::Some("canary"),
            Self::Stable => std::option::Option::Some("stable"),
            Self::Week5 => std::option::Option::Some("week5"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SqlUpdateTrack {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SqlUpdateTrack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SqlUpdateTrack {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Canary,
            2 => Self::Stable,
            3 => Self::Week5,
            _ => Self::UnknownValue(sql_update_track::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for SqlUpdateTrack {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SQL_UPDATE_TRACK_UNSPECIFIED" => Self::Unspecified,
            "canary" => Self::Canary,
            "stable" => Self::Stable,
            "week5" => Self::Week5,
            _ => Self::UnknownValue(sql_update_track::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for SqlUpdateTrack {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Canary => serializer.serialize_i32(1),
            Self::Stable => serializer.serialize_i32(2),
            Self::Week5 => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlUpdateTrack {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlUpdateTrack>::new(
            ".google.cloud.sql.v1.SqlUpdateTrack"))
    }
}
