// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

/// Backup runs delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsDeleteRequest {

    /// The ID of the backup run to delete. To find a backup run ID, use the
    /// [list](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/backupRuns/list)
    /// method.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlBackupRunsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsDeleteRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsDeleteRequest"
    }
}

/// Backup runs get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsGetRequest {

    /// The ID of this backup run.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlBackupRunsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::SqlBackupRunsGetRequest::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsGetRequest"
    }
}

/// Backup runs insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsInsertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::BackupRun>,
}

impl SqlBackupRunsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlBackupRunsInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::BackupRun>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsInsertRequest"
    }
}

/// Backup runs list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlBackupRunsListRequest {

    /// Cloud SQL instance ID, or "-" for all instances. This does not include
    /// the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Maximum number of backup runs per response.
    pub max_results: i32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlBackupRunsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlBackupRunsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlBackupRunsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlBackupRunsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlBackupRunsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlBackupRunsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlBackupRunsListRequest"
    }
}

/// A BackupRun resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRun {

    /// This is always `sql#backupRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The status of this run.
    pub status: crate::model::SqlBackupRunStatus,

    /// The time the run was enqueued in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enqueued_time: std::option::Option<wkt::Timestamp>,

    /// The identifier for this backup run. Unique only for a specific Cloud SQL
    /// instance.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub id: i64,

    /// The time the backup operation actually started in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the backup operation completed in UTC timezone in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Information about why the backup operation failed. This is only present if
    /// the run has the FAILED status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::OperationError>,

    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
    /// This field defaults to "ON_DEMAND" and is ignored, when specified for
    /// insert requests.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlBackupRunType,

    /// The description of this run, only applicable to on-demand backups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The start time of the backup window during which this the backup was
    /// attempted in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for
    /// example `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window_start_time: std::option::Option<wkt::Timestamp>,

    /// Name of the database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// Location of the backups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Encryption configuration specific to a backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_configuration: std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Encryption status specific to a backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    pub backup_kind: crate::model::SqlBackupKind,

    /// Backup time zone to prevent restores to an instance with
    /// a different time zone. Now relevant only for SQL Server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    /// Output only. The maximum chargeable bytes for the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_chargeable_bytes: std::option::Option<i64>,
}

impl BackupRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRun::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [status][crate::model::BackupRun::status].
    pub fn set_status<T: std::convert::Into<crate::model::SqlBackupRunStatus>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [enqueued_time][crate::model::BackupRun::enqueued_time].
    pub fn set_enqueued_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.enqueued_time = v.into();
        self
    }

    /// Sets the value of [id][crate::model::BackupRun::id].
    pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackupRun::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BackupRun::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BackupRun::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<crate::model::OperationError>>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BackupRun::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlBackupRunType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BackupRun::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [window_start_time][crate::model::BackupRun::window_start_time].
    pub fn set_window_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.window_start_time = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::BackupRun::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::BackupRun::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [location][crate::model::BackupRun::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::BackupRun::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionConfiguration>>>(mut self, v: T) -> Self {
        self.disk_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::BackupRun::disk_encryption_status].
    pub fn set_disk_encryption_status<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionStatus>>>(mut self, v: T) -> Self {
        self.disk_encryption_status = v.into();
        self
    }

    /// Sets the value of [backup_kind][crate::model::BackupRun::backup_kind].
    pub fn set_backup_kind<T: std::convert::Into<crate::model::SqlBackupKind>>(mut self, v: T) -> Self {
        self.backup_kind = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::BackupRun::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [max_chargeable_bytes][crate::model::BackupRun::max_chargeable_bytes].
    pub fn set_max_chargeable_bytes<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.max_chargeable_bytes = v.into();
        self
    }
}

impl wkt::message::Message for BackupRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRun"
    }
}

/// Backup run list results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRunsListResponse {

    /// This is always `sql#backupRunsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// A list of backup runs in reverse chronological order of the enqueued time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::BackupRun>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl BackupRunsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::BackupRunsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::BackupRunsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::BackupRunsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupRun>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BackupRunsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRunsListResponse"
    }
}

/// Connect settings retrieval request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectSettingsRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_time: std::option::Option<wkt::Timestamp>,
}

impl GetConnectSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GetConnectSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GetConnectSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GetConnectSettingsRequest::read_time].
    pub fn set_read_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.read_time = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GetConnectSettingsRequest"
    }
}

/// Connect settings retrieval response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectSettings {

    /// This is always `sql#connectSettings`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// SSL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The assigned IP addresses for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// The cloud region for the instance. For example, `us-central1`,
    /// `europe-west1`. The region cannot be changed after instance creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The database engine type and version. The `databaseVersion`
    /// field cannot be changed after instance creation.
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
    /// or `MYSQL_5_6`.
    /// PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11`, `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
    /// SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
    /// `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
    /// `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// Whether PSC connectivity is enabled for this instance.
    pub psc_enabled: bool,

    /// The dns name of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dns_name: std::string::String,

    /// Specify what type of CA is used for the server certificate.
    pub server_ca_mode: crate::model::connect_settings::CaMode,
}

impl ConnectSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ConnectSettings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::ConnectSettings::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ConnectSettings::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::ConnectSettings::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::ConnectSettings::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(mut self, v: T) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [psc_enabled][crate::model::ConnectSettings::psc_enabled].
    pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.psc_enabled = v.into();
        self
    }

    /// Sets the value of [dns_name][crate::model::ConnectSettings::dns_name].
    pub fn set_dns_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dns_name = v.into();
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::ConnectSettings::server_ca_mode].
    pub fn set_server_ca_mode<T: std::convert::Into<crate::model::connect_settings::CaMode>>(mut self, v: T) -> Self {
        self.server_ca_mode = v.into();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::ConnectSettings::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConnectSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ConnectSettings"
    }
}

/// Defines additional types related to ConnectSettings
pub mod connect_settings {
    #[allow(unused_imports)]
    use super::*;


    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(Clone, Debug, PartialEq)]
    pub struct CaMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [CaMode](CaMode)
    pub mod ca_mode {
        use super::CaMode;
        

        /// CA mode is unknown.
        pub const CA_MODE_UNSPECIFIED: CaMode = CaMode::known("CA_MODE_UNSPECIFIED", 0);

        /// Google-managed self-signed internal CA.
        pub const GOOGLE_MANAGED_INTERNAL_CA: CaMode = CaMode::known("GOOGLE_MANAGED_INTERNAL_CA", 1);

        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        pub const GOOGLE_MANAGED_CAS_CA: CaMode = CaMode::known("GOOGLE_MANAGED_CAS_CA", 2);
    }

    impl CaMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(CaMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(CaMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(CaMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for CaMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CA_MODE_UNSPECIFIED" => ca_mode::CA_MODE_UNSPECIFIED,
                "GOOGLE_MANAGED_INTERNAL_CA" => ca_mode::GOOGLE_MANAGED_INTERNAL_CA,
                "GOOGLE_MANAGED_CAS_CA" => ca_mode::GOOGLE_MANAGED_CAS_CA,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => ca_mode::CA_MODE_UNSPECIFIED,
                1 => ca_mode::GOOGLE_MANAGED_INTERNAL_CA,
                2 => ca_mode::GOOGLE_MANAGED_CAS_CA,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Ephemeral certificate creation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateEphemeralCertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// PEM encoded public key to include in the signed certificate.
    #[serde(rename = "public_key")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// Optional. Access token to include in the signed certificate.
    #[serde(rename = "access_token")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_time: std::option::Option<wkt::Timestamp>,

    /// Optional. If set, it will contain the cert valid duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub valid_duration: std::option::Option<wkt::Duration>,
}

impl GenerateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::GenerateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::GenerateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateEphemeralCertRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::GenerateEphemeralCertRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [read_time][crate::model::GenerateEphemeralCertRequest::read_time].
    pub fn set_read_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.read_time = v.into();
        self
    }

    /// Sets the value of [valid_duration][crate::model::GenerateEphemeralCertRequest::valid_duration].
    pub fn set_valid_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.valid_duration = v.into();
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertRequest"
    }
}

/// Ephemeral certificate creation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateEphemeralCertResponse {

    /// Generated cert
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ephemeral_cert: std::option::Option<crate::model::SslCert>,
}

impl GenerateEphemeralCertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ephemeral_cert][crate::model::GenerateEphemeralCertResponse::ephemeral_cert].
    pub fn set_ephemeral_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.ephemeral_cert = v.into();
        self
    }
}

impl wkt::message::Message for GenerateEphemeralCertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GenerateEphemeralCertResponse"
    }
}

/// Database delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesDeleteRequest {

    /// Name of the database to be deleted in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlDatabasesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesDeleteRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesDeleteRequest"
    }
}

/// Database get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesGetRequest {

    /// Name of the database in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlDatabasesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesGetRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesGetRequest"
    }
}

/// Database insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesInsertRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::Database>,
}

impl SqlDatabasesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::Database>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesInsertRequest"
    }
}

/// Database list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlDatabasesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesListRequest"
    }
}

/// Database update request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlDatabasesUpdateRequest {

    /// Name of the database to be updated in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::Database>,
}

impl SqlDatabasesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::SqlDatabasesUpdateRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlDatabasesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlDatabasesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlDatabasesUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::Database>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlDatabasesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlDatabasesUpdateRequest"
    }
}

/// Database list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabasesListResponse {

    /// This is always `sql#databasesList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of database resources in the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Database>,
}

impl DatabasesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabasesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::DatabasesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabasesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabasesListResponse"
    }
}

/// Flags list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlFlagsListRequest {

    /// Database type and version you want to retrieve flags for. By default, this
    /// method returns flags for all database types and versions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_version: std::string::String,
}

impl SqlFlagsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::SqlFlagsListRequest::database_version].
    pub fn set_database_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }
}

impl wkt::message::Message for SqlFlagsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlFlagsListRequest"
    }
}

/// Flags list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FlagsListResponse {

    /// This is always `sql#flagsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of flags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Flag>,
}

impl FlagsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::FlagsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::FlagsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Flag>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FlagsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FlagsListResponse"
    }
}

/// A flag resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Flag {

    /// This is the name of the flag. Flag names always use underscores, not
    /// hyphens, for example: `max_allowed_packet`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of the flag. Flags are typed to being `BOOLEAN`, `STRING`,
    /// `INTEGER` or `NONE`. `NONE` is used for flags that do not take a
    /// value, such as `skip_grant_tables`.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlFlagType,

    /// The database version this flag applies to. Can be
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_8_0_18`, `MYSQL_8_0_26`, `MYSQL_5_7`,
    /// or `MYSQL_5_6`. PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12`. SQL Server instances:
    /// `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`,
    /// `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    /// See [the complete
    /// list](/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub applies_to: std::vec::Vec<crate::model::SqlDatabaseVersion>,

    /// For `STRING` flags, a list of strings that the value can be set to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_string_values: std::vec::Vec<std::string::String>,

    /// For `INTEGER` flags, the minimum allowed value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub min_value: std::option::Option<wkt::Int64Value>,

    /// For `INTEGER` flags, the maximum allowed value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_value: std::option::Option<wkt::Int64Value>,

    /// Indicates whether changing this flag will trigger a database restart. Only
    /// applicable to Second Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requires_restart: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#flag`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Whether or not the flag is considered in beta.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub in_beta: std::option::Option<wkt::BoolValue>,

    /// Use this field if only certain integers are accepted. Can be combined
    /// with min_value and max_value to add additional values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub allowed_int_values: std::vec::Vec<i64>,
}

impl Flag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Flag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Flag::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlFlagType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [min_value][crate::model::Flag::min_value].
    pub fn set_min_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.min_value = v.into();
        self
    }

    /// Sets the value of [max_value][crate::model::Flag::max_value].
    pub fn set_max_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.max_value = v.into();
        self
    }

    /// Sets the value of [requires_restart][crate::model::Flag::requires_restart].
    pub fn set_requires_restart<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.requires_restart = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Flag::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [in_beta][crate::model::Flag::in_beta].
    pub fn set_in_beta<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.in_beta = v.into();
        self
    }

    /// Sets the value of [applies_to][crate::model::Flag::applies_to].
    pub fn set_applies_to<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlDatabaseVersion>
    {
        use std::iter::Iterator;
        self.applies_to = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allowed_string_values][crate::model::Flag::allowed_string_values].
    pub fn set_allowed_string_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.allowed_string_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allowed_int_values][crate::model::Flag::allowed_int_values].
    pub fn set_allowed_int_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>
    {
        use std::iter::Iterator;
        self.allowed_int_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Flag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Flag"
    }
}

/// Instance add server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAddServerCaRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesAddServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAddServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAddServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAddServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAddServerCaRequest"
    }
}

/// Instance clone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesCloneRequest {

    /// The ID of the Cloud SQL instance to be cloned (source). This does not
    /// include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the source as well as the clone Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesCloneRequest>,
}

impl SqlInstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCloneRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCloneRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCloneRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesCloneRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCloneRequest"
    }
}

/// Instance delete request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDeleteRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDeleteRequest"
    }
}

/// Instance demote master request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDemoteMasterRequest {

    /// Cloud SQL instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesDemoteMasterRequest>,
}

impl SqlInstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteMasterRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteMasterRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteMasterRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesDemoteMasterRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteMasterRequest"
    }
}

/// Instance demote request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesDemoteRequest {

    /// Required. Cloud SQL instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Required. The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesDemoteRequest>,
}

impl SqlInstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesDemoteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesDemoteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesDemoteRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesDemoteRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesDemoteRequest"
    }
}

/// Instance export request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesExportRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be exported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesExportRequest>,
}

impl SqlInstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesExportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesExportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesExportRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesExportRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesExportRequest"
    }
}

/// Instance failover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesFailoverRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesFailoverRequest>,
}

impl SqlInstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesFailoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesFailoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesFailoverRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesFailoverRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesFailoverRequest"
    }
}

/// Instance get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetRequest"
    }
}

/// Instance import request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesImportRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesImportRequest>,
}

impl SqlInstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesImportRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesImportRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesImportRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesImportRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesImportRequest"
    }
}

/// Instance insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesInsertRequest {

    /// Project ID of the project to which the newly created Cloud SQL instances
    /// should belong.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,
}

impl SqlInstancesInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlInstancesInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesInsertRequest"
    }
}

/// Instance list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesListRequest {

    /// A filter expression that filters resources listed in the response.
    /// The expression is in the form of field:value. For example,
    /// 'instanceType:CLOUD_SQL_INSTANCE'. Fields can be nested as needed as per
    /// their JSON representation, such as 'settings.userLabels.auto_start:true'.
    ///
    /// Multiple filter queries are space-separated. For example.
    /// 'state:RUNNABLE instanceType:CLOUD_SQL_INSTANCE'. By default, each
    /// expression is an AND expression. However, you can include AND and OR
    /// expressions explicitly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The maximum number of instances to return. The service may return fewer
    /// than this value.
    /// If unspecified, at most 500 instances are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project for which to list Cloud SQL instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::SqlInstancesListRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlInstancesListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlInstancesListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListRequest"
    }
}

/// Instance list server CAs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesListServerCasRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesListServerCasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesListServerCasRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesListServerCasRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesListServerCasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesListServerCasRequest"
    }
}

/// Instance patch request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPatchRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,
}

impl SqlInstancesPatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPatchRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPatchRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPatchRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPatchRequest"
    }
}

/// Instance promote replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPromoteReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Set to true to invoke a replica failover to the designated DR
    /// replica. As part of replica failover, the promote operation attempts
    /// to add the original primary instance as a replica of the promoted
    /// DR replica when the original primary instance comes back online.
    /// If set to false or not specified, then the original primary
    /// instance becomes an independent Cloud SQL primary instance.
    /// Only applicable to MySQL.
    pub failover: bool,
}

impl SqlInstancesPromoteReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPromoteReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPromoteReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [failover][crate::model::SqlInstancesPromoteReplicaRequest::failover].
    pub fn set_failover<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.failover = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPromoteReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPromoteReplicaRequest"
    }
}

/// Instance switchover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesSwitchoverRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Optional. (MySQL only) Cloud SQL instance operations timeout, which is a
    /// sum of all database operations. Default value is 10 minutes and can be
    /// modified to a maximum value of 24 hours.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub db_timeout: std::option::Option<wkt::Duration>,
}

impl SqlInstancesSwitchoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesSwitchoverRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesSwitchoverRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [db_timeout][crate::model::SqlInstancesSwitchoverRequest::db_timeout].
    pub fn set_db_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.db_timeout = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesSwitchoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesSwitchoverRequest"
    }
}

/// Instance reset SSL config request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesResetSslConfigRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesResetSslConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetSslConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetSslConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetSslConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetSslConfigRequest"
    }
}

/// Instance restart request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRestartRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance to be restarted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesRestartRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestartRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestartRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRestartRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestartRequest"
    }
}

/// Instance restore backup request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRestoreBackupRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesRestoreBackupRequest>,
}

impl SqlInstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRestoreBackupRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRestoreBackupRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRestoreBackupRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesRestoreBackupRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRestoreBackupRequest"
    }
}

/// Instance rotate server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRotateServerCaRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesRotateServerCaRequest>,
}

impl SqlInstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRotateServerCaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRotateServerCaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRotateServerCaRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesRotateServerCaRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRotateServerCaRequest"
    }
}

/// Instance start replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStartReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesStartReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStartReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartReplicaRequest"
    }
}

/// Instance stop replica request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStopReplicaRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesStopReplicaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStopReplicaRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStopReplicaRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesStopReplicaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStopReplicaRequest"
    }
}

/// Instance truncate log request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesTruncateLogRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesTruncateLogRequest>,
}

impl SqlInstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesTruncateLogRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesTruncateLogRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesTruncateLogRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesTruncateLogRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesTruncateLogRequest"
    }
}

/// Instance perform disk shrink request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesPerformDiskShrinkRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Perform disk shrink context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::PerformDiskShrinkContext>,
}

impl SqlInstancesPerformDiskShrinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesPerformDiskShrinkRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesPerformDiskShrinkRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesPerformDiskShrinkRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::PerformDiskShrinkContext>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesPerformDiskShrinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesPerformDiskShrinkRequest"
    }
}

/// Instance update request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesUpdateRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::DatabaseInstance>,
}

impl SqlInstancesUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::DatabaseInstance>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesUpdateRequest"
    }
}

/// Instance reschedule maintenance request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>,
}

impl SqlInstancesRescheduleMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesRescheduleMaintenanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesRescheduleMaintenanceRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesRescheduleMaintenanceRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SqlInstancesRescheduleMaintenanceRequestBody>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequest"
    }
}

/// Instance reencrypt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReencryptRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Reencrypt body that users request
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesReencryptRequest>,
}

impl SqlInstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReencryptRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReencryptRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesReencryptRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesReencryptRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReencryptRequest"
    }
}

/// Database Instance reencrypt request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesReencryptRequest {

    /// Configuration specific to backup re-encryption
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_reencryption_config: std::option::Option<crate::model::BackupReencryptionConfig>,
}

impl InstancesReencryptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_reencryption_config][crate::model::InstancesReencryptRequest::backup_reencryption_config].
    pub fn set_backup_reencryption_config<T: std::convert::Into<std::option::Option<crate::model::BackupReencryptionConfig>>>(mut self, v: T) -> Self {
        self.backup_reencryption_config = v.into();
        self
    }
}

impl wkt::message::Message for InstancesReencryptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesReencryptRequest"
    }
}

/// Backup Reencryption Config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupReencryptionConfig {

    /// Backup re-encryption limit
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_limit: std::option::Option<i32>,

    /// Type of backups users want to re-encrypt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_type: std::option::Option<crate::model::backup_reencryption_config::BackupType>,
}

impl BackupReencryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_limit][crate::model::BackupReencryptionConfig::backup_limit].
    pub fn set_backup_limit<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.backup_limit = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::BackupReencryptionConfig::backup_type].
    pub fn set_backup_type<T: std::convert::Into<std::option::Option<crate::model::backup_reencryption_config::BackupType>>>(mut self, v: T) -> Self {
        self.backup_type = v.into();
        self
    }
}

impl wkt::message::Message for BackupReencryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupReencryptionConfig"
    }
}

/// Defines additional types related to BackupReencryptionConfig
pub mod backup_reencryption_config {
    #[allow(unused_imports)]
    use super::*;


    /// Backup type for re-encryption
    #[derive(Clone, Debug, PartialEq)]
    pub struct BackupType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [BackupType](BackupType)
    pub mod backup_type {
        use super::BackupType;
        

        /// Unknown backup type, will be defaulted to AUTOMATIC backup type
        pub const BACKUP_TYPE_UNSPECIFIED: BackupType = BackupType::known("BACKUP_TYPE_UNSPECIFIED", 0);

        /// Reencrypt automatic backups
        pub const AUTOMATED: BackupType = BackupType::known("AUTOMATED", 1);

        /// Reencrypt on-demand backups
        pub const ON_DEMAND: BackupType = BackupType::known("ON_DEMAND", 2);
    }

    impl BackupType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(BackupType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(BackupType::from(val)),
                Enumeration::UnknownNum { str } => Ok(BackupType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for BackupType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "BACKUP_TYPE_UNSPECIFIED" => backup_type::BACKUP_TYPE_UNSPECIFIED,
                "AUTOMATED" => backup_type::AUTOMATED,
                "ON_DEMAND" => backup_type::ON_DEMAND,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => backup_type::BACKUP_TYPE_UNSPECIFIED,
                1 => backup_type::AUTOMATED,
                2 => backup_type::ON_DEMAND,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Instance get disk shrink config request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesGetDiskShrinkConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetDiskShrinkConfigRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetDiskShrinkConfigRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigRequest"
    }
}

/// Instance verify external sync settings request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Flag to enable verifying connection only
    pub verify_connection_only: bool,

    /// External sync mode
    pub sync_mode: crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Optional. Flag to verify settings required by replication setup only
    pub verify_replication_only: bool,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type: crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    /// Optional. Parallel level for initial data sync. Only applicable for
    /// PostgreSQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig>,
}

impl SqlInstancesVerifyExternalSyncSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [verify_connection_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_connection_only].
    pub fn set_verify_connection_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_connection_only = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_mode].
    pub fn set_sync_mode<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>(mut self, v: T) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [verify_replication_only][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::verify_replication_only].
    pub fn set_verify_replication_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify_replication_only = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::migration_type].
    pub fn set_migration_type<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>(mut self, v: T) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<T: std::convert::Into<crate::model::ExternalSyncParallelLevel>>(mut self, v: T) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of `sync_config`.
    pub fn set_sync_config<T: std::convert::Into<std::option::Option<crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig>>>(mut self, v: T) -> Self
    {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_mysql_sync_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesVerifyExternalSyncSettingsRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>>(mut self, v: T) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_verify_external_sync_settings_request::SyncConfig::MysqlSyncConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsRequest"
    }
}

/// Defines additional types related to SqlInstancesVerifyExternalSyncSettingsRequest
pub mod sql_instances_verify_external_sync_settings_request {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    pub struct ExternalSyncMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ExternalSyncMode](ExternalSyncMode)
    pub mod external_sync_mode {
        use super::ExternalSyncMode;
        

        /// Unknown external sync mode, will be defaulted to ONLINE mode
        pub const EXTERNAL_SYNC_MODE_UNSPECIFIED: ExternalSyncMode = ExternalSyncMode::known("EXTERNAL_SYNC_MODE_UNSPECIFIED", 0);

        /// Online external sync will set up replication after initial data external
        /// sync
        pub const ONLINE: ExternalSyncMode = ExternalSyncMode::known("ONLINE", 1);

        /// Offline external sync only dumps and loads a one-time snapshot of
        /// the primary instance's data
        pub const OFFLINE: ExternalSyncMode = ExternalSyncMode::known("OFFLINE", 2);
    }

    impl ExternalSyncMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ExternalSyncMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExternalSyncMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ExternalSyncMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ExternalSyncMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(ExternalSyncMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ExternalSyncMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "EXTERNAL_SYNC_MODE_UNSPECIFIED" => external_sync_mode::EXTERNAL_SYNC_MODE_UNSPECIFIED,
                "ONLINE" => external_sync_mode::ONLINE,
                "OFFLINE" => external_sync_mode::OFFLINE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ExternalSyncMode {
        fn from(value: i32) -> Self {
            match value {
                0 => external_sync_mode::EXTERNAL_SYNC_MODE_UNSPECIFIED,
                1 => external_sync_mode::ONLINE,
                2 => external_sync_mode::OFFLINE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ExternalSyncMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// MigrationType determines whether the migration is a physical file-based
    /// migration or a logical dump file-based migration.
    #[derive(Clone, Debug, PartialEq)]
    pub struct MigrationType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [MigrationType](MigrationType)
    pub mod migration_type {
        use super::MigrationType;
        

        /// Default value is a logical dump file-based migration
        pub const MIGRATION_TYPE_UNSPECIFIED: MigrationType = MigrationType::known("MIGRATION_TYPE_UNSPECIFIED", 0);

        /// Logical dump file-based migration
        pub const LOGICAL: MigrationType = MigrationType::known("LOGICAL", 1);

        /// Physical file-based migration
        pub const PHYSICAL: MigrationType = MigrationType::known("PHYSICAL", 2);
    }

    impl MigrationType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for MigrationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(MigrationType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(MigrationType::from(val)),
                Enumeration::UnknownNum { str } => Ok(MigrationType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for MigrationType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "MIGRATION_TYPE_UNSPECIFIED" => migration_type::MIGRATION_TYPE_UNSPECIFIED,
                "LOGICAL" => migration_type::LOGICAL,
                "PHYSICAL" => migration_type::PHYSICAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for MigrationType {
        fn from(value: i32) -> Self {
            match value {
                0 => migration_type::MIGRATION_TYPE_UNSPECIFIED,
                1 => migration_type::LOGICAL,
                2 => migration_type::PHYSICAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for MigrationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// Optional. MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance start external sync request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesStartExternalSyncRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// External sync mode.
    pub sync_mode: crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode,

    /// Whether to skip the verification step (VESS).
    pub skip_verification: bool,

    /// Optional. Parallel level for initial data sync. Currently only applicable
    /// for MySQL.
    pub sync_parallel_level: crate::model::ExternalSyncParallelLevel,

    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    pub migration_type: crate::model::sql_instances_verify_external_sync_settings_request::MigrationType,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub sync_config: std::option::Option<crate::model::sql_instances_start_external_sync_request::SyncConfig>,
}

impl SqlInstancesStartExternalSyncRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesStartExternalSyncRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesStartExternalSyncRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sync_mode][crate::model::SqlInstancesStartExternalSyncRequest::sync_mode].
    pub fn set_sync_mode<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::ExternalSyncMode>>(mut self, v: T) -> Self {
        self.sync_mode = v.into();
        self
    }

    /// Sets the value of [skip_verification][crate::model::SqlInstancesStartExternalSyncRequest::skip_verification].
    pub fn set_skip_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_verification = v.into();
        self
    }

    /// Sets the value of [sync_parallel_level][crate::model::SqlInstancesStartExternalSyncRequest::sync_parallel_level].
    pub fn set_sync_parallel_level<T: std::convert::Into<crate::model::ExternalSyncParallelLevel>>(mut self, v: T) -> Self {
        self.sync_parallel_level = v.into();
        self
    }

    /// Sets the value of [migration_type][crate::model::SqlInstancesStartExternalSyncRequest::migration_type].
    pub fn set_migration_type<T: std::convert::Into<crate::model::sql_instances_verify_external_sync_settings_request::MigrationType>>(mut self, v: T) -> Self {
        self.migration_type = v.into();
        self
    }

    /// Sets the value of `sync_config`.
    pub fn set_sync_config<T: std::convert::Into<std::option::Option<crate::model::sql_instances_start_external_sync_request::SyncConfig>>>(mut self, v: T) -> Self
    {
        self.sync_config = v.into();
        self
    }

    /// The value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// if it holds a `MysqlSyncConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_mysql_sync_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::MySqlSyncConfig>> {
        #[allow(unreachable_patterns)]
        self.sync_config.as_ref().and_then(|v| match v {
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [sync_config][crate::model::SqlInstancesStartExternalSyncRequest::sync_config]
    /// to hold a `MysqlSyncConfig`.
    ///
    /// Note that all the setters affecting `sync_config` are
    /// mutually exclusive.
    pub fn set_mysql_sync_config<T: std::convert::Into<std::boxed::Box<crate::model::MySqlSyncConfig>>>(mut self, v: T) -> Self {
        self.sync_config = std::option::Option::Some(
            crate::model::sql_instances_start_external_sync_request::SyncConfig::MysqlSyncConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for SqlInstancesStartExternalSyncRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesStartExternalSyncRequest"
    }
}

/// Defines additional types related to SqlInstancesStartExternalSyncRequest
pub mod sql_instances_start_external_sync_request {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SyncConfig {
        /// MySQL-specific settings for start external sync.
        MysqlSyncConfig(std::boxed::Box<crate::model::MySqlSyncConfig>),
    }
}

/// Instance reset replica size request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesResetReplicaSizeRequest {

    /// Cloud SQL read replica instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// ID of the project that contains the read replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesResetReplicaSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesResetReplicaSizeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesResetReplicaSizeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesResetReplicaSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesResetReplicaSizeRequest"
    }
}

/// Instance create ephemeral certificate request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesCreateEphemeralCertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the Cloud SQL project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SslCertsCreateEphemeralRequest>,
}

impl SqlInstancesCreateEphemeralCertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesCreateEphemeralCertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesCreateEphemeralCertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesCreateEphemeralCertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SslCertsCreateEphemeralRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesCreateEphemeralCertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesCreateEphemeralCertRequest"
    }
}

/// Database instance clone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesCloneRequest {

    /// Contains details about the clone operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clone_context: std::option::Option<crate::model::CloneContext>,
}

impl InstancesCloneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_context][crate::model::InstancesCloneRequest::clone_context].
    pub fn set_clone_context<T: std::convert::Into<std::option::Option<crate::model::CloneContext>>>(mut self, v: T) -> Self {
        self.clone_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesCloneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesCloneRequest"
    }
}

/// Database demote primary instance request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesDemoteMasterRequest {

    /// Contains details about the demoteMaster operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub demote_master_context: std::option::Option<crate::model::DemoteMasterContext>,
}

impl InstancesDemoteMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_master_context][crate::model::InstancesDemoteMasterRequest::demote_master_context].
    pub fn set_demote_master_context<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterContext>>>(mut self, v: T) -> Self {
        self.demote_master_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesDemoteMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteMasterRequest"
    }
}

/// This request is used to demote an existing standalone instance to be a
/// Cloud SQL read replica for an external database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesDemoteRequest {

    /// Required. Contains details about the demote operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub demote_context: std::option::Option<crate::model::DemoteContext>,
}

impl InstancesDemoteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [demote_context][crate::model::InstancesDemoteRequest::demote_context].
    pub fn set_demote_context<T: std::convert::Into<std::option::Option<crate::model::DemoteContext>>>(mut self, v: T) -> Self {
        self.demote_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesDemoteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesDemoteRequest"
    }
}

/// Database instance export request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesExportRequest {

    /// Contains details about the export operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_context: std::option::Option<crate::model::ExportContext>,
}

impl InstancesExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_context][crate::model::InstancesExportRequest::export_context].
    pub fn set_export_context<T: std::convert::Into<std::option::Option<crate::model::ExportContext>>>(mut self, v: T) -> Self {
        self.export_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesExportRequest"
    }
}

/// Instance failover request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesFailoverRequest {

    /// Failover Context.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_context: std::option::Option<crate::model::FailoverContext>,
}

impl InstancesFailoverRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [failover_context][crate::model::InstancesFailoverRequest::failover_context].
    pub fn set_failover_context<T: std::convert::Into<std::option::Option<crate::model::FailoverContext>>>(mut self, v: T) -> Self {
        self.failover_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesFailoverRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesFailoverRequest"
    }
}

/// SslCerts create ephemeral certificate request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsCreateEphemeralRequest {

    /// PEM encoded public key to include in the signed certificate.
    #[serde(rename = "public_key")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// Access token to include in the signed certificate.
    #[serde(rename = "access_token")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,
}

impl SslCertsCreateEphemeralRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [public_key][crate::model::SslCertsCreateEphemeralRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [access_token][crate::model::SslCertsCreateEphemeralRequest::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsCreateEphemeralRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsCreateEphemeralRequest"
    }
}

/// Database instance import request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesImportRequest {

    /// Contains details about the import operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_context: std::option::Option<crate::model::ImportContext>,
}

impl InstancesImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [import_context][crate::model::InstancesImportRequest::import_context].
    pub fn set_import_context<T: std::convert::Into<std::option::Option<crate::model::ImportContext>>>(mut self, v: T) -> Self {
        self.import_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesImportRequest"
    }
}

/// Database instances list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesListResponse {

    /// This is always `sql#instancesList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of warnings that occurred while handling the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<crate::model::ApiWarning>,

    /// List of database instance resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::DatabaseInstance>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl InstancesListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::InstancesListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstancesListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::InstancesListResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ApiWarning>
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [items][crate::model::InstancesListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseInstance>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstancesListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListResponse"
    }
}

/// Instances ListServerCas response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesListServerCasResponse {

    /// List of server CA certificates for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub certs: std::vec::Vec<crate::model::SslCert>,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_version: std::string::String,

    /// This is always `sql#instancesListServerCas`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl InstancesListServerCasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [active_version][crate::model::InstancesListServerCasResponse::active_version].
    pub fn set_active_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.active_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::InstancesListServerCasResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [certs][crate::model::InstancesListServerCasResponse::certs].
    pub fn set_certs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>
    {
        use std::iter::Iterator;
        self.certs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstancesListServerCasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesListServerCasResponse"
    }
}

/// Database instance restore backup request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesRestoreBackupRequest {

    /// Parameters required to perform the restore backup operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_backup_context: std::option::Option<crate::model::RestoreBackupContext>,
}

impl InstancesRestoreBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_backup_context][crate::model::InstancesRestoreBackupRequest::restore_backup_context].
    pub fn set_restore_backup_context<T: std::convert::Into<std::option::Option<crate::model::RestoreBackupContext>>>(mut self, v: T) -> Self {
        self.restore_backup_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesRestoreBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRestoreBackupRequest"
    }
}

/// Rotate server CA request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesRotateServerCaRequest {

    /// Contains details about the rotate server CA operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rotate_server_ca_context: std::option::Option<crate::model::RotateServerCaContext>,
}

impl InstancesRotateServerCaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rotate_server_ca_context][crate::model::InstancesRotateServerCaRequest::rotate_server_ca_context].
    pub fn set_rotate_server_ca_context<T: std::convert::Into<std::option::Option<crate::model::RotateServerCaContext>>>(mut self, v: T) -> Self {
        self.rotate_server_ca_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesRotateServerCaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesRotateServerCaRequest"
    }
}

/// Instance truncate log request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesTruncateLogRequest {

    /// Contains details about the truncate log operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub truncate_log_context: std::option::Option<crate::model::TruncateLogContext>,
}

impl InstancesTruncateLogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [truncate_log_context][crate::model::InstancesTruncateLogRequest::truncate_log_context].
    pub fn set_truncate_log_context<T: std::convert::Into<std::option::Option<crate::model::TruncateLogContext>>>(mut self, v: T) -> Self {
        self.truncate_log_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesTruncateLogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesTruncateLogRequest"
    }
}

/// Request to acquire a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstancesAcquireSsrsLeaseRequest {

    /// Contains details about the acquire SSRS lease operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,
}

impl InstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::InstancesAcquireSsrsLeaseRequest::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T: std::convert::Into<std::option::Option<crate::model::AcquireSsrsLeaseContext>>>(mut self, v: T) -> Self {
        self.acquire_ssrs_lease_context = v.into();
        self
    }
}

impl wkt::message::Message for InstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstancesAcquireSsrsLeaseRequest"
    }
}

/// Instance verify external sync settings response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesVerifyExternalSyncSettingsResponse {

    /// This is always `sql#migrationSettingErrorList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of migration violations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,

    /// List of migration warnings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<crate::model::SqlExternalSyncSettingError>,
}

impl SqlInstancesVerifyExternalSyncSettingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::SqlInstancesVerifyExternalSyncSettingsResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlExternalSyncSettingError>
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlInstancesVerifyExternalSyncSettingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesVerifyExternalSyncSettingsResponse"
    }
}

/// Instance get disk shrink config response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetDiskShrinkConfigResponse {

    /// This is always `sql#getDiskShrinkConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The minimum size to which a disk can be shrunk in GigaBytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub minimal_target_size_gb: i64,

    /// Additional message to customers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl SqlInstancesGetDiskShrinkConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetDiskShrinkConfigResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [minimal_target_size_gb][crate::model::SqlInstancesGetDiskShrinkConfigResponse::minimal_target_size_gb].
    pub fn set_minimal_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.minimal_target_size_gb = v.into();
        self
    }

    /// Sets the value of [message][crate::model::SqlInstancesGetDiskShrinkConfigResponse::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetDiskShrinkConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetDiskShrinkConfigResponse"
    }
}

/// Instance get latest recovery time request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesGetLatestRecoveryTimeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesGetLatestRecoveryTimeRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeRequest"
    }
}

/// Instance get latest recovery time response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesGetLatestRecoveryTimeResponse {

    /// This is always `sql#getLatestRecoveryTime`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Timestamp, identifies the latest recovery time of the source instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_recovery_time: std::option::Option<wkt::Timestamp>,
}

impl SqlInstancesGetLatestRecoveryTimeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [latest_recovery_time][crate::model::SqlInstancesGetLatestRecoveryTimeResponse::latest_recovery_time].
    pub fn set_latest_recovery_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.latest_recovery_time = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesGetLatestRecoveryTimeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesGetLatestRecoveryTimeResponse"
    }
}

/// Database instance clone context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloneContext {

    /// This is always `sql#cloneContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Reserved for future use.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub pitr_timestamp_ms: i64,

    /// Name of the Cloud SQL instance to be created as a clone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination_instance_name: std::string::String,

    /// Binary log coordinates, if specified, identify the position up to which the
    /// source instance is cloned. If not specified, the source instance is
    /// cloned up to the most recent binary log coordinates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bin_log_coordinates: std::option::Option<crate::model::BinLogCoordinates>,

    /// Timestamp, if specified, identifies the time to which the source instance
    /// is cloned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub point_in_time: std::option::Option<wkt::Timestamp>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the cloned instance
    /// ip will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// [a-z]([-a-z0-9]*[a-z0-9])?.
    /// Reserved for future use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// (SQL Server only) Clone only the specified databases from the source
    /// instance. Clone all databases if empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_names: std::vec::Vec<std::string::String>,

    /// Optional. Copy clone and point-in-time recovery clone of an instance to the
    /// specified zone. If no zone is specified, clone to the same primary zone as
    /// the source instance. This field applies to all DB types.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub preferred_zone: std::option::Option<std::string::String>,
}

impl CloneContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::CloneContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [pitr_timestamp_ms][crate::model::CloneContext::pitr_timestamp_ms].
    pub fn set_pitr_timestamp_ms<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pitr_timestamp_ms = v.into();
        self
    }

    /// Sets the value of [destination_instance_name][crate::model::CloneContext::destination_instance_name].
    pub fn set_destination_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_instance_name = v.into();
        self
    }

    /// Sets the value of [bin_log_coordinates][crate::model::CloneContext::bin_log_coordinates].
    pub fn set_bin_log_coordinates<T: std::convert::Into<std::option::Option<crate::model::BinLogCoordinates>>>(mut self, v: T) -> Self {
        self.bin_log_coordinates = v.into();
        self
    }

    /// Sets the value of [point_in_time][crate::model::CloneContext::point_in_time].
    pub fn set_point_in_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.point_in_time = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::CloneContext::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [preferred_zone][crate::model::CloneContext::preferred_zone].
    pub fn set_preferred_zone<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.preferred_zone = v.into();
        self
    }

    /// Sets the value of [database_names][crate::model::CloneContext::database_names].
    pub fn set_database_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.database_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloneContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.CloneContext"
    }
}

/// Binary log coordinates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BinLogCoordinates {

    /// Name of the binary log file for a Cloud SQL instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bin_log_file_name: std::string::String,

    /// Position (offset) within the binary log file.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub bin_log_position: i64,

    /// This is always `sql#binLogCoordinates`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl BinLogCoordinates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bin_log_file_name][crate::model::BinLogCoordinates::bin_log_file_name].
    pub fn set_bin_log_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bin_log_file_name = v.into();
        self
    }

    /// Sets the value of [bin_log_position][crate::model::BinLogCoordinates::bin_log_position].
    pub fn set_bin_log_position<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bin_log_position = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BinLogCoordinates::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BinLogCoordinates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BinLogCoordinates"
    }
}

/// A Cloud SQL instance resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseInstance {

    /// This is always `sql#instance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The current serving state of the Cloud SQL instance.
    pub state: crate::model::database_instance::SqlInstanceState,

    /// The database engine type and version. The `databaseVersion` field cannot
    /// be changed after instance creation.
    pub database_version: crate::model::SqlDatabaseVersion,

    /// The user settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::Settings>,

    /// This field is deprecated and will be removed from a future version of the
    /// API. Use the `settings.settingsVersion` field instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name and status of the failover replica.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_replica: std::option::Option<crate::model::database_instance::SqlFailoverReplica>,

    /// The name of the instance which will act as primary in the replication
    /// setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_instance_name: std::string::String,

    /// The replicas of the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replica_names: std::vec::Vec<std::string::String>,

    /// The maximum disk size of the instance in bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub max_disk_size: std::option::Option<wkt::Int64Value>,

    /// The current disk usage of the instance in bytes. This property has been
    /// deprecated. Use the
    /// "cloudsql.googleapis.com/database/disk/bytes_used" metric in Cloud
    /// Monitoring API instead. Please see [this
    /// announcement](https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ)
    /// for details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub current_disk_size: std::option::Option<wkt::Int64Value>,

    /// The assigned IP addresses for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ip_addresses: std::vec::Vec<crate::model::IpMapping>,

    /// SSL configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The instance type.
    pub instance_type: crate::model::SqlInstanceType,

    /// The project ID of the project containing the Cloud SQL instance. The Google
    /// apps domain is prefixed if applicable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The IPv6 address assigned to the instance.
    /// (Deprecated) This property was applicable only
    /// to First Generation instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ipv6_address: std::string::String,

    /// The service account email address assigned to the instance.\This
    /// property is read-only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email_address: std::string::String,

    /// Configuration specific to on-premises instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub on_premises_configuration: std::option::Option<crate::model::OnPremisesConfiguration>,

    /// Configuration specific to failover replicas and read replicas.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_configuration: std::option::Option<crate::model::ReplicaConfiguration>,

    /// The backend type.
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    ///
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    pub backend_type: crate::model::SqlBackendType,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// If the instance state is SUSPENDED, the reason for the suspension.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub suspension_reason: std::vec::Vec<crate::model::SqlSuspensionReason>,

    /// Connection name of the Cloud SQL instance used in connection strings.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Name of the Cloud SQL instance. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The geographical region of the Cloud SQL instance.
    ///
    /// It can be one of the
    /// [regions](https://cloud.google.com/sql/docs/mysql/locations#location-r)
    /// where Cloud SQL operates:
    ///
    /// For example,  `asia-east1`, `europe-west1`, and  `us-central1`.
    /// The default value is `us-central1`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The Compute Engine zone that the instance is currently serving from. This
    /// value could be different from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary zone. WARNING:
    /// Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gce_zone: std::string::String,

    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional instance. This value could be different
    /// from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary/failover zone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_gce_zone: std::string::String,

    /// Disk encryption configuration specific to an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_configuration: std::option::Option<crate::model::DiskEncryptionConfiguration>,

    /// Disk encryption status specific to an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_encryption_status: std::option::Option<crate::model::DiskEncryptionStatus>,

    /// Initial root password. Use only on creation. You must set root passwords
    /// before you can connect to PostgreSQL instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_password: std::string::String,

    /// The start time of any upcoming scheduled maintenance for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_maintenance: std::option::Option<crate::model::database_instance::SqlScheduledMaintenance>,

    /// This status indicates whether the instance satisfies PZS.
    ///
    /// The status is reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<wkt::BoolValue>,

    /// Output only. Stores the current database version running on the instance
    /// including minor version such as `MYSQL_8_0_18`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_installed_version: std::string::String,

    /// This field represents the report generated by the proactive database
    /// wellness job for OutOfDisk issues.
    ///
    /// * Writers:
    /// * the proactive database wellness job for OOD.
    /// * Readers:
    /// * the proactive database wellness job
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub out_of_disk_report: std::option::Option<crate::model::database_instance::SqlOutOfDiskReport>,

    /// Output only. The time when the instance was created in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. List all maintenance versions applicable on the instance
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub available_maintenance_versions: std::vec::Vec<std::string::String>,

    /// The current software version on the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub maintenance_version: std::string::String,

    /// Output only. All database versions that are available for upgrade.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub upgradable_database_versions: std::vec::Vec<crate::model::AvailableDatabaseVersion>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_network_architecture: std::option::Option<crate::model::database_instance::SqlNetworkArchitecture>,

    /// Output only. The link to service attachment of PSC instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_service_attachment_link: std::option::Option<std::string::String>,

    /// Output only. The dns name of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dns_name: std::option::Option<std::string::String>,

    /// Output only. DEPRECATED: please use write_endpoint instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_dns_name: std::option::Option<std::string::String>,

    /// Output only. The dns name of the primary instance in a replication group.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub write_endpoint: std::option::Option<std::string::String>,

    /// Optional. A primary instance and disaster recovery (DR) replica pair.
    /// A DR replica is a cross-region replica that you designate
    /// for failover in the event that the primary instance
    /// experiences regional failure. Only applicable to MySQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_cluster: std::option::Option<crate::model::ReplicationCluster>,

    /// Gemini instance configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gemini_config: std::option::Option<crate::model::GeminiInstanceConfig>,

    /// Output only. This status indicates whether the instance satisfies PZI.
    ///
    /// The status is reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzi: std::option::Option<wkt::BoolValue>,

    /// Input only. Whether Cloud SQL is enabled to switch storing point-in-time
    /// recovery log files from a data disk to Cloud Storage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub switch_transaction_logs_to_cloud_storage_enabled: std::option::Option<wkt::BoolValue>,
}

impl DatabaseInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DatabaseInstance::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatabaseInstance::state].
    pub fn set_state<T: std::convert::Into<crate::model::database_instance::SqlInstanceState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::DatabaseInstance::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::SqlDatabaseVersion>>(mut self, v: T) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::DatabaseInstance::settings].
    pub fn set_settings<T: std::convert::Into<std::option::Option<crate::model::Settings>>>(mut self, v: T) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DatabaseInstance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [failover_replica][crate::model::DatabaseInstance::failover_replica].
    pub fn set_failover_replica<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlFailoverReplica>>>(mut self, v: T) -> Self {
        self.failover_replica = v.into();
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DatabaseInstance::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [max_disk_size][crate::model::DatabaseInstance::max_disk_size].
    pub fn set_max_disk_size<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.max_disk_size = v.into();
        self
    }

    /// Sets the value of [current_disk_size][crate::model::DatabaseInstance::current_disk_size].
    pub fn set_current_disk_size<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.current_disk_size = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::DatabaseInstance::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::DatabaseInstance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::SqlInstanceType>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [project][crate::model::DatabaseInstance::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [ipv6_address][crate::model::DatabaseInstance::ipv6_address].
    pub fn set_ipv6_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ipv6_address = v.into();
        self
    }

    /// Sets the value of [service_account_email_address][crate::model::DatabaseInstance::service_account_email_address].
    pub fn set_service_account_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account_email_address = v.into();
        self
    }

    /// Sets the value of [on_premises_configuration][crate::model::DatabaseInstance::on_premises_configuration].
    pub fn set_on_premises_configuration<T: std::convert::Into<std::option::Option<crate::model::OnPremisesConfiguration>>>(mut self, v: T) -> Self {
        self.on_premises_configuration = v.into();
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DatabaseInstance::replica_configuration].
    pub fn set_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::ReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.replica_configuration = v.into();
        self
    }

    /// Sets the value of [backend_type][crate::model::DatabaseInstance::backend_type].
    pub fn set_backend_type<T: std::convert::Into<crate::model::SqlBackendType>>(mut self, v: T) -> Self {
        self.backend_type = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::DatabaseInstance::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [connection_name][crate::model::DatabaseInstance::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DatabaseInstance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DatabaseInstance::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::DatabaseInstance::gce_zone].
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [secondary_gce_zone][crate::model::DatabaseInstance::secondary_gce_zone].
    pub fn set_secondary_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_gce_zone = v.into();
        self
    }

    /// Sets the value of [disk_encryption_configuration][crate::model::DatabaseInstance::disk_encryption_configuration].
    pub fn set_disk_encryption_configuration<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionConfiguration>>>(mut self, v: T) -> Self {
        self.disk_encryption_configuration = v.into();
        self
    }

    /// Sets the value of [disk_encryption_status][crate::model::DatabaseInstance::disk_encryption_status].
    pub fn set_disk_encryption_status<T: std::convert::Into<std::option::Option<crate::model::DiskEncryptionStatus>>>(mut self, v: T) -> Self {
        self.disk_encryption_status = v.into();
        self
    }

    /// Sets the value of [root_password][crate::model::DatabaseInstance::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [scheduled_maintenance][crate::model::DatabaseInstance::scheduled_maintenance].
    pub fn set_scheduled_maintenance<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlScheduledMaintenance>>>(mut self, v: T) -> Self {
        self.scheduled_maintenance = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::DatabaseInstance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [database_installed_version][crate::model::DatabaseInstance::database_installed_version].
    pub fn set_database_installed_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_installed_version = v.into();
        self
    }

    /// Sets the value of [out_of_disk_report][crate::model::DatabaseInstance::out_of_disk_report].
    pub fn set_out_of_disk_report<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlOutOfDiskReport>>>(mut self, v: T) -> Self {
        self.out_of_disk_report = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DatabaseInstance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [maintenance_version][crate::model::DatabaseInstance::maintenance_version].
    pub fn set_maintenance_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.maintenance_version = v.into();
        self
    }

    /// Sets the value of [sql_network_architecture][crate::model::DatabaseInstance::sql_network_architecture].
    pub fn set_sql_network_architecture<T: std::convert::Into<std::option::Option<crate::model::database_instance::SqlNetworkArchitecture>>>(mut self, v: T) -> Self {
        self.sql_network_architecture = v.into();
        self
    }

    /// Sets the value of [psc_service_attachment_link][crate::model::DatabaseInstance::psc_service_attachment_link].
    pub fn set_psc_service_attachment_link<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.psc_service_attachment_link = v.into();
        self
    }

    /// Sets the value of [dns_name][crate::model::DatabaseInstance::dns_name].
    pub fn set_dns_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.dns_name = v.into();
        self
    }

    /// Sets the value of [primary_dns_name][crate::model::DatabaseInstance::primary_dns_name].
    pub fn set_primary_dns_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.primary_dns_name = v.into();
        self
    }

    /// Sets the value of [write_endpoint][crate::model::DatabaseInstance::write_endpoint].
    pub fn set_write_endpoint<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.write_endpoint = v.into();
        self
    }

    /// Sets the value of [replication_cluster][crate::model::DatabaseInstance::replication_cluster].
    pub fn set_replication_cluster<T: std::convert::Into<std::option::Option<crate::model::ReplicationCluster>>>(mut self, v: T) -> Self {
        self.replication_cluster = v.into();
        self
    }

    /// Sets the value of [gemini_config][crate::model::DatabaseInstance::gemini_config].
    pub fn set_gemini_config<T: std::convert::Into<std::option::Option<crate::model::GeminiInstanceConfig>>>(mut self, v: T) -> Self {
        self.gemini_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::DatabaseInstance::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [switch_transaction_logs_to_cloud_storage_enabled][crate::model::DatabaseInstance::switch_transaction_logs_to_cloud_storage_enabled].
    pub fn set_switch_transaction_logs_to_cloud_storage_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.switch_transaction_logs_to_cloud_storage_enabled = v.into();
        self
    }

    /// Sets the value of [replica_names][crate::model::DatabaseInstance::replica_names].
    pub fn set_replica_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.replica_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::DatabaseInstance::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpMapping>
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suspension_reason][crate::model::DatabaseInstance::suspension_reason].
    pub fn set_suspension_reason<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlSuspensionReason>
    {
        use std::iter::Iterator;
        self.suspension_reason = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_maintenance_versions][crate::model::DatabaseInstance::available_maintenance_versions].
    pub fn set_available_maintenance_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.available_maintenance_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upgradable_database_versions][crate::model::DatabaseInstance::upgradable_database_versions].
    pub fn set_upgradable_database_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AvailableDatabaseVersion>
    {
        use std::iter::Iterator;
        self.upgradable_database_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance"
    }
}

/// Defines additional types related to DatabaseInstance
pub mod database_instance {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlFailoverReplica {

        /// The name of the failover replica. If specified at instance creation, a
        /// failover replica is created for the instance. The name
        /// doesn't include the project ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The availability status of the failover replica. A false status indicates
        /// that the failover replica is out of sync. The primary instance can only
        /// failover to the failover replica when the status is true.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub available: std::option::Option<wkt::BoolValue>,
    }

    impl SqlFailoverReplica {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::database_instance::SqlFailoverReplica::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [available][crate::model::database_instance::SqlFailoverReplica::available].
        pub fn set_available<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.available = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlFailoverReplica {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlFailoverReplica"
        }
    }

    /// Any scheduled maintenance for this instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlScheduledMaintenance {

        /// The start time of any upcoming scheduled maintenance for this instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        pub can_defer: bool,

        /// If the scheduled maintenance can be rescheduled.
        pub can_reschedule: bool,

        /// Maintenance cannot be rescheduled to start beyond this deadline.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_deadline_time: std::option::Option<wkt::Timestamp>,
    }

    impl SqlScheduledMaintenance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::database_instance::SqlScheduledMaintenance::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [can_defer][crate::model::database_instance::SqlScheduledMaintenance::can_defer].
        pub fn set_can_defer<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_defer = v.into();
            self
        }

        /// Sets the value of [can_reschedule][crate::model::database_instance::SqlScheduledMaintenance::can_reschedule].
        pub fn set_can_reschedule<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.can_reschedule = v.into();
            self
        }

        /// Sets the value of [schedule_deadline_time][crate::model::database_instance::SqlScheduledMaintenance::schedule_deadline_time].
        pub fn set_schedule_deadline_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.schedule_deadline_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlScheduledMaintenance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlScheduledMaintenance"
        }
    }

    /// This message wraps up the information written by out-of-disk detection job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlOutOfDiskReport {

        /// This field represents the state generated by the proactive database
        /// wellness job for OutOfDisk issues.
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        /// * the proactive database wellness job
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sql_out_of_disk_state: std::option::Option<crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState>,

        /// The minimum recommended increase size in GigaBytes
        /// This field is consumed by the frontend
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sql_min_recommended_increase_size_gb: std::option::Option<i32>,
    }

    impl SqlOutOfDiskReport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_out_of_disk_state][crate::model::database_instance::SqlOutOfDiskReport::sql_out_of_disk_state].
        pub fn set_sql_out_of_disk_state<T: std::convert::Into<std::option::Option<crate::model::database_instance::sql_out_of_disk_report::SqlOutOfDiskState>>>(mut self, v: T) -> Self {
            self.sql_out_of_disk_state = v.into();
            self
        }

        /// Sets the value of [sql_min_recommended_increase_size_gb][crate::model::database_instance::SqlOutOfDiskReport::sql_min_recommended_increase_size_gb].
        pub fn set_sql_min_recommended_increase_size_gb<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
            self.sql_min_recommended_increase_size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlOutOfDiskReport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.DatabaseInstance.SqlOutOfDiskReport"
        }
    }

    /// Defines additional types related to SqlOutOfDiskReport
    pub mod sql_out_of_disk_report {
        #[allow(unused_imports)]
        use super::*;


        /// This enum lists all possible states regarding out-of-disk issues.
        #[derive(Clone, Debug, PartialEq)]
        pub struct SqlOutOfDiskState(wkt::enumerations::Enumeration);

        /// Useful constants to work with [SqlOutOfDiskState](SqlOutOfDiskState)
        pub mod sql_out_of_disk_state {
            use super::SqlOutOfDiskState;
            

            /// Unspecified state
            pub const SQL_OUT_OF_DISK_STATE_UNSPECIFIED: SqlOutOfDiskState = SqlOutOfDiskState::known("SQL_OUT_OF_DISK_STATE_UNSPECIFIED", 0);

            /// The instance has plenty space on data disk
            pub const NORMAL: SqlOutOfDiskState = SqlOutOfDiskState::known("NORMAL", 1);

            /// Data disk is almost used up. It is shutdown to prevent data
            /// corruption.
            pub const SOFT_SHUTDOWN: SqlOutOfDiskState = SqlOutOfDiskState::known("SOFT_SHUTDOWN", 2);
        }

        impl SqlOutOfDiskState {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for SqlOutOfDiskState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SqlOutOfDiskState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(SqlOutOfDiskState::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(SqlOutOfDiskState::from(val)),
                    Enumeration::UnknownNum { str } => Ok(SqlOutOfDiskState::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for SqlOutOfDiskState {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" => sql_out_of_disk_state::SQL_OUT_OF_DISK_STATE_UNSPECIFIED,
                    "NORMAL" => sql_out_of_disk_state::NORMAL,
                    "SOFT_SHUTDOWN" => sql_out_of_disk_state::SOFT_SHUTDOWN,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for SqlOutOfDiskState {
            fn from(value: i32) -> Self {
                match value {
                    0 => sql_out_of_disk_state::SQL_OUT_OF_DISK_STATE_UNSPECIFIED,
                    1 => sql_out_of_disk_state::NORMAL,
                    2 => sql_out_of_disk_state::SOFT_SHUTDOWN,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for SqlOutOfDiskState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }
    }

    /// The current serving state of the database instance.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlInstanceState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlInstanceState](SqlInstanceState)
    pub mod sql_instance_state {
        use super::SqlInstanceState;
        

        /// The state of the instance is unknown.
        pub const SQL_INSTANCE_STATE_UNSPECIFIED: SqlInstanceState = SqlInstanceState::known("SQL_INSTANCE_STATE_UNSPECIFIED", 0);

        /// The instance is running, or has been stopped by owner.
        pub const RUNNABLE: SqlInstanceState = SqlInstanceState::known("RUNNABLE", 1);

        /// The instance is not available, for example due to problems with billing.
        pub const SUSPENDED: SqlInstanceState = SqlInstanceState::known("SUSPENDED", 2);

        /// The instance is being deleted.
        pub const PENDING_DELETE: SqlInstanceState = SqlInstanceState::known("PENDING_DELETE", 3);

        /// The instance is being created.
        pub const PENDING_CREATE: SqlInstanceState = SqlInstanceState::known("PENDING_CREATE", 4);

        /// The instance is down for maintenance.
        pub const MAINTENANCE: SqlInstanceState = SqlInstanceState::known("MAINTENANCE", 5);

        /// The creation of the instance failed or a fatal error occurred during
        /// maintenance.
        pub const FAILED: SqlInstanceState = SqlInstanceState::known("FAILED", 6);

        /// Deprecated
        pub const ONLINE_MAINTENANCE: SqlInstanceState = SqlInstanceState::known("ONLINE_MAINTENANCE", 7);
    }

    impl SqlInstanceState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlInstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlInstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlInstanceState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlInstanceState::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlInstanceState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlInstanceState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_INSTANCE_STATE_UNSPECIFIED" => sql_instance_state::SQL_INSTANCE_STATE_UNSPECIFIED,
                "RUNNABLE" => sql_instance_state::RUNNABLE,
                "SUSPENDED" => sql_instance_state::SUSPENDED,
                "PENDING_DELETE" => sql_instance_state::PENDING_DELETE,
                "PENDING_CREATE" => sql_instance_state::PENDING_CREATE,
                "MAINTENANCE" => sql_instance_state::MAINTENANCE,
                "FAILED" => sql_instance_state::FAILED,
                "ONLINE_MAINTENANCE" => sql_instance_state::ONLINE_MAINTENANCE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlInstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_instance_state::SQL_INSTANCE_STATE_UNSPECIFIED,
                1 => sql_instance_state::RUNNABLE,
                2 => sql_instance_state::SUSPENDED,
                3 => sql_instance_state::PENDING_DELETE,
                4 => sql_instance_state::PENDING_CREATE,
                5 => sql_instance_state::MAINTENANCE,
                6 => sql_instance_state::FAILED,
                7 => sql_instance_state::ONLINE_MAINTENANCE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlInstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The SQL network architecture for the instance.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlNetworkArchitecture(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlNetworkArchitecture](SqlNetworkArchitecture)
    pub mod sql_network_architecture {
        use super::SqlNetworkArchitecture;
        

        pub const SQL_NETWORK_ARCHITECTURE_UNSPECIFIED: SqlNetworkArchitecture = SqlNetworkArchitecture::known("SQL_NETWORK_ARCHITECTURE_UNSPECIFIED", 0);

        /// The instance uses the new network architecture.
        pub const NEW_NETWORK_ARCHITECTURE: SqlNetworkArchitecture = SqlNetworkArchitecture::known("NEW_NETWORK_ARCHITECTURE", 1);

        /// The instance uses the old network architecture.
        pub const OLD_NETWORK_ARCHITECTURE: SqlNetworkArchitecture = SqlNetworkArchitecture::known("OLD_NETWORK_ARCHITECTURE", 2);
    }

    impl SqlNetworkArchitecture {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlNetworkArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlNetworkArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlNetworkArchitecture::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlNetworkArchitecture::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlNetworkArchitecture::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlNetworkArchitecture {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED" => sql_network_architecture::SQL_NETWORK_ARCHITECTURE_UNSPECIFIED,
                "NEW_NETWORK_ARCHITECTURE" => sql_network_architecture::NEW_NETWORK_ARCHITECTURE,
                "OLD_NETWORK_ARCHITECTURE" => sql_network_architecture::OLD_NETWORK_ARCHITECTURE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlNetworkArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_network_architecture::SQL_NETWORK_ARCHITECTURE_UNSPECIFIED,
                1 => sql_network_architecture::NEW_NETWORK_ARCHITECTURE,
                2 => sql_network_architecture::OLD_NETWORK_ARCHITECTURE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlNetworkArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Gemini instance configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GeminiInstanceConfig {

    /// Output only. Whether Gemini is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entitled: std::option::Option<bool>,

    /// Output only. Whether the vacuum management is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub google_vacuum_mgmt_enabled: std::option::Option<bool>,

    /// Output only. Whether canceling the out-of-memory (OOM) session is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oom_session_cancel_enabled: std::option::Option<bool>,

    /// Output only. Whether the active query is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_query_enabled: std::option::Option<bool>,

    /// Output only. Whether the index advisor is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_advisor_enabled: std::option::Option<bool>,

    /// Output only. Whether the flag recommender is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub flag_recommender_enabled: std::option::Option<bool>,
}

impl GeminiInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitled][crate::model::GeminiInstanceConfig::entitled].
    pub fn set_entitled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.entitled = v.into();
        self
    }

    /// Sets the value of [google_vacuum_mgmt_enabled][crate::model::GeminiInstanceConfig::google_vacuum_mgmt_enabled].
    pub fn set_google_vacuum_mgmt_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.google_vacuum_mgmt_enabled = v.into();
        self
    }

    /// Sets the value of [oom_session_cancel_enabled][crate::model::GeminiInstanceConfig::oom_session_cancel_enabled].
    pub fn set_oom_session_cancel_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.oom_session_cancel_enabled = v.into();
        self
    }

    /// Sets the value of [active_query_enabled][crate::model::GeminiInstanceConfig::active_query_enabled].
    pub fn set_active_query_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.active_query_enabled = v.into();
        self
    }

    /// Sets the value of [index_advisor_enabled][crate::model::GeminiInstanceConfig::index_advisor_enabled].
    pub fn set_index_advisor_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.index_advisor_enabled = v.into();
        self
    }

    /// Sets the value of [flag_recommender_enabled][crate::model::GeminiInstanceConfig::flag_recommender_enabled].
    pub fn set_flag_recommender_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.flag_recommender_enabled = v.into();
        self
    }
}

impl wkt::message::Message for GeminiInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.GeminiInstanceConfig"
    }
}

/// A primary instance and disaster recovery (DR) replica pair.
/// A DR replica is a cross-region replica that you designate for failover in
/// the event that the primary instance experiences regional failure.
/// Only applicable to MySQL.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationCluster {

    /// Output only. If set, it indicates this instance has a private service
    /// access (PSA) dns endpoint that is pointing to the primary instance of the
    /// cluster. If this instance is the primary, the dns should be pointing to
    /// this instance. After Switchover or Replica failover, this DNS endpoint
    /// points to the promoted instance. This is a read-only field, returned to the
    /// user as information. This field can exist even if a standalone instance
    /// does not yet have a replica, or had a DR replica that was deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psa_write_endpoint: std::string::String,

    /// Optional. If the instance is a primary instance, then this field identifies
    /// the disaster recovery (DR) replica. A DR replica is an optional
    /// configuration for Enterprise Plus edition instances. If the instance is a
    /// read replica, then the field is not set. Set this field to a replica name
    /// to designate a DR replica for a primary instance. Remove the replica name
    /// to remove the DR replica designation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub failover_dr_replica_name: std::string::String,

    /// Output only. Read-only field that indicates whether the replica is a DR
    /// replica. This field is not set if the instance is a primary instance.
    pub dr_replica: bool,
}

impl ReplicationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psa_write_endpoint][crate::model::ReplicationCluster::psa_write_endpoint].
    pub fn set_psa_write_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.psa_write_endpoint = v.into();
        self
    }

    /// Sets the value of [failover_dr_replica_name][crate::model::ReplicationCluster::failover_dr_replica_name].
    pub fn set_failover_dr_replica_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failover_dr_replica_name = v.into();
        self
    }

    /// Sets the value of [dr_replica][crate::model::ReplicationCluster::dr_replica].
    pub fn set_dr_replica<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dr_replica = v.into();
        self
    }
}

impl wkt::message::Message for ReplicationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicationCluster"
    }
}

/// An available database version. It can be a major or a minor version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvailableDatabaseVersion {

    /// The version's major version name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub major_version: std::option::Option<std::string::String>,

    /// The database version name. For MySQL 8.0, this string provides the database
    /// major and minor version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// The database version's display name.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_name: std::option::Option<std::string::String>,
}

impl AvailableDatabaseVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [major_version][crate::model::AvailableDatabaseVersion::major_version].
    pub fn set_major_version<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.major_version = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AvailableDatabaseVersion::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AvailableDatabaseVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for AvailableDatabaseVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AvailableDatabaseVersion"
    }
}

/// Reschedule options for maintenance windows.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesRescheduleMaintenanceRequestBody {

    /// Required. The type of the reschedule the user wants.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reschedule: std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule>,
}

impl SqlInstancesRescheduleMaintenanceRequestBody {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reschedule][crate::model::SqlInstancesRescheduleMaintenanceRequestBody::reschedule].
    pub fn set_reschedule<T: std::convert::Into<std::option::Option<crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule>>>(mut self, v: T) -> Self {
        self.reschedule = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesRescheduleMaintenanceRequestBody {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody"
    }
}

/// Defines additional types related to SqlInstancesRescheduleMaintenanceRequestBody
pub mod sql_instances_reschedule_maintenance_request_body {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Reschedule {

        /// Required. The type of the reschedule.
        pub reschedule_type: crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType,

        /// Optional. Timestamp when the maintenance shall be rescheduled to if
        /// reschedule_type=SPECIFIC_TIME, in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
        /// `2012-11-15T16:19:00.094Z`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schedule_time: std::option::Option<wkt::Timestamp>,
    }

    impl Reschedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reschedule_type][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::reschedule_type].
        pub fn set_reschedule_type<T: std::convert::Into<crate::model::sql_instances_reschedule_maintenance_request_body::RescheduleType>>(mut self, v: T) -> Self {
            self.reschedule_type = v.into();
            self
        }

        /// Sets the value of [schedule_time][crate::model::sql_instances_reschedule_maintenance_request_body::Reschedule::schedule_time].
        pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.schedule_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Reschedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.SqlInstancesRescheduleMaintenanceRequestBody.Reschedule"
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct RescheduleType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [RescheduleType](RescheduleType)
    pub mod reschedule_type {
        use super::RescheduleType;
        

        pub const RESCHEDULE_TYPE_UNSPECIFIED: RescheduleType = RescheduleType::known("RESCHEDULE_TYPE_UNSPECIFIED", 0);

        /// Reschedules maintenance to happen now (within 5 minutes).
        pub const IMMEDIATE: RescheduleType = RescheduleType::known("IMMEDIATE", 1);

        /// Reschedules maintenance to occur within one week from the originally
        /// scheduled day and time.
        pub const NEXT_AVAILABLE_WINDOW: RescheduleType = RescheduleType::known("NEXT_AVAILABLE_WINDOW", 2);

        /// Reschedules maintenance to a specific time and day.
        pub const SPECIFIC_TIME: RescheduleType = RescheduleType::known("SPECIFIC_TIME", 3);
    }

    impl RescheduleType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for RescheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RescheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(RescheduleType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(RescheduleType::from(val)),
                Enumeration::UnknownNum { str } => Ok(RescheduleType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for RescheduleType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "RESCHEDULE_TYPE_UNSPECIFIED" => reschedule_type::RESCHEDULE_TYPE_UNSPECIFIED,
                "IMMEDIATE" => reschedule_type::IMMEDIATE,
                "NEXT_AVAILABLE_WINDOW" => reschedule_type::NEXT_AVAILABLE_WINDOW,
                "SPECIFIC_TIME" => reschedule_type::SPECIFIC_TIME,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => reschedule_type::RESCHEDULE_TYPE_UNSPECIFIED,
                1 => reschedule_type::IMMEDIATE,
                2 => reschedule_type::NEXT_AVAILABLE_WINDOW,
                3 => reschedule_type::SPECIFIC_TIME,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Database instance demote primary instance context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterContext {

    /// This is always `sql#demoteMasterContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Verify the GTID consistency for demote operation. Default value:
    /// `True`. Setting this flag to `false` enables you to bypass the GTID
    /// consistency check between on-premises primary instance and Cloud SQL
    /// instance during the demotion operation but also exposes you to the risk of
    /// future replication failures. Change the value only if you know the reason
    /// for the GTID divergence and are confident that doing so will not cause any
    /// replication issues.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_gtid_consistency: std::option::Option<wkt::BoolValue>,

    /// The name of the instance which will act as on-premises primary instance
    /// in the replication setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub master_instance_name: std::string::String,

    /// Configuration specific to read-replicas replicating from the on-premises
    /// primary instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_configuration: std::option::Option<crate::model::DemoteMasterConfiguration>,

    /// Flag to skip replication setup on the instance.
    pub skip_replication_setup: bool,
}

impl DemoteMasterContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [verify_gtid_consistency][crate::model::DemoteMasterContext::verify_gtid_consistency].
    pub fn set_verify_gtid_consistency<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.verify_gtid_consistency = v.into();
        self
    }

    /// Sets the value of [master_instance_name][crate::model::DemoteMasterContext::master_instance_name].
    pub fn set_master_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_instance_name = v.into();
        self
    }

    /// Sets the value of [replica_configuration][crate::model::DemoteMasterContext::replica_configuration].
    pub fn set_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterConfiguration>>>(mut self, v: T) -> Self {
        self.replica_configuration = v.into();
        self
    }

    /// Sets the value of [skip_replication_setup][crate::model::DemoteMasterContext::skip_replication_setup].
    pub fn set_skip_replication_setup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_replication_setup = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterContext"
    }
}

/// This context is used to demote an existing standalone instance to be
/// a Cloud SQL read replica for an external database server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteContext {

    /// This is always `sql#demoteContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Required. The name of the instance which acts as the on-premises primary
    /// instance in the replication setup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_representative_instance_name: std::string::String,
}

impl DemoteContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [source_representative_instance_name][crate::model::DemoteContext::source_representative_instance_name].
    pub fn set_source_representative_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_representative_instance_name = v.into();
        self
    }
}

impl wkt::message::Message for DemoteContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteContext"
    }
}

/// Database instance failover context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailoverContext {

    /// The current settings version of this instance. Request will be rejected if
    /// this version doesn't match the current settings version.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub settings_version: i64,

    /// This is always `sql#failoverContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl FailoverContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::FailoverContext::settings_version].
    pub fn set_settings_version<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.settings_version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::FailoverContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for FailoverContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.FailoverContext"
    }
}

/// Database instance restore from backup context.
/// Backup context contains source instance id and project id.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreBackupContext {

    /// This is always `sql#restoreBackupContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The ID of the backup run to restore from.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_run_id: i64,

    /// The ID of the instance that the backup was taken from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// The full project ID of the source instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl RestoreBackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RestoreBackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [backup_run_id][crate::model::RestoreBackupContext::backup_run_id].
    pub fn set_backup_run_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_run_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::RestoreBackupContext::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [project][crate::model::RestoreBackupContext::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for RestoreBackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RestoreBackupContext"
    }
}

/// Instance rotate server CA context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RotateServerCaContext {

    /// This is always `sql#rotateServerCaContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The fingerprint of the next version to be rotated to. If left unspecified,
    /// will be rotated to the most recently added server CA version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_version: std::string::String,
}

impl RotateServerCaContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::RotateServerCaContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_version][crate::model::RotateServerCaContext::next_version].
    pub fn set_next_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_version = v.into();
        self
    }
}

impl wkt::message::Message for RotateServerCaContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.RotateServerCaContext"
    }
}

/// Database Instance truncate log context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TruncateLogContext {

    /// This is always `sql#truncateLogContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The type of log to truncate. Valid values are `MYSQL_GENERAL_TABLE` and
    /// `MYSQL_SLOW_TABLE`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_type: std::string::String,
}

impl TruncateLogContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TruncateLogContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [log_type][crate::model::TruncateLogContext::log_type].
    pub fn set_log_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_type = v.into();
        self
    }
}

impl wkt::message::Message for TruncateLogContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TruncateLogContext"
    }
}

/// External primary instance migration setting error/warning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlExternalSyncSettingError {

    /// Can be `sql#externalSyncSettingError` or
    /// `sql#externalSyncSettingWarning`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    #[serde(rename = "type")]
    pub r#type: crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType,

    /// Additional information about the error encountered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,
}

impl SqlExternalSyncSettingError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlExternalSyncSettingError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlExternalSyncSettingError::type].
    pub fn set_type<T: std::convert::Into<crate::model::sql_external_sync_setting_error::SqlExternalSyncSettingErrorType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::SqlExternalSyncSettingError::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for SqlExternalSyncSettingError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlExternalSyncSettingError"
    }
}

/// Defines additional types related to SqlExternalSyncSettingError
pub mod sql_external_sync_setting_error {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlExternalSyncSettingErrorType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlExternalSyncSettingErrorType](SqlExternalSyncSettingErrorType)
    pub mod sql_external_sync_setting_error_type {
        use super::SqlExternalSyncSettingErrorType;
        

        pub const SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED", 0);

        pub const CONNECTION_FAILURE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("CONNECTION_FAILURE", 1);

        pub const BINLOG_NOT_ENABLED: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("BINLOG_NOT_ENABLED", 2);

        pub const INCOMPATIBLE_DATABASE_VERSION: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INCOMPATIBLE_DATABASE_VERSION", 3);

        pub const REPLICA_ALREADY_SETUP: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("REPLICA_ALREADY_SETUP", 4);

        /// The replication user is missing privileges that are required.
        pub const INSUFFICIENT_PRIVILEGE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_PRIVILEGE", 5);

        /// Unsupported migration type.
        pub const UNSUPPORTED_MIGRATION_TYPE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_MIGRATION_TYPE", 6);

        /// No pglogical extension installed on databases, applicable for postgres.
        pub const NO_PGLOGICAL_INSTALLED: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("NO_PGLOGICAL_INSTALLED", 7);

        /// pglogical node already exists on databases, applicable for postgres.
        pub const PGLOGICAL_NODE_ALREADY_EXISTS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("PGLOGICAL_NODE_ALREADY_EXISTS", 8);

        /// The value of parameter wal_level is not set to logical.
        pub const INVALID_WAL_LEVEL: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_WAL_LEVEL", 9);

        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        pub const INVALID_SHARED_PRELOAD_LIBRARY: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_SHARED_PRELOAD_LIBRARY", 10);

        /// The value of parameter max_replication_slots is not sufficient.
        pub const INSUFFICIENT_MAX_REPLICATION_SLOTS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_MAX_REPLICATION_SLOTS", 11);

        /// The value of parameter max_wal_senders is not sufficient.
        pub const INSUFFICIENT_MAX_WAL_SENDERS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_MAX_WAL_SENDERS", 12);

        /// The value of parameter max_worker_processes is not sufficient.
        pub const INSUFFICIENT_MAX_WORKER_PROCESSES: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_MAX_WORKER_PROCESSES", 13);

        /// Extensions installed are either not supported or having unsupported
        /// versions.
        pub const UNSUPPORTED_EXTENSIONS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_EXTENSIONS", 14);

        /// The value of parameter rds.logical_replication is not set to 1.
        pub const INVALID_RDS_LOGICAL_REPLICATION: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_RDS_LOGICAL_REPLICATION", 15);

        /// The primary instance logging setup doesn't allow EM sync.
        pub const INVALID_LOGGING_SETUP: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_LOGGING_SETUP", 16);

        /// The primary instance database parameter setup doesn't allow EM sync.
        pub const INVALID_DB_PARAM: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_DB_PARAM", 17);

        /// The gtid_mode is not supported, applicable for MySQL.
        pub const UNSUPPORTED_GTID_MODE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_GTID_MODE", 18);

        /// SQL Server Agent is not running.
        pub const SQLSERVER_AGENT_NOT_RUNNING: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("SQLSERVER_AGENT_NOT_RUNNING", 19);

        /// The table definition is not support due to missing primary key or replica
        /// identity, applicable for postgres.
        pub const UNSUPPORTED_TABLE_DEFINITION: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_TABLE_DEFINITION", 20);

        /// The customer has a definer that will break EM setup.
        pub const UNSUPPORTED_DEFINER: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_DEFINER", 21);

        /// SQL Server @@SERVERNAME does not match actual host name.
        pub const SQLSERVER_SERVERNAME_MISMATCH: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("SQLSERVER_SERVERNAME_MISMATCH", 22);

        /// The primary instance has been setup and will fail the setup.
        pub const PRIMARY_ALREADY_SETUP: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("PRIMARY_ALREADY_SETUP", 23);

        /// The primary instance has unsupported binary log format.
        pub const UNSUPPORTED_BINLOG_FORMAT: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_BINLOG_FORMAT", 24);

        /// The primary instance's binary log retention setting.
        pub const BINLOG_RETENTION_SETTING: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("BINLOG_RETENTION_SETTING", 25);

        /// The primary instance has tables with unsupported storage engine.
        pub const UNSUPPORTED_STORAGE_ENGINE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_STORAGE_ENGINE", 26);

        /// Source has tables with limited support
        /// eg: PostgreSQL tables without primary keys.
        pub const LIMITED_SUPPORT_TABLES: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("LIMITED_SUPPORT_TABLES", 27);

        /// The replica instance contains existing data.
        pub const EXISTING_DATA_IN_REPLICA: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("EXISTING_DATA_IN_REPLICA", 28);

        /// The replication user is missing privileges that are optional.
        pub const MISSING_OPTIONAL_PRIVILEGES: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("MISSING_OPTIONAL_PRIVILEGES", 29);

        /// Additional BACKUP_ADMIN privilege is granted to the replication user
        /// which may lock source MySQL 8 instance for DDLs during initial sync.
        pub const RISKY_BACKUP_ADMIN_PRIVILEGE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("RISKY_BACKUP_ADMIN_PRIVILEGE", 30);

        /// The Cloud Storage bucket is missing necessary permissions.
        pub const INSUFFICIENT_GCS_PERMISSIONS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_GCS_PERMISSIONS", 31);

        /// The Cloud Storage bucket has an error in the file or contains invalid
        /// file information.
        pub const INVALID_FILE_INFO: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INVALID_FILE_INFO", 32);

        /// The source instance has unsupported database settings for migration.
        pub const UNSUPPORTED_DATABASE_SETTINGS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_DATABASE_SETTINGS", 33);

        /// The replication user is missing parallel import specific privileges.
        /// (e.g. LOCK TABLES) for MySQL.
        pub const MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE", 34);

        /// The global variable local_infile is off on external server replica.
        pub const LOCAL_INFILE_OFF: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("LOCAL_INFILE_OFF", 35);

        /// This code instructs customers to turn on point-in-time recovery manually
        /// for the instance after promoting the Cloud SQL for PostgreSQL instance.
        pub const TURN_ON_PITR_AFTER_PROMOTE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("TURN_ON_PITR_AFTER_PROMOTE", 36);

        /// The minor version of replica database is incompatible with the source.
        pub const INCOMPATIBLE_DATABASE_MINOR_VERSION: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INCOMPATIBLE_DATABASE_MINOR_VERSION", 37);

        /// This warning message indicates that Cloud SQL uses the maximum number of
        /// subscriptions to migrate data from the source to the destination.
        pub const SOURCE_MAX_SUBSCRIPTIONS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("SOURCE_MAX_SUBSCRIPTIONS", 38);

        /// Unable to verify definers on the source for MySQL.
        pub const UNABLE_TO_VERIFY_DEFINERS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNABLE_TO_VERIFY_DEFINERS", 39);

        /// If a time out occurs while the subscription counts are calculated, then
        /// this value is set to 1. Otherwise, this value is set to 2.
        pub const SUBSCRIPTION_CALCULATION_STATUS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("SUBSCRIPTION_CALCULATION_STATUS", 40);

        /// Count of subscriptions needed to sync source data for PostgreSQL
        /// database.
        pub const PG_SUBSCRIPTION_COUNT: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("PG_SUBSCRIPTION_COUNT", 41);

        /// Final parallel level that is used to do migration.
        pub const PG_SYNC_PARALLEL_LEVEL: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("PG_SYNC_PARALLEL_LEVEL", 42);

        /// The disk size of the replica instance is smaller than the data size of
        /// the source instance.
        pub const INSUFFICIENT_DISK_SIZE: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_DISK_SIZE", 43);

        /// The data size of the source instance is greater than 1 TB, the number of
        /// cores of the replica instance is less than 8, and the memory of the
        /// replica is less than 32 GB.
        pub const INSUFFICIENT_MACHINE_TIER: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("INSUFFICIENT_MACHINE_TIER", 44);

        /// The warning message indicates the unsupported extensions will not be
        /// migrated to the destination.
        pub const UNSUPPORTED_EXTENSIONS_NOT_MIGRATED: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_EXTENSIONS_NOT_MIGRATED", 45);

        /// The warning message indicates the pg_cron extension and settings will not
        /// be migrated to the destination.
        pub const EXTENSIONS_NOT_MIGRATED: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("EXTENSIONS_NOT_MIGRATED", 46);

        /// The error message indicates that pg_cron flags are enabled on the
        /// destination which is not supported during the migration.
        pub const PG_CRON_FLAG_ENABLED_IN_REPLICA: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("PG_CRON_FLAG_ENABLED_IN_REPLICA", 47);

        /// This error message indicates that the specified extensions are not
        /// enabled on destination instance. For example, before you can migrate
        /// data to the destination instance, you must enable the PGAudit extension
        /// on the instance.
        pub const EXTENSIONS_NOT_ENABLED_IN_REPLICA: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("EXTENSIONS_NOT_ENABLED_IN_REPLICA", 48);

        /// The source database has generated columns that can't be migrated. Please
        /// change them to regular columns before migration.
        pub const UNSUPPORTED_COLUMNS: SqlExternalSyncSettingErrorType = SqlExternalSyncSettingErrorType::known("UNSUPPORTED_COLUMNS", 49);
    }

    impl SqlExternalSyncSettingErrorType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlExternalSyncSettingErrorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlExternalSyncSettingErrorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlExternalSyncSettingErrorType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlExternalSyncSettingErrorType::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlExternalSyncSettingErrorType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlExternalSyncSettingErrorType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED" => sql_external_sync_setting_error_type::SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED,
                "CONNECTION_FAILURE" => sql_external_sync_setting_error_type::CONNECTION_FAILURE,
                "BINLOG_NOT_ENABLED" => sql_external_sync_setting_error_type::BINLOG_NOT_ENABLED,
                "INCOMPATIBLE_DATABASE_VERSION" => sql_external_sync_setting_error_type::INCOMPATIBLE_DATABASE_VERSION,
                "REPLICA_ALREADY_SETUP" => sql_external_sync_setting_error_type::REPLICA_ALREADY_SETUP,
                "INSUFFICIENT_PRIVILEGE" => sql_external_sync_setting_error_type::INSUFFICIENT_PRIVILEGE,
                "UNSUPPORTED_MIGRATION_TYPE" => sql_external_sync_setting_error_type::UNSUPPORTED_MIGRATION_TYPE,
                "NO_PGLOGICAL_INSTALLED" => sql_external_sync_setting_error_type::NO_PGLOGICAL_INSTALLED,
                "PGLOGICAL_NODE_ALREADY_EXISTS" => sql_external_sync_setting_error_type::PGLOGICAL_NODE_ALREADY_EXISTS,
                "INVALID_WAL_LEVEL" => sql_external_sync_setting_error_type::INVALID_WAL_LEVEL,
                "INVALID_SHARED_PRELOAD_LIBRARY" => sql_external_sync_setting_error_type::INVALID_SHARED_PRELOAD_LIBRARY,
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_REPLICATION_SLOTS,
                "INSUFFICIENT_MAX_WAL_SENDERS" => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_WAL_SENDERS,
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_WORKER_PROCESSES,
                "UNSUPPORTED_EXTENSIONS" => sql_external_sync_setting_error_type::UNSUPPORTED_EXTENSIONS,
                "INVALID_RDS_LOGICAL_REPLICATION" => sql_external_sync_setting_error_type::INVALID_RDS_LOGICAL_REPLICATION,
                "INVALID_LOGGING_SETUP" => sql_external_sync_setting_error_type::INVALID_LOGGING_SETUP,
                "INVALID_DB_PARAM" => sql_external_sync_setting_error_type::INVALID_DB_PARAM,
                "UNSUPPORTED_GTID_MODE" => sql_external_sync_setting_error_type::UNSUPPORTED_GTID_MODE,
                "SQLSERVER_AGENT_NOT_RUNNING" => sql_external_sync_setting_error_type::SQLSERVER_AGENT_NOT_RUNNING,
                "UNSUPPORTED_TABLE_DEFINITION" => sql_external_sync_setting_error_type::UNSUPPORTED_TABLE_DEFINITION,
                "UNSUPPORTED_DEFINER" => sql_external_sync_setting_error_type::UNSUPPORTED_DEFINER,
                "SQLSERVER_SERVERNAME_MISMATCH" => sql_external_sync_setting_error_type::SQLSERVER_SERVERNAME_MISMATCH,
                "PRIMARY_ALREADY_SETUP" => sql_external_sync_setting_error_type::PRIMARY_ALREADY_SETUP,
                "UNSUPPORTED_BINLOG_FORMAT" => sql_external_sync_setting_error_type::UNSUPPORTED_BINLOG_FORMAT,
                "BINLOG_RETENTION_SETTING" => sql_external_sync_setting_error_type::BINLOG_RETENTION_SETTING,
                "UNSUPPORTED_STORAGE_ENGINE" => sql_external_sync_setting_error_type::UNSUPPORTED_STORAGE_ENGINE,
                "LIMITED_SUPPORT_TABLES" => sql_external_sync_setting_error_type::LIMITED_SUPPORT_TABLES,
                "EXISTING_DATA_IN_REPLICA" => sql_external_sync_setting_error_type::EXISTING_DATA_IN_REPLICA,
                "MISSING_OPTIONAL_PRIVILEGES" => sql_external_sync_setting_error_type::MISSING_OPTIONAL_PRIVILEGES,
                "RISKY_BACKUP_ADMIN_PRIVILEGE" => sql_external_sync_setting_error_type::RISKY_BACKUP_ADMIN_PRIVILEGE,
                "INSUFFICIENT_GCS_PERMISSIONS" => sql_external_sync_setting_error_type::INSUFFICIENT_GCS_PERMISSIONS,
                "INVALID_FILE_INFO" => sql_external_sync_setting_error_type::INVALID_FILE_INFO,
                "UNSUPPORTED_DATABASE_SETTINGS" => sql_external_sync_setting_error_type::UNSUPPORTED_DATABASE_SETTINGS,
                "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => sql_external_sync_setting_error_type::MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE,
                "LOCAL_INFILE_OFF" => sql_external_sync_setting_error_type::LOCAL_INFILE_OFF,
                "TURN_ON_PITR_AFTER_PROMOTE" => sql_external_sync_setting_error_type::TURN_ON_PITR_AFTER_PROMOTE,
                "INCOMPATIBLE_DATABASE_MINOR_VERSION" => sql_external_sync_setting_error_type::INCOMPATIBLE_DATABASE_MINOR_VERSION,
                "SOURCE_MAX_SUBSCRIPTIONS" => sql_external_sync_setting_error_type::SOURCE_MAX_SUBSCRIPTIONS,
                "UNABLE_TO_VERIFY_DEFINERS" => sql_external_sync_setting_error_type::UNABLE_TO_VERIFY_DEFINERS,
                "SUBSCRIPTION_CALCULATION_STATUS" => sql_external_sync_setting_error_type::SUBSCRIPTION_CALCULATION_STATUS,
                "PG_SUBSCRIPTION_COUNT" => sql_external_sync_setting_error_type::PG_SUBSCRIPTION_COUNT,
                "PG_SYNC_PARALLEL_LEVEL" => sql_external_sync_setting_error_type::PG_SYNC_PARALLEL_LEVEL,
                "INSUFFICIENT_DISK_SIZE" => sql_external_sync_setting_error_type::INSUFFICIENT_DISK_SIZE,
                "INSUFFICIENT_MACHINE_TIER" => sql_external_sync_setting_error_type::INSUFFICIENT_MACHINE_TIER,
                "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED" => sql_external_sync_setting_error_type::UNSUPPORTED_EXTENSIONS_NOT_MIGRATED,
                "EXTENSIONS_NOT_MIGRATED" => sql_external_sync_setting_error_type::EXTENSIONS_NOT_MIGRATED,
                "PG_CRON_FLAG_ENABLED_IN_REPLICA" => sql_external_sync_setting_error_type::PG_CRON_FLAG_ENABLED_IN_REPLICA,
                "EXTENSIONS_NOT_ENABLED_IN_REPLICA" => sql_external_sync_setting_error_type::EXTENSIONS_NOT_ENABLED_IN_REPLICA,
                "UNSUPPORTED_COLUMNS" => sql_external_sync_setting_error_type::UNSUPPORTED_COLUMNS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlExternalSyncSettingErrorType {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_external_sync_setting_error_type::SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED,
                1 => sql_external_sync_setting_error_type::CONNECTION_FAILURE,
                2 => sql_external_sync_setting_error_type::BINLOG_NOT_ENABLED,
                3 => sql_external_sync_setting_error_type::INCOMPATIBLE_DATABASE_VERSION,
                4 => sql_external_sync_setting_error_type::REPLICA_ALREADY_SETUP,
                5 => sql_external_sync_setting_error_type::INSUFFICIENT_PRIVILEGE,
                6 => sql_external_sync_setting_error_type::UNSUPPORTED_MIGRATION_TYPE,
                7 => sql_external_sync_setting_error_type::NO_PGLOGICAL_INSTALLED,
                8 => sql_external_sync_setting_error_type::PGLOGICAL_NODE_ALREADY_EXISTS,
                9 => sql_external_sync_setting_error_type::INVALID_WAL_LEVEL,
                10 => sql_external_sync_setting_error_type::INVALID_SHARED_PRELOAD_LIBRARY,
                11 => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_REPLICATION_SLOTS,
                12 => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_WAL_SENDERS,
                13 => sql_external_sync_setting_error_type::INSUFFICIENT_MAX_WORKER_PROCESSES,
                14 => sql_external_sync_setting_error_type::UNSUPPORTED_EXTENSIONS,
                15 => sql_external_sync_setting_error_type::INVALID_RDS_LOGICAL_REPLICATION,
                16 => sql_external_sync_setting_error_type::INVALID_LOGGING_SETUP,
                17 => sql_external_sync_setting_error_type::INVALID_DB_PARAM,
                18 => sql_external_sync_setting_error_type::UNSUPPORTED_GTID_MODE,
                19 => sql_external_sync_setting_error_type::SQLSERVER_AGENT_NOT_RUNNING,
                20 => sql_external_sync_setting_error_type::UNSUPPORTED_TABLE_DEFINITION,
                21 => sql_external_sync_setting_error_type::UNSUPPORTED_DEFINER,
                22 => sql_external_sync_setting_error_type::SQLSERVER_SERVERNAME_MISMATCH,
                23 => sql_external_sync_setting_error_type::PRIMARY_ALREADY_SETUP,
                24 => sql_external_sync_setting_error_type::UNSUPPORTED_BINLOG_FORMAT,
                25 => sql_external_sync_setting_error_type::BINLOG_RETENTION_SETTING,
                26 => sql_external_sync_setting_error_type::UNSUPPORTED_STORAGE_ENGINE,
                27 => sql_external_sync_setting_error_type::LIMITED_SUPPORT_TABLES,
                28 => sql_external_sync_setting_error_type::EXISTING_DATA_IN_REPLICA,
                29 => sql_external_sync_setting_error_type::MISSING_OPTIONAL_PRIVILEGES,
                30 => sql_external_sync_setting_error_type::RISKY_BACKUP_ADMIN_PRIVILEGE,
                31 => sql_external_sync_setting_error_type::INSUFFICIENT_GCS_PERMISSIONS,
                32 => sql_external_sync_setting_error_type::INVALID_FILE_INFO,
                33 => sql_external_sync_setting_error_type::UNSUPPORTED_DATABASE_SETTINGS,
                34 => sql_external_sync_setting_error_type::MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE,
                35 => sql_external_sync_setting_error_type::LOCAL_INFILE_OFF,
                36 => sql_external_sync_setting_error_type::TURN_ON_PITR_AFTER_PROMOTE,
                37 => sql_external_sync_setting_error_type::INCOMPATIBLE_DATABASE_MINOR_VERSION,
                38 => sql_external_sync_setting_error_type::SOURCE_MAX_SUBSCRIPTIONS,
                39 => sql_external_sync_setting_error_type::UNABLE_TO_VERIFY_DEFINERS,
                40 => sql_external_sync_setting_error_type::SUBSCRIPTION_CALCULATION_STATUS,
                41 => sql_external_sync_setting_error_type::PG_SUBSCRIPTION_COUNT,
                42 => sql_external_sync_setting_error_type::PG_SYNC_PARALLEL_LEVEL,
                43 => sql_external_sync_setting_error_type::INSUFFICIENT_DISK_SIZE,
                44 => sql_external_sync_setting_error_type::INSUFFICIENT_MACHINE_TIER,
                45 => sql_external_sync_setting_error_type::UNSUPPORTED_EXTENSIONS_NOT_MIGRATED,
                46 => sql_external_sync_setting_error_type::EXTENSIONS_NOT_MIGRATED,
                47 => sql_external_sync_setting_error_type::PG_CRON_FLAG_ENABLED_IN_REPLICA,
                48 => sql_external_sync_setting_error_type::EXTENSIONS_NOT_ENABLED_IN_REPLICA,
                49 => sql_external_sync_setting_error_type::UNSUPPORTED_COLUMNS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlExternalSyncSettingErrorType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// On-premises instance configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OnPremisesConfiguration {

    /// The host and port of the on-premises instance in host:port format
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_port: std::string::String,

    /// This is always `sql#onPremisesConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The username for connecting to on-premises instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for connecting to on-premises instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// The dump file to create the Cloud SQL replica.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_file_path: std::string::String,

    /// The reference to Cloud SQL instance if the source is Cloud SQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_instance: std::option::Option<crate::model::InstanceReference>,
}

impl OnPremisesConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::OnPremisesConfiguration::host_port].
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::OnPremisesConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OnPremisesConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OnPremisesConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::OnPremisesConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::OnPremisesConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::OnPremisesConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [dump_file_path][crate::model::OnPremisesConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [source_instance][crate::model::OnPremisesConfiguration::source_instance].
    pub fn set_source_instance<T: std::convert::Into<std::option::Option<crate::model::InstanceReference>>>(mut self, v: T) -> Self {
        self.source_instance = v.into();
        self
    }
}

impl wkt::message::Message for OnPremisesConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OnPremisesConfiguration"
    }
}

/// Read-replica configuration for connecting to the primary instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaConfiguration {

    /// This is always `sql#replicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mysql_replica_configuration: std::option::Option<crate::model::MySqlReplicaConfiguration>,

    /// Specifies if the replica is the failover target. If the field is set to
    /// `true`, the replica will be designated as a failover replica. In case the
    /// primary instance fails, the replica instance will be promoted as the new
    /// primary instance. Only one replica can be specified as failover target, and
    /// the replica has to be in different zone with the primary instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failover_target: std::option::Option<wkt::BoolValue>,

    /// Optional. Specifies if a SQL Server replica is a cascadable replica. A
    /// cascadable replica is a SQL Server cross region replica that supports
    /// replica(s) under it.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cascadable_replica: std::option::Option<wkt::BoolValue>,
}

impl ReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::ReplicaConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::MySqlReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.mysql_replica_configuration = v.into();
        self
    }

    /// Sets the value of [failover_target][crate::model::ReplicaConfiguration::failover_target].
    pub fn set_failover_target<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.failover_target = v.into();
        self
    }

    /// Sets the value of [cascadable_replica][crate::model::ReplicaConfiguration::cascadable_replica].
    pub fn set_cascadable_replica<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.cascadable_replica = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ReplicaConfiguration"
    }
}

/// Request to acquire a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseRequest {

    /// Required. Cloud SQL instance ID. This doesn't include the project ID. It's
    /// composed of lowercase letters, numbers, and hyphens, and it must start with
    /// a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Project ID of the project that contains the instance (Example:
    /// project-id).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Required. The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::InstancesAcquireSsrsLeaseRequest>,
}

impl SqlInstancesAcquireSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesAcquireSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesAcquireSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlInstancesAcquireSsrsLeaseRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::InstancesAcquireSsrsLeaseRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseRequest"
    }
}

/// Response for the acquire SSRS lease request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesAcquireSsrsLeaseResponse {

    /// The unique identifier for this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,
}

impl SqlInstancesAcquireSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesAcquireSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesAcquireSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesAcquireSsrsLeaseResponse"
    }
}

/// Request to release a lease for SSRS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseRequest {

    /// Required. The Cloud SQL instance ID. This doesn't include the project ID.
    /// The instance ID contains lowercase letters, numbers, and hyphens, and it
    /// must start with a letter. This ID can have a maximum length of 98
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. The project ID that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlInstancesReleaseSsrsLeaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlInstancesReleaseSsrsLeaseRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlInstancesReleaseSsrsLeaseRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseRequest"
    }
}

/// Response for the release SSRS lease request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlInstancesReleaseSsrsLeaseResponse {

    /// The unique identifier for this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,
}

impl SqlInstancesReleaseSsrsLeaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::SqlInstancesReleaseSsrsLeaseResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }
}

impl wkt::message::Message for SqlInstancesReleaseSsrsLeaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlInstancesReleaseSsrsLeaseResponse"
    }
}

/// Operations get request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsGetRequest {

    /// Instance operation ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlOperationsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsGetRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsGetRequest"
    }
}

/// Operations list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Maximum number of operations per response.
    pub max_results: u32,

    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlOperationsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlOperationsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::SqlOperationsListRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SqlOperationsListRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsListRequest"
    }
}

/// Operations list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationsListResponse {

    /// This is always `sql#operationsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of operation resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Operation>,

    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl OperationsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationsListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::OperationsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationsListResponse"
    }
}

/// Operations cancel request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlOperationsCancelRequest {

    /// Instance operation ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlOperationsCancelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::SqlOperationsCancelRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlOperationsCancelRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlOperationsCancelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlOperationsCancelRequest"
    }
}

/// An entry for an Access Control list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AclEntry {

    /// The allowlisted value for the access control list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// The time when this access control entry expires in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A label to identify this entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// This is always `sql#aclEntry`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl AclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::AclEntry::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AclEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::AclEntry::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for AclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AclEntry"
    }
}

/// An Admin API warning message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApiWarning {

    /// Code to uniquely identify the warning type.
    pub code: crate::model::api_warning::SqlApiWarningCode,

    /// The warning message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The region name for REGION_UNREACHABLE warning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,
}

impl ApiWarning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ApiWarning::code].
    pub fn set_code<T: std::convert::Into<crate::model::api_warning::SqlApiWarningCode>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ApiWarning::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ApiWarning::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }
}

impl wkt::message::Message for ApiWarning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ApiWarning"
    }
}

/// Defines additional types related to ApiWarning
pub mod api_warning {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlApiWarningCode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlApiWarningCode](SqlApiWarningCode)
    pub mod sql_api_warning_code {
        use super::SqlApiWarningCode;
        

        /// An unknown or unset warning type from Cloud SQL API.
        pub const SQL_API_WARNING_CODE_UNSPECIFIED: SqlApiWarningCode = SqlApiWarningCode::known("SQL_API_WARNING_CODE_UNSPECIFIED", 0);

        /// Warning when one or more regions are not reachable.  The returned result
        /// set may be incomplete.
        pub const REGION_UNREACHABLE: SqlApiWarningCode = SqlApiWarningCode::known("REGION_UNREACHABLE", 1);

        /// Warning when user provided maxResults parameter exceeds the limit.  The
        /// returned result set may be incomplete.
        pub const MAX_RESULTS_EXCEEDS_LIMIT: SqlApiWarningCode = SqlApiWarningCode::known("MAX_RESULTS_EXCEEDS_LIMIT", 2);

        /// Warning when user tries to create/update a user with credentials that
        /// have previously been compromised by a public data breach.
        pub const COMPROMISED_CREDENTIALS: SqlApiWarningCode = SqlApiWarningCode::known("COMPROMISED_CREDENTIALS", 3);

        /// Warning when the operation succeeds but some non-critical workflow state
        /// failed.
        pub const INTERNAL_STATE_FAILURE: SqlApiWarningCode = SqlApiWarningCode::known("INTERNAL_STATE_FAILURE", 4);
    }

    impl SqlApiWarningCode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlApiWarningCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlApiWarningCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlApiWarningCode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlApiWarningCode::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlApiWarningCode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlApiWarningCode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_API_WARNING_CODE_UNSPECIFIED" => sql_api_warning_code::SQL_API_WARNING_CODE_UNSPECIFIED,
                "REGION_UNREACHABLE" => sql_api_warning_code::REGION_UNREACHABLE,
                "MAX_RESULTS_EXCEEDS_LIMIT" => sql_api_warning_code::MAX_RESULTS_EXCEEDS_LIMIT,
                "COMPROMISED_CREDENTIALS" => sql_api_warning_code::COMPROMISED_CREDENTIALS,
                "INTERNAL_STATE_FAILURE" => sql_api_warning_code::INTERNAL_STATE_FAILURE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlApiWarningCode {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_api_warning_code::SQL_API_WARNING_CODE_UNSPECIFIED,
                1 => sql_api_warning_code::REGION_UNREACHABLE,
                2 => sql_api_warning_code::MAX_RESULTS_EXCEEDS_LIMIT,
                3 => sql_api_warning_code::COMPROMISED_CREDENTIALS,
                4 => sql_api_warning_code::INTERNAL_STATE_FAILURE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlApiWarningCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// We currently only support backup retention by specifying the number
/// of backups we will retain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupRetentionSettings {

    /// The unit that 'retained_backups' represents.
    pub retention_unit: crate::model::backup_retention_settings::RetentionUnit,

    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retained_backups: std::option::Option<wkt::Int32Value>,
}

impl BackupRetentionSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_unit][crate::model::BackupRetentionSettings::retention_unit].
    pub fn set_retention_unit<T: std::convert::Into<crate::model::backup_retention_settings::RetentionUnit>>(mut self, v: T) -> Self {
        self.retention_unit = v.into();
        self
    }

    /// Sets the value of [retained_backups][crate::model::BackupRetentionSettings::retained_backups].
    pub fn set_retained_backups<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.retained_backups = v.into();
        self
    }
}

impl wkt::message::Message for BackupRetentionSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupRetentionSettings"
    }
}

/// Defines additional types related to BackupRetentionSettings
pub mod backup_retention_settings {
    #[allow(unused_imports)]
    use super::*;


    /// The units that retained_backups specifies, we only support COUNT.
    #[derive(Clone, Debug, PartialEq)]
    pub struct RetentionUnit(wkt::enumerations::Enumeration);

    /// Useful constants to work with [RetentionUnit](RetentionUnit)
    pub mod retention_unit {
        use super::RetentionUnit;
        

        /// Backup retention unit is unspecified, will be treated as COUNT.
        pub const RETENTION_UNIT_UNSPECIFIED: RetentionUnit = RetentionUnit::known("RETENTION_UNIT_UNSPECIFIED", 0);

        /// Retention will be by count, eg. "retain the most recent 7 backups".
        pub const COUNT: RetentionUnit = RetentionUnit::known("COUNT", 1);
    }

    impl RetentionUnit {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for RetentionUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetentionUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(RetentionUnit::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(RetentionUnit::from(val)),
                Enumeration::UnknownNum { str } => Ok(RetentionUnit::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for RetentionUnit {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "RETENTION_UNIT_UNSPECIFIED" => retention_unit::RETENTION_UNIT_UNSPECIFIED,
                "COUNT" => retention_unit::COUNT,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for RetentionUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => retention_unit::RETENTION_UNIT_UNSPECIFIED,
                1 => retention_unit::COUNT,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for RetentionUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Database instance backup configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupConfiguration {

    /// Start time for the daily backup configuration in UTC timezone in the 24
    /// hour format - `HH:MM`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_time: std::string::String,

    /// Whether this configuration is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#backupConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// (MySQL only) Whether binary log is enabled. If backup configuration is
    /// disabled, binarylog must be disabled as well.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_log_enabled: std::option::Option<wkt::BoolValue>,

    /// Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_log_archiving_enabled: std::option::Option<wkt::BoolValue>,

    /// Location of the backup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Whether point in time recovery is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub point_in_time_recovery_enabled: std::option::Option<wkt::BoolValue>,

    /// Backup retention settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_retention_settings: std::option::Option<crate::model::BackupRetentionSettings>,

    /// The number of days of transaction logs we retain for point in time
    /// restore, from 1-7.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_log_retention_days: std::option::Option<wkt::Int32Value>,

    /// Output only. This value contains the storage location of transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transactional_log_storage_state: std::option::Option<crate::model::backup_configuration::TransactionalLogStorageState>,
}

impl BackupConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::BackupConfiguration::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::BackupConfiguration::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BackupConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [binary_log_enabled][crate::model::BackupConfiguration::binary_log_enabled].
    pub fn set_binary_log_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.binary_log_enabled = v.into();
        self
    }

    /// Sets the value of [replication_log_archiving_enabled][crate::model::BackupConfiguration::replication_log_archiving_enabled].
    pub fn set_replication_log_archiving_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.replication_log_archiving_enabled = v.into();
        self
    }

    /// Sets the value of [location][crate::model::BackupConfiguration::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [point_in_time_recovery_enabled][crate::model::BackupConfiguration::point_in_time_recovery_enabled].
    pub fn set_point_in_time_recovery_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.point_in_time_recovery_enabled = v.into();
        self
    }

    /// Sets the value of [backup_retention_settings][crate::model::BackupConfiguration::backup_retention_settings].
    pub fn set_backup_retention_settings<T: std::convert::Into<std::option::Option<crate::model::BackupRetentionSettings>>>(mut self, v: T) -> Self {
        self.backup_retention_settings = v.into();
        self
    }

    /// Sets the value of [transaction_log_retention_days][crate::model::BackupConfiguration::transaction_log_retention_days].
    pub fn set_transaction_log_retention_days<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.transaction_log_retention_days = v.into();
        self
    }

    /// Sets the value of [transactional_log_storage_state][crate::model::BackupConfiguration::transactional_log_storage_state].
    pub fn set_transactional_log_storage_state<T: std::convert::Into<std::option::Option<crate::model::backup_configuration::TransactionalLogStorageState>>>(mut self, v: T) -> Self {
        self.transactional_log_storage_state = v.into();
        self
    }
}

impl wkt::message::Message for BackupConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupConfiguration"
    }
}

/// Defines additional types related to BackupConfiguration
pub mod backup_configuration {
    #[allow(unused_imports)]
    use super::*;


    /// This value contains the storage location of the transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TransactionalLogStorageState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [TransactionalLogStorageState](TransactionalLogStorageState)
    pub mod transactional_log_storage_state {
        use super::TransactionalLogStorageState;
        

        /// Unspecified.
        pub const TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED: TransactionalLogStorageState = TransactionalLogStorageState::known("TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED", 0);

        /// The transaction logs used for PITR for the instance are stored
        /// on a data disk.
        pub const DISK: TransactionalLogStorageState = TransactionalLogStorageState::known("DISK", 1);

        /// The transaction logs used for PITR for the instance are switching from
        /// being stored on a data disk to being stored in Cloud Storage.
        /// Only applicable to MySQL.
        pub const SWITCHING_TO_CLOUD_STORAGE: TransactionalLogStorageState = TransactionalLogStorageState::known("SWITCHING_TO_CLOUD_STORAGE", 2);

        /// The transaction logs used for PITR for the instance are now stored
        /// in Cloud Storage. Previously, they were stored on a data disk.
        /// Only applicable to MySQL.
        pub const SWITCHED_TO_CLOUD_STORAGE: TransactionalLogStorageState = TransactionalLogStorageState::known("SWITCHED_TO_CLOUD_STORAGE", 3);

        /// The transaction logs used for PITR for the instance are stored in
        /// Cloud Storage. Only applicable to MySQL and PostgreSQL.
        pub const CLOUD_STORAGE: TransactionalLogStorageState = TransactionalLogStorageState::known("CLOUD_STORAGE", 4);
    }

    impl TransactionalLogStorageState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for TransactionalLogStorageState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransactionalLogStorageState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(TransactionalLogStorageState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(TransactionalLogStorageState::from(val)),
                Enumeration::UnknownNum { str } => Ok(TransactionalLogStorageState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for TransactionalLogStorageState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED" => transactional_log_storage_state::TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED,
                "DISK" => transactional_log_storage_state::DISK,
                "SWITCHING_TO_CLOUD_STORAGE" => transactional_log_storage_state::SWITCHING_TO_CLOUD_STORAGE,
                "SWITCHED_TO_CLOUD_STORAGE" => transactional_log_storage_state::SWITCHED_TO_CLOUD_STORAGE,
                "CLOUD_STORAGE" => transactional_log_storage_state::CLOUD_STORAGE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for TransactionalLogStorageState {
        fn from(value: i32) -> Self {
            match value {
                0 => transactional_log_storage_state::TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED,
                1 => transactional_log_storage_state::DISK,
                2 => transactional_log_storage_state::SWITCHING_TO_CLOUD_STORAGE,
                3 => transactional_log_storage_state::SWITCHED_TO_CLOUD_STORAGE,
                4 => transactional_log_storage_state::CLOUD_STORAGE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for TransactionalLogStorageState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Perform disk shrink context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PerformDiskShrinkContext {

    /// The target disk shrink size in GigaBytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub target_size_gb: i64,
}

impl PerformDiskShrinkContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_size_gb][crate::model::PerformDiskShrinkContext::target_size_gb].
    pub fn set_target_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.target_size_gb = v.into();
        self
    }
}

impl wkt::message::Message for PerformDiskShrinkContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PerformDiskShrinkContext"
    }
}

/// Backup context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupContext {

    /// The identifier of the backup.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub backup_id: i64,

    /// This is always `sql#backupContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl BackupContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_id][crate::model::BackupContext::backup_id].
    pub fn set_backup_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::BackupContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for BackupContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.BackupContext"
    }
}

/// Represents a SQL database on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Database {

    /// This is always `sql#database`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The Cloud SQL charset value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// The Cloud SQL collation value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name of the database in the Cloud SQL instance. This does not include
    /// the project ID or instance name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub database_details: std::option::Option<crate::model::database::DatabaseDetails>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Database::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Database::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::Database::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Database::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [project][crate::model::Database::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of `database_details`.
    pub fn set_database_details<T: std::convert::Into<std::option::Option<crate::model::database::DatabaseDetails>>>(mut self, v: T) -> Self
    {
        self.database_details = v.into();
        self
    }

    /// The value of [database_details][crate::model::Database::database_details]
    /// if it holds a `SqlserverDatabaseDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sqlserver_database_details(&self) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerDatabaseDetails>> {
        #[allow(unreachable_patterns)]
        self.database_details.as_ref().and_then(|v| match v {
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [database_details][crate::model::Database::database_details]
    /// to hold a `SqlserverDatabaseDetails`.
    ///
    /// Note that all the setters affecting `database_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_database_details<T: std::convert::Into<std::boxed::Box<crate::model::SqlServerDatabaseDetails>>>(mut self, v: T) -> Self {
        self.database_details = std::option::Option::Some(
            crate::model::database::DatabaseDetails::SqlserverDatabaseDetails(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Database"
    }
}

/// Defines additional types related to Database
pub mod database {
    #[allow(unused_imports)]
    use super::*;


    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DatabaseDetails {
        SqlserverDatabaseDetails(std::boxed::Box<crate::model::SqlServerDatabaseDetails>),
    }
}

/// Represents a Sql Server database on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerDatabaseDetails {

    /// The version of SQL Server with which the database is to be made compatible
    pub compatibility_level: i32,

    /// The recovery model of a SQL Server database
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recovery_model: std::string::String,
}

impl SqlServerDatabaseDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compatibility_level][crate::model::SqlServerDatabaseDetails::compatibility_level].
    pub fn set_compatibility_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.compatibility_level = v.into();
        self
    }

    /// Sets the value of [recovery_model][crate::model::SqlServerDatabaseDetails::recovery_model].
    pub fn set_recovery_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recovery_model = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerDatabaseDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerDatabaseDetails"
    }
}

/// Database flags for Cloud SQL instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseFlags {

    /// The name of the flag. These flags are passed at instance startup, so
    /// include both server options and system variables. Flags are
    /// specified with underscores, not hyphens. For more information, see
    /// [Configuring Database Flags](https://cloud.google.com/sql/docs/mysql/flags)
    /// in the Cloud SQL documentation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl DatabaseFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatabaseFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DatabaseFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DatabaseFlags"
    }
}

/// MySQL-specific external server sync settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlSyncConfig {

    /// Flags to use for the initial dump.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub initial_sync_flags: std::vec::Vec<crate::model::SyncFlags>,
}

impl MySqlSyncConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_sync_flags][crate::model::MySqlSyncConfig::initial_sync_flags].
    pub fn set_initial_sync_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SyncFlags>
    {
        use std::iter::Iterator;
        self.initial_sync_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MySqlSyncConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlSyncConfig"
    }
}

/// Initial sync flags for certain Cloud SQL APIs.
/// Currently used for the MySQL external server initial dump.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncFlags {

    /// The name of the flag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The value of the flag. This field must be omitted if the flag
    /// doesn't take a value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl SyncFlags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SyncFlags::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::SyncFlags::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for SyncFlags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SyncFlags"
    }
}

/// Reference to another Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceReference {

    /// The name of the Cloud SQL instance being referenced.
    /// This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The region of the Cloud SQL instance being referenced.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// The project ID of the Cloud SQL instance being referenced.
    /// The default is the same project ID as the instance references it.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstanceReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [region][crate::model::InstanceReference::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [project][crate::model::InstanceReference::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InstanceReference"
    }
}

/// Read-replica configuration for connecting to the on-premises primary
/// instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterConfiguration {

    /// This is always `sql#demoteMasterConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mysql_replica_configuration: std::option::Option<crate::model::DemoteMasterMySqlReplicaConfiguration>,
}

impl DemoteMasterConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [mysql_replica_configuration][crate::model::DemoteMasterConfiguration::mysql_replica_configuration].
    pub fn set_mysql_replica_configuration<T: std::convert::Into<std::option::Option<crate::model::DemoteMasterMySqlReplicaConfiguration>>>(mut self, v: T) -> Self {
        self.mysql_replica_configuration = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterConfiguration"
    }
}

/// Read-replica configuration specific to MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DemoteMasterMySqlReplicaConfiguration {

    /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The username for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate. The format of the replica's
    /// private key can be either PKCS #1 or PKCS #8.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,
}

impl DemoteMasterMySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::DemoteMasterMySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [username][crate::model::DemoteMasterMySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::DemoteMasterMySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::DemoteMasterMySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::DemoteMasterMySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for DemoteMasterMySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DemoteMasterMySqlReplicaConfiguration"
    }
}

/// Database instance export context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportContext {

    /// The path to the file in Google Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails. If
    /// `fileType` is `SQL` and the filename ends with .gz,
    /// the contents are compressed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Databases to be exported. <br /> `MySQL instances:` If
    /// `fileType` is `SQL` and no database is specified, all
    /// databases are exported, except for the `mysql` system database.
    /// If `fileType` is `CSV`, you can specify one database,
    /// either by using this property or by using the
    /// `csvExportOptions.selectQuery` property, which takes precedence
    /// over this property. <br /> `PostgreSQL instances:` You must specify
    /// one database to be exported. If `fileType` is `CSV`,
    /// this database must match the one specified in the
    /// `csvExportOptions.selectQuery` property. <br /> `SQL Server
    /// instances:` You must specify one database to be exported, and the
    /// `fileType` must be `BAK`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub databases: std::vec::Vec<std::string::String>,

    /// This is always `sql#exportContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Options for exporting data as SQL statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_export_options: std::option::Option<crate::model::export_context::SqlExportOptions>,

    /// Options for exporting data as CSV. `MySQL` and `PostgreSQL`
    /// instances only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub csv_export_options: std::option::Option<crate::model::export_context::SqlCsvExportOptions>,

    /// The file type for the specified uri.
    pub file_type: crate::model::SqlFileType,

    /// Option for export offload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub offload: std::option::Option<wkt::BoolValue>,

    /// Options for exporting data as BAK files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bak_export_options: std::option::Option<crate::model::export_context::SqlBakExportOptions>,
}

impl ExportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ExportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ExportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [sql_export_options][crate::model::ExportContext::sql_export_options].
    pub fn set_sql_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlExportOptions>>>(mut self, v: T) -> Self {
        self.sql_export_options = v.into();
        self
    }

    /// Sets the value of [csv_export_options][crate::model::ExportContext::csv_export_options].
    pub fn set_csv_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlCsvExportOptions>>>(mut self, v: T) -> Self {
        self.csv_export_options = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ExportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [offload][crate::model::ExportContext::offload].
    pub fn set_offload<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.offload = v.into();
        self
    }

    /// Sets the value of [bak_export_options][crate::model::ExportContext::bak_export_options].
    pub fn set_bak_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::SqlBakExportOptions>>>(mut self, v: T) -> Self {
        self.bak_export_options = v.into();
        self
    }

    /// Sets the value of [databases][crate::model::ExportContext::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ExportContext"
    }
}

/// Defines additional types related to ExportContext
pub mod export_context {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlCsvExportOptions {

        /// The select query used to extract the data.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub select_query: std::string::String,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub lines_terminated_by: std::string::String,
    }

    impl SqlCsvExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [select_query][crate::model::export_context::SqlCsvExportOptions::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::export_context::SqlCsvExportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::export_context::SqlCsvExportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::export_context::SqlCsvExportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::export_context::SqlCsvExportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.lines_terminated_by = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlCsvExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlCsvExportOptions"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlExportOptions {

        /// Tables to export, or that were exported, from the specified database. If
        /// you specify tables, specify one and only one database. For PostgreSQL
        /// instances, you can specify only one table.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub tables: std::vec::Vec<std::string::String>,

        /// Export only schemas.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub schema_only: std::option::Option<wkt::BoolValue>,

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub mysql_export_options: std::option::Option<crate::model::export_context::sql_export_options::MysqlExportOptions>,

        /// Optional. The number of threads to use for parallel export.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the export should be parallel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub postgres_export_options: std::option::Option<crate::model::export_context::sql_export_options::PostgresExportOptions>,
    }

    impl SqlExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [schema_only][crate::model::export_context::SqlExportOptions::schema_only].
        pub fn set_schema_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.schema_only = v.into();
            self
        }

        /// Sets the value of [mysql_export_options][crate::model::export_context::SqlExportOptions::mysql_export_options].
        pub fn set_mysql_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::sql_export_options::MysqlExportOptions>>>(mut self, v: T) -> Self {
            self.mysql_export_options = v.into();
            self
        }

        /// Sets the value of [threads][crate::model::export_context::SqlExportOptions::threads].
        pub fn set_threads<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.threads = v.into();
            self
        }

        /// Sets the value of [parallel][crate::model::export_context::SqlExportOptions::parallel].
        pub fn set_parallel<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.parallel = v.into();
            self
        }

        /// Sets the value of [postgres_export_options][crate::model::export_context::SqlExportOptions::postgres_export_options].
        pub fn set_postgres_export_options<T: std::convert::Into<std::option::Option<crate::model::export_context::sql_export_options::PostgresExportOptions>>>(mut self, v: T) -> Self {
            self.postgres_export_options = v.into();
            self
        }

        /// Sets the value of [tables][crate::model::export_context::SqlExportOptions::tables].
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SqlExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions"
        }
    }

    /// Defines additional types related to SqlExportOptions
    pub mod sql_export_options {
        #[allow(unused_imports)]
        use super::*;


        /// Options for exporting from MySQL.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MysqlExportOptions {

            /// Option to include SQL statement required to set up replication. If set
            /// to `1`, the dump file includes a CHANGE MASTER TO statement with the
            /// binary log coordinates, and --set-gtid-purged is set to ON. If set to
            /// `2`, the CHANGE MASTER TO statement is written as a SQL comment and
            /// has no effect. If set to any value other than `1`, --set-gtid-purged
            /// is set to OFF.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub master_data: std::option::Option<wkt::Int32Value>,
        }

        impl MysqlExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [master_data][crate::model::export_context::sql_export_options::MysqlExportOptions::master_data].
            pub fn set_master_data<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
                self.master_data = v.into();
                self
            }
        }

        impl wkt::message::Message for MysqlExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.MysqlExportOptions"
            }
        }

        /// Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PostgresExportOptions {

            /// Optional. Use this option to include DROP \<object\> SQL statements.
            /// These statements are used to delete database objects before running the
            /// import operation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. Option to include an IF EXISTS SQL statement with each DROP
            /// statement produced by clean.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub if_exists: std::option::Option<wkt::BoolValue>,
        }

        impl PostgresExportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::export_context::sql_export_options::PostgresExportOptions::clean].
            pub fn set_clean<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.clean = v.into();
                self
            }

            /// Sets the value of [if_exists][crate::model::export_context::sql_export_options::PostgresExportOptions::if_exists].
            pub fn set_if_exists<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.if_exists = v.into();
                self
            }
        }

        impl wkt::message::Message for PostgresExportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlExportOptions.PostgresExportOptions"
            }
        }
    }

    /// Options for exporting BAK files (SQL Server-only)
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlBakExportOptions {

        /// Whether or not the export should be striped.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Option for specifying how many stripes to use for the export.
        /// If blank, and the value of the striped field is true,
        /// the number of stripes is automatically chosen.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stripe_count: std::option::Option<wkt::Int32Value>,

        /// Type of this bak file will be export, FULL or DIFF, SQL Server only
        pub bak_type: crate::model::BakType,

        /// Deprecated: copy_only is deprecated. Use differential_base instead
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub copy_only: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup can be used as a differential base
        /// copy_only backup can not be served as differential base
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub differential_base: std::option::Option<wkt::BoolValue>,
    }

    impl SqlBakExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [striped][crate::model::export_context::SqlBakExportOptions::striped].
        pub fn set_striped<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.striped = v.into();
            self
        }

        /// Sets the value of [stripe_count][crate::model::export_context::SqlBakExportOptions::stripe_count].
        pub fn set_stripe_count<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.stripe_count = v.into();
            self
        }

        /// Sets the value of [bak_type][crate::model::export_context::SqlBakExportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [copy_only][crate::model::export_context::SqlBakExportOptions::copy_only].
        pub fn set_copy_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.copy_only = v.into();
            self
        }

        /// Sets the value of [differential_base][crate::model::export_context::SqlBakExportOptions::differential_base].
        pub fn set_differential_base<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.differential_base = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlBakExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ExportContext.SqlBakExportOptions"
        }
    }
}

/// Database instance import context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportContext {

    /// Path to the import file in Cloud Storage, in the form
    /// `gs://bucketName/fileName`. Compressed gzip files (.gz) are supported
    /// when `fileType` is `SQL`. The instance must have
    /// write permissions to the bucket and read access to the file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The target database for the import. If `fileType` is `SQL`, this field
    /// is required only if the import file does not specify a database, and is
    /// overridden by any database specification in the import file. If
    /// `fileType` is `CSV`, one database must be specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// This is always `sql#importContext`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The file type for the specified uri.\`SQL`: The file
    /// contains SQL statements. \`CSV`: The file contains CSV data.
    pub file_type: crate::model::SqlFileType,

    /// Options for importing data as CSV.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub csv_import_options: std::option::Option<crate::model::import_context::SqlCsvImportOptions>,

    /// The PostgreSQL user for this import operation. PostgreSQL instances only.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_user: std::string::String,

    /// Import parameters specific to SQL Server .BAK files
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bak_import_options: std::option::Option<crate::model::import_context::SqlBakImportOptions>,

    /// Optional. Options for importing data from SQL statements.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_import_options: std::option::Option<crate::model::import_context::SqlImportOptions>,
}

impl ImportContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ImportContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ImportContext::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::ImportContext::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ImportContext::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::SqlFileType>>(mut self, v: T) -> Self {
        self.file_type = v.into();
        self
    }

    /// Sets the value of [csv_import_options][crate::model::ImportContext::csv_import_options].
    pub fn set_csv_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlCsvImportOptions>>>(mut self, v: T) -> Self {
        self.csv_import_options = v.into();
        self
    }

    /// Sets the value of [import_user][crate::model::ImportContext::import_user].
    pub fn set_import_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_user = v.into();
        self
    }

    /// Sets the value of [bak_import_options][crate::model::ImportContext::bak_import_options].
    pub fn set_bak_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlBakImportOptions>>>(mut self, v: T) -> Self {
        self.bak_import_options = v.into();
        self
    }

    /// Sets the value of [sql_import_options][crate::model::ImportContext::sql_import_options].
    pub fn set_sql_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::SqlImportOptions>>>(mut self, v: T) -> Self {
        self.sql_import_options = v.into();
        self
    }
}

impl wkt::message::Message for ImportContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.ImportContext"
    }
}

/// Defines additional types related to ImportContext
pub mod import_context {
    #[allow(unused_imports)]
    use super::*;


    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlImportOptions {

        /// Optional. The number of threads to use for parallel import.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub threads: std::option::Option<wkt::Int32Value>,

        /// Optional. Whether or not the import should be parallel.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub parallel: std::option::Option<wkt::BoolValue>,

        /// Optional. Options for importing from a Cloud SQL for PostgreSQL instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub postgres_import_options: std::option::Option<crate::model::import_context::sql_import_options::PostgresImportOptions>,
    }

    impl SqlImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [threads][crate::model::import_context::SqlImportOptions::threads].
        pub fn set_threads<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
            self.threads = v.into();
            self
        }

        /// Sets the value of [parallel][crate::model::import_context::SqlImportOptions::parallel].
        pub fn set_parallel<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.parallel = v.into();
            self
        }

        /// Sets the value of [postgres_import_options][crate::model::import_context::SqlImportOptions::postgres_import_options].
        pub fn set_postgres_import_options<T: std::convert::Into<std::option::Option<crate::model::import_context::sql_import_options::PostgresImportOptions>>>(mut self, v: T) -> Self {
            self.postgres_import_options = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions"
        }
    }

    /// Defines additional types related to SqlImportOptions
    pub mod sql_import_options {
        #[allow(unused_imports)]
        use super::*;


        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PostgresImportOptions {

            /// Optional. The --clean flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub clean: std::option::Option<wkt::BoolValue>,

            /// Optional. The --if-exists flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub if_exists: std::option::Option<wkt::BoolValue>,
        }

        impl PostgresImportOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [clean][crate::model::import_context::sql_import_options::PostgresImportOptions::clean].
            pub fn set_clean<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.clean = v.into();
                self
            }

            /// Sets the value of [if_exists][crate::model::import_context::sql_import_options::PostgresImportOptions::if_exists].
            pub fn set_if_exists<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
                self.if_exists = v.into();
                self
            }
        }

        impl wkt::message::Message for PostgresImportOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlImportOptions.PostgresImportOptions"
            }
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlCsvImportOptions {

        /// The table to which CSV data is imported.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        /// The columns to which CSV data is imported. If not specified, all columns
        /// of the database table are loaded with CSV data.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub columns: std::vec::Vec<std::string::String>,

        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub escape_character: std::string::String,

        /// Specifies the quoting character to be used when a data value is quoted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub quote_character: std::string::String,

        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub fields_terminated_by: std::string::String,

        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub lines_terminated_by: std::string::String,
    }

    impl SqlCsvImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::import_context::SqlCsvImportOptions::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::import_context::SqlCsvImportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.escape_character = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::import_context::SqlCsvImportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [fields_terminated_by][crate::model::import_context::SqlCsvImportOptions::fields_terminated_by].
        pub fn set_fields_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.fields_terminated_by = v.into();
            self
        }

        /// Sets the value of [lines_terminated_by][crate::model::import_context::SqlCsvImportOptions::lines_terminated_by].
        pub fn set_lines_terminated_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.lines_terminated_by = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::import_context::SqlCsvImportOptions::columns].
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SqlCsvImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlCsvImportOptions"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlBakImportOptions {

        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub encryption_options: std::option::Option<crate::model::import_context::sql_bak_import_options::EncryptionOptions>,

        /// Whether or not the backup set being restored is striped.
        /// Applies only to Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub striped: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing will restore database
        /// with NORECOVERY option
        /// Applies only to Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub no_recovery: std::option::Option<wkt::BoolValue>,

        /// Whether or not the backup importing request will just bring database
        /// online without downloading Bak content only one of "no_recovery" and
        /// "recovery_only" can be true otherwise error will return. Applies only to
        /// Cloud SQL for SQL Server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub recovery_only: std::option::Option<wkt::BoolValue>,

        /// Type of the bak content, FULL or DIFF
        pub bak_type: crate::model::BakType,

        /// Optional. The timestamp when the import should stop. This timestamp is in
        /// the [RFC 3339](https://tools.ietf.org/html/rfc3339) format (for example,
        /// `2023-10-01T16:19:00.094`). This field is equivalent to the STOPAT
        /// keyword and applies to Cloud SQL for SQL Server only.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stop_at: std::option::Option<wkt::Timestamp>,

        /// Optional. The marked transaction where the import should stop. This field
        /// is equivalent to the STOPATMARK keyword and applies to Cloud SQL for SQL
        /// Server only.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub stop_at_mark: std::string::String,
    }

    impl SqlBakImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encryption_options][crate::model::import_context::SqlBakImportOptions::encryption_options].
        pub fn set_encryption_options<T: std::convert::Into<std::option::Option<crate::model::import_context::sql_bak_import_options::EncryptionOptions>>>(mut self, v: T) -> Self {
            self.encryption_options = v.into();
            self
        }

        /// Sets the value of [striped][crate::model::import_context::SqlBakImportOptions::striped].
        pub fn set_striped<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.striped = v.into();
            self
        }

        /// Sets the value of [no_recovery][crate::model::import_context::SqlBakImportOptions::no_recovery].
        pub fn set_no_recovery<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.no_recovery = v.into();
            self
        }

        /// Sets the value of [recovery_only][crate::model::import_context::SqlBakImportOptions::recovery_only].
        pub fn set_recovery_only<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
            self.recovery_only = v.into();
            self
        }

        /// Sets the value of [bak_type][crate::model::import_context::SqlBakImportOptions::bak_type].
        pub fn set_bak_type<T: std::convert::Into<crate::model::BakType>>(mut self, v: T) -> Self {
            self.bak_type = v.into();
            self
        }

        /// Sets the value of [stop_at][crate::model::import_context::SqlBakImportOptions::stop_at].
        pub fn set_stop_at<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
            self.stop_at = v.into();
            self
        }

        /// Sets the value of [stop_at_mark][crate::model::import_context::SqlBakImportOptions::stop_at_mark].
        pub fn set_stop_at_mark<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stop_at_mark = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlBakImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions"
        }
    }

    /// Defines additional types related to SqlBakImportOptions
    pub mod sql_bak_import_options {
        #[allow(unused_imports)]
        use super::*;


        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EncryptionOptions {

            /// Path to the Certificate (.cer) in Cloud Storage, in the form
            /// `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub cert_path: std::string::String,

            /// Path to the Certificate Private Key (.pvk)  in Cloud Storage, in the
            /// form `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub pvk_path: std::string::String,

            /// Password that encrypts the private key
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub pvk_password: std::string::String,
        }

        impl EncryptionOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cert_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::cert_path].
            pub fn set_cert_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.cert_path = v.into();
                self
            }

            /// Sets the value of [pvk_path][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_path].
            pub fn set_pvk_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.pvk_path = v.into();
                self
            }

            /// Sets the value of [pvk_password][crate::model::import_context::sql_bak_import_options::EncryptionOptions::pvk_password].
            pub fn set_pvk_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.pvk_password = v.into();
                self
            }
        }

        impl wkt::message::Message for EncryptionOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.sql.v1.ImportContext.SqlBakImportOptions.EncryptionOptions"
            }
        }
    }
}

/// IP Management configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IpConfiguration {

    /// Whether the instance is assigned a public IP address or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ipv4_enabled: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_network: std::string::String,

    /// Use `ssl_mode` instead.
    ///
    /// Whether SSL/TLS connections over IP are enforced.
    /// If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections.
    /// For SSL/TLS connections, the client certificate won't be verified. If
    /// set to true, then only allow connections encrypted with SSL/TLS and with
    /// valid client certificates. If you want to enforce SSL/TLS without enforcing
    /// the requirement for valid client certificates, then use the `ssl_mode` flag
    /// instead of the `require_ssl` flag.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. In 'CIDR' notation, also known as 'slash' notation (for
    /// example: `157.197.200.0/24`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<crate::model::AclEntry>,

    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the instance ip
    /// will be created in the allocated range. The range name must comply with
    /// [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// `[a-z]([-a-z0-9]*[a-z0-9])?.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// Controls connectivity to private IP instances from Google services,
    /// such as BigQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_private_path_for_google_cloud_services: std::option::Option<wkt::BoolValue>,

    /// Specify how SSL/TLS is enforced in database connections. If you must use
    /// the `require_ssl` flag for backward compatibility, then only the following
    /// value pairs are valid:
    ///
    /// For PostgreSQL and MySQL:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`
    /// * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true`
    ///
    /// For SQL Server:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=true`
    ///
    /// The value of `ssl_mode` has priority over the value of `require_ssl`.
    ///
    /// For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and
    /// `require_ssl=false`, `ssl_mode=ENCRYPTED_ONLY` means accept only SSL
    /// connections, while `require_ssl=false` means accept both non-SSL
    /// and SSL connections. In this case, MySQL and PostgreSQL databases respect
    /// `ssl_mode` and accepts only SSL connections.
    pub ssl_mode: crate::model::ip_configuration::SslMode,

    /// PSC settings for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_config: std::option::Option<crate::model::PscConfig>,

    /// Specify what type of CA is used for the server certificate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_mode: std::option::Option<crate::model::ip_configuration::CaMode>,
}

impl IpConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ipv4_enabled][crate::model::IpConfiguration::ipv4_enabled].
    pub fn set_ipv4_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.ipv4_enabled = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::IpConfiguration::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::IpConfiguration::require_ssl].
    pub fn set_require_ssl<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.require_ssl = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::IpConfiguration::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [enable_private_path_for_google_cloud_services][crate::model::IpConfiguration::enable_private_path_for_google_cloud_services].
    pub fn set_enable_private_path_for_google_cloud_services<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_private_path_for_google_cloud_services = v.into();
        self
    }

    /// Sets the value of [ssl_mode][crate::model::IpConfiguration::ssl_mode].
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ip_configuration::SslMode>>(mut self, v: T) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::IpConfiguration::psc_config].
    pub fn set_psc_config<T: std::convert::Into<std::option::Option<crate::model::PscConfig>>>(mut self, v: T) -> Self {
        self.psc_config = v.into();
        self
    }

    /// Sets the value of [server_ca_mode][crate::model::IpConfiguration::server_ca_mode].
    pub fn set_server_ca_mode<T: std::convert::Into<std::option::Option<crate::model::ip_configuration::CaMode>>>(mut self, v: T) -> Self {
        self.server_ca_mode = v.into();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::IpConfiguration::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AclEntry>
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IpConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpConfiguration"
    }
}

/// Defines additional types related to IpConfiguration
pub mod ip_configuration {
    #[allow(unused_imports)]
    use super::*;


    /// The SSL options for database connections.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SslMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SslMode](SslMode)
    pub mod ssl_mode {
        use super::SslMode;
        

        /// The SSL mode is unknown.
        pub const SSL_MODE_UNSPECIFIED: SslMode = SslMode::known("SSL_MODE_UNSPECIFIED", 0);

        /// Allow non-SSL/non-TLS and SSL/TLS connections.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        pub const ALLOW_UNENCRYPTED_AND_ENCRYPTED: SslMode = SslMode::known("ALLOW_UNENCRYPTED_AND_ENCRYPTED", 1);

        /// Only allow connections encrypted with SSL/TLS.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        pub const ENCRYPTED_ONLY: SslMode = SslMode::known("ENCRYPTED_ONLY", 2);

        /// Only allow connections encrypted with SSL/TLS and with valid
        /// client certificates.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be true or
        /// cleared to avoid the conflict between values of two flags.
        /// PostgreSQL clients or users that connect using IAM database
        /// authentication must use either the
        /// [Cloud SQL Auth
        /// Proxy](https://cloud.google.com/sql/docs/postgres/connect-auth-proxy) or
        /// [Cloud SQL
        /// Connectors](https://cloud.google.com/sql/docs/postgres/connect-connectors)
        /// to enforce client identity verification.
        ///
        /// Only applicable to MySQL and PostgreSQL. Not applicable to SQL Server.
        pub const TRUSTED_CLIENT_CERTIFICATE_REQUIRED: SslMode = SslMode::known("TRUSTED_CLIENT_CERTIFICATE_REQUIRED", 3);
    }

    impl SslMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SslMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SslMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SslMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(SslMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SslMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SSL_MODE_UNSPECIFIED" => ssl_mode::SSL_MODE_UNSPECIFIED,
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => ssl_mode::ALLOW_UNENCRYPTED_AND_ENCRYPTED,
                "ENCRYPTED_ONLY" => ssl_mode::ENCRYPTED_ONLY,
                "TRUSTED_CLIENT_CERTIFICATE_REQUIRED" => ssl_mode::TRUSTED_CLIENT_CERTIFICATE_REQUIRED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            match value {
                0 => ssl_mode::SSL_MODE_UNSPECIFIED,
                1 => ssl_mode::ALLOW_UNENCRYPTED_AND_ENCRYPTED,
                2 => ssl_mode::ENCRYPTED_ONLY,
                3 => ssl_mode::TRUSTED_CLIENT_CERTIFICATE_REQUIRED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(Clone, Debug, PartialEq)]
    pub struct CaMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [CaMode](CaMode)
    pub mod ca_mode {
        use super::CaMode;
        

        /// CA mode is unknown.
        pub const CA_MODE_UNSPECIFIED: CaMode = CaMode::known("CA_MODE_UNSPECIFIED", 0);

        /// Google-managed self-signed internal CA.
        pub const GOOGLE_MANAGED_INTERNAL_CA: CaMode = CaMode::known("GOOGLE_MANAGED_INTERNAL_CA", 1);

        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        pub const GOOGLE_MANAGED_CAS_CA: CaMode = CaMode::known("GOOGLE_MANAGED_CAS_CA", 2);
    }

    impl CaMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for CaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(CaMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(CaMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(CaMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for CaMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CA_MODE_UNSPECIFIED" => ca_mode::CA_MODE_UNSPECIFIED,
                "GOOGLE_MANAGED_INTERNAL_CA" => ca_mode::GOOGLE_MANAGED_INTERNAL_CA,
                "GOOGLE_MANAGED_CAS_CA" => ca_mode::GOOGLE_MANAGED_CAS_CA,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for CaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => ca_mode::CA_MODE_UNSPECIFIED,
                1 => ca_mode::GOOGLE_MANAGED_INTERNAL_CA,
                2 => ca_mode::GOOGLE_MANAGED_CAS_CA,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for CaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// PSC settings for a Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConfig {

    /// Whether PSC connectivity is enabled for this instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_enabled: std::option::Option<bool>,

    /// Optional. The list of consumer projects that are allow-listed for PSC
    /// connections to this instance. This instance can be connected to with PSC
    /// from any network in these projects.
    ///
    /// Each consumer project in this list may be represented by a project number
    /// (numeric) or by a project id (alphanumeric).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allowed_consumer_projects: std::vec::Vec<std::string::String>,
}

impl PscConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_enabled][crate::model::PscConfig::psc_enabled].
    pub fn set_psc_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.psc_enabled = v.into();
        self
    }

    /// Sets the value of [allowed_consumer_projects][crate::model::PscConfig::allowed_consumer_projects].
    pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PscConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PscConfig"
    }
}

/// Preferred location. This specifies where a Cloud SQL instance is located.
/// Note that if the preferred location is not available, the instance will be
/// located as close as possible within the region. Only one location may be
/// specified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationPreference {

    /// The App Engine application to follow, it must be in the same region as the
    /// Cloud SQL instance. WARNING: Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub follow_gae_application: std::string::String,

    /// The preferred Compute Engine zone (for example: us-central1-a,
    /// us-central1-b, etc.). WARNING: Changing this might restart the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// The preferred Compute Engine zone for the secondary/failover
    /// (for example: us-central1-a, us-central1-b, etc.).
    /// To disable this field, set it to 'no_secondary_zone'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_zone: std::string::String,

    /// This is always `sql#locationPreference`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl LocationPreference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [follow_gae_application][crate::model::LocationPreference::follow_gae_application].
    pub fn set_follow_gae_application<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.follow_gae_application = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::LocationPreference::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::LocationPreference::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::LocationPreference::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for LocationPreference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.LocationPreference"
    }
}

/// Maintenance window. This specifies when a Cloud SQL instance is
/// restarted for system maintenance purposes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {

    /// Hour of day - 0 to 23. Specify in the UTC time zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hour: std::option::Option<wkt::Int32Value>,

    /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
    /// `SATURDAY`, or `SUNDAY`. Specify in the UTC time zone.
    /// Returned in output as an integer, 1 to 7, where `1` equals Monday.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub day: std::option::Option<wkt::Int32Value>,

    /// Maintenance timing settings: `canary`, `stable`, or `week5`.
    /// For more information, see [About maintenance on Cloud SQL
    /// instances](https://cloud.google.com/sql/docs/mysql/maintenance).
    pub update_track: crate::model::SqlUpdateTrack,

    /// This is always `sql#maintenanceWindow`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hour][crate::model::MaintenanceWindow::hour].
    pub fn set_hour<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.hour = v.into();
        self
    }

    /// Sets the value of [day][crate::model::MaintenanceWindow::day].
    pub fn set_day<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [update_track][crate::model::MaintenanceWindow::update_track].
    pub fn set_update_track<T: std::convert::Into<crate::model::SqlUpdateTrack>>(mut self, v: T) -> Self {
        self.update_track = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::MaintenanceWindow::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MaintenanceWindow"
    }
}

/// Deny maintenance Periods. This specifies a date range during when all CSA
/// rollout will be denied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DenyMaintenancePeriod {

    /// "deny maintenance period" start date. If the year of the start date is
    /// empty, the year of the end date also must be empty. In this case, it means
    /// the deny maintenance period recurs every year. The date is in format
    /// yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_date: std::string::String,

    /// "deny maintenance period" end date. If the year of the end date is empty,
    /// the year of the start date also must be empty. In this case, it means the
    /// no maintenance interval recurs every year. The date is in format yyyy-mm-dd
    /// i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub end_date: std::string::String,

    /// Time in UTC when the "deny maintenance period" starts on start_date and
    /// ends on end_date. The time is in format: HH:mm:SS, i.e., 00:00:00
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time: std::string::String,
}

impl DenyMaintenancePeriod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_date][crate::model::DenyMaintenancePeriod::start_date].
    pub fn set_start_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_date = v.into();
        self
    }

    /// Sets the value of [end_date][crate::model::DenyMaintenancePeriod::end_date].
    pub fn set_end_date<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_date = v.into();
        self
    }

    /// Sets the value of [time][crate::model::DenyMaintenancePeriod::time].
    pub fn set_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time = v.into();
        self
    }
}

impl wkt::message::Message for DenyMaintenancePeriod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DenyMaintenancePeriod"
    }
}

/// Insights configuration. This specifies when Cloud SQL Insights feature is
/// enabled and optional configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightsConfig {

    /// Whether Query Insights feature is enabled.
    pub query_insights_enabled: bool,

    /// Whether Query Insights will record client address when enabled.
    pub record_client_address: bool,

    /// Whether Query Insights will record application tags from query when
    /// enabled.
    pub record_application_tags: bool,

    /// Maximum query length stored in bytes. Default value: 1024 bytes.
    /// Range: 256-4500 bytes. Query length more than this field value will be
    /// truncated to this value. When unset, query length will be the default
    /// value. Changing query length will restart the database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_string_length: std::option::Option<wkt::Int32Value>,

    /// Number of query execution plans captured by Insights per minute
    /// for all queries combined. Default is 5.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_plans_per_minute: std::option::Option<wkt::Int32Value>,
}

impl InsightsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_insights_enabled][crate::model::InsightsConfig::query_insights_enabled].
    pub fn set_query_insights_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.query_insights_enabled = v.into();
        self
    }

    /// Sets the value of [record_client_address][crate::model::InsightsConfig::record_client_address].
    pub fn set_record_client_address<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_client_address = v.into();
        self
    }

    /// Sets the value of [record_application_tags][crate::model::InsightsConfig::record_application_tags].
    pub fn set_record_application_tags<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.record_application_tags = v.into();
        self
    }

    /// Sets the value of [query_string_length][crate::model::InsightsConfig::query_string_length].
    pub fn set_query_string_length<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.query_string_length = v.into();
        self
    }

    /// Sets the value of [query_plans_per_minute][crate::model::InsightsConfig::query_plans_per_minute].
    pub fn set_query_plans_per_minute<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.query_plans_per_minute = v.into();
        self
    }
}

impl wkt::message::Message for InsightsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.InsightsConfig"
    }
}

/// Read-replica configuration specific to MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlReplicaConfiguration {

    /// Path to a SQL dump file in Google Cloud Storage from which the replica
    /// instance is to be created. The URI is in the form gs://bucketName/fileName.
    /// Compressed gzip files (.gz) are also supported.
    /// Dumps have the binlog co-ordinates from which replication
    /// begins. This can be accomplished by setting --master-data to 1 when using
    /// mysqldump.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_file_path: std::string::String,

    /// The username for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// The password for the replication connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Seconds to wait between connect retries. MySQL's default is 60 seconds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connect_retry_interval: std::option::Option<wkt::Int32Value>,

    /// Interval in milliseconds between replication heartbeats.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub master_heartbeat_period: std::option::Option<wkt::Int64Value>,

    /// PEM representation of the trusted CA's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    /// PEM representation of the replica's x509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// A list of permissible ciphers to use for SSL encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_cipher: std::string::String,

    /// Whether or not to check the primary instance's Common Name value in the
    /// certificate that it sends during the SSL handshake.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_server_certificate: std::option::Option<wkt::BoolValue>,

    /// This is always `sql#mysqlReplicaConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl MySqlReplicaConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dump_file_path][crate::model::MySqlReplicaConfiguration::dump_file_path].
    pub fn set_dump_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_file_path = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlReplicaConfiguration::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlReplicaConfiguration::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [connect_retry_interval][crate::model::MySqlReplicaConfiguration::connect_retry_interval].
    pub fn set_connect_retry_interval<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.connect_retry_interval = v.into();
        self
    }

    /// Sets the value of [master_heartbeat_period][crate::model::MySqlReplicaConfiguration::master_heartbeat_period].
    pub fn set_master_heartbeat_period<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.master_heartbeat_period = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::MySqlReplicaConfiguration::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MySqlReplicaConfiguration::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::MySqlReplicaConfiguration::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [ssl_cipher][crate::model::MySqlReplicaConfiguration::ssl_cipher].
    pub fn set_ssl_cipher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ssl_cipher = v.into();
        self
    }

    /// Sets the value of [verify_server_certificate][crate::model::MySqlReplicaConfiguration::verify_server_certificate].
    pub fn set_verify_server_certificate<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.verify_server_certificate = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::MySqlReplicaConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for MySqlReplicaConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.MySqlReplicaConfiguration"
    }
}

/// Disk encryption configuration for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEncryptionConfiguration {

    /// Resource name of KMS key for disk encryption
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// This is always `sql#diskEncryptionConfiguration`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl DiskEncryptionConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::DiskEncryptionConfiguration::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionConfiguration::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionConfiguration"
    }
}

/// Disk encryption status for an instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskEncryptionStatus {

    /// KMS key version used to encrypt the Cloud SQL instance resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    /// This is always `sql#diskEncryptionStatus`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,
}

impl DiskEncryptionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::DiskEncryptionStatus::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::DiskEncryptionStatus::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for DiskEncryptionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DiskEncryptionStatus"
    }
}

/// Database instance IP mapping
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IpMapping {

    /// The type of this IP address. A `PRIMARY` address is a public address that
    /// can accept incoming connections. A `PRIVATE` address is a private address
    /// that can accept incoming connections. An `OUTGOING` address is the source
    /// address of connections originating from the instance, if supported.
    #[serde(rename = "type")]
    pub r#type: crate::model::SqlIpAddressType,

    /// The IP address assigned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// The due time for this IP to be retired in
    /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`. This field is only available when
    /// the IP is scheduled to be retired.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_to_retire: std::option::Option<wkt::Timestamp>,
}

impl IpMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::IpMapping::type].
    pub fn set_type<T: std::convert::Into<crate::model::SqlIpAddressType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::IpMapping::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [time_to_retire][crate::model::IpMapping::time_to_retire].
    pub fn set_time_to_retire<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.time_to_retire = v.into();
        self
    }
}

impl wkt::message::Message for IpMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.IpMapping"
    }
}

/// An Operation resource.&nbsp;For successful operations that return an
/// Operation resource, only the fields relevant to the operation are populated
/// in the resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Operation {

    /// This is always `sql#operation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_link: std::string::String,

    /// The status of an operation.
    pub status: crate::model::operation::SqlOperationStatus,

    /// The email address of the user who initiated this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// The time this operation was enqueued in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insert_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation actually started in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time this operation finished in UTC timezone in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// If errors occurred during processing of this operation, this field will be
    /// populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::OperationErrors>,

    /// An Admin API warning message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub api_warning: std::option::Option<crate::model::ApiWarning>,

    /// The type of the operation. Valid values are:
    ///
    /// * `CREATE`
    /// * `DELETE`
    /// * `UPDATE`
    /// * `RESTART`
    /// * `IMPORT`
    /// * `EXPORT`
    /// * `BACKUP_VOLUME`
    /// * `RESTORE_VOLUME`
    /// * `CREATE_USER`
    /// * `DELETE_USER`
    /// * `CREATE_DATABASE`
    /// * `DELETE_DATABASE`
    pub operation_type: crate::model::operation::SqlOperationType,

    /// The context for import operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub import_context: std::option::Option<crate::model::ImportContext>,

    /// The context for export operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub export_context: std::option::Option<crate::model::ExportContext>,

    /// The context for backup operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_context: std::option::Option<crate::model::BackupContext>,

    /// An identifier that uniquely identifies the operation. You can use this
    /// identifier to retrieve the Operations resource that has information about
    /// the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Name of the database instance related to this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_id: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,

    /// The project ID of the target instance related to this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_project: std::string::String,

    /// The context for acquire SSRS lease operation, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub acquire_ssrs_lease_context: std::option::Option<crate::model::AcquireSsrsLeaseContext>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Operation::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_link = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::SqlOperationStatus>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Operation::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_insert_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.insert_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<crate::model::OperationErrors>>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [api_warning][crate::model::Operation::api_warning].
    pub fn set_api_warning<T: std::convert::Into<std::option::Option<crate::model::ApiWarning>>>(mut self, v: T) -> Self {
        self.api_warning = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation::SqlOperationType>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [import_context][crate::model::Operation::import_context].
    pub fn set_import_context<T: std::convert::Into<std::option::Option<crate::model::ImportContext>>>(mut self, v: T) -> Self {
        self.import_context = v.into();
        self
    }

    /// Sets the value of [export_context][crate::model::Operation::export_context].
    pub fn set_export_context<T: std::convert::Into<std::option::Option<crate::model::ExportContext>>>(mut self, v: T) -> Self {
        self.export_context = v.into();
        self
    }

    /// Sets the value of [backup_context][crate::model::Operation::backup_context].
    pub fn set_backup_context<T: std::convert::Into<std::option::Option<crate::model::BackupContext>>>(mut self, v: T) -> Self {
        self.backup_context = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::Operation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::Operation::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [acquire_ssrs_lease_context][crate::model::Operation::acquire_ssrs_lease_context].
    pub fn set_acquire_ssrs_lease_context<T: std::convert::Into<std::option::Option<crate::model::AcquireSsrsLeaseContext>>>(mut self, v: T) -> Self {
        self.acquire_ssrs_lease_context = v.into();
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Operation"
    }
}

/// Defines additional types related to Operation
pub mod operation {
    #[allow(unused_imports)]
    use super::*;


    /// The type of Cloud SQL operation.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlOperationType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlOperationType](SqlOperationType)
    pub mod sql_operation_type {
        use super::SqlOperationType;
        

        /// Unknown operation type.
        pub const SQL_OPERATION_TYPE_UNSPECIFIED: SqlOperationType = SqlOperationType::known("SQL_OPERATION_TYPE_UNSPECIFIED", 0);

        /// Imports data into a Cloud SQL instance.
        pub const IMPORT: SqlOperationType = SqlOperationType::known("IMPORT", 1);

        /// Exports data from a Cloud SQL instance to a Cloud Storage
        /// bucket.
        pub const EXPORT: SqlOperationType = SqlOperationType::known("EXPORT", 2);

        /// Creates a new Cloud SQL instance.
        pub const CREATE: SqlOperationType = SqlOperationType::known("CREATE", 3);

        /// Updates the settings of a Cloud SQL instance.
        pub const UPDATE: SqlOperationType = SqlOperationType::known("UPDATE", 4);

        /// Deletes a Cloud SQL instance.
        pub const DELETE: SqlOperationType = SqlOperationType::known("DELETE", 5);

        /// Restarts the Cloud SQL instance.
        pub const RESTART: SqlOperationType = SqlOperationType::known("RESTART", 6);

        pub const BACKUP: SqlOperationType = SqlOperationType::known("BACKUP", 7);

        pub const SNAPSHOT: SqlOperationType = SqlOperationType::known("SNAPSHOT", 8);

        /// Performs instance backup.
        pub const BACKUP_VOLUME: SqlOperationType = SqlOperationType::known("BACKUP_VOLUME", 9);

        /// Deletes an instance backup.
        pub const DELETE_VOLUME: SqlOperationType = SqlOperationType::known("DELETE_VOLUME", 10);

        /// Restores an instance backup.
        pub const RESTORE_VOLUME: SqlOperationType = SqlOperationType::known("RESTORE_VOLUME", 11);

        /// Injects a privileged user in mysql for MOB instances.
        pub const INJECT_USER: SqlOperationType = SqlOperationType::known("INJECT_USER", 12);

        /// Clones a Cloud SQL instance.
        pub const CLONE: SqlOperationType = SqlOperationType::known("CLONE", 14);

        /// Stops replication on a Cloud SQL read replica instance.
        pub const STOP_REPLICA: SqlOperationType = SqlOperationType::known("STOP_REPLICA", 15);

        /// Starts replication on a Cloud SQL read replica instance.
        pub const START_REPLICA: SqlOperationType = SqlOperationType::known("START_REPLICA", 16);

        /// Promotes a Cloud SQL replica instance.
        pub const PROMOTE_REPLICA: SqlOperationType = SqlOperationType::known("PROMOTE_REPLICA", 17);

        /// Creates a Cloud SQL replica instance.
        pub const CREATE_REPLICA: SqlOperationType = SqlOperationType::known("CREATE_REPLICA", 18);

        /// Creates a new user in a Cloud SQL instance.
        pub const CREATE_USER: SqlOperationType = SqlOperationType::known("CREATE_USER", 19);

        /// Deletes a user from a Cloud SQL instance.
        pub const DELETE_USER: SqlOperationType = SqlOperationType::known("DELETE_USER", 20);

        /// Updates an existing user in a Cloud SQL instance.
        pub const UPDATE_USER: SqlOperationType = SqlOperationType::known("UPDATE_USER", 21);

        /// Creates a database in the Cloud SQL instance.
        pub const CREATE_DATABASE: SqlOperationType = SqlOperationType::known("CREATE_DATABASE", 22);

        /// Deletes a database in the Cloud SQL instance.
        pub const DELETE_DATABASE: SqlOperationType = SqlOperationType::known("DELETE_DATABASE", 23);

        /// Updates a database in the Cloud SQL instance.
        pub const UPDATE_DATABASE: SqlOperationType = SqlOperationType::known("UPDATE_DATABASE", 24);

        /// Performs failover of an HA-enabled Cloud SQL
        /// failover replica.
        pub const FAILOVER: SqlOperationType = SqlOperationType::known("FAILOVER", 25);

        /// Deletes the backup taken by a backup run.
        pub const DELETE_BACKUP: SqlOperationType = SqlOperationType::known("DELETE_BACKUP", 26);

        pub const RECREATE_REPLICA: SqlOperationType = SqlOperationType::known("RECREATE_REPLICA", 27);

        /// Truncates a general or slow log table in MySQL.
        pub const TRUNCATE_LOG: SqlOperationType = SqlOperationType::known("TRUNCATE_LOG", 28);

        /// Demotes the stand-alone instance to be a Cloud SQL
        /// read replica for an external database server.
        pub const DEMOTE_MASTER: SqlOperationType = SqlOperationType::known("DEMOTE_MASTER", 29);

        /// Indicates that the instance is currently in maintenance. Maintenance
        /// typically causes the instance to be unavailable for 1-3 minutes.
        pub const MAINTENANCE: SqlOperationType = SqlOperationType::known("MAINTENANCE", 30);

        /// This field is deprecated, and will be removed in future version of API.
        pub const ENABLE_PRIVATE_IP: SqlOperationType = SqlOperationType::known("ENABLE_PRIVATE_IP", 31);

        pub const DEFER_MAINTENANCE: SqlOperationType = SqlOperationType::known("DEFER_MAINTENANCE", 32);

        /// Creates clone instance.
        pub const CREATE_CLONE: SqlOperationType = SqlOperationType::known("CREATE_CLONE", 33);

        /// Reschedule maintenance to another time.
        pub const RESCHEDULE_MAINTENANCE: SqlOperationType = SqlOperationType::known("RESCHEDULE_MAINTENANCE", 34);

        /// Starts external sync of a Cloud SQL EM replica to an external primary
        /// instance.
        pub const START_EXTERNAL_SYNC: SqlOperationType = SqlOperationType::known("START_EXTERNAL_SYNC", 35);

        /// Recovers logs from an instance's old data disk.
        pub const LOG_CLEANUP: SqlOperationType = SqlOperationType::known("LOG_CLEANUP", 36);

        /// Performs auto-restart of an HA-enabled Cloud SQL database for auto
        /// recovery.
        pub const AUTO_RESTART: SqlOperationType = SqlOperationType::known("AUTO_RESTART", 37);

        /// Re-encrypts CMEK instances with latest key version.
        pub const REENCRYPT: SqlOperationType = SqlOperationType::known("REENCRYPT", 38);

        /// Switches the roles of the primary and replica pair. The target instance
        /// should be the replica.
        pub const SWITCHOVER: SqlOperationType = SqlOperationType::known("SWITCHOVER", 39);

        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        pub const ACQUIRE_SSRS_LEASE: SqlOperationType = SqlOperationType::known("ACQUIRE_SSRS_LEASE", 42);

        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        pub const RELEASE_SSRS_LEASE: SqlOperationType = SqlOperationType::known("RELEASE_SSRS_LEASE", 43);

        /// Reconfigures old primary after a promote replica operation. Effect of a
        /// promote operation to the old primary is executed in this operation,
        /// asynchronously from the promote replica operation executed to the
        /// replica.
        pub const RECONFIGURE_OLD_PRIMARY: SqlOperationType = SqlOperationType::known("RECONFIGURE_OLD_PRIMARY", 44);

        /// Indicates that the instance, its read replicas, and its cascading
        /// replicas are in maintenance. Maintenance typically gets initiated on
        /// groups of replicas first, followed by the primary instance. For each
        /// instance, maintenance typically causes the instance to be unavailable for
        /// 1-3 minutes.
        pub const CLUSTER_MAINTENANCE: SqlOperationType = SqlOperationType::known("CLUSTER_MAINTENANCE", 45);

        /// Indicates that the instance (and any of its replicas) are currently in
        /// maintenance. This is initiated as a self-service request by using SSM.
        /// Maintenance typically causes the instance to be unavailable for 1-3
        /// minutes.
        pub const SELF_SERVICE_MAINTENANCE: SqlOperationType = SqlOperationType::known("SELF_SERVICE_MAINTENANCE", 46);

        /// Switches a primary instance to a replica. This operation runs as part of
        /// a switchover operation to the original primary instance.
        pub const SWITCHOVER_TO_REPLICA: SqlOperationType = SqlOperationType::known("SWITCHOVER_TO_REPLICA", 47);

        /// Updates the major version of a Cloud SQL instance.
        pub const MAJOR_VERSION_UPGRADE: SqlOperationType = SqlOperationType::known("MAJOR_VERSION_UPGRADE", 48);
    }

    impl SqlOperationType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlOperationType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlOperationType::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlOperationType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlOperationType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_OPERATION_TYPE_UNSPECIFIED" => sql_operation_type::SQL_OPERATION_TYPE_UNSPECIFIED,
                "IMPORT" => sql_operation_type::IMPORT,
                "EXPORT" => sql_operation_type::EXPORT,
                "CREATE" => sql_operation_type::CREATE,
                "UPDATE" => sql_operation_type::UPDATE,
                "DELETE" => sql_operation_type::DELETE,
                "RESTART" => sql_operation_type::RESTART,
                "BACKUP" => sql_operation_type::BACKUP,
                "SNAPSHOT" => sql_operation_type::SNAPSHOT,
                "BACKUP_VOLUME" => sql_operation_type::BACKUP_VOLUME,
                "DELETE_VOLUME" => sql_operation_type::DELETE_VOLUME,
                "RESTORE_VOLUME" => sql_operation_type::RESTORE_VOLUME,
                "INJECT_USER" => sql_operation_type::INJECT_USER,
                "CLONE" => sql_operation_type::CLONE,
                "STOP_REPLICA" => sql_operation_type::STOP_REPLICA,
                "START_REPLICA" => sql_operation_type::START_REPLICA,
                "PROMOTE_REPLICA" => sql_operation_type::PROMOTE_REPLICA,
                "CREATE_REPLICA" => sql_operation_type::CREATE_REPLICA,
                "CREATE_USER" => sql_operation_type::CREATE_USER,
                "DELETE_USER" => sql_operation_type::DELETE_USER,
                "UPDATE_USER" => sql_operation_type::UPDATE_USER,
                "CREATE_DATABASE" => sql_operation_type::CREATE_DATABASE,
                "DELETE_DATABASE" => sql_operation_type::DELETE_DATABASE,
                "UPDATE_DATABASE" => sql_operation_type::UPDATE_DATABASE,
                "FAILOVER" => sql_operation_type::FAILOVER,
                "DELETE_BACKUP" => sql_operation_type::DELETE_BACKUP,
                "RECREATE_REPLICA" => sql_operation_type::RECREATE_REPLICA,
                "TRUNCATE_LOG" => sql_operation_type::TRUNCATE_LOG,
                "DEMOTE_MASTER" => sql_operation_type::DEMOTE_MASTER,
                "MAINTENANCE" => sql_operation_type::MAINTENANCE,
                "ENABLE_PRIVATE_IP" => sql_operation_type::ENABLE_PRIVATE_IP,
                "DEFER_MAINTENANCE" => sql_operation_type::DEFER_MAINTENANCE,
                "CREATE_CLONE" => sql_operation_type::CREATE_CLONE,
                "RESCHEDULE_MAINTENANCE" => sql_operation_type::RESCHEDULE_MAINTENANCE,
                "START_EXTERNAL_SYNC" => sql_operation_type::START_EXTERNAL_SYNC,
                "LOG_CLEANUP" => sql_operation_type::LOG_CLEANUP,
                "AUTO_RESTART" => sql_operation_type::AUTO_RESTART,
                "REENCRYPT" => sql_operation_type::REENCRYPT,
                "SWITCHOVER" => sql_operation_type::SWITCHOVER,
                "ACQUIRE_SSRS_LEASE" => sql_operation_type::ACQUIRE_SSRS_LEASE,
                "RELEASE_SSRS_LEASE" => sql_operation_type::RELEASE_SSRS_LEASE,
                "RECONFIGURE_OLD_PRIMARY" => sql_operation_type::RECONFIGURE_OLD_PRIMARY,
                "CLUSTER_MAINTENANCE" => sql_operation_type::CLUSTER_MAINTENANCE,
                "SELF_SERVICE_MAINTENANCE" => sql_operation_type::SELF_SERVICE_MAINTENANCE,
                "SWITCHOVER_TO_REPLICA" => sql_operation_type::SWITCHOVER_TO_REPLICA,
                "MAJOR_VERSION_UPGRADE" => sql_operation_type::MAJOR_VERSION_UPGRADE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_operation_type::SQL_OPERATION_TYPE_UNSPECIFIED,
                1 => sql_operation_type::IMPORT,
                2 => sql_operation_type::EXPORT,
                3 => sql_operation_type::CREATE,
                4 => sql_operation_type::UPDATE,
                5 => sql_operation_type::DELETE,
                6 => sql_operation_type::RESTART,
                7 => sql_operation_type::BACKUP,
                8 => sql_operation_type::SNAPSHOT,
                9 => sql_operation_type::BACKUP_VOLUME,
                10 => sql_operation_type::DELETE_VOLUME,
                11 => sql_operation_type::RESTORE_VOLUME,
                12 => sql_operation_type::INJECT_USER,
                14 => sql_operation_type::CLONE,
                15 => sql_operation_type::STOP_REPLICA,
                16 => sql_operation_type::START_REPLICA,
                17 => sql_operation_type::PROMOTE_REPLICA,
                18 => sql_operation_type::CREATE_REPLICA,
                19 => sql_operation_type::CREATE_USER,
                20 => sql_operation_type::DELETE_USER,
                21 => sql_operation_type::UPDATE_USER,
                22 => sql_operation_type::CREATE_DATABASE,
                23 => sql_operation_type::DELETE_DATABASE,
                24 => sql_operation_type::UPDATE_DATABASE,
                25 => sql_operation_type::FAILOVER,
                26 => sql_operation_type::DELETE_BACKUP,
                27 => sql_operation_type::RECREATE_REPLICA,
                28 => sql_operation_type::TRUNCATE_LOG,
                29 => sql_operation_type::DEMOTE_MASTER,
                30 => sql_operation_type::MAINTENANCE,
                31 => sql_operation_type::ENABLE_PRIVATE_IP,
                32 => sql_operation_type::DEFER_MAINTENANCE,
                33 => sql_operation_type::CREATE_CLONE,
                34 => sql_operation_type::RESCHEDULE_MAINTENANCE,
                35 => sql_operation_type::START_EXTERNAL_SYNC,
                36 => sql_operation_type::LOG_CLEANUP,
                37 => sql_operation_type::AUTO_RESTART,
                38 => sql_operation_type::REENCRYPT,
                39 => sql_operation_type::SWITCHOVER,
                42 => sql_operation_type::ACQUIRE_SSRS_LEASE,
                43 => sql_operation_type::RELEASE_SSRS_LEASE,
                44 => sql_operation_type::RECONFIGURE_OLD_PRIMARY,
                45 => sql_operation_type::CLUSTER_MAINTENANCE,
                46 => sql_operation_type::SELF_SERVICE_MAINTENANCE,
                47 => sql_operation_type::SWITCHOVER_TO_REPLICA,
                48 => sql_operation_type::MAJOR_VERSION_UPGRADE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The status of an operation.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlOperationStatus(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlOperationStatus](SqlOperationStatus)
    pub mod sql_operation_status {
        use super::SqlOperationStatus;
        

        /// The state of the operation is unknown.
        pub const SQL_OPERATION_STATUS_UNSPECIFIED: SqlOperationStatus = SqlOperationStatus::known("SQL_OPERATION_STATUS_UNSPECIFIED", 0);

        /// The operation has been queued, but has not started yet.
        pub const PENDING: SqlOperationStatus = SqlOperationStatus::known("PENDING", 1);

        /// The operation is running.
        pub const RUNNING: SqlOperationStatus = SqlOperationStatus::known("RUNNING", 2);

        /// The operation completed.
        pub const DONE: SqlOperationStatus = SqlOperationStatus::known("DONE", 3);
    }

    impl SqlOperationStatus {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlOperationStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlOperationStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlOperationStatus::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlOperationStatus::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlOperationStatus::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlOperationStatus {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_OPERATION_STATUS_UNSPECIFIED" => sql_operation_status::SQL_OPERATION_STATUS_UNSPECIFIED,
                "PENDING" => sql_operation_status::PENDING,
                "RUNNING" => sql_operation_status::RUNNING,
                "DONE" => sql_operation_status::DONE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlOperationStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_operation_status::SQL_OPERATION_STATUS_UNSPECIFIED,
                1 => sql_operation_status::PENDING,
                2 => sql_operation_status::RUNNING,
                3 => sql_operation_status::DONE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlOperationStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Database instance operation error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationError {

    /// This is always `sql#operationError`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Identifies the specific error that occurred.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// Additional information about the error encountered.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,
}

impl OperationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationError::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [code][crate::model::OperationError::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::OperationError::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for OperationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationError"
    }
}

/// Database instance operation errors list wrapper.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationErrors {

    /// This is always `sql#operationErrors`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The list of errors encountered while processing this operation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::OperationError>,
}

impl OperationErrors {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::OperationErrors::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::OperationErrors::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationError>
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationErrors {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.OperationErrors"
    }
}

/// Database instance local user password validation policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PasswordValidationPolicy {

    /// Minimum number of characters allowed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_length: std::option::Option<wkt::Int32Value>,

    /// The complexity of the password.
    pub complexity: crate::model::password_validation_policy::Complexity,

    /// Number of previous passwords that cannot be reused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reuse_interval: std::option::Option<wkt::Int32Value>,

    /// Disallow username as a part of the password.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disallow_username_substring: std::option::Option<wkt::BoolValue>,

    /// Minimum interval after which the password can be changed. This flag is only
    /// supported for PostgreSQL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_change_interval: std::option::Option<wkt::Duration>,

    /// Whether the password policy is enabled or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_password_policy: std::option::Option<wkt::BoolValue>,

    /// This field is deprecated and will be removed in a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disallow_compromised_credentials: std::option::Option<wkt::BoolValue>,
}

impl PasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_length][crate::model::PasswordValidationPolicy::min_length].
    pub fn set_min_length<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.min_length = v.into();
        self
    }

    /// Sets the value of [complexity][crate::model::PasswordValidationPolicy::complexity].
    pub fn set_complexity<T: std::convert::Into<crate::model::password_validation_policy::Complexity>>(mut self, v: T) -> Self {
        self.complexity = v.into();
        self
    }

    /// Sets the value of [reuse_interval][crate::model::PasswordValidationPolicy::reuse_interval].
    pub fn set_reuse_interval<T: std::convert::Into<std::option::Option<wkt::Int32Value>>>(mut self, v: T) -> Self {
        self.reuse_interval = v.into();
        self
    }

    /// Sets the value of [disallow_username_substring][crate::model::PasswordValidationPolicy::disallow_username_substring].
    pub fn set_disallow_username_substring<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.disallow_username_substring = v.into();
        self
    }

    /// Sets the value of [password_change_interval][crate::model::PasswordValidationPolicy::password_change_interval].
    pub fn set_password_change_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.password_change_interval = v.into();
        self
    }

    /// Sets the value of [enable_password_policy][crate::model::PasswordValidationPolicy::enable_password_policy].
    pub fn set_enable_password_policy<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_password_policy = v.into();
        self
    }

    /// Sets the value of [disallow_compromised_credentials][crate::model::PasswordValidationPolicy::disallow_compromised_credentials].
    pub fn set_disallow_compromised_credentials<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.disallow_compromised_credentials = v.into();
        self
    }
}

impl wkt::message::Message for PasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordValidationPolicy"
    }
}

/// Defines additional types related to PasswordValidationPolicy
pub mod password_validation_policy {
    #[allow(unused_imports)]
    use super::*;


    /// The complexity choices of the password.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Complexity(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Complexity](Complexity)
    pub mod complexity {
        use super::Complexity;
        

        /// Complexity check is not specified.
        pub const COMPLEXITY_UNSPECIFIED: Complexity = Complexity::known("COMPLEXITY_UNSPECIFIED", 0);

        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric
        /// characters.
        pub const COMPLEXITY_DEFAULT: Complexity = Complexity::known("COMPLEXITY_DEFAULT", 1);
    }

    impl Complexity {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Complexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Complexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Complexity::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Complexity::from(val)),
                Enumeration::UnknownNum { str } => Ok(Complexity::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Complexity {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "COMPLEXITY_UNSPECIFIED" => complexity::COMPLEXITY_UNSPECIFIED,
                "COMPLEXITY_DEFAULT" => complexity::COMPLEXITY_DEFAULT,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Complexity {
        fn from(value: i32) -> Self {
            match value {
                0 => complexity::COMPLEXITY_UNSPECIFIED,
                1 => complexity::COMPLEXITY_DEFAULT,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Complexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Data cache configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataCacheConfig {

    /// Whether data cache is enabled for the instance.
    pub data_cache_enabled: bool,
}

impl DataCacheConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_cache_enabled][crate::model::DataCacheConfig::data_cache_enabled].
    pub fn set_data_cache_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.data_cache_enabled = v.into();
        self
    }
}

impl wkt::message::Message for DataCacheConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.DataCacheConfig"
    }
}

/// Database instance settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Settings {

    /// The version of instance settings. This is a required field for update
    /// method to make sure concurrent updates are handled properly. During update,
    /// use the most recent settingsVersion value for this instance and do not try
    /// to update this value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub settings_version: std::option::Option<wkt::Int64Value>,

    /// The App Engine app IDs that can access this instance.
    /// (Deprecated) Applied to First Generation instances only.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_gae_applications: std::vec::Vec<std::string::String>,

    /// The tier (or machine type) for this instance, for example
    /// `db-custom-1-3840`. WARNING: Changing this restarts the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// This is always `sql#settings`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// User-provided labels, represented as a dictionary where each label is a
    /// single key value pair.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data accessibility.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available)./
    ///
    /// For more information, see [Overview of the High Availability
    /// Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
    pub availability_type: crate::model::SqlAvailabilityType,

    /// The pricing plan for this instance. This can be either `PER_USE` or
    /// `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    pub pricing_plan: crate::model::SqlPricingPlan,

    /// The type of replication this instance uses. This can be either
    /// `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only
    /// applicable to First Generation instances.
    pub replication_type: crate::model::SqlReplicationType,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is RUNNABLE. Valid values:
    ///
    /// * `ALWAYS`: The instance is on, and remains so even in the absence of
    ///   connection requests.
    /// * `NEVER`: The instance is off; it is not activated, even if a
    ///   connection request arrives.
    pub activation_policy: crate::model::settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled for Second Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_configuration: std::option::Option<crate::model::IpConfiguration>,

    /// Configuration to increase storage size automatically. The default value is
    /// true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub storage_auto_resize: std::option::Option<wkt::BoolValue>,

    /// The location preference settings. This allows the instance to be located as
    /// near as possible to either an App Engine app or Compute Engine zone for
    /// better performance. App Engine co-location was only applicable to First
    /// Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location_preference: std::option::Option<crate::model::LocationPreference>,

    /// The database flags passed to the instance at startup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_flags: std::vec::Vec<crate::model::DatabaseFlags>,

    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for
    /// First Generation instances.
    pub data_disk_type: crate::model::SqlDataDiskType,

    /// The maintenance window for this instance. This specifies when the instance
    /// can be restarted for maintenance purposes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_window: std::option::Option<crate::model::MaintenanceWindow>,

    /// The daily backup configuration for the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_configuration: std::option::Option<crate::model::BackupConfiguration>,

    /// Configuration specific to read replica instances. Indicates whether
    /// replication is enabled or not. WARNING: Changing this restarts the
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub database_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// Configuration specific to read replica instances. Indicates whether
    /// database flags for crash-safe replication are enabled. This property was
    /// only applicable to First Generation instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crash_safe_replication_enabled: std::option::Option<wkt::BoolValue>,

    /// The size of data disk, in GB. The data disk size minimum is 10GB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub active_directory_config: std::option::Option<crate::model::SqlActiveDirectoryConfig>,

    /// The name of server Instance collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Deny maintenance periods
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub deny_maintenance_periods: std::vec::Vec<crate::model::DenyMaintenancePeriod>,

    /// Insights configuration, for now relevant only for Postgres.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insights_config: std::option::Option<crate::model::InsightsConfig>,

    /// The local user password validation policy of the instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_validation_policy: std::option::Option<crate::model::PasswordValidationPolicy>,

    /// SQL Server specific audit configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_server_audit_config: std::option::Option<crate::model::SqlServerAuditConfig>,

    /// Optional. The edition of the instance.
    pub edition: crate::model::settings::Edition,

    /// Specifies if connections must use Cloud SQL connectors.
    /// Option values include the following: `NOT_REQUIRED` (Cloud SQL instances
    /// can be connected without Cloud SQL
    /// Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL
    /// Connectors).
    ///
    /// Note that using REQUIRED disables all existing authorized networks. If
    /// this field is not specified when creating a new instance, NOT_REQUIRED is
    /// used. If this field is not specified when patching or updating an existing
    /// instance, it is left unchanged in the instance.
    pub connector_enforcement: crate::model::settings::ConnectorEnforcement,

    /// Configuration to protect against accidental instance deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection_enabled: std::option::Option<wkt::BoolValue>,

    /// Server timezone, relevant only for Cloud SQL for SQL Server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    /// Specifies advanced machine configuration for the instances relevant only
    /// for SQL Server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Configuration for data cache.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_cache_config: std::option::Option<crate::model::DataCacheConfig>,

    /// Optional. When this parameter is set to true, Cloud SQL instances can
    /// connect to Vertex AI to pass requests for real-time predictions and
    /// insights to the AI. The default value is false. This applies only to Cloud
    /// SQL for PostgreSQL instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_google_ml_integration: std::option::Option<wkt::BoolValue>,

    /// Optional. By default, Cloud SQL instances have schema extraction disabled
    /// for Dataplex. When this parameter is set to true, schema extraction for
    /// Dataplex on Cloud SQL instances is activated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_dataplex_integration: std::option::Option<wkt::BoolValue>,
}

impl Settings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings_version][crate::model::Settings::settings_version].
    pub fn set_settings_version<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.settings_version = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Settings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Settings::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::Settings::availability_type].
    pub fn set_availability_type<T: std::convert::Into<crate::model::SqlAvailabilityType>>(mut self, v: T) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [pricing_plan][crate::model::Settings::pricing_plan].
    pub fn set_pricing_plan<T: std::convert::Into<crate::model::SqlPricingPlan>>(mut self, v: T) -> Self {
        self.pricing_plan = v.into();
        self
    }

    /// Sets the value of [replication_type][crate::model::Settings::replication_type].
    pub fn set_replication_type<T: std::convert::Into<crate::model::SqlReplicationType>>(mut self, v: T) -> Self {
        self.replication_type = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::Settings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.storage_auto_resize_limit = v.into();
        self
    }

    /// Sets the value of [activation_policy][crate::model::Settings::activation_policy].
    pub fn set_activation_policy<T: std::convert::Into<crate::model::settings::SqlActivationPolicy>>(mut self, v: T) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_configuration][crate::model::Settings::ip_configuration].
    pub fn set_ip_configuration<T: std::convert::Into<std::option::Option<crate::model::IpConfiguration>>>(mut self, v: T) -> Self {
        self.ip_configuration = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize][crate::model::Settings::storage_auto_resize].
    pub fn set_storage_auto_resize<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.storage_auto_resize = v.into();
        self
    }

    /// Sets the value of [location_preference][crate::model::Settings::location_preference].
    pub fn set_location_preference<T: std::convert::Into<std::option::Option<crate::model::LocationPreference>>>(mut self, v: T) -> Self {
        self.location_preference = v.into();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::Settings::data_disk_type].
    pub fn set_data_disk_type<T: std::convert::Into<crate::model::SqlDataDiskType>>(mut self, v: T) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [maintenance_window][crate::model::Settings::maintenance_window].
    pub fn set_maintenance_window<T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>>(mut self, v: T) -> Self {
        self.maintenance_window = v.into();
        self
    }

    /// Sets the value of [backup_configuration][crate::model::Settings::backup_configuration].
    pub fn set_backup_configuration<T: std::convert::Into<std::option::Option<crate::model::BackupConfiguration>>>(mut self, v: T) -> Self {
        self.backup_configuration = v.into();
        self
    }

    /// Sets the value of [database_replication_enabled][crate::model::Settings::database_replication_enabled].
    pub fn set_database_replication_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.database_replication_enabled = v.into();
        self
    }

    /// Sets the value of [crash_safe_replication_enabled][crate::model::Settings::crash_safe_replication_enabled].
    pub fn set_crash_safe_replication_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.crash_safe_replication_enabled = v.into();
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::Settings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(mut self, v: T) -> Self {
        self.data_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [active_directory_config][crate::model::Settings::active_directory_config].
    pub fn set_active_directory_config<T: std::convert::Into<std::option::Option<crate::model::SqlActiveDirectoryConfig>>>(mut self, v: T) -> Self {
        self.active_directory_config = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Settings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [insights_config][crate::model::Settings::insights_config].
    pub fn set_insights_config<T: std::convert::Into<std::option::Option<crate::model::InsightsConfig>>>(mut self, v: T) -> Self {
        self.insights_config = v.into();
        self
    }

    /// Sets the value of [password_validation_policy][crate::model::Settings::password_validation_policy].
    pub fn set_password_validation_policy<T: std::convert::Into<std::option::Option<crate::model::PasswordValidationPolicy>>>(mut self, v: T) -> Self {
        self.password_validation_policy = v.into();
        self
    }

    /// Sets the value of [sql_server_audit_config][crate::model::Settings::sql_server_audit_config].
    pub fn set_sql_server_audit_config<T: std::convert::Into<std::option::Option<crate::model::SqlServerAuditConfig>>>(mut self, v: T) -> Self {
        self.sql_server_audit_config = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::Settings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::settings::Edition>>(mut self, v: T) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [connector_enforcement][crate::model::Settings::connector_enforcement].
    pub fn set_connector_enforcement<T: std::convert::Into<crate::model::settings::ConnectorEnforcement>>(mut self, v: T) -> Self {
        self.connector_enforcement = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Settings::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.deletion_protection_enabled = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::Settings::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::Settings::advanced_machine_features].
    pub fn set_advanced_machine_features<T: std::convert::Into<std::option::Option<crate::model::AdvancedMachineFeatures>>>(mut self, v: T) -> Self {
        self.advanced_machine_features = v.into();
        self
    }

    /// Sets the value of [data_cache_config][crate::model::Settings::data_cache_config].
    pub fn set_data_cache_config<T: std::convert::Into<std::option::Option<crate::model::DataCacheConfig>>>(mut self, v: T) -> Self {
        self.data_cache_config = v.into();
        self
    }

    /// Sets the value of [enable_google_ml_integration][crate::model::Settings::enable_google_ml_integration].
    pub fn set_enable_google_ml_integration<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_google_ml_integration = v.into();
        self
    }

    /// Sets the value of [enable_dataplex_integration][crate::model::Settings::enable_dataplex_integration].
    pub fn set_enable_dataplex_integration<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(mut self, v: T) -> Self {
        self.enable_dataplex_integration = v.into();
        self
    }

    /// Sets the value of [authorized_gae_applications][crate::model::Settings::authorized_gae_applications].
    pub fn set_authorized_gae_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.authorized_gae_applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [database_flags][crate::model::Settings::database_flags].
    pub fn set_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseFlags>
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny_maintenance_periods][crate::model::Settings::deny_maintenance_periods].
    pub fn set_deny_maintenance_periods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DenyMaintenancePeriod>
    {
        use std::iter::Iterator;
        self.deny_maintenance_periods = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::Settings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Settings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Settings"
    }
}

/// Defines additional types related to Settings
pub mod settings {
    #[allow(unused_imports)]
    use super::*;


    /// Specifies when the instance is activated.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlActivationPolicy(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlActivationPolicy](SqlActivationPolicy)
    pub mod sql_activation_policy {
        use super::SqlActivationPolicy;
        

        /// Unknown activation plan.
        pub const SQL_ACTIVATION_POLICY_UNSPECIFIED: SqlActivationPolicy = SqlActivationPolicy::known("SQL_ACTIVATION_POLICY_UNSPECIFIED", 0);

        /// The instance is always up and running.
        pub const ALWAYS: SqlActivationPolicy = SqlActivationPolicy::known("ALWAYS", 1);

        /// The instance never starts.
        pub const NEVER: SqlActivationPolicy = SqlActivationPolicy::known("NEVER", 2);

        /// The instance starts upon receiving requests.
        pub const ON_DEMAND: SqlActivationPolicy = SqlActivationPolicy::known("ON_DEMAND", 3);
    }

    impl SqlActivationPolicy {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlActivationPolicy::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlActivationPolicy::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlActivationPolicy::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlActivationPolicy {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => sql_activation_policy::SQL_ACTIVATION_POLICY_UNSPECIFIED,
                "ALWAYS" => sql_activation_policy::ALWAYS,
                "NEVER" => sql_activation_policy::NEVER,
                "ON_DEMAND" => sql_activation_policy::ON_DEMAND,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_activation_policy::SQL_ACTIVATION_POLICY_UNSPECIFIED,
                1 => sql_activation_policy::ALWAYS,
                2 => sql_activation_policy::NEVER,
                3 => sql_activation_policy::ON_DEMAND,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Edition(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Edition](Edition)
    pub mod edition {
        use super::Edition;
        

        /// The instance did not specify the edition.
        pub const EDITION_UNSPECIFIED: Edition = Edition::known("EDITION_UNSPECIFIED", 0);

        /// The instance is an enterprise edition.
        pub const ENTERPRISE: Edition = Edition::known("ENTERPRISE", 2);

        /// The instance is an Enterprise Plus edition.
        pub const ENTERPRISE_PLUS: Edition = Edition::known("ENTERPRISE_PLUS", 3);
    }

    impl Edition {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Edition::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Edition::from(val)),
                Enumeration::UnknownNum { str } => Ok(Edition::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Edition {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "EDITION_UNSPECIFIED" => edition::EDITION_UNSPECIFIED,
                "ENTERPRISE" => edition::ENTERPRISE,
                "ENTERPRISE_PLUS" => edition::ENTERPRISE_PLUS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => edition::EDITION_UNSPECIFIED,
                2 => edition::ENTERPRISE,
                3 => edition::ENTERPRISE_PLUS,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The options for enforcing Cloud SQL connectors in the instance.
    #[derive(Clone, Debug, PartialEq)]
    pub struct ConnectorEnforcement(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ConnectorEnforcement](ConnectorEnforcement)
    pub mod connector_enforcement {
        use super::ConnectorEnforcement;
        

        /// The requirement for Cloud SQL connectors is unknown.
        pub const CONNECTOR_ENFORCEMENT_UNSPECIFIED: ConnectorEnforcement = ConnectorEnforcement::known("CONNECTOR_ENFORCEMENT_UNSPECIFIED", 0);

        /// Do not require Cloud SQL connectors.
        pub const NOT_REQUIRED: ConnectorEnforcement = ConnectorEnforcement::known("NOT_REQUIRED", 1);

        /// Require all connections to use Cloud SQL connectors, including the
        /// Cloud SQL Auth Proxy and Cloud SQL Java, Python, and Go connectors.
        /// Note: This disables all existing authorized networks.
        pub const REQUIRED: ConnectorEnforcement = ConnectorEnforcement::known("REQUIRED", 2);
    }

    impl ConnectorEnforcement {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ConnectorEnforcement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectorEnforcement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ConnectorEnforcement::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ConnectorEnforcement::from(val)),
                Enumeration::UnknownNum { str } => Ok(ConnectorEnforcement::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ConnectorEnforcement {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "CONNECTOR_ENFORCEMENT_UNSPECIFIED" => connector_enforcement::CONNECTOR_ENFORCEMENT_UNSPECIFIED,
                "NOT_REQUIRED" => connector_enforcement::NOT_REQUIRED,
                "REQUIRED" => connector_enforcement::REQUIRED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ConnectorEnforcement {
        fn from(value: i32) -> Self {
            match value {
                0 => connector_enforcement::CONNECTOR_ENFORCEMENT_UNSPECIFIED,
                1 => connector_enforcement::NOT_REQUIRED,
                2 => connector_enforcement::REQUIRED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ConnectorEnforcement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Specifies options for controlling advanced machine features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {

    /// The number of threads per physical core.
    pub threads_per_core: i32,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.threads_per_core = v.into();
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AdvancedMachineFeatures"
    }
}

/// SslCerts Resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCert {

    /// This is always `sql#sslCert`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// Serial number, as extracted from the certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert_serial_number: std::string::String,

    /// PEM representation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert: std::string::String,

    /// The time when the certificate was created in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// User supplied name.  Constrained to [a-zA-Z.-_ ]+.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub common_name: std::string::String,

    /// The time when the certificate expires in [RFC
    /// 3339](https://tools.ietf.org/html/rfc3339) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// Sha1 Fingerprint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,

    /// Name of the database instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The URI of this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub self_link: std::string::String,
}

impl SslCert {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCert::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [cert_serial_number][crate::model::SslCert::cert_serial_number].
    pub fn set_cert_serial_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert_serial_number = v.into();
        self
    }

    /// Sets the value of [cert][crate::model::SslCert::cert].
    pub fn set_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SslCert::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [common_name][crate::model::SslCert::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::SslCert::expiration_time].
    pub fn set_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.expiration_time = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SslCert::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SslCert::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::SslCert::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }
}

impl wkt::message::Message for SslCert {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCert"
    }
}

/// SslCertDetail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertDetail {

    /// The public information about the cert.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cert_info: std::option::Option<crate::model::SslCert>,

    /// The private key for the client cert, in pem format.  Keep private in order
    /// to protect your security.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cert_private_key: std::string::String,
}

impl SslCertDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cert_info][crate::model::SslCertDetail::cert_info].
    pub fn set_cert_info<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.cert_info = v.into();
        self
    }

    /// Sets the value of [cert_private_key][crate::model::SslCertDetail::cert_private_key].
    pub fn set_cert_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cert_private_key = v.into();
        self
    }
}

impl wkt::message::Message for SslCertDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertDetail"
    }
}

/// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlActiveDirectoryConfig {

    /// This is always sql#activeDirectoryConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The name of the domain (e.g., mydomain.com).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain: std::string::String,
}

impl SqlActiveDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlActiveDirectoryConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::SqlActiveDirectoryConfig::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for SqlActiveDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlActiveDirectoryConfig"
    }
}

/// SQL Server specific audit configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerAuditConfig {

    /// This is always sql#sqlServerAuditConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The name of the destination bucket (e.g., gs://mybucket).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// How long to keep generated audit files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention_interval: std::option::Option<wkt::Duration>,

    /// How often to upload generated audit files.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upload_interval: std::option::Option<wkt::Duration>,
}

impl SqlServerAuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SqlServerAuditConfig::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::SqlServerAuditConfig::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [retention_interval][crate::model::SqlServerAuditConfig::retention_interval].
    pub fn set_retention_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.retention_interval = v.into();
        self
    }

    /// Sets the value of [upload_interval][crate::model::SqlServerAuditConfig::upload_interval].
    pub fn set_upload_interval<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.upload_interval = v.into();
        self
    }
}

impl wkt::message::Message for SqlServerAuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerAuditConfig"
    }
}

/// Acquire SSRS lease context.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcquireSsrsLeaseContext {

    /// The username to be used as the setup login to connect to the database
    /// server for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub setup_login: std::option::Option<std::string::String>,

    /// The username to be used as the service login to connect to the report
    /// database for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_login: std::option::Option<std::string::String>,

    /// The report database to be used for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_database: std::option::Option<std::string::String>,

    /// Lease duration needed for SSRS setup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,
}

impl AcquireSsrsLeaseContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [setup_login][crate::model::AcquireSsrsLeaseContext::setup_login].
    pub fn set_setup_login<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.setup_login = v.into();
        self
    }

    /// Sets the value of [service_login][crate::model::AcquireSsrsLeaseContext::service_login].
    pub fn set_service_login<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.service_login = v.into();
        self
    }

    /// Sets the value of [report_database][crate::model::AcquireSsrsLeaseContext::report_database].
    pub fn set_report_database<T: std::convert::Into<std::option::Option<std::string::String>>>(mut self, v: T) -> Self {
        self.report_database = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::AcquireSsrsLeaseContext::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.duration = v.into();
        self
    }
}

impl wkt::message::Message for AcquireSsrsLeaseContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.AcquireSsrsLeaseContext"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsDeleteRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,
}

impl SqlSslCertsDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsDeleteRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsDeleteRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsGetRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Sha1 FingerPrint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sha1_fingerprint: std::string::String,
}

impl SqlSslCertsGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [sha1_fingerprint][crate::model::SqlSslCertsGetRequest::sha1_fingerprint].
    pub fn set_sha1_fingerprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha1_fingerprint = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsGetRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsInsertRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::SslCertsInsertRequest>,
}

impl SqlSslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlSslCertsInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::SslCertsInsertRequest>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsInsertRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlSslCertsListRequest {

    /// Cloud SQL instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlSslCertsListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlSslCertsListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlSslCertsListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlSslCertsListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlSslCertsListRequest"
    }
}

/// SslCerts insert request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsInsertRequest {

    /// User supplied name.  Must be a distinct name from the other certificates
    /// for this instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub common_name: std::string::String,
}

impl SslCertsInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_name][crate::model::SslCertsInsertRequest::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertRequest"
    }
}

/// SslCert insert response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsInsertResponse {

    /// This is always `sql#sslCertsInsert`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The operation to track the ssl certs insert request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::Operation>,

    /// The server Certificate Authority's certificate.  If this is missing you can
    /// force a new one to be generated by calling resetSslConfig method on
    /// instances resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca_cert: std::option::Option<crate::model::SslCert>,

    /// The new client certificate and private key.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_cert: std::option::Option<crate::model::SslCertDetail>,
}

impl SslCertsInsertResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsInsertResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::SslCertsInsertResponse::operation].
    pub fn set_operation<T: std::convert::Into<std::option::Option<crate::model::Operation>>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [server_ca_cert][crate::model::SslCertsInsertResponse::server_ca_cert].
    pub fn set_server_ca_cert<T: std::convert::Into<std::option::Option<crate::model::SslCert>>>(mut self, v: T) -> Self {
        self.server_ca_cert = v.into();
        self
    }

    /// Sets the value of [client_cert][crate::model::SslCertsInsertResponse::client_cert].
    pub fn set_client_cert<T: std::convert::Into<std::option::Option<crate::model::SslCertDetail>>>(mut self, v: T) -> Self {
        self.client_cert = v.into();
        self
    }
}

impl wkt::message::Message for SslCertsInsertResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsInsertResponse"
    }
}

/// SslCerts list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslCertsListResponse {

    /// This is always `sql#sslCertsList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of client certificates for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::SslCert>,
}

impl SslCertsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::SslCertsListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::SslCertsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SslCert>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SslCertsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SslCertsListResponse"
    }
}

/// Tiers list request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlTiersListRequest {

    /// Project ID of the project for which to list tiers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlTiersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::SqlTiersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlTiersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlTiersListRequest"
    }
}

/// Tiers list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TiersListResponse {

    /// This is always `sql#tiersList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of tiers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::Tier>,
}

impl TiersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::TiersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [items][crate::model::TiersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tier>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TiersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.TiersListResponse"
    }
}

/// A Google Cloud SQL service tier resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Tier {

    /// An identifier for the machine type, for example, `db-custom-1-3840`. For
    /// related information, see [Pricing](/sql/pricing).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// The maximum RAM usage of this tier in bytes.
    #[serde(rename = "RAM")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub ram: i64,

    /// This is always `sql#tier`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The maximum disk size of this tier in bytes.
    #[serde(rename = "DiskQuota")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_quota: i64,

    /// The applicable regions for this tier.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub region: std::vec::Vec<std::string::String>,
}

impl Tier {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tier][crate::model::Tier::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [ram][crate::model::Tier::ram].
    pub fn set_ram<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ram = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Tier::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [disk_quota][crate::model::Tier::disk_quota].
    pub fn set_disk_quota<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_quota = v.into();
        self
    }

    /// Sets the value of [region][crate::model::Tier::region].
    pub fn set_region<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.region = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Tier {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.Tier"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersDeleteRequest {

    /// Host of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Name of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlUsersDeleteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersDeleteRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersDeleteRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersDeleteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersDeleteRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersDeleteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersDeleteRequest"
    }
}

/// Request message for Users Get RPC
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersGetRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// User of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Host of a user of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,
}

impl SqlUsersGetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersGetRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersGetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersGetRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [host][crate::model::SqlUsersGetRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersGetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersGetRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersInsertRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::User>,
}

impl SqlUsersInsertRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersInsertRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersInsertRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersInsertRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::User>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersInsertRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersInsertRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersListRequest {

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,
}

impl SqlUsersListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::SqlUsersListRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersListRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersListRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlUsersUpdateRequest {

    /// Optional. Host of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Database instance ID. This does not include the project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Name of the user in the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Project ID of the project that contains the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub body: std::option::Option<crate::model::User>,
}

impl SqlUsersUpdateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::SqlUsersUpdateRequest::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::SqlUsersUpdateRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SqlUsersUpdateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SqlUsersUpdateRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [body][crate::model::SqlUsersUpdateRequest::body].
    pub fn set_body<T: std::convert::Into<std::option::Option<crate::model::User>>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for SqlUsersUpdateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlUsersUpdateRequest"
    }
}

/// User level password validation policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserPasswordValidationPolicy {

    /// Number of failed login attempts allowed before user get locked.
    pub allowed_failed_attempts: i32,

    /// Expiration duration after password is updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_expiration_duration: std::option::Option<wkt::Duration>,

    /// If true, failed login attempts check will be enabled.
    pub enable_failed_attempts_check: bool,

    /// Output only. Read-only password status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::PasswordStatus>,

    /// If true, the user must specify the current password before changing the
    /// password. This flag is supported only for MySQL.
    pub enable_password_verification: bool,
}

impl UserPasswordValidationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed_failed_attempts][crate::model::UserPasswordValidationPolicy::allowed_failed_attempts].
    pub fn set_allowed_failed_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.allowed_failed_attempts = v.into();
        self
    }

    /// Sets the value of [password_expiration_duration][crate::model::UserPasswordValidationPolicy::password_expiration_duration].
    pub fn set_password_expiration_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(mut self, v: T) -> Self {
        self.password_expiration_duration = v.into();
        self
    }

    /// Sets the value of [enable_failed_attempts_check][crate::model::UserPasswordValidationPolicy::enable_failed_attempts_check].
    pub fn set_enable_failed_attempts_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_failed_attempts_check = v.into();
        self
    }

    /// Sets the value of [status][crate::model::UserPasswordValidationPolicy::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::PasswordStatus>>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [enable_password_verification][crate::model::UserPasswordValidationPolicy::enable_password_verification].
    pub fn set_enable_password_verification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_password_verification = v.into();
        self
    }
}

impl wkt::message::Message for UserPasswordValidationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UserPasswordValidationPolicy"
    }
}

/// Read-only password status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PasswordStatus {

    /// If true, user does not have login privileges.
    pub locked: bool,

    /// The expiration time of the current password.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_expiration_time: std::option::Option<wkt::Timestamp>,
}

impl PasswordStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locked][crate::model::PasswordStatus::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [password_expiration_time][crate::model::PasswordStatus::password_expiration_time].
    pub fn set_password_expiration_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(mut self, v: T) -> Self {
        self.password_expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for PasswordStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.PasswordStatus"
    }
}

/// A Cloud SQL user resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct User {

    /// This is always `sql#user`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// The password for the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// The name of the user in the Cloud SQL instance. Can be omitted for
    /// `update` because it is already specified in the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The host from which the user can connect. For `insert`
    /// operations, host defaults to an empty string. For `update`
    /// operations, host is specified as part of the request URL. The host name
    /// cannot be updated after insertion.  For a MySQL instance, it's required;
    /// for a PostgreSQL or SQL Server instance, it's optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// The name of the Cloud SQL instance. This does not include the project ID.
    /// Can be omitted for `update` because it is already specified on the
    /// URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable. Can be omitted for `update` because
    /// it is already specified on the URL.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The user type. It determines the method to authenticate the user during
    /// login. The default is the database's built-in user type.
    #[serde(rename = "type")]
    pub r#type: crate::model::user::SqlUserType,

    /// User level password validation policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub password_policy: std::option::Option<crate::model::UserPasswordValidationPolicy>,

    /// Dual password status for the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dual_password_type: std::option::Option<crate::model::user::DualPasswordType>,

    /// User details for specific database type
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub user_details: std::option::Option<crate::model::user::UserDetails>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::User::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::User::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [host][crate::model::User::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::User::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [project][crate::model::User::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::User::type].
    pub fn set_type<T: std::convert::Into<crate::model::user::SqlUserType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [password_policy][crate::model::User::password_policy].
    pub fn set_password_policy<T: std::convert::Into<std::option::Option<crate::model::UserPasswordValidationPolicy>>>(mut self, v: T) -> Self {
        self.password_policy = v.into();
        self
    }

    /// Sets the value of [dual_password_type][crate::model::User::dual_password_type].
    pub fn set_dual_password_type<T: std::convert::Into<std::option::Option<crate::model::user::DualPasswordType>>>(mut self, v: T) -> Self {
        self.dual_password_type = v.into();
        self
    }

    /// Sets the value of `user_details`.
    pub fn set_user_details<T: std::convert::Into<std::option::Option<crate::model::user::UserDetails>>>(mut self, v: T) -> Self
    {
        self.user_details = v.into();
        self
    }

    /// The value of [user_details][crate::model::User::user_details]
    /// if it holds a `SqlserverUserDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sqlserver_user_details(&self) -> std::option::Option<&std::boxed::Box<crate::model::SqlServerUserDetails>> {
        #[allow(unreachable_patterns)]
        self.user_details.as_ref().and_then(|v| match v {
            crate::model::user::UserDetails::SqlserverUserDetails(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_details][crate::model::User::user_details]
    /// to hold a `SqlserverUserDetails`.
    ///
    /// Note that all the setters affecting `user_details` are
    /// mutually exclusive.
    pub fn set_sqlserver_user_details<T: std::convert::Into<std::boxed::Box<crate::model::SqlServerUserDetails>>>(mut self, v: T) -> Self {
        self.user_details = std::option::Option::Some(
            crate::model::user::UserDetails::SqlserverUserDetails(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.User"
    }
}

/// Defines additional types related to User
pub mod user {
    #[allow(unused_imports)]
    use super::*;


    /// The user type.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SqlUserType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [SqlUserType](SqlUserType)
    pub mod sql_user_type {
        use super::SqlUserType;
        

        /// The database's built-in user type.
        pub const BUILT_IN: SqlUserType = SqlUserType::known("BUILT_IN", 0);

        /// Cloud IAM user.
        pub const CLOUD_IAM_USER: SqlUserType = SqlUserType::known("CLOUD_IAM_USER", 1);

        /// Cloud IAM service account.
        pub const CLOUD_IAM_SERVICE_ACCOUNT: SqlUserType = SqlUserType::known("CLOUD_IAM_SERVICE_ACCOUNT", 2);

        /// Cloud IAM group non-login user.
        pub const CLOUD_IAM_GROUP: SqlUserType = SqlUserType::known("CLOUD_IAM_GROUP", 3);

        /// Cloud IAM group login user.
        pub const CLOUD_IAM_GROUP_USER: SqlUserType = SqlUserType::known("CLOUD_IAM_GROUP_USER", 4);

        /// Cloud IAM group login service account.
        pub const CLOUD_IAM_GROUP_SERVICE_ACCOUNT: SqlUserType = SqlUserType::known("CLOUD_IAM_GROUP_SERVICE_ACCOUNT", 5);
    }

    impl SqlUserType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for SqlUserType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlUserType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(SqlUserType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(SqlUserType::from(val)),
                Enumeration::UnknownNum { str } => Ok(SqlUserType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for SqlUserType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "BUILT_IN" => sql_user_type::BUILT_IN,
                "CLOUD_IAM_USER" => sql_user_type::CLOUD_IAM_USER,
                "CLOUD_IAM_SERVICE_ACCOUNT" => sql_user_type::CLOUD_IAM_SERVICE_ACCOUNT,
                "CLOUD_IAM_GROUP" => sql_user_type::CLOUD_IAM_GROUP,
                "CLOUD_IAM_GROUP_USER" => sql_user_type::CLOUD_IAM_GROUP_USER,
                "CLOUD_IAM_GROUP_SERVICE_ACCOUNT" => sql_user_type::CLOUD_IAM_GROUP_SERVICE_ACCOUNT,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for SqlUserType {
        fn from(value: i32) -> Self {
            match value {
                0 => sql_user_type::BUILT_IN,
                1 => sql_user_type::CLOUD_IAM_USER,
                2 => sql_user_type::CLOUD_IAM_SERVICE_ACCOUNT,
                3 => sql_user_type::CLOUD_IAM_GROUP,
                4 => sql_user_type::CLOUD_IAM_GROUP_USER,
                5 => sql_user_type::CLOUD_IAM_GROUP_SERVICE_ACCOUNT,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for SqlUserType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The type of retained password.
    #[derive(Clone, Debug, PartialEq)]
    pub struct DualPasswordType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [DualPasswordType](DualPasswordType)
    pub mod dual_password_type {
        use super::DualPasswordType;
        

        /// The default value.
        pub const DUAL_PASSWORD_TYPE_UNSPECIFIED: DualPasswordType = DualPasswordType::known("DUAL_PASSWORD_TYPE_UNSPECIFIED", 0);

        /// Do not update the user's dual password status.
        pub const NO_MODIFY_DUAL_PASSWORD: DualPasswordType = DualPasswordType::known("NO_MODIFY_DUAL_PASSWORD", 1);

        /// No dual password usable for connecting using this user.
        pub const NO_DUAL_PASSWORD: DualPasswordType = DualPasswordType::known("NO_DUAL_PASSWORD", 2);

        /// Dual password usable for connecting using this user.
        pub const DUAL_PASSWORD: DualPasswordType = DualPasswordType::known("DUAL_PASSWORD", 3);
    }

    impl DualPasswordType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for DualPasswordType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DualPasswordType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(DualPasswordType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(DualPasswordType::from(val)),
                Enumeration::UnknownNum { str } => Ok(DualPasswordType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for DualPasswordType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "DUAL_PASSWORD_TYPE_UNSPECIFIED" => dual_password_type::DUAL_PASSWORD_TYPE_UNSPECIFIED,
                "NO_MODIFY_DUAL_PASSWORD" => dual_password_type::NO_MODIFY_DUAL_PASSWORD,
                "NO_DUAL_PASSWORD" => dual_password_type::NO_DUAL_PASSWORD,
                "DUAL_PASSWORD" => dual_password_type::DUAL_PASSWORD,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for DualPasswordType {
        fn from(value: i32) -> Self {
            match value {
                0 => dual_password_type::DUAL_PASSWORD_TYPE_UNSPECIFIED,
                1 => dual_password_type::NO_MODIFY_DUAL_PASSWORD,
                2 => dual_password_type::NO_DUAL_PASSWORD,
                3 => dual_password_type::DUAL_PASSWORD,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for DualPasswordType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// User details for specific database type
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum UserDetails {
        SqlserverUserDetails(std::boxed::Box<crate::model::SqlServerUserDetails>),
    }
}

/// Represents a Sql Server user on the Cloud SQL instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlServerUserDetails {

    /// If the user has been disabled
    pub disabled: bool,

    /// The server roles for this user
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub server_roles: std::vec::Vec<std::string::String>,
}

impl SqlServerUserDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::SqlServerUserDetails::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [server_roles][crate::model::SqlServerUserDetails::server_roles].
    pub fn set_server_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.server_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlServerUserDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.SqlServerUserDetails"
    }
}

/// User list response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsersListResponse {

    /// This is always `sql#usersList`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    /// List of user resources in the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::User>,

    /// Unused.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl UsersListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::UsersListResponse::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::UsersListResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [items][crate::model::UsersListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UsersListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.sql.v1.UsersListResponse"
    }
}

/// The status of a backup run.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlBackupRunStatus(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlBackupRunStatus](SqlBackupRunStatus)
pub mod sql_backup_run_status {
    use super::SqlBackupRunStatus;
    

    /// The status of the run is unknown.
    pub const SQL_BACKUP_RUN_STATUS_UNSPECIFIED: SqlBackupRunStatus = SqlBackupRunStatus::known("SQL_BACKUP_RUN_STATUS_UNSPECIFIED", 0);

    /// The backup operation was enqueued.
    pub const ENQUEUED: SqlBackupRunStatus = SqlBackupRunStatus::known("ENQUEUED", 1);

    /// The backup is overdue across a given backup window. Indicates a
    /// problem. Example: Long-running operation in progress during
    /// the whole window.
    pub const OVERDUE: SqlBackupRunStatus = SqlBackupRunStatus::known("OVERDUE", 2);

    /// The backup is in progress.
    pub const RUNNING: SqlBackupRunStatus = SqlBackupRunStatus::known("RUNNING", 3);

    /// The backup failed.
    pub const FAILED: SqlBackupRunStatus = SqlBackupRunStatus::known("FAILED", 4);

    /// The backup was successful.
    pub const SUCCESSFUL: SqlBackupRunStatus = SqlBackupRunStatus::known("SUCCESSFUL", 5);

    /// The backup was skipped (without problems) for a given backup
    /// window. Example: Instance was idle.
    pub const SKIPPED: SqlBackupRunStatus = SqlBackupRunStatus::known("SKIPPED", 6);

    /// The backup is about to be deleted.
    pub const DELETION_PENDING: SqlBackupRunStatus = SqlBackupRunStatus::known("DELETION_PENDING", 7);

    /// The backup deletion failed.
    pub const DELETION_FAILED: SqlBackupRunStatus = SqlBackupRunStatus::known("DELETION_FAILED", 8);

    /// The backup has been deleted.
    pub const DELETED: SqlBackupRunStatus = SqlBackupRunStatus::known("DELETED", 9);
}

impl SqlBackupRunStatus {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlBackupRunStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlBackupRunStatus::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlBackupRunStatus::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlBackupRunStatus::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlBackupRunStatus {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_BACKUP_RUN_STATUS_UNSPECIFIED" => sql_backup_run_status::SQL_BACKUP_RUN_STATUS_UNSPECIFIED,
            "ENQUEUED" => sql_backup_run_status::ENQUEUED,
            "OVERDUE" => sql_backup_run_status::OVERDUE,
            "RUNNING" => sql_backup_run_status::RUNNING,
            "FAILED" => sql_backup_run_status::FAILED,
            "SUCCESSFUL" => sql_backup_run_status::SUCCESSFUL,
            "SKIPPED" => sql_backup_run_status::SKIPPED,
            "DELETION_PENDING" => sql_backup_run_status::DELETION_PENDING,
            "DELETION_FAILED" => sql_backup_run_status::DELETION_FAILED,
            "DELETED" => sql_backup_run_status::DELETED,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlBackupRunStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_backup_run_status::SQL_BACKUP_RUN_STATUS_UNSPECIFIED,
            1 => sql_backup_run_status::ENQUEUED,
            2 => sql_backup_run_status::OVERDUE,
            3 => sql_backup_run_status::RUNNING,
            4 => sql_backup_run_status::FAILED,
            5 => sql_backup_run_status::SUCCESSFUL,
            6 => sql_backup_run_status::SKIPPED,
            7 => sql_backup_run_status::DELETION_PENDING,
            8 => sql_backup_run_status::DELETION_FAILED,
            9 => sql_backup_run_status::DELETED,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlBackupRunStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Defines the supported backup kinds.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlBackupKind(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlBackupKind](SqlBackupKind)
pub mod sql_backup_kind {
    use super::SqlBackupKind;
    

    /// This is an unknown BackupKind.
    pub const SQL_BACKUP_KIND_UNSPECIFIED: SqlBackupKind = SqlBackupKind::known("SQL_BACKUP_KIND_UNSPECIFIED", 0);

    /// The snapshot based backups
    pub const SNAPSHOT: SqlBackupKind = SqlBackupKind::known("SNAPSHOT", 1);

    /// Physical backups
    pub const PHYSICAL: SqlBackupKind = SqlBackupKind::known("PHYSICAL", 2);
}

impl SqlBackupKind {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlBackupKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlBackupKind::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlBackupKind::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlBackupKind::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlBackupKind {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_BACKUP_KIND_UNSPECIFIED" => sql_backup_kind::SQL_BACKUP_KIND_UNSPECIFIED,
            "SNAPSHOT" => sql_backup_kind::SNAPSHOT,
            "PHYSICAL" => sql_backup_kind::PHYSICAL,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlBackupKind {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_backup_kind::SQL_BACKUP_KIND_UNSPECIFIED,
            1 => sql_backup_kind::SNAPSHOT,
            2 => sql_backup_kind::PHYSICAL,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlBackupKind {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Type of backup (i.e. automated, on demand, etc).
#[derive(Clone, Debug, PartialEq)]
pub struct SqlBackupRunType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlBackupRunType](SqlBackupRunType)
pub mod sql_backup_run_type {
    use super::SqlBackupRunType;
    

    /// This is an unknown BackupRun type.
    pub const SQL_BACKUP_RUN_TYPE_UNSPECIFIED: SqlBackupRunType = SqlBackupRunType::known("SQL_BACKUP_RUN_TYPE_UNSPECIFIED", 0);

    /// The backup schedule automatically triggers a backup.
    pub const AUTOMATED: SqlBackupRunType = SqlBackupRunType::known("AUTOMATED", 1);

    /// The user manually triggers a backup.
    pub const ON_DEMAND: SqlBackupRunType = SqlBackupRunType::known("ON_DEMAND", 2);
}

impl SqlBackupRunType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlBackupRunType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackupRunType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlBackupRunType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlBackupRunType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlBackupRunType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlBackupRunType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_BACKUP_RUN_TYPE_UNSPECIFIED" => sql_backup_run_type::SQL_BACKUP_RUN_TYPE_UNSPECIFIED,
            "AUTOMATED" => sql_backup_run_type::AUTOMATED,
            "ON_DEMAND" => sql_backup_run_type::ON_DEMAND,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlBackupRunType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_backup_run_type::SQL_BACKUP_RUN_TYPE_UNSPECIFIED,
            1 => sql_backup_run_type::AUTOMATED,
            2 => sql_backup_run_type::ON_DEMAND,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlBackupRunType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlFlagType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlFlagType](SqlFlagType)
pub mod sql_flag_type {
    use super::SqlFlagType;
    

    /// This is an unknown flag type.
    pub const SQL_FLAG_TYPE_UNSPECIFIED: SqlFlagType = SqlFlagType::known("SQL_FLAG_TYPE_UNSPECIFIED", 0);

    /// Boolean type flag.
    pub const BOOLEAN: SqlFlagType = SqlFlagType::known("BOOLEAN", 1);

    /// String type flag.
    pub const STRING: SqlFlagType = SqlFlagType::known("STRING", 2);

    /// Integer type flag.
    pub const INTEGER: SqlFlagType = SqlFlagType::known("INTEGER", 3);

    /// Flag type used for a server startup option.
    pub const NONE: SqlFlagType = SqlFlagType::known("NONE", 4);

    /// Type introduced specially for MySQL TimeZone offset. Accept a string value
    /// with the format [-12:59, 13:00].
    pub const MYSQL_TIMEZONE_OFFSET: SqlFlagType = SqlFlagType::known("MYSQL_TIMEZONE_OFFSET", 5);

    /// Float type flag.
    pub const FLOAT: SqlFlagType = SqlFlagType::known("FLOAT", 6);

    /// Comma-separated list of the strings in a SqlFlagType enum.
    pub const REPEATED_STRING: SqlFlagType = SqlFlagType::known("REPEATED_STRING", 7);
}

impl SqlFlagType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlFlagType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFlagType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlFlagType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlFlagType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlFlagType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlFlagType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_FLAG_TYPE_UNSPECIFIED" => sql_flag_type::SQL_FLAG_TYPE_UNSPECIFIED,
            "BOOLEAN" => sql_flag_type::BOOLEAN,
            "STRING" => sql_flag_type::STRING,
            "INTEGER" => sql_flag_type::INTEGER,
            "NONE" => sql_flag_type::NONE,
            "MYSQL_TIMEZONE_OFFSET" => sql_flag_type::MYSQL_TIMEZONE_OFFSET,
            "FLOAT" => sql_flag_type::FLOAT,
            "REPEATED_STRING" => sql_flag_type::REPEATED_STRING,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlFlagType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_flag_type::SQL_FLAG_TYPE_UNSPECIFIED,
            1 => sql_flag_type::BOOLEAN,
            2 => sql_flag_type::STRING,
            3 => sql_flag_type::INTEGER,
            4 => sql_flag_type::NONE,
            5 => sql_flag_type::MYSQL_TIMEZONE_OFFSET,
            6 => sql_flag_type::FLOAT,
            7 => sql_flag_type::REPEATED_STRING,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlFlagType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// External Sync parallel level.
#[derive(Clone, Debug, PartialEq)]
pub struct ExternalSyncParallelLevel(wkt::enumerations::Enumeration);

/// Useful constants to work with [ExternalSyncParallelLevel](ExternalSyncParallelLevel)
pub mod external_sync_parallel_level {
    use super::ExternalSyncParallelLevel;
    

    /// Unknown sync parallel level. Will be defaulted to OPTIMAL.
    pub const EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED: ExternalSyncParallelLevel = ExternalSyncParallelLevel::known("EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED", 0);

    /// Minimal parallel level.
    pub const MIN: ExternalSyncParallelLevel = ExternalSyncParallelLevel::known("MIN", 1);

    /// Optimal parallel level.
    pub const OPTIMAL: ExternalSyncParallelLevel = ExternalSyncParallelLevel::known("OPTIMAL", 2);

    /// Maximum parallel level.
    pub const MAX: ExternalSyncParallelLevel = ExternalSyncParallelLevel::known("MAX", 3);
}

impl ExternalSyncParallelLevel {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for ExternalSyncParallelLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for ExternalSyncParallelLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(ExternalSyncParallelLevel::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(ExternalSyncParallelLevel::from(val)),
            Enumeration::UnknownNum { str } => Ok(ExternalSyncParallelLevel::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for ExternalSyncParallelLevel {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED" => external_sync_parallel_level::EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED,
            "MIN" => external_sync_parallel_level::MIN,
            "OPTIMAL" => external_sync_parallel_level::OPTIMAL,
            "MAX" => external_sync_parallel_level::MAX,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for ExternalSyncParallelLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => external_sync_parallel_level::EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED,
            1 => external_sync_parallel_level::MIN,
            2 => external_sync_parallel_level::OPTIMAL,
            3 => external_sync_parallel_level::MAX,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for ExternalSyncParallelLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlInstanceType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlInstanceType](SqlInstanceType)
pub mod sql_instance_type {
    use super::SqlInstanceType;
    

    /// This is an unknown Cloud SQL instance type.
    pub const SQL_INSTANCE_TYPE_UNSPECIFIED: SqlInstanceType = SqlInstanceType::known("SQL_INSTANCE_TYPE_UNSPECIFIED", 0);

    /// A regular Cloud SQL instance that is not replicating from a primary
    /// instance.
    pub const CLOUD_SQL_INSTANCE: SqlInstanceType = SqlInstanceType::known("CLOUD_SQL_INSTANCE", 1);

    /// An instance running on the customer's premises that is not managed by
    /// Cloud SQL.
    pub const ON_PREMISES_INSTANCE: SqlInstanceType = SqlInstanceType::known("ON_PREMISES_INSTANCE", 2);

    /// A Cloud SQL instance acting as a read-replica.
    pub const READ_REPLICA_INSTANCE: SqlInstanceType = SqlInstanceType::known("READ_REPLICA_INSTANCE", 3);
}

impl SqlInstanceType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlInstanceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlInstanceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlInstanceType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlInstanceType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlInstanceType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlInstanceType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_INSTANCE_TYPE_UNSPECIFIED" => sql_instance_type::SQL_INSTANCE_TYPE_UNSPECIFIED,
            "CLOUD_SQL_INSTANCE" => sql_instance_type::CLOUD_SQL_INSTANCE,
            "ON_PREMISES_INSTANCE" => sql_instance_type::ON_PREMISES_INSTANCE,
            "READ_REPLICA_INSTANCE" => sql_instance_type::READ_REPLICA_INSTANCE,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlInstanceType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_instance_type::SQL_INSTANCE_TYPE_UNSPECIFIED,
            1 => sql_instance_type::CLOUD_SQL_INSTANCE,
            2 => sql_instance_type::ON_PREMISES_INSTANCE,
            3 => sql_instance_type::READ_REPLICA_INSTANCE,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlInstanceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The suspension reason of the database instance if the state is SUSPENDED.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlSuspensionReason(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlSuspensionReason](SqlSuspensionReason)
pub mod sql_suspension_reason {
    use super::SqlSuspensionReason;
    

    /// This is an unknown suspension reason.
    pub const SQL_SUSPENSION_REASON_UNSPECIFIED: SqlSuspensionReason = SqlSuspensionReason::known("SQL_SUSPENSION_REASON_UNSPECIFIED", 0);

    /// The instance is suspended due to billing issues (for example:, GCP account
    /// issue)
    pub const BILLING_ISSUE: SqlSuspensionReason = SqlSuspensionReason::known("BILLING_ISSUE", 2);

    /// The instance is suspended due to illegal content (for example:, child
    /// pornography, copyrighted material, etc.).
    pub const LEGAL_ISSUE: SqlSuspensionReason = SqlSuspensionReason::known("LEGAL_ISSUE", 3);

    /// The instance is causing operational issues (for example:, causing the
    /// database to crash).
    pub const OPERATIONAL_ISSUE: SqlSuspensionReason = SqlSuspensionReason::known("OPERATIONAL_ISSUE", 4);

    /// The KMS key used by the instance is either revoked or denied access to
    pub const KMS_KEY_ISSUE: SqlSuspensionReason = SqlSuspensionReason::known("KMS_KEY_ISSUE", 5);
}

impl SqlSuspensionReason {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlSuspensionReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlSuspensionReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlSuspensionReason::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlSuspensionReason::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlSuspensionReason::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlSuspensionReason {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_SUSPENSION_REASON_UNSPECIFIED" => sql_suspension_reason::SQL_SUSPENSION_REASON_UNSPECIFIED,
            "BILLING_ISSUE" => sql_suspension_reason::BILLING_ISSUE,
            "LEGAL_ISSUE" => sql_suspension_reason::LEGAL_ISSUE,
            "OPERATIONAL_ISSUE" => sql_suspension_reason::OPERATIONAL_ISSUE,
            "KMS_KEY_ISSUE" => sql_suspension_reason::KMS_KEY_ISSUE,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlSuspensionReason {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_suspension_reason::SQL_SUSPENSION_REASON_UNSPECIFIED,
            2 => sql_suspension_reason::BILLING_ISSUE,
            3 => sql_suspension_reason::LEGAL_ISSUE,
            4 => sql_suspension_reason::OPERATIONAL_ISSUE,
            5 => sql_suspension_reason::KMS_KEY_ISSUE,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlSuspensionReason {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlFileType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlFileType](SqlFileType)
pub mod sql_file_type {
    use super::SqlFileType;
    

    /// Unknown file type.
    pub const SQL_FILE_TYPE_UNSPECIFIED: SqlFileType = SqlFileType::known("SQL_FILE_TYPE_UNSPECIFIED", 0);

    /// File containing SQL statements.
    pub const SQL: SqlFileType = SqlFileType::known("SQL", 1);

    /// File in CSV format.
    pub const CSV: SqlFileType = SqlFileType::known("CSV", 2);

    pub const BAK: SqlFileType = SqlFileType::known("BAK", 4);
}

impl SqlFileType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlFileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlFileType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlFileType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlFileType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlFileType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlFileType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_FILE_TYPE_UNSPECIFIED" => sql_file_type::SQL_FILE_TYPE_UNSPECIFIED,
            "SQL" => sql_file_type::SQL,
            "CSV" => sql_file_type::CSV,
            "BAK" => sql_file_type::BAK,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlFileType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_file_type::SQL_FILE_TYPE_UNSPECIFIED,
            1 => sql_file_type::SQL,
            2 => sql_file_type::CSV,
            4 => sql_file_type::BAK,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlFileType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct BakType(wkt::enumerations::Enumeration);

/// Useful constants to work with [BakType](BakType)
pub mod bak_type {
    use super::BakType;
    

    /// Default type.
    pub const BAK_TYPE_UNSPECIFIED: BakType = BakType::known("BAK_TYPE_UNSPECIFIED", 0);

    /// Full backup.
    pub const FULL: BakType = BakType::known("FULL", 1);

    /// Differential backup.
    pub const DIFF: BakType = BakType::known("DIFF", 2);

    /// Transaction Log backup
    pub const TLOG: BakType = BakType::known("TLOG", 3);
}

impl BakType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for BakType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for BakType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(BakType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(BakType::from(val)),
            Enumeration::UnknownNum { str } => Ok(BakType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for BakType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "BAK_TYPE_UNSPECIFIED" => bak_type::BAK_TYPE_UNSPECIFIED,
            "FULL" => bak_type::FULL,
            "DIFF" => bak_type::DIFF,
            "TLOG" => bak_type::TLOG,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for BakType {
    fn from(value: i32) -> Self {
        match value {
            0 => bak_type::BAK_TYPE_UNSPECIFIED,
            1 => bak_type::FULL,
            2 => bak_type::DIFF,
            3 => bak_type::TLOG,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for BakType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlBackendType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlBackendType](SqlBackendType)
pub mod sql_backend_type {
    use super::SqlBackendType;
    

    /// This is an unknown backend type for instance.
    pub const SQL_BACKEND_TYPE_UNSPECIFIED: SqlBackendType = SqlBackendType::known("SQL_BACKEND_TYPE_UNSPECIFIED", 0);

    /// V1 speckle instance.
    pub const FIRST_GEN: SqlBackendType = SqlBackendType::known("FIRST_GEN", 1);

    /// V2 speckle instance.
    pub const SECOND_GEN: SqlBackendType = SqlBackendType::known("SECOND_GEN", 2);

    /// On premises instance.
    pub const EXTERNAL: SqlBackendType = SqlBackendType::known("EXTERNAL", 3);
}

impl SqlBackendType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlBackendType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlBackendType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlBackendType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlBackendType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlBackendType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlBackendType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_BACKEND_TYPE_UNSPECIFIED" => sql_backend_type::SQL_BACKEND_TYPE_UNSPECIFIED,
            "FIRST_GEN" => sql_backend_type::FIRST_GEN,
            "SECOND_GEN" => sql_backend_type::SECOND_GEN,
            "EXTERNAL" => sql_backend_type::EXTERNAL,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlBackendType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_backend_type::SQL_BACKEND_TYPE_UNSPECIFIED,
            1 => sql_backend_type::FIRST_GEN,
            2 => sql_backend_type::SECOND_GEN,
            3 => sql_backend_type::EXTERNAL,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlBackendType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlIpAddressType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlIpAddressType](SqlIpAddressType)
pub mod sql_ip_address_type {
    use super::SqlIpAddressType;
    

    /// This is an unknown IP address type.
    pub const SQL_IP_ADDRESS_TYPE_UNSPECIFIED: SqlIpAddressType = SqlIpAddressType::known("SQL_IP_ADDRESS_TYPE_UNSPECIFIED", 0);

    /// IP address the customer is supposed to connect to. Usually this is the
    /// load balancer's IP address
    pub const PRIMARY: SqlIpAddressType = SqlIpAddressType::known("PRIMARY", 1);

    /// Source IP address of the connection a read replica establishes to its
    /// external primary instance. This IP address can be allowlisted by the
    /// customer in case it has a firewall that filters incoming connection to its
    /// on premises primary instance.
    pub const OUTGOING: SqlIpAddressType = SqlIpAddressType::known("OUTGOING", 2);

    /// Private IP used when using private IPs and network peering.
    pub const PRIVATE: SqlIpAddressType = SqlIpAddressType::known("PRIVATE", 3);

    /// V1 IP of a migrated instance. We want the user to
    /// decommission this IP as soon as the migration is complete.
    /// Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
    pub const MIGRATED_1ST_GEN: SqlIpAddressType = SqlIpAddressType::known("MIGRATED_1ST_GEN", 4);
}

impl SqlIpAddressType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlIpAddressType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlIpAddressType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlIpAddressType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlIpAddressType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlIpAddressType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlIpAddressType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" => sql_ip_address_type::SQL_IP_ADDRESS_TYPE_UNSPECIFIED,
            "PRIMARY" => sql_ip_address_type::PRIMARY,
            "OUTGOING" => sql_ip_address_type::OUTGOING,
            "PRIVATE" => sql_ip_address_type::PRIVATE,
            "MIGRATED_1ST_GEN" => sql_ip_address_type::MIGRATED_1ST_GEN,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlIpAddressType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_ip_address_type::SQL_IP_ADDRESS_TYPE_UNSPECIFIED,
            1 => sql_ip_address_type::PRIMARY,
            2 => sql_ip_address_type::OUTGOING,
            3 => sql_ip_address_type::PRIVATE,
            4 => sql_ip_address_type::MIGRATED_1ST_GEN,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlIpAddressType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The database engine type and version.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlDatabaseVersion(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlDatabaseVersion](SqlDatabaseVersion)
pub mod sql_database_version {
    use super::SqlDatabaseVersion;
    

    /// This is an unknown database version.
    pub const SQL_DATABASE_VERSION_UNSPECIFIED: SqlDatabaseVersion = SqlDatabaseVersion::known("SQL_DATABASE_VERSION_UNSPECIFIED", 0);

    /// The database version is MySQL 5.1.
    pub const MYSQL_5_1: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_5_1", 2);

    /// The database version is MySQL 5.5.
    pub const MYSQL_5_5: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_5_5", 3);

    /// The database version is MySQL 5.6.
    pub const MYSQL_5_6: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_5_6", 5);

    /// The database version is MySQL 5.7.
    pub const MYSQL_5_7: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_5_7", 6);

    /// The database version is SQL Server 2017 Standard.
    pub const SQLSERVER_2017_STANDARD: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2017_STANDARD", 11);

    /// The database version is SQL Server 2017 Enterprise.
    pub const SQLSERVER_2017_ENTERPRISE: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2017_ENTERPRISE", 14);

    /// The database version is SQL Server 2017 Express.
    pub const SQLSERVER_2017_EXPRESS: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2017_EXPRESS", 15);

    /// The database version is SQL Server 2017 Web.
    pub const SQLSERVER_2017_WEB: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2017_WEB", 16);

    /// The database version is PostgreSQL 9.6.
    pub const POSTGRES_9_6: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_9_6", 9);

    /// The database version is PostgreSQL 10.
    pub const POSTGRES_10: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_10", 18);

    /// The database version is PostgreSQL 11.
    pub const POSTGRES_11: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_11", 10);

    /// The database version is PostgreSQL 12.
    pub const POSTGRES_12: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_12", 19);

    /// The database version is PostgreSQL 13.
    pub const POSTGRES_13: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_13", 23);

    /// The database version is PostgreSQL 14.
    pub const POSTGRES_14: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_14", 110);

    /// The database version is PostgreSQL 15.
    pub const POSTGRES_15: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_15", 172);

    /// The database version is PostgreSQL 16.
    pub const POSTGRES_16: SqlDatabaseVersion = SqlDatabaseVersion::known("POSTGRES_16", 272);

    /// The database version is MySQL 8.
    pub const MYSQL_8_0: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0", 20);

    /// The database major version is MySQL 8.0 and the minor version is 18.
    pub const MYSQL_8_0_18: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_18", 41);

    /// The database major version is MySQL 8.0 and the minor version is 26.
    pub const MYSQL_8_0_26: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_26", 85);

    /// The database major version is MySQL 8.0 and the minor version is 27.
    pub const MYSQL_8_0_27: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_27", 111);

    /// The database major version is MySQL 8.0 and the minor version is 28.
    pub const MYSQL_8_0_28: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_28", 132);

    /// The database major version is MySQL 8.0 and the minor version is 29.
    pub const MYSQL_8_0_29: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_29", 148);

    /// The database major version is MySQL 8.0 and the minor version is 30.
    pub const MYSQL_8_0_30: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_30", 174);

    /// The database major version is MySQL 8.0 and the minor version is 31.
    pub const MYSQL_8_0_31: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_31", 197);

    /// The database major version is MySQL 8.0 and the minor version is 32.
    pub const MYSQL_8_0_32: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_32", 213);

    /// The database major version is MySQL 8.0 and the minor version is 33.
    pub const MYSQL_8_0_33: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_33", 238);

    /// The database major version is MySQL 8.0 and the minor version is 34.
    pub const MYSQL_8_0_34: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_34", 239);

    /// The database major version is MySQL 8.0 and the minor version is 35.
    pub const MYSQL_8_0_35: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_35", 240);

    /// The database major version is MySQL 8.0 and the minor version is 36.
    pub const MYSQL_8_0_36: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_36", 241);

    /// The database major version is MySQL 8.0 and the minor version is 37.
    pub const MYSQL_8_0_37: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_37", 355);

    /// The database major version is MySQL 8.0 and the minor version is 38.
    pub const MYSQL_8_0_38: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_38", 356);

    /// The database major version is MySQL 8.0 and the minor version is 39.
    pub const MYSQL_8_0_39: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_39", 357);

    /// The database major version is MySQL 8.0 and the minor version is 40.
    pub const MYSQL_8_0_40: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_0_40", 358);

    /// The database version is MySQL 8.4.
    pub const MYSQL_8_4: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_4", 398);

    /// The database version is MySQL 8.4 and the patch version is 0.
    pub const MYSQL_8_4_0: SqlDatabaseVersion = SqlDatabaseVersion::known("MYSQL_8_4_0", 399);

    /// The database version is SQL Server 2019 Standard.
    pub const SQLSERVER_2019_STANDARD: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2019_STANDARD", 26);

    /// The database version is SQL Server 2019 Enterprise.
    pub const SQLSERVER_2019_ENTERPRISE: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2019_ENTERPRISE", 27);

    /// The database version is SQL Server 2019 Express.
    pub const SQLSERVER_2019_EXPRESS: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2019_EXPRESS", 28);

    /// The database version is SQL Server 2019 Web.
    pub const SQLSERVER_2019_WEB: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2019_WEB", 29);

    /// The database version is SQL Server 2022 Standard.
    pub const SQLSERVER_2022_STANDARD: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2022_STANDARD", 199);

    /// The database version is SQL Server 2022 Enterprise.
    pub const SQLSERVER_2022_ENTERPRISE: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2022_ENTERPRISE", 200);

    /// The database version is SQL Server 2022 Express.
    pub const SQLSERVER_2022_EXPRESS: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2022_EXPRESS", 201);

    /// The database version is SQL Server 2022 Web.
    pub const SQLSERVER_2022_WEB: SqlDatabaseVersion = SqlDatabaseVersion::known("SQLSERVER_2022_WEB", 202);
}

impl SqlDatabaseVersion {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlDatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlDatabaseVersion::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlDatabaseVersion::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlDatabaseVersion::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlDatabaseVersion {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_DATABASE_VERSION_UNSPECIFIED" => sql_database_version::SQL_DATABASE_VERSION_UNSPECIFIED,
            "MYSQL_5_1" => sql_database_version::MYSQL_5_1,
            "MYSQL_5_5" => sql_database_version::MYSQL_5_5,
            "MYSQL_5_6" => sql_database_version::MYSQL_5_6,
            "MYSQL_5_7" => sql_database_version::MYSQL_5_7,
            "SQLSERVER_2017_STANDARD" => sql_database_version::SQLSERVER_2017_STANDARD,
            "SQLSERVER_2017_ENTERPRISE" => sql_database_version::SQLSERVER_2017_ENTERPRISE,
            "SQLSERVER_2017_EXPRESS" => sql_database_version::SQLSERVER_2017_EXPRESS,
            "SQLSERVER_2017_WEB" => sql_database_version::SQLSERVER_2017_WEB,
            "POSTGRES_9_6" => sql_database_version::POSTGRES_9_6,
            "POSTGRES_10" => sql_database_version::POSTGRES_10,
            "POSTGRES_11" => sql_database_version::POSTGRES_11,
            "POSTGRES_12" => sql_database_version::POSTGRES_12,
            "POSTGRES_13" => sql_database_version::POSTGRES_13,
            "POSTGRES_14" => sql_database_version::POSTGRES_14,
            "POSTGRES_15" => sql_database_version::POSTGRES_15,
            "POSTGRES_16" => sql_database_version::POSTGRES_16,
            "MYSQL_8_0" => sql_database_version::MYSQL_8_0,
            "MYSQL_8_0_18" => sql_database_version::MYSQL_8_0_18,
            "MYSQL_8_0_26" => sql_database_version::MYSQL_8_0_26,
            "MYSQL_8_0_27" => sql_database_version::MYSQL_8_0_27,
            "MYSQL_8_0_28" => sql_database_version::MYSQL_8_0_28,
            "MYSQL_8_0_29" => sql_database_version::MYSQL_8_0_29,
            "MYSQL_8_0_30" => sql_database_version::MYSQL_8_0_30,
            "MYSQL_8_0_31" => sql_database_version::MYSQL_8_0_31,
            "MYSQL_8_0_32" => sql_database_version::MYSQL_8_0_32,
            "MYSQL_8_0_33" => sql_database_version::MYSQL_8_0_33,
            "MYSQL_8_0_34" => sql_database_version::MYSQL_8_0_34,
            "MYSQL_8_0_35" => sql_database_version::MYSQL_8_0_35,
            "MYSQL_8_0_36" => sql_database_version::MYSQL_8_0_36,
            "MYSQL_8_0_37" => sql_database_version::MYSQL_8_0_37,
            "MYSQL_8_0_38" => sql_database_version::MYSQL_8_0_38,
            "MYSQL_8_0_39" => sql_database_version::MYSQL_8_0_39,
            "MYSQL_8_0_40" => sql_database_version::MYSQL_8_0_40,
            "MYSQL_8_4" => sql_database_version::MYSQL_8_4,
            "MYSQL_8_4_0" => sql_database_version::MYSQL_8_4_0,
            "SQLSERVER_2019_STANDARD" => sql_database_version::SQLSERVER_2019_STANDARD,
            "SQLSERVER_2019_ENTERPRISE" => sql_database_version::SQLSERVER_2019_ENTERPRISE,
            "SQLSERVER_2019_EXPRESS" => sql_database_version::SQLSERVER_2019_EXPRESS,
            "SQLSERVER_2019_WEB" => sql_database_version::SQLSERVER_2019_WEB,
            "SQLSERVER_2022_STANDARD" => sql_database_version::SQLSERVER_2022_STANDARD,
            "SQLSERVER_2022_ENTERPRISE" => sql_database_version::SQLSERVER_2022_ENTERPRISE,
            "SQLSERVER_2022_EXPRESS" => sql_database_version::SQLSERVER_2022_EXPRESS,
            "SQLSERVER_2022_WEB" => sql_database_version::SQLSERVER_2022_WEB,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlDatabaseVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_database_version::SQL_DATABASE_VERSION_UNSPECIFIED,
            2 => sql_database_version::MYSQL_5_1,
            3 => sql_database_version::MYSQL_5_5,
            5 => sql_database_version::MYSQL_5_6,
            6 => sql_database_version::MYSQL_5_7,
            9 => sql_database_version::POSTGRES_9_6,
            10 => sql_database_version::POSTGRES_11,
            11 => sql_database_version::SQLSERVER_2017_STANDARD,
            14 => sql_database_version::SQLSERVER_2017_ENTERPRISE,
            15 => sql_database_version::SQLSERVER_2017_EXPRESS,
            16 => sql_database_version::SQLSERVER_2017_WEB,
            18 => sql_database_version::POSTGRES_10,
            19 => sql_database_version::POSTGRES_12,
            20 => sql_database_version::MYSQL_8_0,
            23 => sql_database_version::POSTGRES_13,
            26 => sql_database_version::SQLSERVER_2019_STANDARD,
            27 => sql_database_version::SQLSERVER_2019_ENTERPRISE,
            28 => sql_database_version::SQLSERVER_2019_EXPRESS,
            29 => sql_database_version::SQLSERVER_2019_WEB,
            41 => sql_database_version::MYSQL_8_0_18,
            85 => sql_database_version::MYSQL_8_0_26,
            110 => sql_database_version::POSTGRES_14,
            111 => sql_database_version::MYSQL_8_0_27,
            132 => sql_database_version::MYSQL_8_0_28,
            148 => sql_database_version::MYSQL_8_0_29,
            172 => sql_database_version::POSTGRES_15,
            174 => sql_database_version::MYSQL_8_0_30,
            197 => sql_database_version::MYSQL_8_0_31,
            199 => sql_database_version::SQLSERVER_2022_STANDARD,
            200 => sql_database_version::SQLSERVER_2022_ENTERPRISE,
            201 => sql_database_version::SQLSERVER_2022_EXPRESS,
            202 => sql_database_version::SQLSERVER_2022_WEB,
            213 => sql_database_version::MYSQL_8_0_32,
            238 => sql_database_version::MYSQL_8_0_33,
            239 => sql_database_version::MYSQL_8_0_34,
            240 => sql_database_version::MYSQL_8_0_35,
            241 => sql_database_version::MYSQL_8_0_36,
            272 => sql_database_version::POSTGRES_16,
            355 => sql_database_version::MYSQL_8_0_37,
            356 => sql_database_version::MYSQL_8_0_38,
            357 => sql_database_version::MYSQL_8_0_39,
            358 => sql_database_version::MYSQL_8_0_40,
            398 => sql_database_version::MYSQL_8_4,
            399 => sql_database_version::MYSQL_8_4_0,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlDatabaseVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The pricing plan for this instance.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlPricingPlan(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlPricingPlan](SqlPricingPlan)
pub mod sql_pricing_plan {
    use super::SqlPricingPlan;
    

    /// This is an unknown pricing plan for this instance.
    pub const SQL_PRICING_PLAN_UNSPECIFIED: SqlPricingPlan = SqlPricingPlan::known("SQL_PRICING_PLAN_UNSPECIFIED", 0);

    /// The instance is billed at a monthly flat rate.
    pub const PACKAGE: SqlPricingPlan = SqlPricingPlan::known("PACKAGE", 1);

    /// The instance is billed per usage.
    pub const PER_USE: SqlPricingPlan = SqlPricingPlan::known("PER_USE", 2);
}

impl SqlPricingPlan {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlPricingPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlPricingPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlPricingPlan::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlPricingPlan::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlPricingPlan::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlPricingPlan {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_PRICING_PLAN_UNSPECIFIED" => sql_pricing_plan::SQL_PRICING_PLAN_UNSPECIFIED,
            "PACKAGE" => sql_pricing_plan::PACKAGE,
            "PER_USE" => sql_pricing_plan::PER_USE,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlPricingPlan {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_pricing_plan::SQL_PRICING_PLAN_UNSPECIFIED,
            1 => sql_pricing_plan::PACKAGE,
            2 => sql_pricing_plan::PER_USE,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlPricingPlan {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlReplicationType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlReplicationType](SqlReplicationType)
pub mod sql_replication_type {
    use super::SqlReplicationType;
    

    /// This is an unknown replication type for a Cloud SQL instance.
    pub const SQL_REPLICATION_TYPE_UNSPECIFIED: SqlReplicationType = SqlReplicationType::known("SQL_REPLICATION_TYPE_UNSPECIFIED", 0);

    /// The synchronous replication mode for First Generation instances. It is the
    /// default value.
    pub const SYNCHRONOUS: SqlReplicationType = SqlReplicationType::known("SYNCHRONOUS", 1);

    /// The asynchronous replication mode for First Generation instances. It
    /// provides a slight performance gain, but if an outage occurs while this
    /// option is set to asynchronous, you can lose up to a few seconds of updates
    /// to your data.
    pub const ASYNCHRONOUS: SqlReplicationType = SqlReplicationType::known("ASYNCHRONOUS", 2);
}

impl SqlReplicationType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlReplicationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlReplicationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlReplicationType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlReplicationType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlReplicationType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlReplicationType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_REPLICATION_TYPE_UNSPECIFIED" => sql_replication_type::SQL_REPLICATION_TYPE_UNSPECIFIED,
            "SYNCHRONOUS" => sql_replication_type::SYNCHRONOUS,
            "ASYNCHRONOUS" => sql_replication_type::ASYNCHRONOUS,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlReplicationType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_replication_type::SQL_REPLICATION_TYPE_UNSPECIFIED,
            1 => sql_replication_type::SYNCHRONOUS,
            2 => sql_replication_type::ASYNCHRONOUS,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlReplicationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The type of disk that is used for a v2 instance to use.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlDataDiskType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlDataDiskType](SqlDataDiskType)
pub mod sql_data_disk_type {
    use super::SqlDataDiskType;
    

    /// This is an unknown data disk type.
    pub const SQL_DATA_DISK_TYPE_UNSPECIFIED: SqlDataDiskType = SqlDataDiskType::known("SQL_DATA_DISK_TYPE_UNSPECIFIED", 0);

    /// An SSD data disk.
    pub const PD_SSD: SqlDataDiskType = SqlDataDiskType::known("PD_SSD", 1);

    /// An HDD data disk.
    pub const PD_HDD: SqlDataDiskType = SqlDataDiskType::known("PD_HDD", 2);

    /// This field is deprecated and will be removed from a future version of the
    /// API.
    pub const OBSOLETE_LOCAL_SSD: SqlDataDiskType = SqlDataDiskType::known("OBSOLETE_LOCAL_SSD", 3);
}

impl SqlDataDiskType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlDataDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlDataDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlDataDiskType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlDataDiskType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlDataDiskType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlDataDiskType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_DATA_DISK_TYPE_UNSPECIFIED" => sql_data_disk_type::SQL_DATA_DISK_TYPE_UNSPECIFIED,
            "PD_SSD" => sql_data_disk_type::PD_SSD,
            "PD_HDD" => sql_data_disk_type::PD_HDD,
            "OBSOLETE_LOCAL_SSD" => sql_data_disk_type::OBSOLETE_LOCAL_SSD,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlDataDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_data_disk_type::SQL_DATA_DISK_TYPE_UNSPECIFIED,
            1 => sql_data_disk_type::PD_SSD,
            2 => sql_data_disk_type::PD_HDD,
            3 => sql_data_disk_type::OBSOLETE_LOCAL_SSD,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlDataDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The availability type of the given Cloud SQL instance.
#[derive(Clone, Debug, PartialEq)]
pub struct SqlAvailabilityType(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlAvailabilityType](SqlAvailabilityType)
pub mod sql_availability_type {
    use super::SqlAvailabilityType;
    

    /// This is an unknown Availability type.
    pub const SQL_AVAILABILITY_TYPE_UNSPECIFIED: SqlAvailabilityType = SqlAvailabilityType::known("SQL_AVAILABILITY_TYPE_UNSPECIFIED", 0);

    /// Zonal available instance.
    pub const ZONAL: SqlAvailabilityType = SqlAvailabilityType::known("ZONAL", 1);

    /// Regional available instance.
    pub const REGIONAL: SqlAvailabilityType = SqlAvailabilityType::known("REGIONAL", 2);
}

impl SqlAvailabilityType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlAvailabilityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlAvailabilityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlAvailabilityType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlAvailabilityType::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlAvailabilityType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlAvailabilityType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => sql_availability_type::SQL_AVAILABILITY_TYPE_UNSPECIFIED,
            "ZONAL" => sql_availability_type::ZONAL,
            "REGIONAL" => sql_availability_type::REGIONAL,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlAvailabilityType {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_availability_type::SQL_AVAILABILITY_TYPE_UNSPECIFIED,
            1 => sql_availability_type::ZONAL,
            2 => sql_availability_type::REGIONAL,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlAvailabilityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct SqlUpdateTrack(wkt::enumerations::Enumeration);

/// Useful constants to work with [SqlUpdateTrack](SqlUpdateTrack)
pub mod sql_update_track {
    use super::SqlUpdateTrack;
    

    /// This is an unknown maintenance timing preference.
    pub const SQL_UPDATE_TRACK_UNSPECIFIED: SqlUpdateTrack = SqlUpdateTrack::known("SQL_UPDATE_TRACK_UNSPECIFIED", 0);

    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 7 to 14 days
    /// after the notification is sent out. Also referred to as `Week 1` (Console)
    /// and `preview` (gcloud CLI).
    pub const CANARY: SqlUpdateTrack = SqlUpdateTrack::known("CANARY", 1);

    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 15 to 21 days
    /// after the notification is sent out. Also referred to as `Week 2` (Console)
    /// and `production` (gcloud CLI).
    pub const STABLE: SqlUpdateTrack = SqlUpdateTrack::known("STABLE", 2);

    /// For instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 35 to 42 days
    /// after the notification is sent out.
    pub const WEEK_5: SqlUpdateTrack = SqlUpdateTrack::known("WEEK_5", 3);
}

impl SqlUpdateTrack {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for SqlUpdateTrack {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for SqlUpdateTrack {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(SqlUpdateTrack::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(SqlUpdateTrack::from(val)),
            Enumeration::UnknownNum { str } => Ok(SqlUpdateTrack::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for SqlUpdateTrack {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "SQL_UPDATE_TRACK_UNSPECIFIED" => sql_update_track::SQL_UPDATE_TRACK_UNSPECIFIED,
            "CANARY" => sql_update_track::CANARY,
            "STABLE" => sql_update_track::STABLE,
            "WEEK_5" => sql_update_track::WEEK_5,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for SqlUpdateTrack {
    fn from(value: i32) -> Self {
        match value {
            0 => sql_update_track::SQL_UPDATE_TRACK_UNSPECIFIED,
            1 => sql_update_track::CANARY,
            2 => sql_update_track::STABLE,
            3 => sql_update_track::WEEK_5,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for SqlUpdateTrack {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
