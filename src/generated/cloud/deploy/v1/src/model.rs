// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Payload proto for "clouddeploy.googleapis.com/automation"
/// Platform Log event that describes the Automation related events.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationEvent {
    /// Debug message for when there is an update on the AutomationRun.
    /// Provides further details about the resource creation or state change.
    pub message: std::string::String,

    /// The name of the `AutomationRun`.
    pub automation: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AutomationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [automation][crate::model::AutomationEvent::automation].
    pub fn set_automation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::AutomationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AutomationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for AutomationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __automation,
            __pipeline_uid,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "automation" => Ok(__FieldTag::__automation),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation => {
                            if !fields.insert(__FieldTag::__automation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation",
                                ));
                            }
                            result.automation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.automation.is_empty() {
            state.serialize_entry("automation", &self.automation)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("automation", &self.automation);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/automation_run"
/// Platform Log event that describes the AutomationRun related events.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationRunEvent {
    /// Debug message for when there is an update on the AutomationRun.
    /// Provides further details about the resource creation or state change.
    pub message: std::string::String,

    /// The name of the `AutomationRun`.
    pub automation_run: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// Identifier of the `Automation`.
    pub automation_id: std::string::String,

    /// Identifier of the `Automation` rule.
    pub rule_id: std::string::String,

    /// ID of the `Target` to which the `AutomationRun` is created.
    pub destination_target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRunEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AutomationRunEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [automation_run][crate::model::AutomationRunEvent::automation_run].
    pub fn set_automation_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_run = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::AutomationRunEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::AutomationRunEvent::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::AutomationRunEvent::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [destination_target_id][crate::model::AutomationRunEvent::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AutomationRunEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for AutomationRunEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRunEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationRunEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __automation_run,
            __pipeline_uid,
            __automation_id,
            __rule_id,
            __destination_target_id,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationRunEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "automationRun" => Ok(__FieldTag::__automation_run),
                            "automation_run" => Ok(__FieldTag::__automation_run),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "automationId" => Ok(__FieldTag::__automation_id),
                            "automation_id" => Ok(__FieldTag::__automation_id),
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "destinationTargetId" => Ok(__FieldTag::__destination_target_id),
                            "destination_target_id" => Ok(__FieldTag::__destination_target_id),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationRunEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationRunEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation_run => {
                            if !fields.insert(__FieldTag::__automation_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_run",
                                ));
                            }
                            result.automation_run = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation_id => {
                            if !fields.insert(__FieldTag::__automation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_id",
                                ));
                            }
                            result.automation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_target_id => {
                            if !fields.insert(__FieldTag::__destination_target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_target_id",
                                ));
                            }
                            result.destination_target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationRunEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.automation_run.is_empty() {
            state.serialize_entry("automationRun", &self.automation_run)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.automation_id.is_empty() {
            state.serialize_entry("automationId", &self.automation_id)?;
        }
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !self.destination_target_id.is_empty() {
            state.serialize_entry("destinationTargetId", &self.destination_target_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationRunEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationRunEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("automation_run", &self.automation_run);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("automation_id", &self.automation_id);
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("destination_target_id", &self.destination_target_id);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `DeliveryPipeline` resource in the Cloud Deploy API.
///
/// A `DeliveryPipeline` defines a pipeline through which a Skaffold
/// configuration can progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeliveryPipeline {
    /// Identifier. Name of the `DeliveryPipeline`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}`.
    /// The `deliveryPipeline` component must match
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Unique identifier of the `DeliveryPipeline`.
    pub uid: std::string::String,

    /// Optional. Description of the `DeliveryPipeline`. Max length is 255
    /// characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the pipeline was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the pipeline was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Information around the state of the Delivery Pipeline.
    pub condition: std::option::Option<crate::model::PipelineCondition>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. When suspended, no new releases or rollouts can be created,
    /// but in-progress ones will complete.
    pub suspended: bool,

    /// The ordering configuration of the `DeliveryPipeline`.
    pub pipeline: std::option::Option<crate::model::delivery_pipeline::Pipeline>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeliveryPipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DeliveryPipeline::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeliveryPipeline::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DeliveryPipeline::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DeliveryPipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DeliveryPipeline::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeliveryPipeline::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeliveryPipeline::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeliveryPipeline::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::DeliveryPipeline::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PipelineCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::DeliveryPipeline::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PipelineCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::DeliveryPipeline::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::DeliveryPipeline::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [pipeline][crate::model::DeliveryPipeline::pipeline].
    ///
    /// Note that all the setters affecting `pipeline` are mutually
    /// exclusive.
    pub fn set_pipeline<
        T: std::convert::Into<std::option::Option<crate::model::delivery_pipeline::Pipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = v.into();
        self
    }

    /// The value of [pipeline][crate::model::DeliveryPipeline::pipeline]
    /// if it holds a `SerialPipeline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serial_pipeline(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SerialPipeline>> {
        #[allow(unreachable_patterns)]
        self.pipeline.as_ref().and_then(|v| match v {
            crate::model::delivery_pipeline::Pipeline::SerialPipeline(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pipeline][crate::model::DeliveryPipeline::pipeline]
    /// to hold a `SerialPipeline`.
    ///
    /// Note that all the setters affecting `pipeline` are
    /// mutually exclusive.
    pub fn set_serial_pipeline<
        T: std::convert::Into<std::boxed::Box<crate::model::SerialPipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = std::option::Option::Some(
            crate::model::delivery_pipeline::Pipeline::SerialPipeline(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeliveryPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipeline"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeliveryPipeline {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __serial_pipeline,
            __condition,
            __etag,
            __suspended,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliveryPipeline")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "serialPipeline" => Ok(__FieldTag::__serial_pipeline),
                            "serial_pipeline" => Ok(__FieldTag::__serial_pipeline),
                            "condition" => Ok(__FieldTag::__condition),
                            "etag" => Ok(__FieldTag::__etag),
                            "suspended" => Ok(__FieldTag::__suspended),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeliveryPipeline;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliveryPipeline")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__serial_pipeline => {
                            if !fields.insert(__FieldTag::__serial_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serial_pipeline",
                                ));
                            }
                            if result.pipeline.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `pipeline`, a oneof with full ID .google.cloud.deploy.v1.DeliveryPipeline.serial_pipeline, latest field was serialPipeline",
                                ));
                            }
                            result.pipeline = std::option::Option::Some(
                                crate::model::delivery_pipeline::Pipeline::SerialPipeline(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SerialPipeline>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<crate::model::PipelineCondition>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeliveryPipeline {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if let Some(value) = self.serial_pipeline() {
            state.serialize_entry("serialPipeline", value)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeliveryPipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeliveryPipeline");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("suspended", &self.suspended);
        debug_struct.field("pipeline", &self.pipeline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeliveryPipeline].
pub mod delivery_pipeline {
    #[allow(unused_imports)]
    use super::*;

    /// The ordering configuration of the `DeliveryPipeline`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Pipeline {
        /// Optional. SerialPipeline defines a sequential set of stages for a
        /// `DeliveryPipeline`.
        SerialPipeline(std::boxed::Box<crate::model::SerialPipeline>),
    }
}

/// SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SerialPipeline {
    /// Optional. Each stage specifies configuration for a `Target`. The ordering
    /// of this list defines the promotion flow.
    pub stages: std::vec::Vec<crate::model::Stage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerialPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stages][crate::model::SerialPipeline::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Stage>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerialPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SerialPipeline"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SerialPipeline {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SerialPipeline")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stages" => Ok(__FieldTag::__stages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SerialPipeline;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SerialPipeline")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stages => {
                            if !fields.insert(__FieldTag::__stages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stages",
                                ));
                            }
                            result.stages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Stage>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SerialPipeline {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.stages.is_empty() {
            state.serialize_entry("stages", &self.stages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SerialPipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SerialPipeline");
        debug_struct.field("stages", &self.stages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Stage specifies a location to which to deploy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Stage {
    /// Optional. The target_id to which this stage points. This field refers
    /// exclusively to the last segment of a target name. For example, this field
    /// would just be `my-target` (rather than
    /// `projects/project/locations/location/targets/my-target`). The location of
    /// the `Target` is inferred to be the same as the location of the
    /// `DeliveryPipeline` that contains this `Stage`.
    pub target_id: std::string::String,

    /// Optional. Skaffold profiles to use when rendering the manifest for this
    /// stage's `Target`.
    pub profiles: std::vec::Vec<std::string::String>,

    /// Optional. The strategy to use for a `Rollout` to this stage.
    pub strategy: std::option::Option<crate::model::Strategy>,

    /// Optional. The deploy parameters to use for the target in this stage.
    pub deploy_parameters: std::vec::Vec<crate::model::DeployParameters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Stage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::Stage::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::Stage::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [strategy][crate::model::Stage::strategy].
    pub fn set_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Strategy>,
    {
        self.strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [strategy][crate::model::Stage::strategy].
    pub fn set_or_clear_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Strategy>,
    {
        self.strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Stage::deploy_parameters].
    pub fn set_deploy_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployParameters>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Stage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Stage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Stage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_id,
            __profiles,
            __strategy,
            __deploy_parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Stage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "profiles" => Ok(__FieldTag::__profiles),
                            "strategy" => Ok(__FieldTag::__strategy),
                            "deployParameters" => Ok(__FieldTag::__deploy_parameters),
                            "deploy_parameters" => Ok(__FieldTag::__deploy_parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Stage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Stage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__profiles => {
                            if !fields.insert(__FieldTag::__profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profiles",
                                ));
                            }
                            result.profiles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__strategy => {
                            if !fields.insert(__FieldTag::__strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for strategy",
                                ));
                            }
                            result.strategy =
                                map.next_value::<std::option::Option<crate::model::Strategy>>()?;
                        }
                        __FieldTag::__deploy_parameters => {
                            if !fields.insert(__FieldTag::__deploy_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_parameters",
                                ));
                            }
                            result.deploy_parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DeployParameters>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Stage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !self.profiles.is_empty() {
            state.serialize_entry("profiles", &self.profiles)?;
        }
        if self.strategy.is_some() {
            state.serialize_entry("strategy", &self.strategy)?;
        }
        if !self.deploy_parameters.is_empty() {
            state.serialize_entry("deployParameters", &self.deploy_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Stage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Stage");
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("profiles", &self.profiles);
        debug_struct.field("strategy", &self.strategy);
        debug_struct.field("deploy_parameters", &self.deploy_parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeployParameters contains deploy parameters information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployParameters {
    /// Required. Values are deploy parameters in key-value pairs.
    pub values: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Deploy parameters are applied to targets with match labels.
    /// If unspecified, deploy parameters are applied to all targets (including
    /// child targets of a multi-target).
    pub match_target_labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DeployParameters::values].
    pub fn set_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [match_target_labels][crate::model::DeployParameters::match_target_labels].
    pub fn set_match_target_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.match_target_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DeployParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            __match_target_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            "matchTargetLabels" => Ok(__FieldTag::__match_target_labels),
                            "match_target_labels" => Ok(__FieldTag::__match_target_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__match_target_labels => {
                            if !fields.insert(__FieldTag::__match_target_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_target_labels",
                                ));
                            }
                            result.match_target_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self.match_target_labels.is_empty() {
            state.serialize_entry("matchTargetLabels", &self.match_target_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployParameters");
        debug_struct.field("values", &self.values);
        debug_struct.field("match_target_labels", &self.match_target_labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Strategy contains deployment strategy information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Strategy {
    /// Deployment strategy details.
    pub deployment_strategy: std::option::Option<crate::model::strategy::DeploymentStrategy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Strategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy].
    ///
    /// Note that all the setters affecting `deployment_strategy` are mutually
    /// exclusive.
    pub fn set_deployment_strategy<
        T: std::convert::Into<std::option::Option<crate::model::strategy::DeploymentStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy = v.into();
        self
    }

    /// The value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// if it holds a `Standard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard(&self) -> std::option::Option<&std::boxed::Box<crate::model::Standard>> {
        #[allow(unreachable_patterns)]
        self.deployment_strategy.as_ref().and_then(|v| match v {
            crate::model::strategy::DeploymentStrategy::Standard(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// to hold a `Standard`.
    ///
    /// Note that all the setters affecting `deployment_strategy` are
    /// mutually exclusive.
    pub fn set_standard<T: std::convert::Into<std::boxed::Box<crate::model::Standard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy = std::option::Option::Some(
            crate::model::strategy::DeploymentStrategy::Standard(v.into()),
        );
        self
    }

    /// The value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// if it holds a `Canary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn canary(&self) -> std::option::Option<&std::boxed::Box<crate::model::Canary>> {
        #[allow(unreachable_patterns)]
        self.deployment_strategy.as_ref().and_then(|v| match v {
            crate::model::strategy::DeploymentStrategy::Canary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// to hold a `Canary`.
    ///
    /// Note that all the setters affecting `deployment_strategy` are
    /// mutually exclusive.
    pub fn set_canary<T: std::convert::Into<std::boxed::Box<crate::model::Canary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy =
            std::option::Option::Some(crate::model::strategy::DeploymentStrategy::Canary(v.into()));
        self
    }
}

impl wkt::message::Message for Strategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Strategy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Strategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard,
            __canary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Strategy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standard" => Ok(__FieldTag::__standard),
                            "canary" => Ok(__FieldTag::__canary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Strategy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Strategy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard => {
                            if !fields.insert(__FieldTag::__standard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard",
                                ));
                            }
                            if result.deployment_strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_strategy`, a oneof with full ID .google.cloud.deploy.v1.Strategy.standard, latest field was standard",
                                ));
                            }
                            result.deployment_strategy = std::option::Option::Some(
                                crate::model::strategy::DeploymentStrategy::Standard(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Standard>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__canary => {
                            if !fields.insert(__FieldTag::__canary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canary",
                                ));
                            }
                            if result.deployment_strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_strategy`, a oneof with full ID .google.cloud.deploy.v1.Strategy.canary, latest field was canary",
                                ));
                            }
                            result.deployment_strategy =
                                std::option::Option::Some(
                                    crate::model::strategy::DeploymentStrategy::Canary(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Canary>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Strategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.standard() {
            state.serialize_entry("standard", value)?;
        }
        if let Some(value) = self.canary() {
            state.serialize_entry("canary", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Strategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Strategy");
        debug_struct.field("deployment_strategy", &self.deployment_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Strategy].
pub mod strategy {
    #[allow(unused_imports)]
    use super::*;

    /// Deployment strategy details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeploymentStrategy {
        /// Optional. Standard deployment strategy executes a single deploy and
        /// allows verifying the deployment.
        Standard(std::boxed::Box<crate::model::Standard>),
        /// Optional. Canary deployment strategy provides progressive percentage
        /// based deployments to a Target.
        Canary(std::boxed::Box<crate::model::Canary>),
    }
}

/// Predeploy contains the predeploy job configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Predeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the predeploy job.
    pub actions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Predeploy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::Predeploy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Predeploy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Predeploy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Predeploy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Predeploy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Predeploy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Predeploy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Predeploy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Predeploy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Predeploy");
        debug_struct.field("actions", &self.actions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Postdeploy contains the postdeploy job configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Postdeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the postdeploy job.
    pub actions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Postdeploy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::Postdeploy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Postdeploy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Postdeploy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Postdeploy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Postdeploy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Postdeploy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Postdeploy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Postdeploy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Postdeploy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Postdeploy");
        debug_struct.field("actions", &self.actions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Standard represents the standard deployment strategy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Standard {
    /// Optional. Whether to verify a deployment via `skaffold verify`.
    pub verify: bool,

    /// Optional. Configuration for the predeploy job. If this is not configured,
    /// the predeploy job will not be present.
    pub predeploy: std::option::Option<crate::model::Predeploy>,

    /// Optional. Configuration for the postdeploy job. If this is not configured,
    /// the postdeploy job will not be present.
    pub postdeploy: std::option::Option<crate::model::Postdeploy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Standard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [verify][crate::model::Standard::verify].
    pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify = v.into();
        self
    }

    /// Sets the value of [predeploy][crate::model::Standard::predeploy].
    pub fn set_predeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy][crate::model::Standard::predeploy].
    pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy][crate::model::Standard::postdeploy].
    pub fn set_postdeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy][crate::model::Standard::postdeploy].
    pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Standard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Standard"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Standard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __verify,
            __predeploy,
            __postdeploy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Standard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "verify" => Ok(__FieldTag::__verify),
                            "predeploy" => Ok(__FieldTag::__predeploy),
                            "postdeploy" => Ok(__FieldTag::__postdeploy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Standard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Standard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__verify => {
                            if !fields.insert(__FieldTag::__verify) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify",
                                ));
                            }
                            result.verify = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predeploy => {
                            if !fields.insert(__FieldTag::__predeploy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predeploy",
                                ));
                            }
                            result.predeploy =
                                map.next_value::<std::option::Option<crate::model::Predeploy>>()?;
                        }
                        __FieldTag::__postdeploy => {
                            if !fields.insert(__FieldTag::__postdeploy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postdeploy",
                                ));
                            }
                            result.postdeploy =
                                map.next_value::<std::option::Option<crate::model::Postdeploy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Standard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.verify) {
            state.serialize_entry("verify", &self.verify)?;
        }
        if self.predeploy.is_some() {
            state.serialize_entry("predeploy", &self.predeploy)?;
        }
        if self.postdeploy.is_some() {
            state.serialize_entry("postdeploy", &self.postdeploy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Standard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Standard");
        debug_struct.field("verify", &self.verify);
        debug_struct.field("predeploy", &self.predeploy);
        debug_struct.field("postdeploy", &self.postdeploy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Canary represents the canary deployment strategy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Canary {
    /// Optional. Runtime specific configurations for the deployment strategy. The
    /// runtime configuration is used to determine how Cloud Deploy will split
    /// traffic to enable a progressive deployment.
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// The mode to use for the canary deployment strategy.
    pub mode: std::option::Option<crate::model::canary::Mode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Canary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_config][crate::model::Canary::runtime_config].
    pub fn set_runtime_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_config][crate::model::Canary::runtime_config].
    pub fn set_or_clear_runtime_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mode][crate::model::Canary::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<T: std::convert::Into<std::option::Option<crate::model::canary::Mode>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::Canary::mode]
    /// if it holds a `CanaryDeployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn canary_deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CanaryDeployment>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::canary::Mode::CanaryDeployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Canary::mode]
    /// to hold a `CanaryDeployment`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_canary_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::CanaryDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::canary::Mode::CanaryDeployment(v.into()));
        self
    }

    /// The value of [mode][crate::model::Canary::mode]
    /// if it holds a `CustomCanaryDeployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_canary_deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomCanaryDeployment>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::canary::Mode::CustomCanaryDeployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Canary::mode]
    /// to hold a `CustomCanaryDeployment`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_custom_canary_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::CustomCanaryDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::canary::Mode::CustomCanaryDeployment(v.into()));
        self
    }
}

impl wkt::message::Message for Canary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Canary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Canary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __runtime_config,
            __canary_deployment,
            __custom_canary_deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Canary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "runtimeConfig" => Ok(__FieldTag::__runtime_config),
                            "runtime_config" => Ok(__FieldTag::__runtime_config),
                            "canaryDeployment" => Ok(__FieldTag::__canary_deployment),
                            "canary_deployment" => Ok(__FieldTag::__canary_deployment),
                            "customCanaryDeployment" => Ok(__FieldTag::__custom_canary_deployment),
                            "custom_canary_deployment" => {
                                Ok(__FieldTag::__custom_canary_deployment)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Canary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Canary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__runtime_config => {
                            if !fields.insert(__FieldTag::__runtime_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_config",
                                ));
                            }
                            result.runtime_config = map
                                .next_value::<std::option::Option<crate::model::RuntimeConfig>>()?;
                        }
                        __FieldTag::__canary_deployment => {
                            if !fields.insert(__FieldTag::__canary_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canary_deployment",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.deploy.v1.Canary.canary_deployment, latest field was canaryDeployment",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::canary::Mode::CanaryDeployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CanaryDeployment>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__custom_canary_deployment => {
                            if !fields.insert(__FieldTag::__custom_canary_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_canary_deployment",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.cloud.deploy.v1.Canary.custom_canary_deployment, latest field was customCanaryDeployment",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::canary::Mode::CustomCanaryDeployment(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CustomCanaryDeployment>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Canary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.runtime_config.is_some() {
            state.serialize_entry("runtimeConfig", &self.runtime_config)?;
        }
        if let Some(value) = self.canary_deployment() {
            state.serialize_entry("canaryDeployment", value)?;
        }
        if let Some(value) = self.custom_canary_deployment() {
            state.serialize_entry("customCanaryDeployment", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Canary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Canary");
        debug_struct.field("runtime_config", &self.runtime_config);
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Canary].
pub mod canary {
    #[allow(unused_imports)]
    use super::*;

    /// The mode to use for the canary deployment strategy.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Optional. Configures the progressive based deployment for a Target.
        CanaryDeployment(std::boxed::Box<crate::model::CanaryDeployment>),
        /// Optional. Configures the progressive based deployment for a Target, but
        /// allows customizing at the phase level where a phase represents each of
        /// the percentage deployments.
        CustomCanaryDeployment(std::boxed::Box<crate::model::CustomCanaryDeployment>),
    }
}

/// CanaryDeployment represents the canary deployment configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CanaryDeployment {
    /// Required. The percentage based deployments that will occur as a part of a
    /// `Rollout`. List is expected in ascending order and each integer n is
    /// 0 <= n < 100.
    /// If the GatewayServiceMesh is configured for Kubernetes, then the range for
    /// n is 0 <= n <= 100.
    pub percentages: std::vec::Vec<i32>,

    /// Optional. Whether to run verify tests after each percentage deployment via
    /// `skaffold verify`.
    pub verify: bool,

    /// Optional. Configuration for the predeploy job of the first phase. If this
    /// is not configured, there will be no predeploy job for this phase.
    pub predeploy: std::option::Option<crate::model::Predeploy>,

    /// Optional. Configuration for the postdeploy job of the last phase. If this
    /// is not configured, there will be no postdeploy job for this phase.
    pub postdeploy: std::option::Option<crate::model::Postdeploy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CanaryDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [percentages][crate::model::CanaryDeployment::percentages].
    pub fn set_percentages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.percentages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [verify][crate::model::CanaryDeployment::verify].
    pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify = v.into();
        self
    }

    /// Sets the value of [predeploy][crate::model::CanaryDeployment::predeploy].
    pub fn set_predeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy][crate::model::CanaryDeployment::predeploy].
    pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy][crate::model::CanaryDeployment::postdeploy].
    pub fn set_postdeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy][crate::model::CanaryDeployment::postdeploy].
    pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CanaryDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CanaryDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CanaryDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __percentages,
            __verify,
            __predeploy,
            __postdeploy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CanaryDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "percentages" => Ok(__FieldTag::__percentages),
                            "verify" => Ok(__FieldTag::__verify),
                            "predeploy" => Ok(__FieldTag::__predeploy),
                            "postdeploy" => Ok(__FieldTag::__postdeploy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CanaryDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CanaryDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__percentages => {
                            if !fields.insert(__FieldTag::__percentages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percentages",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.percentages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__verify => {
                            if !fields.insert(__FieldTag::__verify) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify",
                                ));
                            }
                            result.verify = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__predeploy => {
                            if !fields.insert(__FieldTag::__predeploy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predeploy",
                                ));
                            }
                            result.predeploy =
                                map.next_value::<std::option::Option<crate::model::Predeploy>>()?;
                        }
                        __FieldTag::__postdeploy => {
                            if !fields.insert(__FieldTag::__postdeploy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postdeploy",
                                ));
                            }
                            result.postdeploy =
                                map.next_value::<std::option::Option<crate::model::Postdeploy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CanaryDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.percentages.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("percentages", &__With(&self.percentages))?;
        }
        if !wkt::internal::is_default(&self.verify) {
            state.serialize_entry("verify", &self.verify)?;
        }
        if self.predeploy.is_some() {
            state.serialize_entry("predeploy", &self.predeploy)?;
        }
        if self.postdeploy.is_some() {
            state.serialize_entry("postdeploy", &self.postdeploy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CanaryDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CanaryDeployment");
        debug_struct.field("percentages", &self.percentages);
        debug_struct.field("verify", &self.verify);
        debug_struct.field("predeploy", &self.predeploy);
        debug_struct.field("postdeploy", &self.postdeploy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CustomCanaryDeployment represents the custom canary deployment
/// configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomCanaryDeployment {
    /// Required. Configuration for each phase in the canary deployment in the
    /// order executed.
    pub phase_configs: std::vec::Vec<crate::model::custom_canary_deployment::PhaseConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomCanaryDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phase_configs][crate::model::CustomCanaryDeployment::phase_configs].
    pub fn set_phase_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_canary_deployment::PhaseConfig>,
    {
        use std::iter::Iterator;
        self.phase_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomCanaryDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomCanaryDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomCanaryDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phase_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomCanaryDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phaseConfigs" => Ok(__FieldTag::__phase_configs),
                            "phase_configs" => Ok(__FieldTag::__phase_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomCanaryDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomCanaryDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phase_configs => {
                            if !fields.insert(__FieldTag::__phase_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_configs",
                                ));
                            }
                            result.phase_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::custom_canary_deployment::PhaseConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomCanaryDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phase_configs.is_empty() {
            state.serialize_entry("phaseConfigs", &self.phase_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomCanaryDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomCanaryDeployment");
        debug_struct.field("phase_configs", &self.phase_configs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CustomCanaryDeployment].
pub mod custom_canary_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// PhaseConfig represents the configuration for a phase in the custom
    /// canary deployment.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PhaseConfig {
        /// Required. The ID to assign to the `Rollout` phase.
        /// This value must consist of lower-case letters, numbers, and hyphens,
        /// start with a letter and end with a letter or a number, and have a max
        /// length of 63 characters. In other words, it must match the following
        /// regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        pub phase_id: std::string::String,

        /// Required. Percentage deployment for the phase.
        pub percentage: i32,

        /// Optional. Skaffold profiles to use when rendering the manifest for this
        /// phase. These are in addition to the profiles list specified in the
        /// `DeliveryPipeline` stage.
        pub profiles: std::vec::Vec<std::string::String>,

        /// Optional. Whether to run verify tests after the deployment via `skaffold
        /// verify`.
        pub verify: bool,

        /// Optional. Configuration for the predeploy job of this phase. If this is
        /// not configured, there will be no predeploy job for this phase.
        pub predeploy: std::option::Option<crate::model::Predeploy>,

        /// Optional. Configuration for the postdeploy job of this phase. If this is
        /// not configured, there will be no postdeploy job for this phase.
        pub postdeploy: std::option::Option<crate::model::Postdeploy>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PhaseConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [phase_id][crate::model::custom_canary_deployment::PhaseConfig::phase_id].
        pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.phase_id = v.into();
            self
        }

        /// Sets the value of [percentage][crate::model::custom_canary_deployment::PhaseConfig::percentage].
        pub fn set_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.percentage = v.into();
            self
        }

        /// Sets the value of [profiles][crate::model::custom_canary_deployment::PhaseConfig::profiles].
        pub fn set_profiles<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.profiles = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [verify][crate::model::custom_canary_deployment::PhaseConfig::verify].
        pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.verify = v.into();
            self
        }

        /// Sets the value of [predeploy][crate::model::custom_canary_deployment::PhaseConfig::predeploy].
        pub fn set_predeploy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Predeploy>,
        {
            self.predeploy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [predeploy][crate::model::custom_canary_deployment::PhaseConfig::predeploy].
        pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Predeploy>,
        {
            self.predeploy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [postdeploy][crate::model::custom_canary_deployment::PhaseConfig::postdeploy].
        pub fn set_postdeploy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Postdeploy>,
        {
            self.postdeploy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [postdeploy][crate::model::custom_canary_deployment::PhaseConfig::postdeploy].
        pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Postdeploy>,
        {
            self.postdeploy = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PhaseConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.CustomCanaryDeployment.PhaseConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PhaseConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __phase_id,
                __percentage,
                __profiles,
                __verify,
                __predeploy,
                __postdeploy,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PhaseConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "phaseId" => Ok(__FieldTag::__phase_id),
                                "phase_id" => Ok(__FieldTag::__phase_id),
                                "percentage" => Ok(__FieldTag::__percentage),
                                "profiles" => Ok(__FieldTag::__profiles),
                                "verify" => Ok(__FieldTag::__verify),
                                "predeploy" => Ok(__FieldTag::__predeploy),
                                "postdeploy" => Ok(__FieldTag::__postdeploy),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PhaseConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PhaseConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__phase_id => {
                                if !fields.insert(__FieldTag::__phase_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phase_id",
                                    ));
                                }
                                result.phase_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__percentage => {
                                if !fields.insert(__FieldTag::__percentage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for percentage",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.percentage =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__profiles => {
                                if !fields.insert(__FieldTag::__profiles) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for profiles",
                                    ));
                                }
                                result.profiles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__verify => {
                                if !fields.insert(__FieldTag::__verify) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for verify",
                                    ));
                                }
                                result.verify = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__predeploy => {
                                if !fields.insert(__FieldTag::__predeploy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for predeploy",
                                    ));
                                }
                                result.predeploy = map
                                    .next_value::<std::option::Option<crate::model::Predeploy>>()?;
                            }
                            __FieldTag::__postdeploy => {
                                if !fields.insert(__FieldTag::__postdeploy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for postdeploy",
                                    ));
                                }
                                result.postdeploy = map
                                    .next_value::<std::option::Option<crate::model::Postdeploy>>(
                                    )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PhaseConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.phase_id.is_empty() {
                state.serialize_entry("phaseId", &self.phase_id)?;
            }
            if !wkt::internal::is_default(&self.percentage) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("percentage", &__With(&self.percentage))?;
            }
            if !self.profiles.is_empty() {
                state.serialize_entry("profiles", &self.profiles)?;
            }
            if !wkt::internal::is_default(&self.verify) {
                state.serialize_entry("verify", &self.verify)?;
            }
            if self.predeploy.is_some() {
                state.serialize_entry("predeploy", &self.predeploy)?;
            }
            if self.postdeploy.is_some() {
                state.serialize_entry("postdeploy", &self.postdeploy)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PhaseConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PhaseConfig");
            debug_struct.field("phase_id", &self.phase_id);
            debug_struct.field("percentage", &self.percentage);
            debug_struct.field("profiles", &self.profiles);
            debug_struct.field("verify", &self.verify);
            debug_struct.field("predeploy", &self.predeploy);
            debug_struct.field("postdeploy", &self.postdeploy);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// KubernetesConfig contains the Kubernetes runtime configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesConfig {
    /// The service definition configuration.
    pub service_definition: std::option::Option<crate::model::kubernetes_config::ServiceDefinition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition].
    ///
    /// Note that all the setters affecting `service_definition` are mutually
    /// exclusive.
    pub fn set_service_definition<
        T: std::convert::Into<std::option::Option<crate::model::kubernetes_config::ServiceDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = v.into();
        self
    }

    /// The value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// if it holds a `GatewayServiceMesh`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gateway_service_mesh(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>>
    {
        #[allow(unreachable_patterns)]
        self.service_definition.as_ref().and_then(|v| match v {
            crate::model::kubernetes_config::ServiceDefinition::GatewayServiceMesh(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// to hold a `GatewayServiceMesh`.
    ///
    /// Note that all the setters affecting `service_definition` are
    /// mutually exclusive.
    pub fn set_gateway_service_mesh<
        T: std::convert::Into<std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = std::option::Option::Some(
            crate::model::kubernetes_config::ServiceDefinition::GatewayServiceMesh(v.into()),
        );
        self
    }

    /// The value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// if it holds a `ServiceNetworking`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_networking(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>>
    {
        #[allow(unreachable_patterns)]
        self.service_definition.as_ref().and_then(|v| match v {
            crate::model::kubernetes_config::ServiceDefinition::ServiceNetworking(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// to hold a `ServiceNetworking`.
    ///
    /// Note that all the setters affecting `service_definition` are
    /// mutually exclusive.
    pub fn set_service_networking<
        T: std::convert::Into<std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = std::option::Option::Some(
            crate::model::kubernetes_config::ServiceDefinition::ServiceNetworking(v.into()),
        );
        self
    }
}

impl wkt::message::Message for KubernetesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gateway_service_mesh,
            __service_networking,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gatewayServiceMesh" => Ok(__FieldTag::__gateway_service_mesh),
                            "gateway_service_mesh" => Ok(__FieldTag::__gateway_service_mesh),
                            "serviceNetworking" => Ok(__FieldTag::__service_networking),
                            "service_networking" => Ok(__FieldTag::__service_networking),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gateway_service_mesh => {
                            if !fields.insert(__FieldTag::__gateway_service_mesh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_service_mesh",
                                ));
                            }
                            if result.service_definition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `service_definition`, a oneof with full ID .google.cloud.deploy.v1.KubernetesConfig.gateway_service_mesh, latest field was gatewayServiceMesh",
                                ));
                            }
                            result.service_definition = std::option::Option::Some(
                                crate::model::kubernetes_config::ServiceDefinition::GatewayServiceMesh(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__service_networking => {
                            if !fields.insert(__FieldTag::__service_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_networking",
                                ));
                            }
                            if result.service_definition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `service_definition`, a oneof with full ID .google.cloud.deploy.v1.KubernetesConfig.service_networking, latest field was serviceNetworking",
                                ));
                            }
                            result.service_definition = std::option::Option::Some(
                                crate::model::kubernetes_config::ServiceDefinition::ServiceNetworking(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gateway_service_mesh() {
            state.serialize_entry("gatewayServiceMesh", value)?;
        }
        if let Some(value) = self.service_networking() {
            state.serialize_entry("serviceNetworking", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for KubernetesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesConfig");
        debug_struct.field("service_definition", &self.service_definition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [KubernetesConfig].
pub mod kubernetes_config {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the Kubernetes Gateway API service mesh configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GatewayServiceMesh {
        /// Required. Name of the Gateway API HTTPRoute.
        pub http_route: std::string::String,

        /// Required. Name of the Kubernetes Service.
        pub service: std::string::String,

        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified HTTPRoute and Service.
        pub deployment: std::string::String,

        /// Optional. The time to wait for route updates to propagate. The maximum
        /// configurable time is 3 hours, in seconds format. If unspecified, there is
        /// no wait time.
        pub route_update_wait_time: std::option::Option<wkt::Duration>,

        /// Optional. The amount of time to migrate traffic back from the canary
        /// Service to the original Service during the stable phase deployment. If
        /// specified, must be between 15s and 3600s. If unspecified, there is no
        /// cutback time.
        pub stable_cutback_duration: std::option::Option<wkt::Duration>,

        /// Optional. The label to use when selecting Pods for the Deployment and
        /// Service resources. This label must already be present in both resources.
        pub pod_selector_label: std::string::String,

        /// Optional. Route destinations allow configuring the Gateway API HTTPRoute
        /// to be deployed to additional clusters. This option is available for
        /// multi-cluster service mesh set ups that require the route to exist in the
        /// clusters that call the service. If unspecified, the HTTPRoute will only
        /// be deployed to the Target cluster.
        pub route_destinations: std::option::Option<
            crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GatewayServiceMesh {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [http_route][crate::model::kubernetes_config::GatewayServiceMesh::http_route].
        pub fn set_http_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.http_route = v.into();
            self
        }

        /// Sets the value of [service][crate::model::kubernetes_config::GatewayServiceMesh::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [deployment][crate::model::kubernetes_config::GatewayServiceMesh::deployment].
        pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.deployment = v.into();
            self
        }

        /// Sets the value of [route_update_wait_time][crate::model::kubernetes_config::GatewayServiceMesh::route_update_wait_time].
        pub fn set_route_update_wait_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.route_update_wait_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [route_update_wait_time][crate::model::kubernetes_config::GatewayServiceMesh::route_update_wait_time].
        pub fn set_or_clear_route_update_wait_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.route_update_wait_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stable_cutback_duration][crate::model::kubernetes_config::GatewayServiceMesh::stable_cutback_duration].
        pub fn set_stable_cutback_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.stable_cutback_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stable_cutback_duration][crate::model::kubernetes_config::GatewayServiceMesh::stable_cutback_duration].
        pub fn set_or_clear_stable_cutback_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.stable_cutback_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [pod_selector_label][crate::model::kubernetes_config::GatewayServiceMesh::pod_selector_label].
        pub fn set_pod_selector_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pod_selector_label = v.into();
            self
        }

        /// Sets the value of [route_destinations][crate::model::kubernetes_config::GatewayServiceMesh::route_destinations].
        pub fn set_route_destinations<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
                >,
        {
            self.route_destinations = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [route_destinations][crate::model::kubernetes_config::GatewayServiceMesh::route_destinations].
        pub fn set_or_clear_route_destinations<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
                >,
        {
            self.route_destinations = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GatewayServiceMesh {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.GatewayServiceMesh"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GatewayServiceMesh {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __http_route,
                __service,
                __deployment,
                __route_update_wait_time,
                __stable_cutback_duration,
                __pod_selector_label,
                __route_destinations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GatewayServiceMesh")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "httpRoute" => Ok(__FieldTag::__http_route),
                                "http_route" => Ok(__FieldTag::__http_route),
                                "service" => Ok(__FieldTag::__service),
                                "deployment" => Ok(__FieldTag::__deployment),
                                "routeUpdateWaitTime" => Ok(__FieldTag::__route_update_wait_time),
                                "route_update_wait_time" => {
                                    Ok(__FieldTag::__route_update_wait_time)
                                }
                                "stableCutbackDuration" => {
                                    Ok(__FieldTag::__stable_cutback_duration)
                                }
                                "stable_cutback_duration" => {
                                    Ok(__FieldTag::__stable_cutback_duration)
                                }
                                "podSelectorLabel" => Ok(__FieldTag::__pod_selector_label),
                                "pod_selector_label" => Ok(__FieldTag::__pod_selector_label),
                                "routeDestinations" => Ok(__FieldTag::__route_destinations),
                                "route_destinations" => Ok(__FieldTag::__route_destinations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GatewayServiceMesh;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GatewayServiceMesh")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__http_route => {
                                if !fields.insert(__FieldTag::__http_route) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for http_route",
                                    ));
                                }
                                result.http_route = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__deployment => {
                                if !fields.insert(__FieldTag::__deployment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deployment",
                                    ));
                                }
                                result.deployment = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__route_update_wait_time => {
                                if !fields.insert(__FieldTag::__route_update_wait_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for route_update_wait_time",
                                    ));
                                }
                                result.route_update_wait_time =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__stable_cutback_duration => {
                                if !fields.insert(__FieldTag::__stable_cutback_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stable_cutback_duration",
                                    ));
                                }
                                result.stable_cutback_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__pod_selector_label => {
                                if !fields.insert(__FieldTag::__pod_selector_label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pod_selector_label",
                                    ));
                                }
                                result.pod_selector_label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__route_destinations => {
                                if !fields.insert(__FieldTag::__route_destinations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for route_destinations",
                                    ));
                                }
                                result.route_destinations = map.next_value::<std::option::Option<crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GatewayServiceMesh {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.http_route.is_empty() {
                state.serialize_entry("httpRoute", &self.http_route)?;
            }
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self.deployment.is_empty() {
                state.serialize_entry("deployment", &self.deployment)?;
            }
            if self.route_update_wait_time.is_some() {
                state.serialize_entry("routeUpdateWaitTime", &self.route_update_wait_time)?;
            }
            if self.stable_cutback_duration.is_some() {
                state.serialize_entry("stableCutbackDuration", &self.stable_cutback_duration)?;
            }
            if !self.pod_selector_label.is_empty() {
                state.serialize_entry("podSelectorLabel", &self.pod_selector_label)?;
            }
            if self.route_destinations.is_some() {
                state.serialize_entry("routeDestinations", &self.route_destinations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GatewayServiceMesh {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GatewayServiceMesh");
            debug_struct.field("http_route", &self.http_route);
            debug_struct.field("service", &self.service);
            debug_struct.field("deployment", &self.deployment);
            debug_struct.field("route_update_wait_time", &self.route_update_wait_time);
            debug_struct.field("stable_cutback_duration", &self.stable_cutback_duration);
            debug_struct.field("pod_selector_label", &self.pod_selector_label);
            debug_struct.field("route_destinations", &self.route_destinations);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GatewayServiceMesh].
    pub mod gateway_service_mesh {
        #[allow(unused_imports)]
        use super::*;

        /// Information about route destinations for the Gateway API service mesh.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RouteDestinations {
            /// Required. The clusters where the Gateway API HTTPRoute resource will be
            /// deployed to. Valid entries include the associated entities IDs
            /// configured in the Target resource and "@self" to include the Target
            /// cluster.
            pub destination_ids: std::vec::Vec<std::string::String>,

            /// Optional. Whether to propagate the Kubernetes Service to the route
            /// destination clusters. The Service will always be deployed to the Target
            /// cluster even if the HTTPRoute is not. This option may be used to
            /// facilitate successful DNS lookup in the route destination clusters. Can
            /// only be set to true if destinations are specified.
            pub propagate_service: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RouteDestinations {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [destination_ids][crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations::destination_ids].
            pub fn set_destination_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.destination_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [propagate_service][crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations::propagate_service].
            pub fn set_propagate_service<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.propagate_service = v.into();
                self
            }
        }

        impl wkt::message::Message for RouteDestinations {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.GatewayServiceMesh.RouteDestinations"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RouteDestinations {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __destination_ids,
                    __propagate_service,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RouteDestinations")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "destinationIds" => Ok(__FieldTag::__destination_ids),
                                    "destination_ids" => Ok(__FieldTag::__destination_ids),
                                    "propagateService" => Ok(__FieldTag::__propagate_service),
                                    "propagate_service" => Ok(__FieldTag::__propagate_service),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RouteDestinations;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RouteDestinations")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__destination_ids => {
                                    if !fields.insert(__FieldTag::__destination_ids) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for destination_ids",
                                            ),
                                        );
                                    }
                                    result.destination_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__propagate_service => {
                                    if !fields.insert(__FieldTag::__propagate_service) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for propagate_service",
                                            ),
                                        );
                                    }
                                    result.propagate_service = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RouteDestinations {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.destination_ids.is_empty() {
                    state.serialize_entry("destinationIds", &self.destination_ids)?;
                }
                if !wkt::internal::is_default(&self.propagate_service) {
                    state.serialize_entry("propagateService", &self.propagate_service)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for RouteDestinations {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("RouteDestinations");
                debug_struct.field("destination_ids", &self.destination_ids);
                debug_struct.field("propagate_service", &self.propagate_service);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Information about the Kubernetes Service networking configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServiceNetworking {
        /// Required. Name of the Kubernetes Service.
        pub service: std::string::String,

        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified Service.
        pub deployment: std::string::String,

        /// Optional. Whether to disable Pod overprovisioning. If Pod
        /// overprovisioning is disabled then Cloud Deploy will limit the number of
        /// total Pods used for the deployment strategy to the number of Pods the
        /// Deployment has on the cluster.
        pub disable_pod_overprovisioning: bool,

        /// Optional. The label to use when selecting Pods for the Deployment
        /// resource. This label must already be present in the Deployment.
        pub pod_selector_label: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServiceNetworking {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::kubernetes_config::ServiceNetworking::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [deployment][crate::model::kubernetes_config::ServiceNetworking::deployment].
        pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.deployment = v.into();
            self
        }

        /// Sets the value of [disable_pod_overprovisioning][crate::model::kubernetes_config::ServiceNetworking::disable_pod_overprovisioning].
        pub fn set_disable_pod_overprovisioning<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_pod_overprovisioning = v.into();
            self
        }

        /// Sets the value of [pod_selector_label][crate::model::kubernetes_config::ServiceNetworking::pod_selector_label].
        pub fn set_pod_selector_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pod_selector_label = v.into();
            self
        }
    }

    impl wkt::message::Message for ServiceNetworking {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.ServiceNetworking"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServiceNetworking {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                __deployment,
                __disable_pod_overprovisioning,
                __pod_selector_label,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServiceNetworking")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                "deployment" => Ok(__FieldTag::__deployment),
                                "disablePodOverprovisioning" => {
                                    Ok(__FieldTag::__disable_pod_overprovisioning)
                                }
                                "disable_pod_overprovisioning" => {
                                    Ok(__FieldTag::__disable_pod_overprovisioning)
                                }
                                "podSelectorLabel" => Ok(__FieldTag::__pod_selector_label),
                                "pod_selector_label" => Ok(__FieldTag::__pod_selector_label),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServiceNetworking;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServiceNetworking")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__deployment => {
                                if !fields.insert(__FieldTag::__deployment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deployment",
                                    ));
                                }
                                result.deployment = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__disable_pod_overprovisioning => {
                                if !fields.insert(__FieldTag::__disable_pod_overprovisioning) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_pod_overprovisioning",
                                    ));
                                }
                                result.disable_pod_overprovisioning = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pod_selector_label => {
                                if !fields.insert(__FieldTag::__pod_selector_label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pod_selector_label",
                                    ));
                                }
                                result.pod_selector_label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServiceNetworking {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if !self.deployment.is_empty() {
                state.serialize_entry("deployment", &self.deployment)?;
            }
            if !wkt::internal::is_default(&self.disable_pod_overprovisioning) {
                state.serialize_entry(
                    "disablePodOverprovisioning",
                    &self.disable_pod_overprovisioning,
                )?;
            }
            if !self.pod_selector_label.is_empty() {
                state.serialize_entry("podSelectorLabel", &self.pod_selector_label)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ServiceNetworking {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ServiceNetworking");
            debug_struct.field("service", &self.service);
            debug_struct.field("deployment", &self.deployment);
            debug_struct.field(
                "disable_pod_overprovisioning",
                &self.disable_pod_overprovisioning,
            );
            debug_struct.field("pod_selector_label", &self.pod_selector_label);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The service definition configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServiceDefinition {
        /// Optional. Kubernetes Gateway API service mesh configuration.
        GatewayServiceMesh(std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>),
        /// Optional. Kubernetes Service networking configuration.
        ServiceNetworking(std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>),
    }
}

/// CloudRunConfig contains the Cloud Run runtime configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunConfig {
    /// Optional. Whether Cloud Deploy should update the traffic stanza in a Cloud
    /// Run Service on the user's behalf to facilitate traffic splitting. This is
    /// required to be true for CanaryDeployments, but optional for
    /// CustomCanaryDeployments.
    pub automatic_traffic_control: bool,

    /// Optional. A list of tags that are added to the canary revision while the
    /// canary phase is in progress.
    pub canary_revision_tags: std::vec::Vec<std::string::String>,

    /// Optional. A list of tags that are added to the prior revision while the
    /// canary phase is in progress.
    pub prior_revision_tags: std::vec::Vec<std::string::String>,

    /// Optional. A list of tags that are added to the final stable revision when
    /// the stable phase is applied.
    pub stable_revision_tags: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic_traffic_control][crate::model::CloudRunConfig::automatic_traffic_control].
    pub fn set_automatic_traffic_control<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.automatic_traffic_control = v.into();
        self
    }

    /// Sets the value of [canary_revision_tags][crate::model::CloudRunConfig::canary_revision_tags].
    pub fn set_canary_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.canary_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [prior_revision_tags][crate::model::CloudRunConfig::prior_revision_tags].
    pub fn set_prior_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prior_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stable_revision_tags][crate::model::CloudRunConfig::stable_revision_tags].
    pub fn set_stable_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stable_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudRunConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __automatic_traffic_control,
            __canary_revision_tags,
            __prior_revision_tags,
            __stable_revision_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "automaticTrafficControl" => {
                                Ok(__FieldTag::__automatic_traffic_control)
                            }
                            "automatic_traffic_control" => {
                                Ok(__FieldTag::__automatic_traffic_control)
                            }
                            "canaryRevisionTags" => Ok(__FieldTag::__canary_revision_tags),
                            "canary_revision_tags" => Ok(__FieldTag::__canary_revision_tags),
                            "priorRevisionTags" => Ok(__FieldTag::__prior_revision_tags),
                            "prior_revision_tags" => Ok(__FieldTag::__prior_revision_tags),
                            "stableRevisionTags" => Ok(__FieldTag::__stable_revision_tags),
                            "stable_revision_tags" => Ok(__FieldTag::__stable_revision_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__automatic_traffic_control => {
                            if !fields.insert(__FieldTag::__automatic_traffic_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic_traffic_control",
                                ));
                            }
                            result.automatic_traffic_control = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canary_revision_tags => {
                            if !fields.insert(__FieldTag::__canary_revision_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canary_revision_tags",
                                ));
                            }
                            result.canary_revision_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__prior_revision_tags => {
                            if !fields.insert(__FieldTag::__prior_revision_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prior_revision_tags",
                                ));
                            }
                            result.prior_revision_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__stable_revision_tags => {
                            if !fields.insert(__FieldTag::__stable_revision_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stable_revision_tags",
                                ));
                            }
                            result.stable_revision_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.automatic_traffic_control) {
            state.serialize_entry("automaticTrafficControl", &self.automatic_traffic_control)?;
        }
        if !self.canary_revision_tags.is_empty() {
            state.serialize_entry("canaryRevisionTags", &self.canary_revision_tags)?;
        }
        if !self.prior_revision_tags.is_empty() {
            state.serialize_entry("priorRevisionTags", &self.prior_revision_tags)?;
        }
        if !self.stable_revision_tags.is_empty() {
            state.serialize_entry("stableRevisionTags", &self.stable_revision_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunConfig");
        debug_struct.field("automatic_traffic_control", &self.automatic_traffic_control);
        debug_struct.field("canary_revision_tags", &self.canary_revision_tags);
        debug_struct.field("prior_revision_tags", &self.prior_revision_tags);
        debug_struct.field("stable_revision_tags", &self.stable_revision_tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RuntimeConfig contains the runtime specific configurations for a deployment
/// strategy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// The runtime configuration details.
    pub runtime_config: std::option::Option<crate::model::runtime_config::RuntimeConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config].
    ///
    /// Note that all the setters affecting `runtime_config` are mutually
    /// exclusive.
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::runtime_config::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// The value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// if it holds a `Kubernetes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kubernetes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KubernetesConfig>> {
        #[allow(unreachable_patterns)]
        self.runtime_config.as_ref().and_then(|v| match v {
            crate::model::runtime_config::RuntimeConfig::Kubernetes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// to hold a `Kubernetes`.
    ///
    /// Note that all the setters affecting `runtime_config` are
    /// mutually exclusive.
    pub fn set_kubernetes<
        T: std::convert::Into<std::boxed::Box<crate::model::KubernetesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = std::option::Option::Some(
            crate::model::runtime_config::RuntimeConfig::Kubernetes(v.into()),
        );
        self
    }

    /// The value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunConfig>> {
        #[allow(unreachable_patterns)]
        self.runtime_config.as_ref().and_then(|v| match v {
            crate::model::runtime_config::RuntimeConfig::CloudRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `runtime_config` are
    /// mutually exclusive.
    pub fn set_cloud_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRunConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = std::option::Option::Some(
            crate::model::runtime_config::RuntimeConfig::CloudRun(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RuntimeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kubernetes,
            __cloud_run,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kubernetes" => Ok(__FieldTag::__kubernetes),
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kubernetes => {
                            if !fields.insert(__FieldTag::__kubernetes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes",
                                ));
                            }
                            if result.runtime_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `runtime_config`, a oneof with full ID .google.cloud.deploy.v1.RuntimeConfig.kubernetes, latest field was kubernetes",
                                ));
                            }
                            result.runtime_config = std::option::Option::Some(
                                crate::model::runtime_config::RuntimeConfig::Kubernetes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::KubernetesConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            if result.runtime_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `runtime_config`, a oneof with full ID .google.cloud.deploy.v1.RuntimeConfig.cloud_run, latest field was cloudRun",
                                ));
                            }
                            result.runtime_config = std::option::Option::Some(
                                crate::model::runtime_config::RuntimeConfig::CloudRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRunConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.kubernetes() {
            state.serialize_entry("kubernetes", value)?;
        }
        if let Some(value) = self.cloud_run() {
            state.serialize_entry("cloudRun", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RuntimeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeConfig");
        debug_struct.field("runtime_config", &self.runtime_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RuntimeConfig].
pub mod runtime_config {
    #[allow(unused_imports)]
    use super::*;

    /// The runtime configuration details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuntimeConfig {
        /// Optional. Kubernetes runtime configuration.
        Kubernetes(std::boxed::Box<crate::model::KubernetesConfig>),
        /// Optional. Cloud Run runtime configuration.
        CloudRun(std::boxed::Box<crate::model::CloudRunConfig>),
    }
}

/// PipelineReadyCondition contains information around the status of the
/// Pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PipelineReadyCondition {
    /// True if the Pipeline is in a valid state. Otherwise at least one condition
    /// in `PipelineCondition` is in an invalid state. Iterate over those
    /// conditions and see which condition(s) has status = false to find out what
    /// is wrong with the Pipeline.
    pub status: bool,

    /// Last time the condition was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PipelineReadyCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::PipelineReadyCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PipelineReadyCondition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PipelineReadyCondition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PipelineReadyCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PipelineReadyCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PipelineReadyCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PipelineReadyCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PipelineReadyCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PipelineReadyCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PipelineReadyCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PipelineReadyCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PipelineReadyCondition");
        debug_struct.field("status", &self.status);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// `TargetsPresentCondition` contains information on any Targets referenced in
/// the Delivery Pipeline that do not actually exist.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetsPresentCondition {
    /// True if there aren't any missing Targets.
    pub status: bool,

    /// The list of Target names that do not exist. For example,
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    pub missing_targets: std::vec::Vec<std::string::String>,

    /// Last time the condition was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetsPresentCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TargetsPresentCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [missing_targets][crate::model::TargetsPresentCondition::missing_targets].
    pub fn set_missing_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::TargetsPresentCondition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetsPresentCondition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetsPresentCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetsPresentCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetsPresentCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __missing_targets,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetsPresentCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "missingTargets" => Ok(__FieldTag::__missing_targets),
                            "missing_targets" => Ok(__FieldTag::__missing_targets),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetsPresentCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetsPresentCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__missing_targets => {
                            if !fields.insert(__FieldTag::__missing_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_targets",
                                ));
                            }
                            result.missing_targets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetsPresentCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.missing_targets.is_empty() {
            state.serialize_entry("missingTargets", &self.missing_targets)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetsPresentCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetsPresentCondition");
        debug_struct.field("status", &self.status);
        debug_struct.field("missing_targets", &self.missing_targets);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TargetsTypeCondition contains information on whether the Targets defined in
/// the Delivery Pipeline are of the same type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetsTypeCondition {
    /// True if the targets are all a comparable type. For example this is true if
    /// all targets are GKE clusters. This is false if some targets are Cloud Run
    /// targets and others are GKE clusters.
    pub status: bool,

    /// Human readable error message.
    pub error_details: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetsTypeCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TargetsTypeCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [error_details][crate::model::TargetsTypeCondition::error_details].
    pub fn set_error_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_details = v.into();
        self
    }
}

impl wkt::message::Message for TargetsTypeCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetsTypeCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetsTypeCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __error_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetsTypeCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "errorDetails" => Ok(__FieldTag::__error_details),
                            "error_details" => Ok(__FieldTag::__error_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetsTypeCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetsTypeCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_details => {
                            if !fields.insert(__FieldTag::__error_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_details",
                                ));
                            }
                            result.error_details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetsTypeCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetsTypeCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetsTypeCondition");
        debug_struct.field("status", &self.status);
        debug_struct.field("error_details", &self.error_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PipelineCondition contains all conditions relevant to a Delivery Pipeline.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PipelineCondition {
    /// Details around the Pipeline's overall status.
    pub pipeline_ready_condition: std::option::Option<crate::model::PipelineReadyCondition>,

    /// Details around targets enumerated in the pipeline.
    pub targets_present_condition: std::option::Option<crate::model::TargetsPresentCondition>,

    /// Details on the whether the targets enumerated in the pipeline are of the
    /// same type.
    pub targets_type_condition: std::option::Option<crate::model::TargetsTypeCondition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PipelineCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_ready_condition][crate::model::PipelineCondition::pipeline_ready_condition].
    pub fn set_pipeline_ready_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PipelineReadyCondition>,
    {
        self.pipeline_ready_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pipeline_ready_condition][crate::model::PipelineCondition::pipeline_ready_condition].
    pub fn set_or_clear_pipeline_ready_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PipelineReadyCondition>,
    {
        self.pipeline_ready_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_present_condition][crate::model::PipelineCondition::targets_present_condition].
    pub fn set_targets_present_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_present_condition][crate::model::PipelineCondition::targets_present_condition].
    pub fn set_or_clear_targets_present_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_type_condition][crate::model::PipelineCondition::targets_type_condition].
    pub fn set_targets_type_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsTypeCondition>,
    {
        self.targets_type_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_type_condition][crate::model::PipelineCondition::targets_type_condition].
    pub fn set_or_clear_targets_type_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsTypeCondition>,
    {
        self.targets_type_condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PipelineCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PipelineCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PipelineCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pipeline_ready_condition,
            __targets_present_condition,
            __targets_type_condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PipelineCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pipelineReadyCondition" => Ok(__FieldTag::__pipeline_ready_condition),
                            "pipeline_ready_condition" => {
                                Ok(__FieldTag::__pipeline_ready_condition)
                            }
                            "targetsPresentCondition" => {
                                Ok(__FieldTag::__targets_present_condition)
                            }
                            "targets_present_condition" => {
                                Ok(__FieldTag::__targets_present_condition)
                            }
                            "targetsTypeCondition" => Ok(__FieldTag::__targets_type_condition),
                            "targets_type_condition" => Ok(__FieldTag::__targets_type_condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PipelineCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PipelineCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pipeline_ready_condition => {
                            if !fields.insert(__FieldTag::__pipeline_ready_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_ready_condition",
                                ));
                            }
                            result.pipeline_ready_condition = map.next_value::<std::option::Option<crate::model::PipelineReadyCondition>>()?
                                ;
                        }
                        __FieldTag::__targets_present_condition => {
                            if !fields.insert(__FieldTag::__targets_present_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets_present_condition",
                                ));
                            }
                            result.targets_present_condition = map.next_value::<std::option::Option<crate::model::TargetsPresentCondition>>()?
                                ;
                        }
                        __FieldTag::__targets_type_condition => {
                            if !fields.insert(__FieldTag::__targets_type_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets_type_condition",
                                ));
                            }
                            result.targets_type_condition = map.next_value::<std::option::Option<crate::model::TargetsTypeCondition>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PipelineCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.pipeline_ready_condition.is_some() {
            state.serialize_entry("pipelineReadyCondition", &self.pipeline_ready_condition)?;
        }
        if self.targets_present_condition.is_some() {
            state.serialize_entry("targetsPresentCondition", &self.targets_present_condition)?;
        }
        if self.targets_type_condition.is_some() {
            state.serialize_entry("targetsTypeCondition", &self.targets_type_condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PipelineCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PipelineCondition");
        debug_struct.field("pipeline_ready_condition", &self.pipeline_ready_condition);
        debug_struct.field("targets_present_condition", &self.targets_present_condition);
        debug_struct.field("targets_type_condition", &self.targets_type_condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListDeliveryPipelines`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeliveryPipelinesRequest {
    /// Required. The parent, which owns this collection of pipelines. Format must
    /// be `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// The maximum number of pipelines to return. The service may return
    /// fewer than this value. If unspecified, at most 50 pipelines will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListDeliveryPipelines` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter pipelines to be returned. See <https://google.aip.dev/160> for more
    /// details.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeliveryPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeliveryPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeliveryPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeliveryPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeliveryPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeliveryPipelinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDeliveryPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeliveryPipelinesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeliveryPipelinesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeliveryPipelinesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeliveryPipelinesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeliveryPipelinesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeliveryPipelinesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeliveryPipelinesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeliveryPipelinesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListDeliveryPipelines`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeliveryPipelinesResponse {
    /// The `DeliveryPipeline` objects.
    pub delivery_pipelines: std::vec::Vec<crate::model::DeliveryPipeline>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeliveryPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [delivery_pipelines][crate::model::ListDeliveryPipelinesResponse::delivery_pipelines].
    pub fn set_delivery_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        use std::iter::Iterator;
        self.delivery_pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeliveryPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDeliveryPipelinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeliveryPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeliveryPipelinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeliveryPipelinesResponse {
    type PageItem = crate::model::DeliveryPipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.delivery_pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeliveryPipelinesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __delivery_pipelines,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeliveryPipelinesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deliveryPipelines" => Ok(__FieldTag::__delivery_pipelines),
                            "delivery_pipelines" => Ok(__FieldTag::__delivery_pipelines),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeliveryPipelinesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeliveryPipelinesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__delivery_pipelines => {
                            if !fields.insert(__FieldTag::__delivery_pipelines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipelines",
                                ));
                            }
                            result.delivery_pipelines =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DeliveryPipeline>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeliveryPipelinesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.delivery_pipelines.is_empty() {
            state.serialize_entry("deliveryPipelines", &self.delivery_pipelines)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeliveryPipelinesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeliveryPipelinesResponse");
        debug_struct.field("delivery_pipelines", &self.delivery_pipelines);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetDeliveryPipeline`
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeliveryPipelineRequest {
    /// Required. Name of the `DeliveryPipeline`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeliveryPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetDeliveryPipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeliveryPipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeliveryPipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeliveryPipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeliveryPipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDeliveryPipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDeliveryPipelineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDeliveryPipelineRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `CreateDeliveryPipeline`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDeliveryPipelineRequest {
    /// Required. The parent collection in which the `DeliveryPipeline` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `DeliveryPipeline`.
    pub delivery_pipeline_id: std::string::String,

    /// Required. The `DeliveryPipeline` to create.
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipeline>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeliveryPipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline_id][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline_id].
    pub fn set_delivery_pipeline_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline_id = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateDeliveryPipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDeliveryPipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __delivery_pipeline_id,
            __delivery_pipeline,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeliveryPipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deliveryPipelineId" => Ok(__FieldTag::__delivery_pipeline_id),
                            "delivery_pipeline_id" => Ok(__FieldTag::__delivery_pipeline_id),
                            "deliveryPipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "delivery_pipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDeliveryPipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeliveryPipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delivery_pipeline_id => {
                            if !fields.insert(__FieldTag::__delivery_pipeline_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline_id",
                                ));
                            }
                            result.delivery_pipeline_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delivery_pipeline => {
                            if !fields.insert(__FieldTag::__delivery_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline",
                                ));
                            }
                            result.delivery_pipeline = map
                                .next_value::<std::option::Option<crate::model::DeliveryPipeline>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDeliveryPipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.delivery_pipeline_id.is_empty() {
            state.serialize_entry("deliveryPipelineId", &self.delivery_pipeline_id)?;
        }
        if self.delivery_pipeline.is_some() {
            state.serialize_entry("deliveryPipeline", &self.delivery_pipeline)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDeliveryPipelineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDeliveryPipelineRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("delivery_pipeline_id", &self.delivery_pipeline_id);
        debug_struct.field("delivery_pipeline", &self.delivery_pipeline);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `UpdateDeliveryPipeline`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDeliveryPipelineRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `DeliveryPipeline` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `DeliveryPipeline` to update.
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipeline>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `DeliveryPipeline` that does not exist
    /// will result in the creation of a new `DeliveryPipeline`.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeliveryPipelineRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeliveryPipelineRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::UpdateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::UpdateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDeliveryPipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateDeliveryPipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDeliveryPipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __delivery_pipeline,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeliveryPipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "deliveryPipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "delivery_pipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDeliveryPipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeliveryPipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__delivery_pipeline => {
                            if !fields.insert(__FieldTag::__delivery_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline",
                                ));
                            }
                            result.delivery_pipeline = map
                                .next_value::<std::option::Option<crate::model::DeliveryPipeline>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDeliveryPipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.delivery_pipeline.is_some() {
            state.serialize_entry("deliveryPipeline", &self.delivery_pipeline)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDeliveryPipelineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDeliveryPipelineRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("delivery_pipeline", &self.delivery_pipeline);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `DeleteDeliveryPipeline`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDeliveryPipelineRequest {
    /// Required. The name of the `DeliveryPipeline` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `DeliveryPipeline` will succeed.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    pub validate_only: bool,

    /// Optional. If set to true, all child resources under this pipeline will also
    /// be deleted. Otherwise, the request will only work if the pipeline has no
    /// child resources.
    pub force: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeliveryPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteDeliveryPipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteDeliveryPipelineRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDeliveryPipelineRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteDeliveryPipelineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDeliveryPipelineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __allow_missing,
            __validate_only,
            __force,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDeliveryPipelineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDeliveryPipelineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDeliveryPipelineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDeliveryPipelineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDeliveryPipelineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDeliveryPipelineRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("force", &self.force);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configs for the Rollback rollout.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackTargetConfig {
    /// Optional. The rollback `Rollout` to create.
    pub rollout: std::option::Option<crate::model::Rollout>,

    /// Optional. The starting phase ID for the `Rollout`. If unspecified, the
    /// `Rollout` will start in the stable phase.
    pub starting_phase_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RollbackTargetConfig::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::RollbackTargetConfig::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [starting_phase_id][crate::model::RollbackTargetConfig::starting_phase_id].
    pub fn set_starting_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.starting_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackTargetConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackTargetConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __starting_phase_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackTargetConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "startingPhaseId" => Ok(__FieldTag::__starting_phase_id),
                            "starting_phase_id" => Ok(__FieldTag::__starting_phase_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackTargetConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackTargetConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout =
                                map.next_value::<std::option::Option<crate::model::Rollout>>()?;
                        }
                        __FieldTag::__starting_phase_id => {
                            if !fields.insert(__FieldTag::__starting_phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for starting_phase_id",
                                ));
                            }
                            result.starting_phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackTargetConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.starting_phase_id.is_empty() {
            state.serialize_entry("startingPhaseId", &self.starting_phase_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackTargetConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackTargetConfig");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("starting_phase_id", &self.starting_phase_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `RollbackTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackTargetRequest {
    /// Required. The `DeliveryPipeline` for which the rollback `Rollout` must be
    /// created. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub name: std::string::String,

    /// Required. ID of the `Target` that is being rolled back.
    pub target_id: std::string::String,

    /// Required. ID of the rollback `Rollout` to create.
    pub rollout_id: std::string::String,

    /// Optional. ID of the `Release` to roll back to. If this isn't specified, the
    /// previous successful `Rollout` to the specified target will be used to
    /// determine the `Release`.
    pub release_id: std::string::String,

    /// Optional. If provided, this must be the latest `Rollout` that is on the
    /// `Target`.
    pub rollout_to_roll_back: std::string::String,

    /// Optional. Configs for the rollback `Rollout`.
    pub rollback_config: std::option::Option<crate::model::RollbackTargetConfig>,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with a `RollbackTargetResponse`.
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deploy_policy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RollbackTargetRequest::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::RollbackTargetRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [release_id][crate::model::RollbackTargetRequest::release_id].
    pub fn set_release_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_id = v.into();
        self
    }

    /// Sets the value of [rollout_to_roll_back][crate::model::RollbackTargetRequest::rollout_to_roll_back].
    pub fn set_rollout_to_roll_back<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_to_roll_back = v.into();
        self
    }

    /// Sets the value of [rollback_config][crate::model::RollbackTargetRequest::rollback_config].
    pub fn set_rollback_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollback_config][crate::model::RollbackTargetRequest::rollback_config].
    pub fn set_or_clear_rollback_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::RollbackTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::RollbackTargetRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RollbackTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackTargetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_id,
            __rollout_id,
            __release_id,
            __rollout_to_roll_back,
            __rollback_config,
            __validate_only,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackTargetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "rolloutId" => Ok(__FieldTag::__rollout_id),
                            "rollout_id" => Ok(__FieldTag::__rollout_id),
                            "releaseId" => Ok(__FieldTag::__release_id),
                            "release_id" => Ok(__FieldTag::__release_id),
                            "rolloutToRollBack" => Ok(__FieldTag::__rollout_to_roll_back),
                            "rollout_to_roll_back" => Ok(__FieldTag::__rollout_to_roll_back),
                            "rollbackConfig" => Ok(__FieldTag::__rollback_config),
                            "rollback_config" => Ok(__FieldTag::__rollback_config),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackTargetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackTargetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_id => {
                            if !fields.insert(__FieldTag::__rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_id",
                                ));
                            }
                            result.rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_id => {
                            if !fields.insert(__FieldTag::__release_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_id",
                                ));
                            }
                            result.release_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_to_roll_back => {
                            if !fields.insert(__FieldTag::__rollout_to_roll_back) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_to_roll_back",
                                ));
                            }
                            result.rollout_to_roll_back = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollback_config => {
                            if !fields.insert(__FieldTag::__rollback_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollback_config",
                                ));
                            }
                            result.rollback_config = map.next_value::<std::option::Option<crate::model::RollbackTargetConfig>>()?
                                ;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackTargetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !self.rollout_id.is_empty() {
            state.serialize_entry("rolloutId", &self.rollout_id)?;
        }
        if !self.release_id.is_empty() {
            state.serialize_entry("releaseId", &self.release_id)?;
        }
        if !self.rollout_to_roll_back.is_empty() {
            state.serialize_entry("rolloutToRollBack", &self.rollout_to_roll_back)?;
        }
        if self.rollback_config.is_some() {
            state.serialize_entry("rollbackConfig", &self.rollback_config)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackTargetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackTargetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("rollout_id", &self.rollout_id);
        debug_struct.field("release_id", &self.release_id);
        debug_struct.field("rollout_to_roll_back", &self.rollout_to_roll_back);
        debug_struct.field("rollback_config", &self.rollback_config);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `RollbackTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackTargetResponse {
    /// The config of the rollback `Rollout` created or will be created.
    pub rollback_config: std::option::Option<crate::model::RollbackTargetConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollback_config][crate::model::RollbackTargetResponse::rollback_config].
    pub fn set_rollback_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollback_config][crate::model::RollbackTargetResponse::rollback_config].
    pub fn set_or_clear_rollback_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RollbackTargetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackTargetResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollback_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackTargetResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollbackConfig" => Ok(__FieldTag::__rollback_config),
                            "rollback_config" => Ok(__FieldTag::__rollback_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackTargetResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackTargetResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollback_config => {
                            if !fields.insert(__FieldTag::__rollback_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollback_config",
                                ));
                            }
                            result.rollback_config = map.next_value::<std::option::Option<crate::model::RollbackTargetConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackTargetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rollback_config.is_some() {
            state.serialize_entry("rollbackConfig", &self.rollback_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackTargetResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackTargetResponse");
        debug_struct.field("rollback_config", &self.rollback_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `Target` resource in the Cloud Deploy API.
///
/// A `Target` defines a location to which a Skaffold configuration
/// can be deployed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Target {
    /// Identifier. Name of the `Target`. Format is
    /// `projects/{project}/locations/{location}/targets/{target}`.
    /// The `target` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Resource id of the `Target`.
    pub target_id: std::string::String,

    /// Output only. Unique identifier of the `Target`.
    pub uid: std::string::String,

    /// Optional. Description of the `Target`. Max length is 255 characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Whether or not the `Target` requires approval.
    pub require_approval: bool,

    /// Output only. Time at which the `Target` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the `Target` was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Map of entity IDs to their associated entities. Associated
    /// entities allows specifying places other than the deployment target for
    /// specific features. For example, the Gateway API canary can be configured to
    /// deploy the HTTPRoute to a different cluster(s) than the deployment cluster
    /// using associated entities. An entity ID must consist of lower-case letters,
    /// numbers, and hyphens, start with a letter and end with a letter or a
    /// number, and have a max length of 63 characters. In other words, it must
    /// match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    pub associated_entities:
        std::collections::HashMap<std::string::String, crate::model::AssociatedEntities>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Configurations for all execution that relates to this `Target`.
    /// Each `ExecutionEnvironmentUsage` value may only be used in a single
    /// configuration; using the same value multiple times is an error.
    /// When one or more configurations are specified, they must include the
    /// `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values.
    /// When no configurations are specified, execution will use the default
    /// specified in `DefaultPool`.
    pub execution_configs: std::vec::Vec<crate::model::ExecutionConfig>,

    /// Optional. The deploy parameters to use for this target.
    pub deploy_parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    pub deployment_target: std::option::Option<crate::model::target::DeploymentTarget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Target {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Target::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::Target::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Target::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Target::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Target::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Target::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [require_approval][crate::model::Target::require_approval].
    pub fn set_require_approval<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_approval = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Target::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Target::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Target::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Target::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [associated_entities][crate::model::Target::associated_entities].
    pub fn set_associated_entities<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AssociatedEntities>,
    {
        use std::iter::Iterator;
        self.associated_entities = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Target::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [execution_configs][crate::model::Target::execution_configs].
    pub fn set_execution_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExecutionConfig>,
    {
        use std::iter::Iterator;
        self.execution_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Target::deploy_parameters].
    pub fn set_deploy_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target].
    ///
    /// Note that all the setters affecting `deployment_target` are mutually
    /// exclusive.
    pub fn set_deployment_target<
        T: std::convert::Into<std::option::Option<crate::model::target::DeploymentTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = v.into();
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `Gke`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke(&self) -> std::option::Option<&std::boxed::Box<crate::model::GkeCluster>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::Gke(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `Gke`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_gke<T: std::convert::Into<std::boxed::Box<crate::model::GkeCluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target =
            std::option::Option::Some(crate::model::target::DeploymentTarget::Gke(v.into()));
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `AnthosCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn anthos_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AnthosCluster>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::AnthosCluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `AnthosCluster`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_anthos_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::AnthosCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::AnthosCluster(v.into()),
        );
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `Run`, `None` if the field is not set or
    /// holds a different branch.
    pub fn run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunLocation>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::Run(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `Run`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRunLocation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target =
            std::option::Option::Some(crate::model::target::DeploymentTarget::Run(v.into()));
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `MultiTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_target(&self) -> std::option::Option<&std::boxed::Box<crate::model::MultiTarget>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::MultiTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `MultiTarget`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_multi_target<T: std::convert::Into<std::boxed::Box<crate::model::MultiTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::MultiTarget(v.into()),
        );
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `CustomTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomTarget>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::CustomTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `CustomTarget`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_custom_target<T: std::convert::Into<std::boxed::Box<crate::model::CustomTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::CustomTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Target {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Target"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Target {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_id,
            __uid,
            __description,
            __annotations,
            __labels,
            __require_approval,
            __create_time,
            __update_time,
            __gke,
            __anthos_cluster,
            __run,
            __multi_target,
            __custom_target,
            __associated_entities,
            __etag,
            __execution_configs,
            __deploy_parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Target")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "requireApproval" => Ok(__FieldTag::__require_approval),
                            "require_approval" => Ok(__FieldTag::__require_approval),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "gke" => Ok(__FieldTag::__gke),
                            "anthosCluster" => Ok(__FieldTag::__anthos_cluster),
                            "anthos_cluster" => Ok(__FieldTag::__anthos_cluster),
                            "run" => Ok(__FieldTag::__run),
                            "multiTarget" => Ok(__FieldTag::__multi_target),
                            "multi_target" => Ok(__FieldTag::__multi_target),
                            "customTarget" => Ok(__FieldTag::__custom_target),
                            "custom_target" => Ok(__FieldTag::__custom_target),
                            "associatedEntities" => Ok(__FieldTag::__associated_entities),
                            "associated_entities" => Ok(__FieldTag::__associated_entities),
                            "etag" => Ok(__FieldTag::__etag),
                            "executionConfigs" => Ok(__FieldTag::__execution_configs),
                            "execution_configs" => Ok(__FieldTag::__execution_configs),
                            "deployParameters" => Ok(__FieldTag::__deploy_parameters),
                            "deploy_parameters" => Ok(__FieldTag::__deploy_parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Target;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Target")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__require_approval => {
                            if !fields.insert(__FieldTag::__require_approval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_approval",
                                ));
                            }
                            result.require_approval = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__gke => {
                            if !fields.insert(__FieldTag::__gke) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke",
                                ));
                            }
                            if result.deployment_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_target`, a oneof with full ID .google.cloud.deploy.v1.Target.gke, latest field was gke",
                                ));
                            }
                            result.deployment_target = std::option::Option::Some(
                                crate::model::target::DeploymentTarget::Gke(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GkeCluster>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__anthos_cluster => {
                            if !fields.insert(__FieldTag::__anthos_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anthos_cluster",
                                ));
                            }
                            if result.deployment_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_target`, a oneof with full ID .google.cloud.deploy.v1.Target.anthos_cluster, latest field was anthosCluster",
                                ));
                            }
                            result.deployment_target = std::option::Option::Some(
                                crate::model::target::DeploymentTarget::AnthosCluster(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AnthosCluster>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__run => {
                            if !fields.insert(__FieldTag::__run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run",
                                ));
                            }
                            if result.deployment_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_target`, a oneof with full ID .google.cloud.deploy.v1.Target.run, latest field was run",
                                ));
                            }
                            result.deployment_target = std::option::Option::Some(
                                crate::model::target::DeploymentTarget::Run(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudRunLocation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_target => {
                            if !fields.insert(__FieldTag::__multi_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_target",
                                ));
                            }
                            if result.deployment_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_target`, a oneof with full ID .google.cloud.deploy.v1.Target.multi_target, latest field was multiTarget",
                                ));
                            }
                            result.deployment_target = std::option::Option::Some(
                                crate::model::target::DeploymentTarget::MultiTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MultiTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__custom_target => {
                            if !fields.insert(__FieldTag::__custom_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target",
                                ));
                            }
                            if result.deployment_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `deployment_target`, a oneof with full ID .google.cloud.deploy.v1.Target.custom_target, latest field was customTarget",
                                ));
                            }
                            result.deployment_target = std::option::Option::Some(
                                crate::model::target::DeploymentTarget::CustomTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CustomTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__associated_entities => {
                            if !fields.insert(__FieldTag::__associated_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for associated_entities",
                                ));
                            }
                            result.associated_entities = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::AssociatedEntities,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_configs => {
                            if !fields.insert(__FieldTag::__execution_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_configs",
                                ));
                            }
                            result.execution_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExecutionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_parameters => {
                            if !fields.insert(__FieldTag::__deploy_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_parameters",
                                ));
                            }
                            result.deploy_parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Target {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.require_approval) {
            state.serialize_entry("requireApproval", &self.require_approval)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if let Some(value) = self.gke() {
            state.serialize_entry("gke", value)?;
        }
        if let Some(value) = self.anthos_cluster() {
            state.serialize_entry("anthosCluster", value)?;
        }
        if let Some(value) = self.run() {
            state.serialize_entry("run", value)?;
        }
        if let Some(value) = self.multi_target() {
            state.serialize_entry("multiTarget", value)?;
        }
        if let Some(value) = self.custom_target() {
            state.serialize_entry("customTarget", value)?;
        }
        if !self.associated_entities.is_empty() {
            state.serialize_entry("associatedEntities", &self.associated_entities)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.execution_configs.is_empty() {
            state.serialize_entry("executionConfigs", &self.execution_configs)?;
        }
        if !self.deploy_parameters.is_empty() {
            state.serialize_entry("deployParameters", &self.deploy_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Target {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Target");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("require_approval", &self.require_approval);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("associated_entities", &self.associated_entities);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("execution_configs", &self.execution_configs);
        debug_struct.field("deploy_parameters", &self.deploy_parameters);
        debug_struct.field("deployment_target", &self.deployment_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Target].
pub mod target {
    #[allow(unused_imports)]
    use super::*;

    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeploymentTarget {
        /// Optional. Information specifying a GKE Cluster.
        Gke(std::boxed::Box<crate::model::GkeCluster>),
        /// Optional. Information specifying an Anthos Cluster.
        AnthosCluster(std::boxed::Box<crate::model::AnthosCluster>),
        /// Optional. Information specifying a Cloud Run deployment target.
        Run(std::boxed::Box<crate::model::CloudRunLocation>),
        /// Optional. Information specifying a multiTarget.
        MultiTarget(std::boxed::Box<crate::model::MultiTarget>),
        /// Optional. Information specifying a Custom Target.
        CustomTarget(std::boxed::Box<crate::model::CustomTarget>),
    }
}

/// Configuration of the environment to use when calling Skaffold.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionConfig {
    /// Required. Usages when this configuration should be applied.
    pub usages: std::vec::Vec<crate::model::execution_config::ExecutionEnvironmentUsage>,

    /// Optional. The resource name of the `WorkerPool`, with the format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// If this optional field is unspecified, the default Cloud Build pool will be
    /// used.
    pub worker_pool: std::string::String,

    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) is used.
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location in which to store execution outputs. This
    /// can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    pub artifact_storage: std::string::String,

    /// Optional. Execution timeout for a Cloud Build Execution. This must be
    /// between 10m and 24h in seconds format. If unspecified, a default timeout of
    /// 1h is used.
    pub execution_timeout: std::option::Option<wkt::Duration>,

    /// Optional. If true, additional logging will be enabled when running builds
    /// in this execution environment.
    pub verbose: bool,

    /// Details of the environment.
    pub execution_environment:
        std::option::Option<crate::model::execution_config::ExecutionEnvironment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [usages][crate::model::ExecutionConfig::usages].
    pub fn set_usages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::execution_config::ExecutionEnvironmentUsage>,
    {
        use std::iter::Iterator;
        self.usages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [worker_pool][crate::model::ExecutionConfig::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::ExecutionConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::ExecutionConfig::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::ExecutionConfig::execution_timeout].
    pub fn set_execution_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_timeout][crate::model::ExecutionConfig::execution_timeout].
    pub fn set_or_clear_execution_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verbose][crate::model::ExecutionConfig::verbose].
    pub fn set_verbose<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verbose = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment].
    ///
    /// Note that all the setters affecting `execution_environment` are mutually
    /// exclusive.
    pub fn set_execution_environment<
        T: std::convert::Into<
                std::option::Option<crate::model::execution_config::ExecutionEnvironment>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// The value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// if it holds a `DefaultPool`, `None` if the field is not set or
    /// holds a different branch.
    pub fn default_pool(&self) -> std::option::Option<&std::boxed::Box<crate::model::DefaultPool>> {
        #[allow(unreachable_patterns)]
        self.execution_environment.as_ref().and_then(|v| match v {
            crate::model::execution_config::ExecutionEnvironment::DefaultPool(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// to hold a `DefaultPool`.
    ///
    /// Note that all the setters affecting `execution_environment` are
    /// mutually exclusive.
    pub fn set_default_pool<T: std::convert::Into<std::boxed::Box<crate::model::DefaultPool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = std::option::Option::Some(
            crate::model::execution_config::ExecutionEnvironment::DefaultPool(v.into()),
        );
        self
    }

    /// The value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// if it holds a `PrivatePool`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_pool(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrivatePool>> {
        #[allow(unreachable_patterns)]
        self.execution_environment.as_ref().and_then(|v| match v {
            crate::model::execution_config::ExecutionEnvironment::PrivatePool(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// to hold a `PrivatePool`.
    ///
    /// Note that all the setters affecting `execution_environment` are
    /// mutually exclusive.
    pub fn set_private_pool<T: std::convert::Into<std::boxed::Box<crate::model::PrivatePool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = std::option::Option::Some(
            crate::model::execution_config::ExecutionEnvironment::PrivatePool(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecutionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ExecutionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __usages,
            __default_pool,
            __private_pool,
            __worker_pool,
            __service_account,
            __artifact_storage,
            __execution_timeout,
            __verbose,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "usages" => Ok(__FieldTag::__usages),
                            "defaultPool" => Ok(__FieldTag::__default_pool),
                            "default_pool" => Ok(__FieldTag::__default_pool),
                            "privatePool" => Ok(__FieldTag::__private_pool),
                            "private_pool" => Ok(__FieldTag::__private_pool),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "artifactStorage" => Ok(__FieldTag::__artifact_storage),
                            "artifact_storage" => Ok(__FieldTag::__artifact_storage),
                            "executionTimeout" => Ok(__FieldTag::__execution_timeout),
                            "execution_timeout" => Ok(__FieldTag::__execution_timeout),
                            "verbose" => Ok(__FieldTag::__verbose),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__usages => {
                            if !fields.insert(__FieldTag::__usages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usages",
                                ));
                            }
                            result.usages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::execution_config::ExecutionEnvironmentUsage,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_pool => {
                            if !fields.insert(__FieldTag::__default_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_pool",
                                ));
                            }
                            if result.execution_environment.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `execution_environment`, a oneof with full ID .google.cloud.deploy.v1.ExecutionConfig.default_pool, latest field was defaultPool",
                                ));
                            }
                            result.execution_environment = std::option::Option::Some(
                                crate::model::execution_config::ExecutionEnvironment::DefaultPool(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DefaultPool>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__private_pool => {
                            if !fields.insert(__FieldTag::__private_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_pool",
                                ));
                            }
                            if result.execution_environment.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `execution_environment`, a oneof with full ID .google.cloud.deploy.v1.ExecutionConfig.private_pool, latest field was privatePool",
                                ));
                            }
                            result.execution_environment = std::option::Option::Some(
                                crate::model::execution_config::ExecutionEnvironment::PrivatePool(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrivatePool>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_storage => {
                            if !fields.insert(__FieldTag::__artifact_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_storage",
                                ));
                            }
                            result.artifact_storage = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_timeout => {
                            if !fields.insert(__FieldTag::__execution_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_timeout",
                                ));
                            }
                            result.execution_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__verbose => {
                            if !fields.insert(__FieldTag::__verbose) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verbose",
                                ));
                            }
                            result.verbose = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.usages.is_empty() {
            state.serialize_entry("usages", &self.usages)?;
        }
        if let Some(value) = self.default_pool() {
            state.serialize_entry("defaultPool", value)?;
        }
        if let Some(value) = self.private_pool() {
            state.serialize_entry("privatePool", value)?;
        }
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.artifact_storage.is_empty() {
            state.serialize_entry("artifactStorage", &self.artifact_storage)?;
        }
        if self.execution_timeout.is_some() {
            state.serialize_entry("executionTimeout", &self.execution_timeout)?;
        }
        if !wkt::internal::is_default(&self.verbose) {
            state.serialize_entry("verbose", &self.verbose)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExecutionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionConfig");
        debug_struct.field("usages", &self.usages);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("artifact_storage", &self.artifact_storage);
        debug_struct.field("execution_timeout", &self.execution_timeout);
        debug_struct.field("verbose", &self.verbose);
        debug_struct.field("execution_environment", &self.execution_environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExecutionConfig].
pub mod execution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible usages of this configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionEnvironmentUsage {
        /// Default value. This value is unused.
        Unspecified,
        /// Use for rendering.
        Render,
        /// Use for deploying and deployment hooks.
        Deploy,
        /// Use for deployment verification.
        Verify,
        /// Use for predeploy job execution.
        Predeploy,
        /// Use for postdeploy job execution.
        Postdeploy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionEnvironmentUsage::value] or
        /// [ExecutionEnvironmentUsage::name].
        UnknownValue(execution_environment_usage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_environment_usage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionEnvironmentUsage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Render => std::option::Option::Some(1),
                Self::Deploy => std::option::Option::Some(2),
                Self::Verify => std::option::Option::Some(3),
                Self::Predeploy => std::option::Option::Some(4),
                Self::Postdeploy => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED")
                }
                Self::Render => std::option::Option::Some("RENDER"),
                Self::Deploy => std::option::Option::Some("DEPLOY"),
                Self::Verify => std::option::Option::Some("VERIFY"),
                Self::Predeploy => std::option::Option::Some("PREDEPLOY"),
                Self::Postdeploy => std::option::Option::Some("POSTDEPLOY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionEnvironmentUsage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionEnvironmentUsage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionEnvironmentUsage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Render,
                2 => Self::Deploy,
                3 => Self::Verify,
                4 => Self::Predeploy,
                5 => Self::Postdeploy,
                _ => Self::UnknownValue(execution_environment_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionEnvironmentUsage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED" => Self::Unspecified,
                "RENDER" => Self::Render,
                "DEPLOY" => Self::Deploy,
                "VERIFY" => Self::Verify,
                "PREDEPLOY" => Self::Predeploy,
                "POSTDEPLOY" => Self::Postdeploy,
                _ => Self::UnknownValue(execution_environment_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionEnvironmentUsage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Render => serializer.serialize_i32(1),
                Self::Deploy => serializer.serialize_i32(2),
                Self::Verify => serializer.serialize_i32(3),
                Self::Predeploy => serializer.serialize_i32(4),
                Self::Postdeploy => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionEnvironmentUsage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ExecutionEnvironmentUsage>::new(
                    ".google.cloud.deploy.v1.ExecutionConfig.ExecutionEnvironmentUsage",
                ),
            )
        }
    }

    /// Details of the environment.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionEnvironment {
        /// Optional. Use default Cloud Build pool.
        DefaultPool(std::boxed::Box<crate::model::DefaultPool>),
        /// Optional. Use private Cloud Build pool.
        PrivatePool(std::boxed::Box<crate::model::PrivatePool>),
    }
}

/// Execution using the default Cloud Build pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DefaultPool {
    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    pub artifact_storage: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DefaultPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::DefaultPool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::DefaultPool::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }
}

impl wkt::message::Message for DefaultPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DefaultPool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DefaultPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account,
            __artifact_storage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DefaultPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "artifactStorage" => Ok(__FieldTag::__artifact_storage),
                            "artifact_storage" => Ok(__FieldTag::__artifact_storage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DefaultPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DefaultPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_storage => {
                            if !fields.insert(__FieldTag::__artifact_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_storage",
                                ));
                            }
                            result.artifact_storage = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DefaultPool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.artifact_storage.is_empty() {
            state.serialize_entry("artifactStorage", &self.artifact_storage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DefaultPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DefaultPool");
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("artifact_storage", &self.artifact_storage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Execution using a private Cloud Build pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivatePool {
    /// Required. Resource name of the Cloud Build worker pool to use. The format
    /// is `projects/{project}/locations/{location}/workerPools/{pool}`.
    pub worker_pool: std::string::String,

    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    pub artifact_storage: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::PrivatePool::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::PrivatePool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::PrivatePool::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }
}

impl wkt::message::Message for PrivatePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PrivatePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivatePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __worker_pool,
            __service_account,
            __artifact_storage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivatePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "artifactStorage" => Ok(__FieldTag::__artifact_storage),
                            "artifact_storage" => Ok(__FieldTag::__artifact_storage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivatePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivatePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_storage => {
                            if !fields.insert(__FieldTag::__artifact_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_storage",
                                ));
                            }
                            result.artifact_storage = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivatePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.artifact_storage.is_empty() {
            state.serialize_entry("artifactStorage", &self.artifact_storage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivatePool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivatePool");
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("artifact_storage", &self.artifact_storage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information specifying a GKE Cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeCluster {
    /// Optional. Information specifying a GKE Cluster. Format is
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
    pub cluster: std::string::String,

    /// Optional. If true, `cluster` is accessed using the private IP address of
    /// the control plane endpoint. Otherwise, the default IP address of the
    /// control plane endpoint is used. The default IP address is the private IP
    /// address for clusters with private control-plane endpoints and the public IP
    /// address otherwise.
    ///
    /// Only specify this option when `cluster` is a [private GKE
    /// cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
    /// Note that `internal_ip` and `dns_endpoint` cannot both be set to true.
    pub internal_ip: bool,

    /// Optional. If set, used to configure a
    /// [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy)
    /// to the Kubernetes server.
    pub proxy_url: std::string::String,

    /// Optional. If set, the cluster will be accessed using the DNS endpoint. Note
    /// that both `dns_endpoint` and `internal_ip` cannot be set to true.
    pub dns_endpoint: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GkeCluster::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::GkeCluster::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [proxy_url][crate::model::GkeCluster::proxy_url].
    pub fn set_proxy_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_url = v.into();
        self
    }

    /// Sets the value of [dns_endpoint][crate::model::GkeCluster::dns_endpoint].
    pub fn set_dns_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dns_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for GkeCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GkeCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            __internal_ip,
            __proxy_url,
            __dns_endpoint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "proxyUrl" => Ok(__FieldTag::__proxy_url),
                            "proxy_url" => Ok(__FieldTag::__proxy_url),
                            "dnsEndpoint" => Ok(__FieldTag::__dns_endpoint),
                            "dns_endpoint" => Ok(__FieldTag::__dns_endpoint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__proxy_url => {
                            if !fields.insert(__FieldTag::__proxy_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_url",
                                ));
                            }
                            result.proxy_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dns_endpoint => {
                            if !fields.insert(__FieldTag::__dns_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_endpoint",
                                ));
                            }
                            result.dns_endpoint = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !wkt::internal::is_default(&self.internal_ip) {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.proxy_url.is_empty() {
            state.serialize_entry("proxyUrl", &self.proxy_url)?;
        }
        if !wkt::internal::is_default(&self.dns_endpoint) {
            state.serialize_entry("dnsEndpoint", &self.dns_endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GkeCluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeCluster");
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("proxy_url", &self.proxy_url);
        debug_struct.field("dns_endpoint", &self.dns_endpoint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information specifying an Anthos Cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnthosCluster {
    /// Optional. Membership of the GKE Hub-registered cluster to which to apply
    /// the Skaffold configuration. Format is
    /// `projects/{project}/locations/{location}/memberships/{membership_name}`.
    pub membership: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnthosCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [membership][crate::model::AnthosCluster::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for AnthosCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AnthosCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnthosCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __membership,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnthosCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "membership" => Ok(__FieldTag::__membership),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnthosCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnthosCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnthosCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.membership.is_empty() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnthosCluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnthosCluster");
        debug_struct.field("membership", &self.membership);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information specifying where to deploy a Cloud Run Service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunLocation {
    /// Required. The location for the Cloud Run Service. Format must be
    /// `projects/{project}/locations/{location}`.
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::CloudRunLocation::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunLocation");
        debug_struct.field("location", &self.location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information specifying a multiTarget.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MultiTarget {
    /// Required. The target_ids of this multiTarget.
    pub target_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_ids][crate::model::MultiTarget::target_ids].
    pub fn set_target_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MultiTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.MultiTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MultiTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetIds" => Ok(__FieldTag::__target_ids),
                            "target_ids" => Ok(__FieldTag::__target_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MultiTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_ids => {
                            if !fields.insert(__FieldTag::__target_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_ids",
                                ));
                            }
                            result.target_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MultiTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_ids.is_empty() {
            state.serialize_entry("targetIds", &self.target_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MultiTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiTarget");
        debug_struct.field("target_ids", &self.target_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information specifying a Custom Target.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomTarget {
    /// Required. The name of the CustomTargetType. Format must be
    /// `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
    pub custom_target_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_target_type][crate::model::CustomTarget::custom_target_type].
    pub fn set_custom_target_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type = v.into();
        self
    }
}

impl wkt::message::Message for CustomTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_target_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customTargetType" => Ok(__FieldTag::__custom_target_type),
                            "custom_target_type" => Ok(__FieldTag::__custom_target_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_target_type => {
                            if !fields.insert(__FieldTag::__custom_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type",
                                ));
                            }
                            result.custom_target_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom_target_type.is_empty() {
            state.serialize_entry("customTargetType", &self.custom_target_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomTarget");
        debug_struct.field("custom_target_type", &self.custom_target_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about entities associated with a `Target`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssociatedEntities {
    /// Optional. Information specifying GKE clusters as associated entities.
    pub gke_clusters: std::vec::Vec<crate::model::GkeCluster>,

    /// Optional. Information specifying Anthos clusters as associated entities.
    pub anthos_clusters: std::vec::Vec<crate::model::AnthosCluster>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssociatedEntities {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_clusters][crate::model::AssociatedEntities::gke_clusters].
    pub fn set_gke_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GkeCluster>,
    {
        use std::iter::Iterator;
        self.gke_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [anthos_clusters][crate::model::AssociatedEntities::anthos_clusters].
    pub fn set_anthos_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnthosCluster>,
    {
        use std::iter::Iterator;
        self.anthos_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssociatedEntities {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AssociatedEntities"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssociatedEntities {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_clusters,
            __anthos_clusters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssociatedEntities")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeClusters" => Ok(__FieldTag::__gke_clusters),
                            "gke_clusters" => Ok(__FieldTag::__gke_clusters),
                            "anthosClusters" => Ok(__FieldTag::__anthos_clusters),
                            "anthos_clusters" => Ok(__FieldTag::__anthos_clusters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssociatedEntities;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssociatedEntities")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_clusters => {
                            if !fields.insert(__FieldTag::__gke_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_clusters",
                                ));
                            }
                            result.gke_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GkeCluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__anthos_clusters => {
                            if !fields.insert(__FieldTag::__anthos_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anthos_clusters",
                                ));
                            }
                            result.anthos_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AnthosCluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssociatedEntities {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gke_clusters.is_empty() {
            state.serialize_entry("gkeClusters", &self.gke_clusters)?;
        }
        if !self.anthos_clusters.is_empty() {
            state.serialize_entry("anthosClusters", &self.anthos_clusters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssociatedEntities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssociatedEntities");
        debug_struct.field("gke_clusters", &self.gke_clusters);
        debug_struct.field("anthos_clusters", &self.anthos_clusters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListTargets`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetsRequest {
    /// Required. The parent, which owns this collection of targets. Format must be
    /// `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of `Target` objects to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Target` objects
    /// will be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter targets to be returned. See <https://google.aip.dev/160> for
    /// more details.
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTargetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTargetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListTargetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListTargets`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetsResponse {
    /// The `Target` objects.
    pub targets: std::vec::Vec<crate::model::Target>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets][crate::model::ListTargetsResponse::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Target>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTargetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTargetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListTargetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetsResponse {
    type PageItem = crate::model::Target;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.targets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __targets,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targets" => Ok(__FieldTag::__targets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__targets => {
                            if !fields.insert(__FieldTag::__targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets",
                                ));
                            }
                            result.targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.targets.is_empty() {
            state.serialize_entry("targets", &self.targets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetsResponse");
        debug_struct.field("targets", &self.targets);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTargetRequest {
    /// Required. Name of the `Target`. Format must be
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetTargetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTargetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTargetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTargetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTargetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTargetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTargetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTargetRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `CreateTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTargetRequest {
    /// Required. The parent collection in which the `Target` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `Target`.
    pub target_id: std::string::String,

    /// Required. The `Target` to create.
    pub target: std::option::Option<crate::model::Target>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::CreateTargetRequest::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [target][crate::model::CreateTargetRequest::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::CreateTargetRequest::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateTargetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTargetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __target_id,
            __target,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTargetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "target" => Ok(__FieldTag::__target),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTargetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTargetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTargetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTargetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTargetRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("target", &self.target);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `UpdateTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTargetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `Target` resource. The fields specified in the update_mask
    /// are relative to the resource, not the full request. A field will be
    /// overwritten if it's in the mask. If the user doesn't provide a mask then
    /// all fields are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `Target` to update.
    pub target: std::option::Option<crate::model::Target>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `Target` that does not exist will
    /// result in the creation of a new `Target`.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTargetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTargetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::UpdateTargetRequest::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::UpdateTargetRequest::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateTargetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateTargetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTargetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __target,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTargetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "target" => Ok(__FieldTag::__target),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTargetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTargetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTargetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTargetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTargetRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("target", &self.target);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `DeleteTarget`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTargetRequest {
    /// Required. The name of the `Target` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `Target` will succeed.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteTargetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteTargetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteTargetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTargetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __allow_missing,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTargetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTargetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTargetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTargetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTargetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTargetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `CustomTargetType` resource in the Cloud Deploy API.
///
/// A `CustomTargetType` defines a type of custom target that can be referenced
/// in a `Target` in order to facilitate deploying to other systems besides the
/// supported runtimes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomTargetType {
    /// Identifier. Name of the `CustomTargetType`. Format is
    /// `projects/{project}/locations/{location}/customTargetTypes/{customTargetType}`.
    /// The `customTargetType` component must match
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Resource id of the `CustomTargetType`.
    pub custom_target_type_id: std::string::String,

    /// Output only. Unique identifier of the `CustomTargetType`.
    pub uid: std::string::String,

    /// Optional. Description of the `CustomTargetType`. Max length is 255
    /// characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the `CustomTargetType` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the `CustomTargetType` was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Defines the `CustomTargetType` renderer and deployer.
    pub definition: std::option::Option<crate::model::custom_target_type::Definition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomTargetType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [custom_target_type_id][crate::model::CustomTargetType::custom_target_type_id].
    pub fn set_custom_target_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_id = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::CustomTargetType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CustomTargetType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::CustomTargetType::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::CustomTargetType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomTargetType::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CustomTargetType::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CustomTargetType::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CustomTargetType::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::CustomTargetType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::CustomTargetType::definition].
    ///
    /// Note that all the setters affecting `definition` are mutually
    /// exclusive.
    pub fn set_definition<
        T: std::convert::Into<std::option::Option<crate::model::custom_target_type::Definition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.definition = v.into();
        self
    }

    /// The value of [definition][crate::model::CustomTargetType::definition]
    /// if it holds a `CustomActions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_actions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomTargetSkaffoldActions>> {
        #[allow(unreachable_patterns)]
        self.definition.as_ref().and_then(|v| match v {
            crate::model::custom_target_type::Definition::CustomActions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [definition][crate::model::CustomTargetType::definition]
    /// to hold a `CustomActions`.
    ///
    /// Note that all the setters affecting `definition` are
    /// mutually exclusive.
    pub fn set_custom_actions<
        T: std::convert::Into<std::boxed::Box<crate::model::CustomTargetSkaffoldActions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.definition = std::option::Option::Some(
            crate::model::custom_target_type::Definition::CustomActions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CustomTargetType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomTargetType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __custom_target_type_id,
            __uid,
            __description,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __etag,
            __custom_actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomTargetType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "customTargetTypeId" => Ok(__FieldTag::__custom_target_type_id),
                            "custom_target_type_id" => Ok(__FieldTag::__custom_target_type_id),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "customActions" => Ok(__FieldTag::__custom_actions),
                            "custom_actions" => Ok(__FieldTag::__custom_actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomTargetType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomTargetType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type_id => {
                            if !fields.insert(__FieldTag::__custom_target_type_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type_id",
                                ));
                            }
                            result.custom_target_type_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_actions => {
                            if !fields.insert(__FieldTag::__custom_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_actions",
                                ));
                            }
                            if result.definition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `definition`, a oneof with full ID .google.cloud.deploy.v1.CustomTargetType.custom_actions, latest field was customActions",
                                ));
                            }
                            result.definition = std::option::Option::Some(
                                crate::model::custom_target_type::Definition::CustomActions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CustomTargetSkaffoldActions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomTargetType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.custom_target_type_id.is_empty() {
            state.serialize_entry("customTargetTypeId", &self.custom_target_type_id)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if let Some(value) = self.custom_actions() {
            state.serialize_entry("customActions", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomTargetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomTargetType");
        debug_struct.field("name", &self.name);
        debug_struct.field("custom_target_type_id", &self.custom_target_type_id);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("definition", &self.definition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CustomTargetType].
pub mod custom_target_type {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the `CustomTargetType` renderer and deployer.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Definition {
        /// Optional. Configures render and deploy for the `CustomTargetType` using
        /// Skaffold custom actions.
        CustomActions(std::boxed::Box<crate::model::CustomTargetSkaffoldActions>),
    }
}

/// CustomTargetSkaffoldActions represents the `CustomTargetType` configuration
/// using Skaffold custom actions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomTargetSkaffoldActions {
    /// Optional. The Skaffold custom action responsible for render operations. If
    /// not provided then Cloud Deploy will perform the render operations via
    /// `skaffold render`.
    pub render_action: std::string::String,

    /// Required. The Skaffold custom action responsible for deploy operations.
    pub deploy_action: std::string::String,

    /// Optional. List of Skaffold modules Cloud Deploy will include in the
    /// Skaffold Config as required before performing diagnose.
    pub include_skaffold_modules: std::vec::Vec<crate::model::SkaffoldModules>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetSkaffoldActions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [render_action][crate::model::CustomTargetSkaffoldActions::render_action].
    pub fn set_render_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.render_action = v.into();
        self
    }

    /// Sets the value of [deploy_action][crate::model::CustomTargetSkaffoldActions::deploy_action].
    pub fn set_deploy_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_action = v.into();
        self
    }

    /// Sets the value of [include_skaffold_modules][crate::model::CustomTargetSkaffoldActions::include_skaffold_modules].
    pub fn set_include_skaffold_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SkaffoldModules>,
    {
        use std::iter::Iterator;
        self.include_skaffold_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomTargetSkaffoldActions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetSkaffoldActions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomTargetSkaffoldActions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __render_action,
            __deploy_action,
            __include_skaffold_modules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomTargetSkaffoldActions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "renderAction" => Ok(__FieldTag::__render_action),
                            "render_action" => Ok(__FieldTag::__render_action),
                            "deployAction" => Ok(__FieldTag::__deploy_action),
                            "deploy_action" => Ok(__FieldTag::__deploy_action),
                            "includeSkaffoldModules" => Ok(__FieldTag::__include_skaffold_modules),
                            "include_skaffold_modules" => {
                                Ok(__FieldTag::__include_skaffold_modules)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomTargetSkaffoldActions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomTargetSkaffoldActions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__render_action => {
                            if !fields.insert(__FieldTag::__render_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for render_action",
                                ));
                            }
                            result.render_action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_action => {
                            if !fields.insert(__FieldTag::__deploy_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_action",
                                ));
                            }
                            result.deploy_action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_skaffold_modules => {
                            if !fields.insert(__FieldTag::__include_skaffold_modules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_skaffold_modules",
                                ));
                            }
                            result.include_skaffold_modules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SkaffoldModules>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomTargetSkaffoldActions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.render_action.is_empty() {
            state.serialize_entry("renderAction", &self.render_action)?;
        }
        if !self.deploy_action.is_empty() {
            state.serialize_entry("deployAction", &self.deploy_action)?;
        }
        if !self.include_skaffold_modules.is_empty() {
            state.serialize_entry("includeSkaffoldModules", &self.include_skaffold_modules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomTargetSkaffoldActions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomTargetSkaffoldActions");
        debug_struct.field("render_action", &self.render_action);
        debug_struct.field("deploy_action", &self.deploy_action);
        debug_struct.field("include_skaffold_modules", &self.include_skaffold_modules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Skaffold Config modules and their remote source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SkaffoldModules {
    /// Optional. The Skaffold Config modules to use from the specified source.
    pub configs: std::vec::Vec<std::string::String>,

    /// The source that contains the Skaffold Config modules.
    pub source: std::option::Option<crate::model::skaffold_modules::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SkaffoldModules {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [configs][crate::model::SkaffoldModules::configs].
    pub fn set_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::skaffold_modules::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `Git`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::Git(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `Git`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::skaffold_modules::Source::Git(v.into()));
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `GoogleCloudStorage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cloud_storage(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::GoogleCloudStorage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `GoogleCloudStorage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_google_cloud_storage<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::skaffold_modules::Source::GoogleCloudStorage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `GoogleCloudBuildRepo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cloud_build_repo(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::GoogleCloudBuildRepo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `GoogleCloudBuildRepo`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_google_cloud_build_repo<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::skaffold_modules::Source::GoogleCloudBuildRepo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SkaffoldModules {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SkaffoldModules {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __configs,
            __git,
            __google_cloud_storage,
            __google_cloud_build_repo,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SkaffoldModules")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "configs" => Ok(__FieldTag::__configs),
                            "git" => Ok(__FieldTag::__git),
                            "googleCloudStorage" => Ok(__FieldTag::__google_cloud_storage),
                            "google_cloud_storage" => Ok(__FieldTag::__google_cloud_storage),
                            "googleCloudBuildRepo" => Ok(__FieldTag::__google_cloud_build_repo),
                            "google_cloud_build_repo" => Ok(__FieldTag::__google_cloud_build_repo),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SkaffoldModules;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SkaffoldModules")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__configs => {
                            if !fields.insert(__FieldTag::__configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for configs",
                                ));
                            }
                            result.configs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__git => {
                            if !fields.insert(__FieldTag::__git) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.deploy.v1.SkaffoldModules.git, latest field was git",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::skaffold_modules::Source::Git(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::skaffold_modules::SkaffoldGitSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__google_cloud_storage => {
                            if !fields.insert(__FieldTag::__google_cloud_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_cloud_storage",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.deploy.v1.SkaffoldModules.google_cloud_storage, latest field was googleCloudStorage",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::skaffold_modules::Source::GoogleCloudStorage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::skaffold_modules::SkaffoldGCSSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__google_cloud_build_repo => {
                            if !fields.insert(__FieldTag::__google_cloud_build_repo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_cloud_build_repo",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.deploy.v1.SkaffoldModules.google_cloud_build_repo, latest field was googleCloudBuildRepo",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::skaffold_modules::Source::GoogleCloudBuildRepo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::skaffold_modules::SkaffoldGCBRepoSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SkaffoldModules {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.configs.is_empty() {
            state.serialize_entry("configs", &self.configs)?;
        }
        if let Some(value) = self.git() {
            state.serialize_entry("git", value)?;
        }
        if let Some(value) = self.google_cloud_storage() {
            state.serialize_entry("googleCloudStorage", value)?;
        }
        if let Some(value) = self.google_cloud_build_repo() {
            state.serialize_entry("googleCloudBuildRepo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SkaffoldModules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SkaffoldModules");
        debug_struct.field("configs", &self.configs);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SkaffoldModules].
pub mod skaffold_modules {
    #[allow(unused_imports)]
    use super::*;

    /// Git repository containing Skaffold Config modules.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SkaffoldGitSource {
        /// Required. Git repository the package should be cloned from.
        pub repo: std::string::String,

        /// Optional. Relative path from the repository root to the Skaffold file.
        pub path: std::string::String,

        /// Optional. Git branch or tag to use when cloning the repository.
        pub r#ref: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGitSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repo][crate::model::skaffold_modules::SkaffoldGitSource::repo].
        pub fn set_repo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repo = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGitSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [r#ref][crate::model::skaffold_modules::SkaffoldGitSource::ref].
        pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#ref = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGitSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGitSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SkaffoldGitSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repo,
                __path,
                __ref,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SkaffoldGitSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repo" => Ok(__FieldTag::__repo),
                                "path" => Ok(__FieldTag::__path),
                                "ref" => Ok(__FieldTag::__ref),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SkaffoldGitSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SkaffoldGitSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repo => {
                                if !fields.insert(__FieldTag::__repo) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repo",
                                    ));
                                }
                                result.repo = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ref => {
                                if !fields.insert(__FieldTag::__ref) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ref",
                                    ));
                                }
                                result.r#ref = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SkaffoldGitSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repo.is_empty() {
                state.serialize_entry("repo", &self.repo)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.r#ref.is_empty() {
                state.serialize_entry("ref", &self.r#ref)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SkaffoldGitSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SkaffoldGitSource");
            debug_struct.field("repo", &self.repo);
            debug_struct.field("path", &self.path);
            debug_struct.field("r#ref", &self.r#ref);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Cloud Storage bucket containing Skaffold Config modules.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SkaffoldGCSSource {
        /// Required. Cloud Storage source paths to copy recursively. For example,
        /// providing "gs://my-bucket/dir/configs/*" will result in Skaffold copying
        /// all files within the "dir/configs" directory in the bucket "my-bucket".
        pub source: std::string::String,

        /// Optional. Relative path from the source to the Skaffold file.
        pub path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGCSSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::skaffold_modules::SkaffoldGCSSource::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGCSSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGCSSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGCSSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SkaffoldGCSSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source,
                __path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SkaffoldGCSSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "source" => Ok(__FieldTag::__source),
                                "path" => Ok(__FieldTag::__path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SkaffoldGCSSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SkaffoldGCSSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SkaffoldGCSSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source.is_empty() {
                state.serialize_entry("source", &self.source)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SkaffoldGCSSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SkaffoldGCSSource");
            debug_struct.field("source", &self.source);
            debug_struct.field("path", &self.path);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Cloud Build V2 Repository containing Skaffold Configs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SkaffoldGCBRepoSource {
        /// Required. Name of the Cloud Build V2 Repository.
        /// Format is
        /// projects/{project}/locations/{location}/connections/{connection}/repositories/{repository}.
        pub repository: std::string::String,

        /// Optional. Relative path from the repository root to the Skaffold Config
        /// file.
        pub path: std::string::String,

        /// Optional. Branch or tag to use when cloning the repository.
        pub r#ref: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGCBRepoSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::skaffold_modules::SkaffoldGCBRepoSource::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGCBRepoSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [r#ref][crate::model::skaffold_modules::SkaffoldGCBRepoSource::ref].
        pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#ref = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGCBRepoSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGCBRepoSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SkaffoldGCBRepoSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __repository,
                __path,
                __ref,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SkaffoldGCBRepoSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "repository" => Ok(__FieldTag::__repository),
                                "path" => Ok(__FieldTag::__path),
                                "ref" => Ok(__FieldTag::__ref),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SkaffoldGCBRepoSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SkaffoldGCBRepoSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__repository => {
                                if !fields.insert(__FieldTag::__repository) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repository",
                                    ));
                                }
                                result.repository = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ref => {
                                if !fields.insert(__FieldTag::__ref) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ref",
                                    ));
                                }
                                result.r#ref = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SkaffoldGCBRepoSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.repository.is_empty() {
                state.serialize_entry("repository", &self.repository)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.r#ref.is_empty() {
                state.serialize_entry("ref", &self.r#ref)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SkaffoldGCBRepoSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SkaffoldGCBRepoSource");
            debug_struct.field("repository", &self.repository);
            debug_struct.field("path", &self.path);
            debug_struct.field("r#ref", &self.r#ref);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The source that contains the Skaffold Config modules.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Remote git repository containing the Skaffold Config modules.
        Git(std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>),
        /// Optional. Cloud Storage bucket containing the Skaffold Config modules.
        GoogleCloudStorage(std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>),
        /// Optional. Cloud Build V2 repository containing the Skaffold Config
        /// modules.
        GoogleCloudBuildRepo(
            std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>,
        ),
    }
}

/// The request object for `ListCustomTargetTypes`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomTargetTypesRequest {
    /// Required. The parent that owns this collection of custom target types.
    /// Format must be `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of `CustomTargetType` objects to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `CustomTargetType` objects will be returned. The maximum value is 1000;
    /// values above 1000 will be set to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListCustomTargetTypes`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter custom target types to be returned. See
    /// <https://google.aip.dev/160> for more details.
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomTargetTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomTargetTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomTargetTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomTargetTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomTargetTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomTargetTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomTargetTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListCustomTargetTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomTargetTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomTargetTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomTargetTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomTargetTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomTargetTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCustomTargetTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCustomTargetTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListCustomTargetTypes.`
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomTargetTypesResponse {
    /// The `CustomTargetType` objects.
    pub custom_target_types: std::vec::Vec<crate::model::CustomTargetType>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomTargetTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_target_types][crate::model::ListCustomTargetTypesResponse::custom_target_types].
    pub fn set_custom_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomTargetType>,
    {
        use std::iter::Iterator;
        self.custom_target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomTargetTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomTargetTypesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomTargetTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListCustomTargetTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomTargetTypesResponse {
    type PageItem = crate::model::CustomTargetType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_target_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomTargetTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_target_types,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomTargetTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customTargetTypes" => Ok(__FieldTag::__custom_target_types),
                            "custom_target_types" => Ok(__FieldTag::__custom_target_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomTargetTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomTargetTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_target_types => {
                            if !fields.insert(__FieldTag::__custom_target_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_types",
                                ));
                            }
                            result.custom_target_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomTargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomTargetTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom_target_types.is_empty() {
            state.serialize_entry("customTargetTypes", &self.custom_target_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCustomTargetTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCustomTargetTypesResponse");
        debug_struct.field("custom_target_types", &self.custom_target_types);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetCustomTargetType`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCustomTargetTypeRequest {
    /// Required. Name of the `CustomTargetType`. Format must be
    /// `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomTargetTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetCustomTargetTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCustomTargetTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCustomTargetTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCustomTargetTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCustomTargetTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCustomTargetTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCustomTargetTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCustomTargetTypeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `CreateCustomTargetType`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCustomTargetTypeRequest {
    /// Required. The parent collection in which the `CustomTargetType` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `CustomTargetType`.
    pub custom_target_type_id: std::string::String,

    /// Required. The `CustomTargetType` to create.
    pub custom_target_type: std::option::Option<crate::model::CustomTargetType>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomTargetTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_target_type_id][crate::model::CreateCustomTargetTypeRequest::custom_target_type_id].
    pub fn set_custom_target_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_id = v.into();
        self
    }

    /// Sets the value of [custom_target_type][crate::model::CreateCustomTargetTypeRequest::custom_target_type].
    pub fn set_custom_target_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target_type][crate::model::CreateCustomTargetTypeRequest::custom_target_type].
    pub fn set_or_clear_custom_target_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateCustomTargetTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCustomTargetTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __custom_target_type_id,
            __custom_target_type,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCustomTargetTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "customTargetTypeId" => Ok(__FieldTag::__custom_target_type_id),
                            "custom_target_type_id" => Ok(__FieldTag::__custom_target_type_id),
                            "customTargetType" => Ok(__FieldTag::__custom_target_type),
                            "custom_target_type" => Ok(__FieldTag::__custom_target_type),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCustomTargetTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCustomTargetTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type_id => {
                            if !fields.insert(__FieldTag::__custom_target_type_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type_id",
                                ));
                            }
                            result.custom_target_type_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type => {
                            if !fields.insert(__FieldTag::__custom_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type",
                                ));
                            }
                            result.custom_target_type = map
                                .next_value::<std::option::Option<crate::model::CustomTargetType>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCustomTargetTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.custom_target_type_id.is_empty() {
            state.serialize_entry("customTargetTypeId", &self.custom_target_type_id)?;
        }
        if self.custom_target_type.is_some() {
            state.serialize_entry("customTargetType", &self.custom_target_type)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCustomTargetTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCustomTargetTypeRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("custom_target_type_id", &self.custom_target_type_id);
        debug_struct.field("custom_target_type", &self.custom_target_type);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `UpdateCustomTargetType`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCustomTargetTypeRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `CustomTargetType` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `CustomTargetType` to update.
    pub custom_target_type: std::option::Option<crate::model::CustomTargetType>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `CustomTargetType` that does not exist
    /// will result in the creation of a new `CustomTargetType`.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomTargetTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCustomTargetTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_target_type][crate::model::UpdateCustomTargetTypeRequest::custom_target_type].
    pub fn set_custom_target_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target_type][crate::model::UpdateCustomTargetTypeRequest::custom_target_type].
    pub fn set_or_clear_custom_target_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateCustomTargetTypeRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateCustomTargetTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCustomTargetTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __custom_target_type,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCustomTargetTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "customTargetType" => Ok(__FieldTag::__custom_target_type),
                            "custom_target_type" => Ok(__FieldTag::__custom_target_type),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCustomTargetTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCustomTargetTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__custom_target_type => {
                            if !fields.insert(__FieldTag::__custom_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type",
                                ));
                            }
                            result.custom_target_type = map
                                .next_value::<std::option::Option<crate::model::CustomTargetType>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCustomTargetTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.custom_target_type.is_some() {
            state.serialize_entry("customTargetType", &self.custom_target_type)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCustomTargetTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCustomTargetTypeRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("custom_target_type", &self.custom_target_type);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `DeleteCustomTargetType`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCustomTargetTypeRequest {
    /// Required. The name of the `CustomTargetType` to delete. Format must be
    /// `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `CustomTargetType` will succeed.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated but no actual change is
    /// made.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomTargetTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteCustomTargetTypeRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteCustomTargetTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteCustomTargetTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCustomTargetTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __allow_missing,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCustomTargetTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCustomTargetTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCustomTargetTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCustomTargetTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCustomTargetTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCustomTargetTypeRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `DeployPolicy` resource in the Cloud Deploy API.
///
/// A `DeployPolicy` inhibits manual or automation-driven actions within a
/// Delivery Pipeline or Target.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployPolicy {
    /// Output only. Name of the `DeployPolicy`. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    /// The `deployPolicy` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Unique identifier of the `DeployPolicy`.
    pub uid: std::string::String,

    /// Optional. Description of the `DeployPolicy`. Max length is 255 characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. Annotations must meet the following
    /// constraints:
    ///
    /// * Annotations are key/value pairs.
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (`/`).
    /// * The name segment is required and must be 63 characters or less,
    ///   beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
    ///   dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
    /// * The prefix is optional. If specified, the prefix must be a DNS subdomain:
    ///   a series of DNS labels separated by dots(`.`), not longer than 253
    ///   characters in total, followed by a slash (`/`).
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set>
    /// for more details.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the deploy policy was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the deploy policy was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. When suspended, the policy will not prevent actions from
    /// occurring, even if the action violates the policy.
    pub suspended: bool,

    /// Required. Selected resources to which the policy will be applied. At least
    /// one selector is required. If one selector matches the resource the policy
    /// applies. For example, if there are two selectors and the action being
    /// attempted matches one of them, the policy will apply to that action.
    pub selectors: std::vec::Vec<crate::model::DeployPolicyResourceSelector>,

    /// Required. Rules to apply. At least one rule must be present.
    pub rules: std::vec::Vec<crate::model::PolicyRule>,

    /// The weak etag of the `DeployPolicy` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DeployPolicy::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeployPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DeployPolicy::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DeployPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployPolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeployPolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeployPolicy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeployPolicy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suspended][crate::model::DeployPolicy::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [selectors][crate::model::DeployPolicy::selectors].
    pub fn set_selectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployPolicyResourceSelector>,
    {
        use std::iter::Iterator;
        self.selectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::DeployPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::DeployPolicy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeployPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __suspended,
            __selectors,
            __rules,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "suspended" => Ok(__FieldTag::__suspended),
                            "selectors" => Ok(__FieldTag::__selectors),
                            "rules" => Ok(__FieldTag::__rules),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selectors => {
                            if !fields.insert(__FieldTag::__selectors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selectors",
                                ));
                            }
                            result.selectors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DeployPolicyResourceSelector>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PolicyRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if !self.selectors.is_empty() {
            state.serialize_entry("selectors", &self.selectors)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployPolicy");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("suspended", &self.suspended);
        debug_struct.field("selectors", &self.selectors);
        debug_struct.field("rules", &self.rules);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeployPolicy].
pub mod deploy_policy {
    #[allow(unused_imports)]
    use super::*;

    /// What invoked the action. Filters enforcing the policy depending on what
    /// invoked the action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Invoker {
        /// Unspecified.
        Unspecified,
        /// The action is user-driven. For example, creating a rollout manually via a
        /// gcloud create command.
        User,
        /// Automated action by Cloud Deploy.
        DeployAutomation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Invoker::value] or
        /// [Invoker::name].
        UnknownValue(invoker::UnknownValue),
    }

    #[doc(hidden)]
    pub mod invoker {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Invoker {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::User => std::option::Option::Some(1),
                Self::DeployAutomation => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INVOKER_UNSPECIFIED"),
                Self::User => std::option::Option::Some("USER"),
                Self::DeployAutomation => std::option::Option::Some("DEPLOY_AUTOMATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Invoker {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Invoker {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Invoker {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::User,
                2 => Self::DeployAutomation,
                _ => Self::UnknownValue(invoker::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Invoker {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INVOKER_UNSPECIFIED" => Self::Unspecified,
                "USER" => Self::User,
                "DEPLOY_AUTOMATION" => Self::DeployAutomation,
                _ => Self::UnknownValue(invoker::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Invoker {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::User => serializer.serialize_i32(1),
                Self::DeployAutomation => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Invoker {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Invoker>::new(
                ".google.cloud.deploy.v1.DeployPolicy.Invoker",
            ))
        }
    }
}

/// Contains information on the resources to select for a deploy policy.
/// Attributes provided must all match the resource in order for policy
/// restrictions to apply. For example, if delivery pipelines attributes given
/// are an id "prod" and labels "foo: bar", a delivery pipeline resource must
/// match both that id and have that label in order to be subject to the policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployPolicyResourceSelector {
    /// Optional. Contains attributes about a delivery pipeline.
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipelineAttribute>,

    /// Optional. Contains attributes about a target.
    pub target: std::option::Option<crate::model::TargetAttribute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyResourceSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeployPolicyResourceSelector::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipelineAttribute>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::DeployPolicyResourceSelector::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipelineAttribute>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::DeployPolicyResourceSelector::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetAttribute>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::DeployPolicyResourceSelector::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetAttribute>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployPolicyResourceSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyResourceSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployPolicyResourceSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __delivery_pipeline,
            __target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployPolicyResourceSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deliveryPipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "delivery_pipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "target" => Ok(__FieldTag::__target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployPolicyResourceSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployPolicyResourceSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__delivery_pipeline => {
                            if !fields.insert(__FieldTag::__delivery_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline",
                                ));
                            }
                            result.delivery_pipeline = map.next_value::<std::option::Option<crate::model::DeliveryPipelineAttribute>>()?
                                ;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<crate::model::TargetAttribute>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployPolicyResourceSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.delivery_pipeline.is_some() {
            state.serialize_entry("deliveryPipeline", &self.delivery_pipeline)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployPolicyResourceSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployPolicyResourceSelector");
        debug_struct.field("delivery_pipeline", &self.delivery_pipeline);
        debug_struct.field("target", &self.target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains criteria for selecting DeliveryPipelines.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeliveryPipelineAttribute {
    /// Optional. ID of the `DeliveryPipeline`. The value of this field could be
    /// one of the following:
    ///
    /// * The last segment of a pipeline name
    /// * "*", all delivery pipelines in a location
    pub id: std::string::String,

    /// DeliveryPipeline labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipelineAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeliveryPipelineAttribute::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DeliveryPipelineAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DeliveryPipelineAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipelineAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeliveryPipelineAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliveryPipelineAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeliveryPipelineAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliveryPipelineAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeliveryPipelineAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeliveryPipelineAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeliveryPipelineAttribute");
        debug_struct.field("id", &self.id);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains criteria for selecting Targets. This could be used to select targets
/// for a Deploy Policy or for an Automation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetAttribute {
    /// Optional. ID of the `Target`. The value of this field could be one of the
    /// following:
    ///
    /// * The last segment of a target name
    /// * "*", all targets in a location
    pub id: std::string::String,

    /// Target labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TargetAttribute::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TargetAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TargetAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetAttribute");
        debug_struct.field("id", &self.id);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Deploy Policy rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicyRule {
    pub rule: std::option::Option<crate::model::policy_rule::Rule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::PolicyRule::rule].
    ///
    /// Note that all the setters affecting `rule` are mutually
    /// exclusive.
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::policy_rule::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// The value of [rule][crate::model::PolicyRule::rule]
    /// if it holds a `RolloutRestriction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollout_restriction(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RolloutRestriction>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::policy_rule::Rule::RolloutRestriction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::PolicyRule::rule]
    /// to hold a `RolloutRestriction`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_rollout_restriction<
        T: std::convert::Into<std::boxed::Box<crate::model::RolloutRestriction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(crate::model::policy_rule::Rule::RolloutRestriction(
            v.into(),
        ));
        self
    }
}

impl wkt::message::Message for PolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PolicyRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout_restriction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rolloutRestriction" => Ok(__FieldTag::__rollout_restriction),
                            "rollout_restriction" => Ok(__FieldTag::__rollout_restriction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PolicyRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout_restriction => {
                            if !fields.insert(__FieldTag::__rollout_restriction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_restriction",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.cloud.deploy.v1.PolicyRule.rollout_restriction, latest field was rolloutRestriction",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::policy_rule::Rule::RolloutRestriction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RolloutRestriction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PolicyRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.rollout_restriction() {
            state.serialize_entry("rolloutRestriction", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PolicyRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PolicyRule");
        debug_struct.field("rule", &self.rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PolicyRule].
pub mod policy_rule {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Rule {
        /// Optional. Rollout restrictions.
        RolloutRestriction(std::boxed::Box<crate::model::RolloutRestriction>),
    }
}

/// Rollout restrictions.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutRestriction {
    /// Required. Restriction rule ID. Required and must be unique within a
    /// DeployPolicy. The format is `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub id: std::string::String,

    /// Optional. What invoked the action. If left empty, all invoker types will be
    /// restricted.
    pub invokers: std::vec::Vec<crate::model::deploy_policy::Invoker>,

    /// Optional. Rollout actions to be restricted as part of the policy. If left
    /// empty, all actions will be restricted.
    pub actions: std::vec::Vec<crate::model::rollout_restriction::RolloutActions>,

    /// Required. Time window within which actions are restricted.
    pub time_windows: std::option::Option<crate::model::TimeWindows>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutRestriction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RolloutRestriction::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [invokers][crate::model::RolloutRestriction::invokers].
    pub fn set_invokers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::deploy_policy::Invoker>,
    {
        use std::iter::Iterator;
        self.invokers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::RolloutRestriction::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rollout_restriction::RolloutActions>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [time_windows][crate::model::RolloutRestriction::time_windows].
    pub fn set_time_windows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindows>,
    {
        self.time_windows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_windows][crate::model::RolloutRestriction::time_windows].
    pub fn set_or_clear_time_windows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindows>,
    {
        self.time_windows = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RolloutRestriction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutRestriction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutRestriction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __invokers,
            __actions,
            __time_windows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutRestriction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "invokers" => Ok(__FieldTag::__invokers),
                            "actions" => Ok(__FieldTag::__actions),
                            "timeWindows" => Ok(__FieldTag::__time_windows),
                            "time_windows" => Ok(__FieldTag::__time_windows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutRestriction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutRestriction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invokers => {
                            if !fields.insert(__FieldTag::__invokers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invokers",
                                ));
                            }
                            result.invokers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::deploy_policy::Invoker>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::rollout_restriction::RolloutActions,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_windows => {
                            if !fields.insert(__FieldTag::__time_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_windows",
                                ));
                            }
                            result.time_windows =
                                map.next_value::<std::option::Option<crate::model::TimeWindows>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RolloutRestriction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.invokers.is_empty() {
            state.serialize_entry("invokers", &self.invokers)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if self.time_windows.is_some() {
            state.serialize_entry("timeWindows", &self.time_windows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RolloutRestriction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutRestriction");
        debug_struct.field("id", &self.id);
        debug_struct.field("invokers", &self.invokers);
        debug_struct.field("actions", &self.actions);
        debug_struct.field("time_windows", &self.time_windows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RolloutRestriction].
pub mod rollout_restriction {
    #[allow(unused_imports)]
    use super::*;

    /// Rollout actions to be restricted as part of the policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutActions {
        /// Unspecified.
        Unspecified,
        /// Advance the rollout to the next phase.
        Advance,
        /// Approve the rollout.
        Approve,
        /// Cancel the rollout.
        Cancel,
        /// Create a rollout.
        Create,
        /// Ignore a job result on the rollout.
        IgnoreJob,
        /// Retry a job for a rollout.
        RetryJob,
        /// Rollback a rollout.
        Rollback,
        /// Terminate a jobrun.
        TerminateJobrun,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutActions::value] or
        /// [RolloutActions::name].
        UnknownValue(rollout_actions::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_actions {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutActions {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Advance => std::option::Option::Some(1),
                Self::Approve => std::option::Option::Some(2),
                Self::Cancel => std::option::Option::Some(3),
                Self::Create => std::option::Option::Some(4),
                Self::IgnoreJob => std::option::Option::Some(5),
                Self::RetryJob => std::option::Option::Some(6),
                Self::Rollback => std::option::Option::Some(7),
                Self::TerminateJobrun => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_ACTIONS_UNSPECIFIED"),
                Self::Advance => std::option::Option::Some("ADVANCE"),
                Self::Approve => std::option::Option::Some("APPROVE"),
                Self::Cancel => std::option::Option::Some("CANCEL"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::IgnoreJob => std::option::Option::Some("IGNORE_JOB"),
                Self::RetryJob => std::option::Option::Some("RETRY_JOB"),
                Self::Rollback => std::option::Option::Some("ROLLBACK"),
                Self::TerminateJobrun => std::option::Option::Some("TERMINATE_JOBRUN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutActions {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutActions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutActions {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Advance,
                2 => Self::Approve,
                3 => Self::Cancel,
                4 => Self::Create,
                5 => Self::IgnoreJob,
                6 => Self::RetryJob,
                7 => Self::Rollback,
                8 => Self::TerminateJobrun,
                _ => Self::UnknownValue(rollout_actions::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutActions {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_ACTIONS_UNSPECIFIED" => Self::Unspecified,
                "ADVANCE" => Self::Advance,
                "APPROVE" => Self::Approve,
                "CANCEL" => Self::Cancel,
                "CREATE" => Self::Create,
                "IGNORE_JOB" => Self::IgnoreJob,
                "RETRY_JOB" => Self::RetryJob,
                "ROLLBACK" => Self::Rollback,
                "TERMINATE_JOBRUN" => Self::TerminateJobrun,
                _ => Self::UnknownValue(rollout_actions::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutActions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Advance => serializer.serialize_i32(1),
                Self::Approve => serializer.serialize_i32(2),
                Self::Cancel => serializer.serialize_i32(3),
                Self::Create => serializer.serialize_i32(4),
                Self::IgnoreJob => serializer.serialize_i32(5),
                Self::RetryJob => serializer.serialize_i32(6),
                Self::Rollback => serializer.serialize_i32(7),
                Self::TerminateJobrun => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutActions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutActions>::new(
                ".google.cloud.deploy.v1.RolloutRestriction.RolloutActions",
            ))
        }
    }
}

/// Time windows within which actions are restricted. See the
/// [documentation](https://cloud.google.com/deploy/docs/deploy-policy#dates_times)
/// for more information on how to configure dates/times.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeWindows {
    /// Required. The time zone in IANA format [IANA Time Zone
    /// Database](https://www.iana.org/time-zones) (e.g. America/New_York).
    pub time_zone: std::string::String,

    /// Optional. One-time windows within which actions are restricted.
    pub one_time_windows: std::vec::Vec<crate::model::OneTimeWindow>,

    /// Optional. Recurring weekly windows within which actions are restricted.
    pub weekly_windows: std::vec::Vec<crate::model::WeeklyWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindows {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::TimeWindows::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [one_time_windows][crate::model::TimeWindows::one_time_windows].
    pub fn set_one_time_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OneTimeWindow>,
    {
        use std::iter::Iterator;
        self.one_time_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weekly_windows][crate::model::TimeWindows::weekly_windows].
    pub fn set_weekly_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WeeklyWindow>,
    {
        use std::iter::Iterator;
        self.weekly_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeWindows {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimeWindows"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeWindows {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __one_time_windows,
            __weekly_windows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindows")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "oneTimeWindows" => Ok(__FieldTag::__one_time_windows),
                            "one_time_windows" => Ok(__FieldTag::__one_time_windows),
                            "weeklyWindows" => Ok(__FieldTag::__weekly_windows),
                            "weekly_windows" => Ok(__FieldTag::__weekly_windows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeWindows;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindows")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__one_time_windows => {
                            if !fields.insert(__FieldTag::__one_time_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for one_time_windows",
                                ));
                            }
                            result.one_time_windows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OneTimeWindow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__weekly_windows => {
                            if !fields.insert(__FieldTag::__weekly_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_windows",
                                ));
                            }
                            result.weekly_windows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WeeklyWindow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeWindows {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.one_time_windows.is_empty() {
            state.serialize_entry("oneTimeWindows", &self.one_time_windows)?;
        }
        if !self.weekly_windows.is_empty() {
            state.serialize_entry("weeklyWindows", &self.weekly_windows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeWindows {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindows");
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("one_time_windows", &self.one_time_windows);
        debug_struct.field("weekly_windows", &self.weekly_windows);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// One-time window within which actions are restricted. For example, blocking
/// actions over New Year's Eve from December 31st at 5pm to January 1st at 9am.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OneTimeWindow {
    /// Required. Start date.
    pub start_date: std::option::Option<gtype::model::Date>,

    /// Required. Start time (inclusive). Use 00:00 for the beginning of the day.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Required. End date.
    pub end_date: std::option::Option<gtype::model::Date>,

    /// Required. End time (exclusive). You may use 24:00 for the end of the day.
    pub end_time: std::option::Option<gtype::model::TimeOfDay>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OneTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_date][crate::model::OneTimeWindow::start_date].
    pub fn set_start_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_date][crate::model::OneTimeWindow::start_date].
    pub fn set_or_clear_start_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::OneTimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OneTimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_date][crate::model::OneTimeWindow::end_date].
    pub fn set_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_date][crate::model::OneTimeWindow::end_date].
    pub fn set_or_clear_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OneTimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OneTimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OneTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.OneTimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OneTimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_date,
            __start_time,
            __end_date,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OneTimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startDate" => Ok(__FieldTag::__start_date),
                            "start_date" => Ok(__FieldTag::__start_date),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endDate" => Ok(__FieldTag::__end_date),
                            "end_date" => Ok(__FieldTag::__end_date),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OneTimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OneTimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_date => {
                            if !fields.insert(__FieldTag::__start_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_date",
                                ));
                            }
                            result.start_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__end_date => {
                            if !fields.insert(__FieldTag::__end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_date",
                                ));
                            }
                            result.end_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OneTimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_date.is_some() {
            state.serialize_entry("startDate", &self.start_date)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_date.is_some() {
            state.serialize_entry("endDate", &self.end_date)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OneTimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OneTimeWindow");
        debug_struct.field("start_date", &self.start_date);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_date", &self.end_date);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Weekly windows. For example, blocking actions every Saturday and Sunday.
/// Another example would be blocking actions every weekday from 5pm to midnight.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WeeklyWindow {
    /// Optional. Days of week. If left empty, all days of the week will be
    /// included.
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. Start time (inclusive). Use 00:00 for the beginning of the day.
    /// If you specify start_time you must also specify end_time. If left empty,
    /// this will block for the entire day for the days specified in days_of_week.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Optional. End time (exclusive). Use 24:00 to indicate midnight. If you
    /// specify end_time you must also specify start_time. If left empty, this will
    /// block for the entire day for the days specified in days_of_week.
    pub end_time: std::option::Option<gtype::model::TimeOfDay>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklyWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [days_of_week][crate::model::WeeklyWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::WeeklyWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WeeklyWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::WeeklyWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::WeeklyWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WeeklyWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.WeeklyWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WeeklyWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __days_of_week,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WeeklyWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                            "days_of_week" => Ok(__FieldTag::__days_of_week),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WeeklyWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WeeklyWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__days_of_week => {
                            if !fields.insert(__FieldTag::__days_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_week",
                                ));
                            }
                            result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WeeklyWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.days_of_week.is_empty() {
            state.serialize_entry("daysOfWeek", &self.days_of_week)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WeeklyWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WeeklyWindow");
        debug_struct.field("days_of_week", &self.days_of_week);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Returned from an action if one or more policies were
/// violated, and therefore the action was prevented. Contains information about
/// what policies were violated and why.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicyViolation {
    /// Policy violation details.
    pub policy_violation_details: std::vec::Vec<crate::model::PolicyViolationDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyViolation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_violation_details][crate::model::PolicyViolation::policy_violation_details].
    pub fn set_policy_violation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyViolationDetails>,
    {
        use std::iter::Iterator;
        self.policy_violation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyViolation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyViolation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PolicyViolation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_violation_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyViolation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyViolationDetails" => Ok(__FieldTag::__policy_violation_details),
                            "policy_violation_details" => {
                                Ok(__FieldTag::__policy_violation_details)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PolicyViolation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyViolation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_violation_details => {
                            if !fields.insert(__FieldTag::__policy_violation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_violation_details",
                                ));
                            }
                            result.policy_violation_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PolicyViolationDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PolicyViolation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy_violation_details.is_empty() {
            state.serialize_entry("policyViolationDetails", &self.policy_violation_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PolicyViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PolicyViolation");
        debug_struct.field("policy_violation_details", &self.policy_violation_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Policy violation details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PolicyViolationDetails {
    /// Name of the policy that was violated.
    /// Policy resource will be in the format of
    /// `projects/{project}/locations/{location}/policies/{policy}`.
    pub policy: std::string::String,

    /// Id of the rule that triggered the policy violation.
    pub rule_id: std::string::String,

    /// User readable message about why the request violated a policy. This is not
    /// intended for machine parsing.
    pub failure_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyViolationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::PolicyViolationDetails::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::PolicyViolationDetails::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PolicyViolationDetails::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PolicyViolationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyViolationDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PolicyViolationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __rule_id,
            __failure_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyViolationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PolicyViolationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyViolationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PolicyViolationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PolicyViolationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PolicyViolationDetails");
        debug_struct.field("policy", &self.policy);
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("failure_message", &self.failure_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `Release` resource in the Cloud Deploy API.
///
/// A `Release` defines a specific Skaffold configuration instance
/// that can be deployed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Release {
    /// Identifier. Name of the `Release`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
    /// The `release` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Release`.
    pub uid: std::string::String,

    /// Optional. Description of the `Release`. Max length is 255 characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Indicates whether this is an abandoned release.
    pub abandoned: bool,

    /// Output only. Time at which the `Release` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the render began.
    pub render_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the render completed.
    pub render_end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Cloud Storage URI of tar.gz archive containing Skaffold
    /// configuration.
    pub skaffold_config_uri: std::string::String,

    /// Optional. Filepath of the Skaffold config inside of the config URI.
    pub skaffold_config_path: std::string::String,

    /// Optional. List of artifacts to pass through to Skaffold command.
    pub build_artifacts: std::vec::Vec<crate::model::BuildArtifact>,

    /// Output only. Snapshot of the parent pipeline taken at release creation
    /// time.
    pub delivery_pipeline_snapshot: std::option::Option<crate::model::DeliveryPipeline>,

    /// Output only. Snapshot of the targets taken at release creation time.
    pub target_snapshots: std::vec::Vec<crate::model::Target>,

    /// Output only. Snapshot of the custom target types referenced by the targets
    /// taken at release creation time.
    pub custom_target_type_snapshots: std::vec::Vec<crate::model::CustomTargetType>,

    /// Output only. Current state of the render operation.
    pub render_state: crate::model::release::RenderState,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. The Skaffold version to use when operating on this release, such
    /// as "1.20.0". Not all versions are valid; Cloud Deploy supports a specific
    /// set of versions.
    ///
    /// If unset, the most recent supported Skaffold version will be used.
    pub skaffold_version: std::string::String,

    /// Output only. Map from target ID to the target artifacts created
    /// during the render operation.
    pub target_artifacts:
        std::collections::HashMap<std::string::String, crate::model::TargetArtifact>,

    /// Output only. Map from target ID to details of the render operation for that
    /// target.
    pub target_renders:
        std::collections::HashMap<std::string::String, crate::model::release::TargetRender>,

    /// Output only. Information around the state of the Release.
    pub condition: std::option::Option<crate::model::release::ReleaseCondition>,

    /// Optional. The deploy parameters to use for all targets in this release.
    pub deploy_parameters: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Release {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Release::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Release::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Release::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Release::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Release::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [abandoned][crate::model::Release::abandoned].
    pub fn set_abandoned<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.abandoned = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Release::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Release::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [render_start_time][crate::model::Release::render_start_time].
    pub fn set_render_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [render_start_time][crate::model::Release::render_start_time].
    pub fn set_or_clear_render_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [render_end_time][crate::model::Release::render_end_time].
    pub fn set_render_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [render_end_time][crate::model::Release::render_end_time].
    pub fn set_or_clear_render_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skaffold_config_uri][crate::model::Release::skaffold_config_uri].
    pub fn set_skaffold_config_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_uri = v.into();
        self
    }

    /// Sets the value of [skaffold_config_path][crate::model::Release::skaffold_config_path].
    pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_path = v.into();
        self
    }

    /// Sets the value of [build_artifacts][crate::model::Release::build_artifacts].
    pub fn set_build_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildArtifact>,
    {
        use std::iter::Iterator;
        self.build_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [delivery_pipeline_snapshot][crate::model::Release::delivery_pipeline_snapshot].
    pub fn set_delivery_pipeline_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline_snapshot][crate::model::Release::delivery_pipeline_snapshot].
    pub fn set_or_clear_delivery_pipeline_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_snapshots][crate::model::Release::target_snapshots].
    pub fn set_target_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Target>,
    {
        use std::iter::Iterator;
        self.target_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_target_type_snapshots][crate::model::Release::custom_target_type_snapshots].
    pub fn set_custom_target_type_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomTargetType>,
    {
        use std::iter::Iterator;
        self.custom_target_type_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [render_state][crate::model::Release::render_state].
    pub fn set_render_state<T: std::convert::Into<crate::model::release::RenderState>>(
        mut self,
        v: T,
    ) -> Self {
        self.render_state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Release::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [skaffold_version][crate::model::Release::skaffold_version].
    pub fn set_skaffold_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_version = v.into();
        self
    }

    /// Sets the value of [target_artifacts][crate::model::Release::target_artifacts].
    pub fn set_target_artifacts<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TargetArtifact>,
    {
        use std::iter::Iterator;
        self.target_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [target_renders][crate::model::Release::target_renders].
    pub fn set_target_renders<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::release::TargetRender>,
    {
        use std::iter::Iterator;
        self.target_renders = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [condition][crate::model::Release::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::release::ReleaseCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Release::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::release::ReleaseCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Release::deploy_parameters].
    pub fn set_deploy_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Release {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Release"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Release {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __annotations,
            __labels,
            __abandoned,
            __create_time,
            __render_start_time,
            __render_end_time,
            __skaffold_config_uri,
            __skaffold_config_path,
            __build_artifacts,
            __delivery_pipeline_snapshot,
            __target_snapshots,
            __custom_target_type_snapshots,
            __render_state,
            __etag,
            __skaffold_version,
            __target_artifacts,
            __target_renders,
            __condition,
            __deploy_parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Release")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "abandoned" => Ok(__FieldTag::__abandoned),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "renderStartTime" => Ok(__FieldTag::__render_start_time),
                            "render_start_time" => Ok(__FieldTag::__render_start_time),
                            "renderEndTime" => Ok(__FieldTag::__render_end_time),
                            "render_end_time" => Ok(__FieldTag::__render_end_time),
                            "skaffoldConfigUri" => Ok(__FieldTag::__skaffold_config_uri),
                            "skaffold_config_uri" => Ok(__FieldTag::__skaffold_config_uri),
                            "skaffoldConfigPath" => Ok(__FieldTag::__skaffold_config_path),
                            "skaffold_config_path" => Ok(__FieldTag::__skaffold_config_path),
                            "buildArtifacts" => Ok(__FieldTag::__build_artifacts),
                            "build_artifacts" => Ok(__FieldTag::__build_artifacts),
                            "deliveryPipelineSnapshot" => {
                                Ok(__FieldTag::__delivery_pipeline_snapshot)
                            }
                            "delivery_pipeline_snapshot" => {
                                Ok(__FieldTag::__delivery_pipeline_snapshot)
                            }
                            "targetSnapshots" => Ok(__FieldTag::__target_snapshots),
                            "target_snapshots" => Ok(__FieldTag::__target_snapshots),
                            "customTargetTypeSnapshots" => {
                                Ok(__FieldTag::__custom_target_type_snapshots)
                            }
                            "custom_target_type_snapshots" => {
                                Ok(__FieldTag::__custom_target_type_snapshots)
                            }
                            "renderState" => Ok(__FieldTag::__render_state),
                            "render_state" => Ok(__FieldTag::__render_state),
                            "etag" => Ok(__FieldTag::__etag),
                            "skaffoldVersion" => Ok(__FieldTag::__skaffold_version),
                            "skaffold_version" => Ok(__FieldTag::__skaffold_version),
                            "targetArtifacts" => Ok(__FieldTag::__target_artifacts),
                            "target_artifacts" => Ok(__FieldTag::__target_artifacts),
                            "targetRenders" => Ok(__FieldTag::__target_renders),
                            "target_renders" => Ok(__FieldTag::__target_renders),
                            "condition" => Ok(__FieldTag::__condition),
                            "deployParameters" => Ok(__FieldTag::__deploy_parameters),
                            "deploy_parameters" => Ok(__FieldTag::__deploy_parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Release;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Release")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__abandoned => {
                            if !fields.insert(__FieldTag::__abandoned) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for abandoned",
                                ));
                            }
                            result.abandoned = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__render_start_time => {
                            if !fields.insert(__FieldTag::__render_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for render_start_time",
                                ));
                            }
                            result.render_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__render_end_time => {
                            if !fields.insert(__FieldTag::__render_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for render_end_time",
                                ));
                            }
                            result.render_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__skaffold_config_uri => {
                            if !fields.insert(__FieldTag::__skaffold_config_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skaffold_config_uri",
                                ));
                            }
                            result.skaffold_config_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skaffold_config_path => {
                            if !fields.insert(__FieldTag::__skaffold_config_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skaffold_config_path",
                                ));
                            }
                            result.skaffold_config_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_artifacts => {
                            if !fields.insert(__FieldTag::__build_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_artifacts",
                                ));
                            }
                            result.build_artifacts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BuildArtifact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__delivery_pipeline_snapshot => {
                            if !fields.insert(__FieldTag::__delivery_pipeline_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline_snapshot",
                                ));
                            }
                            result.delivery_pipeline_snapshot = map
                                .next_value::<std::option::Option<crate::model::DeliveryPipeline>>(
                                )?;
                        }
                        __FieldTag::__target_snapshots => {
                            if !fields.insert(__FieldTag::__target_snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_snapshots",
                                ));
                            }
                            result.target_snapshots = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type_snapshots => {
                            if !fields.insert(__FieldTag::__custom_target_type_snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type_snapshots",
                                ));
                            }
                            result.custom_target_type_snapshots =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomTargetType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__render_state => {
                            if !fields.insert(__FieldTag::__render_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for render_state",
                                ));
                            }
                            result.render_state = map.next_value::<std::option::Option<crate::model::release::RenderState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skaffold_version => {
                            if !fields.insert(__FieldTag::__skaffold_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skaffold_version",
                                ));
                            }
                            result.skaffold_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_artifacts => {
                            if !fields.insert(__FieldTag::__target_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_artifacts",
                                ));
                            }
                            result.target_artifacts = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TargetArtifact,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_renders => {
                            if !fields.insert(__FieldTag::__target_renders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_renders",
                                ));
                            }
                            result.target_renders = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::release::TargetRender,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::release::ReleaseCondition>>()?
                                ;
                        }
                        __FieldTag::__deploy_parameters => {
                            if !fields.insert(__FieldTag::__deploy_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_parameters",
                                ));
                            }
                            result.deploy_parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Release {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.abandoned) {
            state.serialize_entry("abandoned", &self.abandoned)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.render_start_time.is_some() {
            state.serialize_entry("renderStartTime", &self.render_start_time)?;
        }
        if self.render_end_time.is_some() {
            state.serialize_entry("renderEndTime", &self.render_end_time)?;
        }
        if !self.skaffold_config_uri.is_empty() {
            state.serialize_entry("skaffoldConfigUri", &self.skaffold_config_uri)?;
        }
        if !self.skaffold_config_path.is_empty() {
            state.serialize_entry("skaffoldConfigPath", &self.skaffold_config_path)?;
        }
        if !self.build_artifacts.is_empty() {
            state.serialize_entry("buildArtifacts", &self.build_artifacts)?;
        }
        if self.delivery_pipeline_snapshot.is_some() {
            state.serialize_entry("deliveryPipelineSnapshot", &self.delivery_pipeline_snapshot)?;
        }
        if !self.target_snapshots.is_empty() {
            state.serialize_entry("targetSnapshots", &self.target_snapshots)?;
        }
        if !self.custom_target_type_snapshots.is_empty() {
            state.serialize_entry(
                "customTargetTypeSnapshots",
                &self.custom_target_type_snapshots,
            )?;
        }
        if !wkt::internal::is_default(&self.render_state) {
            state.serialize_entry("renderState", &self.render_state)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.skaffold_version.is_empty() {
            state.serialize_entry("skaffoldVersion", &self.skaffold_version)?;
        }
        if !self.target_artifacts.is_empty() {
            state.serialize_entry("targetArtifacts", &self.target_artifacts)?;
        }
        if !self.target_renders.is_empty() {
            state.serialize_entry("targetRenders", &self.target_renders)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.deploy_parameters.is_empty() {
            state.serialize_entry("deployParameters", &self.deploy_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Release {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Release");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("abandoned", &self.abandoned);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("render_start_time", &self.render_start_time);
        debug_struct.field("render_end_time", &self.render_end_time);
        debug_struct.field("skaffold_config_uri", &self.skaffold_config_uri);
        debug_struct.field("skaffold_config_path", &self.skaffold_config_path);
        debug_struct.field("build_artifacts", &self.build_artifacts);
        debug_struct.field(
            "delivery_pipeline_snapshot",
            &self.delivery_pipeline_snapshot,
        );
        debug_struct.field("target_snapshots", &self.target_snapshots);
        debug_struct.field(
            "custom_target_type_snapshots",
            &self.custom_target_type_snapshots,
        );
        debug_struct.field("render_state", &self.render_state);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("skaffold_version", &self.skaffold_version);
        debug_struct.field("target_artifacts", &self.target_artifacts);
        debug_struct.field("target_renders", &self.target_renders);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("deploy_parameters", &self.deploy_parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Release].
pub mod release {
    #[allow(unused_imports)]
    use super::*;

    /// Details of rendering for a single target.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TargetRender {
        /// Output only. The resource name of the Cloud Build `Build` object that is
        /// used to render the manifest for this target. Format is
        /// `projects/{project}/locations/{location}/builds/{build}`.
        pub rendering_build: std::string::String,

        /// Output only. Current state of the render operation for this Target.
        pub rendering_state: crate::model::release::target_render::TargetRenderState,

        /// Output only. Metadata related to the `Release` render for this Target.
        pub metadata: std::option::Option<crate::model::RenderMetadata>,

        /// Output only. Reason this render failed. This will always be unspecified
        /// while the render in progress.
        pub failure_cause: crate::model::release::target_render::FailureCause,

        /// Output only. Additional information about the render failure, if
        /// available.
        pub failure_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TargetRender {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rendering_build][crate::model::release::TargetRender::rendering_build].
        pub fn set_rendering_build<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rendering_build = v.into();
            self
        }

        /// Sets the value of [rendering_state][crate::model::release::TargetRender::rendering_state].
        pub fn set_rendering_state<
            T: std::convert::Into<crate::model::release::target_render::TargetRenderState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rendering_state = v.into();
            self
        }

        /// Sets the value of [metadata][crate::model::release::TargetRender::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RenderMetadata>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::release::TargetRender::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RenderMetadata>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }

        /// Sets the value of [failure_cause][crate::model::release::TargetRender::failure_cause].
        pub fn set_failure_cause<
            T: std::convert::Into<crate::model::release::target_render::FailureCause>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.failure_cause = v.into();
            self
        }

        /// Sets the value of [failure_message][crate::model::release::TargetRender::failure_message].
        pub fn set_failure_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.failure_message = v.into();
            self
        }
    }

    impl wkt::message::Message for TargetRender {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.TargetRender"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TargetRender {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rendering_build,
                __rendering_state,
                __metadata,
                __failure_cause,
                __failure_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TargetRender")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "renderingBuild" => Ok(__FieldTag::__rendering_build),
                                "rendering_build" => Ok(__FieldTag::__rendering_build),
                                "renderingState" => Ok(__FieldTag::__rendering_state),
                                "rendering_state" => Ok(__FieldTag::__rendering_state),
                                "metadata" => Ok(__FieldTag::__metadata),
                                "failureCause" => Ok(__FieldTag::__failure_cause),
                                "failure_cause" => Ok(__FieldTag::__failure_cause),
                                "failureMessage" => Ok(__FieldTag::__failure_message),
                                "failure_message" => Ok(__FieldTag::__failure_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TargetRender;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TargetRender")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rendering_build => {
                                if !fields.insert(__FieldTag::__rendering_build) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rendering_build",
                                    ));
                                }
                                result.rendering_build = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__rendering_state => {
                                if !fields.insert(__FieldTag::__rendering_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rendering_state",
                                    ));
                                }
                                result.rendering_state = map
                                    .next_value::<std::option::Option<
                                        crate::model::release::target_render::TargetRenderState,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata = map.next_value::<std::option::Option<crate::model::RenderMetadata>>()?
                                    ;
                            }
                            __FieldTag::__failure_cause => {
                                if !fields.insert(__FieldTag::__failure_cause) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failure_cause",
                                    ));
                                }
                                result.failure_cause = map
                                    .next_value::<std::option::Option<
                                        crate::model::release::target_render::FailureCause,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__failure_message => {
                                if !fields.insert(__FieldTag::__failure_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failure_message",
                                    ));
                                }
                                result.failure_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TargetRender {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rendering_build.is_empty() {
                state.serialize_entry("renderingBuild", &self.rendering_build)?;
            }
            if !wkt::internal::is_default(&self.rendering_state) {
                state.serialize_entry("renderingState", &self.rendering_state)?;
            }
            if self.metadata.is_some() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !wkt::internal::is_default(&self.failure_cause) {
                state.serialize_entry("failureCause", &self.failure_cause)?;
            }
            if !self.failure_message.is_empty() {
                state.serialize_entry("failureMessage", &self.failure_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TargetRender {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TargetRender");
            debug_struct.field("rendering_build", &self.rendering_build);
            debug_struct.field("rendering_state", &self.rendering_state);
            debug_struct.field("metadata", &self.metadata);
            debug_struct.field("failure_cause", &self.failure_cause);
            debug_struct.field("failure_message", &self.failure_message);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [TargetRender].
    pub mod target_render {
        #[allow(unused_imports)]
        use super::*;

        /// Valid states of the render operation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TargetRenderState {
            /// The render operation state is unspecified.
            Unspecified,
            /// The render operation has completed successfully.
            Succeeded,
            /// The render operation has failed.
            Failed,
            /// The render operation is in progress.
            InProgress,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TargetRenderState::value] or
            /// [TargetRenderState::name].
            UnknownValue(target_render_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod target_render_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TargetRenderState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Succeeded => std::option::Option::Some(1),
                    Self::Failed => std::option::Option::Some(2),
                    Self::InProgress => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("TARGET_RENDER_STATE_UNSPECIFIED")
                    }
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TargetRenderState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TargetRenderState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TargetRenderState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Succeeded,
                    2 => Self::Failed,
                    3 => Self::InProgress,
                    _ => Self::UnknownValue(target_render_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TargetRenderState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TARGET_RENDER_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    "IN_PROGRESS" => Self::InProgress,
                    _ => Self::UnknownValue(target_render_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TargetRenderState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Succeeded => serializer.serialize_i32(1),
                    Self::Failed => serializer.serialize_i32(2),
                    Self::InProgress => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TargetRenderState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetRenderState>::new(
                    ".google.cloud.deploy.v1.Release.TargetRender.TargetRenderState",
                ))
            }
        }

        /// Well-known rendering failures.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FailureCause {
            /// No reason for failure is specified.
            Unspecified,
            /// Cloud Build is not available, either because it is not enabled or
            /// because Cloud Deploy has insufficient permissions. See [required
            /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
            CloudBuildUnavailable,
            /// The render operation did not complete successfully; check Cloud Build
            /// logs.
            ExecutionFailed,
            /// Cloud Build failed to fulfill Cloud Deploy's request. See
            /// failure_message for additional details.
            CloudBuildRequestFailed,
            /// The render operation did not complete successfully because the
            /// verification stanza required for verify was not found on the Skaffold
            /// configuration.
            VerificationConfigNotFound,
            /// The render operation did not complete successfully because the custom
            /// action(s) required for Rollout jobs were not found in the Skaffold
            /// configuration. See failure_message for additional details.
            CustomActionNotFound,
            /// Release failed during rendering because the release configuration is
            /// not supported with the specified deployment strategy.
            DeploymentStrategyNotSupported,
            /// The render operation had a feature configured that is not supported.
            RenderFeatureNotSupported,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FailureCause::value] or
            /// [FailureCause::name].
            UnknownValue(failure_cause::UnknownValue),
        }

        #[doc(hidden)]
        pub mod failure_cause {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FailureCause {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::CloudBuildUnavailable => std::option::Option::Some(1),
                    Self::ExecutionFailed => std::option::Option::Some(2),
                    Self::CloudBuildRequestFailed => std::option::Option::Some(3),
                    Self::VerificationConfigNotFound => std::option::Option::Some(4),
                    Self::CustomActionNotFound => std::option::Option::Some(5),
                    Self::DeploymentStrategyNotSupported => std::option::Option::Some(6),
                    Self::RenderFeatureNotSupported => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                    Self::CloudBuildUnavailable => {
                        std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE")
                    }
                    Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                    Self::CloudBuildRequestFailed => {
                        std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                    }
                    Self::VerificationConfigNotFound => {
                        std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                    }
                    Self::CustomActionNotFound => {
                        std::option::Option::Some("CUSTOM_ACTION_NOT_FOUND")
                    }
                    Self::DeploymentStrategyNotSupported => {
                        std::option::Option::Some("DEPLOYMENT_STRATEGY_NOT_SUPPORTED")
                    }
                    Self::RenderFeatureNotSupported => {
                        std::option::Option::Some("RENDER_FEATURE_NOT_SUPPORTED")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FailureCause {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FailureCause {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FailureCause {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::CloudBuildUnavailable,
                    2 => Self::ExecutionFailed,
                    3 => Self::CloudBuildRequestFailed,
                    4 => Self::VerificationConfigNotFound,
                    5 => Self::CustomActionNotFound,
                    6 => Self::DeploymentStrategyNotSupported,
                    7 => Self::RenderFeatureNotSupported,
                    _ => Self::UnknownValue(failure_cause::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FailureCause {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                    "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                    "EXECUTION_FAILED" => Self::ExecutionFailed,
                    "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                    "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                    "CUSTOM_ACTION_NOT_FOUND" => Self::CustomActionNotFound,
                    "DEPLOYMENT_STRATEGY_NOT_SUPPORTED" => Self::DeploymentStrategyNotSupported,
                    "RENDER_FEATURE_NOT_SUPPORTED" => Self::RenderFeatureNotSupported,
                    _ => Self::UnknownValue(failure_cause::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FailureCause {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                    Self::ExecutionFailed => serializer.serialize_i32(2),
                    Self::CloudBuildRequestFailed => serializer.serialize_i32(3),
                    Self::VerificationConfigNotFound => serializer.serialize_i32(4),
                    Self::CustomActionNotFound => serializer.serialize_i32(5),
                    Self::DeploymentStrategyNotSupported => serializer.serialize_i32(6),
                    Self::RenderFeatureNotSupported => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FailureCause {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                    ".google.cloud.deploy.v1.Release.TargetRender.FailureCause",
                ))
            }
        }
    }

    /// ReleaseReadyCondition contains information around the status of the
    /// Release. If a release is not ready, you cannot create a rollout with the
    /// release.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReleaseReadyCondition {
        /// True if the Release is in a valid state. Otherwise at least one condition
        /// in `ReleaseCondition` is in an invalid state. Iterate over those
        /// conditions and see which condition(s) has status = false to find out what
        /// is wrong with the Release.
        pub status: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseReadyCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::release::ReleaseReadyCondition::status].
        pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for ReleaseReadyCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.ReleaseReadyCondition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReleaseReadyCondition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReleaseReadyCondition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReleaseReadyCondition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReleaseReadyCondition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReleaseReadyCondition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ReleaseReadyCondition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ReleaseReadyCondition");
            debug_struct.field("status", &self.status);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// SkaffoldSupportedCondition contains information about when support for the
    /// release's version of Skaffold ends.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SkaffoldSupportedCondition {
        /// True if the version of Skaffold used by this release is supported.
        pub status: bool,

        /// The Skaffold support state for this release's version of Skaffold.
        pub skaffold_support_state: crate::model::SkaffoldSupportState,

        /// The time at which this release's version of Skaffold will enter
        /// maintenance mode.
        pub maintenance_mode_time: std::option::Option<wkt::Timestamp>,

        /// The time at which this release's version of Skaffold will no longer be
        /// supported.
        pub support_expiration_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldSupportedCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::release::SkaffoldSupportedCondition::status].
        pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [skaffold_support_state][crate::model::release::SkaffoldSupportedCondition::skaffold_support_state].
        pub fn set_skaffold_support_state<
            T: std::convert::Into<crate::model::SkaffoldSupportState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.skaffold_support_state = v.into();
            self
        }

        /// Sets the value of [maintenance_mode_time][crate::model::release::SkaffoldSupportedCondition::maintenance_mode_time].
        pub fn set_maintenance_mode_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.maintenance_mode_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [maintenance_mode_time][crate::model::release::SkaffoldSupportedCondition::maintenance_mode_time].
        pub fn set_or_clear_maintenance_mode_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.maintenance_mode_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [support_expiration_time][crate::model::release::SkaffoldSupportedCondition::support_expiration_time].
        pub fn set_support_expiration_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.support_expiration_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [support_expiration_time][crate::model::release::SkaffoldSupportedCondition::support_expiration_time].
        pub fn set_or_clear_support_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.support_expiration_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SkaffoldSupportedCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.SkaffoldSupportedCondition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SkaffoldSupportedCondition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __status,
                __skaffold_support_state,
                __maintenance_mode_time,
                __support_expiration_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SkaffoldSupportedCondition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "status" => Ok(__FieldTag::__status),
                                "skaffoldSupportState" => Ok(__FieldTag::__skaffold_support_state),
                                "skaffold_support_state" => {
                                    Ok(__FieldTag::__skaffold_support_state)
                                }
                                "maintenanceModeTime" => Ok(__FieldTag::__maintenance_mode_time),
                                "maintenance_mode_time" => Ok(__FieldTag::__maintenance_mode_time),
                                "supportExpirationTime" => {
                                    Ok(__FieldTag::__support_expiration_time)
                                }
                                "support_expiration_time" => {
                                    Ok(__FieldTag::__support_expiration_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SkaffoldSupportedCondition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SkaffoldSupportedCondition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__skaffold_support_state => {
                                if !fields.insert(__FieldTag::__skaffold_support_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for skaffold_support_state",
                                    ));
                                }
                                result.skaffold_support_state = map.next_value::<std::option::Option<crate::model::SkaffoldSupportState>>()?.unwrap_or_default();
                            }
                            __FieldTag::__maintenance_mode_time => {
                                if !fields.insert(__FieldTag::__maintenance_mode_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for maintenance_mode_time",
                                    ));
                                }
                                result.maintenance_mode_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__support_expiration_time => {
                                if !fields.insert(__FieldTag::__support_expiration_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for support_expiration_time",
                                    ));
                                }
                                result.support_expiration_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SkaffoldSupportedCondition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !wkt::internal::is_default(&self.skaffold_support_state) {
                state.serialize_entry("skaffoldSupportState", &self.skaffold_support_state)?;
            }
            if self.maintenance_mode_time.is_some() {
                state.serialize_entry("maintenanceModeTime", &self.maintenance_mode_time)?;
            }
            if self.support_expiration_time.is_some() {
                state.serialize_entry("supportExpirationTime", &self.support_expiration_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SkaffoldSupportedCondition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SkaffoldSupportedCondition");
            debug_struct.field("status", &self.status);
            debug_struct.field("skaffold_support_state", &self.skaffold_support_state);
            debug_struct.field("maintenance_mode_time", &self.maintenance_mode_time);
            debug_struct.field("support_expiration_time", &self.support_expiration_time);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// ReleaseCondition contains all conditions relevant to a Release.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReleaseCondition {
        /// Details around the Releases's overall status.
        pub release_ready_condition:
            std::option::Option<crate::model::release::ReleaseReadyCondition>,

        /// Details around the support state of the release's Skaffold
        /// version.
        pub skaffold_supported_condition:
            std::option::Option<crate::model::release::SkaffoldSupportedCondition>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [release_ready_condition][crate::model::release::ReleaseCondition::release_ready_condition].
        pub fn set_release_ready_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::release::ReleaseReadyCondition>,
        {
            self.release_ready_condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [release_ready_condition][crate::model::release::ReleaseCondition::release_ready_condition].
        pub fn set_or_clear_release_ready_condition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::release::ReleaseReadyCondition>,
        {
            self.release_ready_condition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [skaffold_supported_condition][crate::model::release::ReleaseCondition::skaffold_supported_condition].
        pub fn set_skaffold_supported_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::release::SkaffoldSupportedCondition>,
        {
            self.skaffold_supported_condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [skaffold_supported_condition][crate::model::release::ReleaseCondition::skaffold_supported_condition].
        pub fn set_or_clear_skaffold_supported_condition<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::release::SkaffoldSupportedCondition>,
        {
            self.skaffold_supported_condition = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReleaseCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.ReleaseCondition"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReleaseCondition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __release_ready_condition,
                __skaffold_supported_condition,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReleaseCondition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "releaseReadyCondition" => {
                                    Ok(__FieldTag::__release_ready_condition)
                                }
                                "release_ready_condition" => {
                                    Ok(__FieldTag::__release_ready_condition)
                                }
                                "skaffoldSupportedCondition" => {
                                    Ok(__FieldTag::__skaffold_supported_condition)
                                }
                                "skaffold_supported_condition" => {
                                    Ok(__FieldTag::__skaffold_supported_condition)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReleaseCondition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReleaseCondition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__release_ready_condition => {
                                if !fields.insert(__FieldTag::__release_ready_condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for release_ready_condition",
                                    ));
                                }
                                result.release_ready_condition = map
                                    .next_value::<std::option::Option<
                                        crate::model::release::ReleaseReadyCondition,
                                    >>()?;
                            }
                            __FieldTag::__skaffold_supported_condition => {
                                if !fields.insert(__FieldTag::__skaffold_supported_condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for skaffold_supported_condition",
                                    ));
                                }
                                result.skaffold_supported_condition = map
                                    .next_value::<std::option::Option<
                                        crate::model::release::SkaffoldSupportedCondition,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReleaseCondition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.release_ready_condition.is_some() {
                state.serialize_entry("releaseReadyCondition", &self.release_ready_condition)?;
            }
            if self.skaffold_supported_condition.is_some() {
                state.serialize_entry(
                    "skaffoldSupportedCondition",
                    &self.skaffold_supported_condition,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ReleaseCondition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ReleaseCondition");
            debug_struct.field("release_ready_condition", &self.release_ready_condition);
            debug_struct.field(
                "skaffold_supported_condition",
                &self.skaffold_supported_condition,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Valid states of the render operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RenderState {
        /// The render state is unspecified.
        Unspecified,
        /// All rendering operations have completed successfully.
        Succeeded,
        /// All rendering operations have completed, and one or more have failed.
        Failed,
        /// Rendering has started and is not complete.
        InProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RenderState::value] or
        /// [RenderState::name].
        UnknownValue(render_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod render_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RenderState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RENDER_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RenderState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RenderState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RenderState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::InProgress,
                _ => Self::UnknownValue(render_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RenderState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RENDER_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                _ => Self::UnknownValue(render_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RenderState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RenderState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RenderState>::new(
                ".google.cloud.deploy.v1.Release.RenderState",
            ))
        }
    }
}

/// The request object for `CreateDeployPolicy`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDeployPolicyRequest {
    /// Required. The parent collection in which the `DeployPolicy` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `DeployPolicy`.
    pub deploy_policy_id: std::string::String,

    /// Required. The `DeployPolicy` to create.
    pub deploy_policy: std::option::Option<crate::model::DeployPolicy>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeployPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deploy_policy_id][crate::model::CreateDeployPolicyRequest::deploy_policy_id].
    pub fn set_deploy_policy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_id = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::CreateDeployPolicyRequest::deploy_policy].
    pub fn set_deploy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_policy][crate::model::CreateDeployPolicyRequest::deploy_policy].
    pub fn set_or_clear_deploy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateDeployPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDeployPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __deploy_policy_id,
            __deploy_policy,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDeployPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "deployPolicyId" => Ok(__FieldTag::__deploy_policy_id),
                            "deploy_policy_id" => Ok(__FieldTag::__deploy_policy_id),
                            "deployPolicy" => Ok(__FieldTag::__deploy_policy),
                            "deploy_policy" => Ok(__FieldTag::__deploy_policy),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDeployPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDeployPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy_id => {
                            if !fields.insert(__FieldTag::__deploy_policy_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy_id",
                                ));
                            }
                            result.deploy_policy_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy => {
                            if !fields.insert(__FieldTag::__deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy",
                                ));
                            }
                            result.deploy_policy = map
                                .next_value::<std::option::Option<crate::model::DeployPolicy>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDeployPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.deploy_policy_id.is_empty() {
            state.serialize_entry("deployPolicyId", &self.deploy_policy_id)?;
        }
        if self.deploy_policy.is_some() {
            state.serialize_entry("deployPolicy", &self.deploy_policy)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDeployPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDeployPolicyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("deploy_policy_id", &self.deploy_policy_id);
        debug_struct.field("deploy_policy", &self.deploy_policy);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `UpdateDeployPolicy`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDeployPolicyRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `DeployPolicy` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `DeployPolicy` to update.
    pub deploy_policy: std::option::Option<crate::model::DeployPolicy>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `DeployPolicy` that does not exist
    /// will result in the creation of a new `DeployPolicy`.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeployPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeployPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_policy][crate::model::UpdateDeployPolicyRequest::deploy_policy].
    pub fn set_deploy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_policy][crate::model::UpdateDeployPolicyRequest::deploy_policy].
    pub fn set_or_clear_deploy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDeployPolicyRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateDeployPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDeployPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __deploy_policy,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDeployPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "deployPolicy" => Ok(__FieldTag::__deploy_policy),
                            "deploy_policy" => Ok(__FieldTag::__deploy_policy),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDeployPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDeployPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__deploy_policy => {
                            if !fields.insert(__FieldTag::__deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy",
                                ));
                            }
                            result.deploy_policy = map
                                .next_value::<std::option::Option<crate::model::DeployPolicy>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDeployPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.deploy_policy.is_some() {
            state.serialize_entry("deployPolicy", &self.deploy_policy)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDeployPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDeployPolicyRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("deploy_policy", &self.deploy_policy);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `DeleteDeployPolicy`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDeployPolicyRequest {
    /// Required. The name of the `DeployPolicy` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `DeployPolicy` will succeed.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeployPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteDeployPolicyRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDeployPolicyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteDeployPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDeployPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __allow_missing,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDeployPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDeployPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDeployPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDeployPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDeployPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDeployPolicyRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListDeployPolicies`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeployPoliciesRequest {
    /// Required. The parent, which owns this collection of deploy policies. Format
    /// must be `projects/{project_id}/locations/{location_name}`.
    pub parent: std::string::String,

    /// The maximum number of deploy policies to return. The service may return
    /// fewer than this value. If unspecified, at most 50 deploy policies will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListDeployPolicies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter deploy policies to be returned. See <https://google.aip.dev/160> for
    /// more details. All fields can be used in the filter.
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeployPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeployPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeployPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeployPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeployPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeployPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDeployPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeployPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeployPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeployPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeployPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeployPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeployPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeployPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeployPoliciesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListDeployPolicies`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeployPoliciesResponse {
    /// The `DeployPolicy` objects.
    pub deploy_policies: std::vec::Vec<crate::model::DeployPolicy>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeployPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deploy_policies][crate::model::ListDeployPoliciesResponse::deploy_policies].
    pub fn set_deploy_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployPolicy>,
    {
        use std::iter::Iterator;
        self.deploy_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeployPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDeployPoliciesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeployPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeployPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeployPoliciesResponse {
    type PageItem = crate::model::DeployPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deploy_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeployPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deploy_policies,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeployPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deployPolicies" => Ok(__FieldTag::__deploy_policies),
                            "deploy_policies" => Ok(__FieldTag::__deploy_policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeployPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeployPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deploy_policies => {
                            if !fields.insert(__FieldTag::__deploy_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policies",
                                ));
                            }
                            result.deploy_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DeployPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDeployPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deploy_policies.is_empty() {
            state.serialize_entry("deployPolicies", &self.deploy_policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDeployPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDeployPoliciesResponse");
        debug_struct.field("deploy_policies", &self.deploy_policies);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetDeployPolicy`
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeployPolicyRequest {
    /// Required. Name of the `DeployPolicy`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeployPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetDeployPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeployPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeployPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeployPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeployPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDeployPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDeployPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDeployPolicyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Description of an a image to use during Skaffold rendering.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildArtifact {
    /// Optional. Image name in Skaffold configuration.
    pub image: std::string::String,

    /// Optional. Image tag to use. This will generally be the full path to an
    /// image, such as "gcr.io/my-project/busybox:1.2.3" or
    /// "gcr.io/my-project/busybox@sha256:abc123".
    pub tag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::BuildArtifact::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::BuildArtifact::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for BuildArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.BuildArtifact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image,
            __tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "image" => Ok(__FieldTag::__image),
                            "tag" => Ok(__FieldTag::__tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            result.image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildArtifact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image.is_empty() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BuildArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildArtifact");
        debug_struct.field("image", &self.image);
        debug_struct.field("tag", &self.tag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The artifacts produced by a target render operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetArtifact {
    /// Output only. File path of the resolved Skaffold configuration for the
    /// stable phase, relative to the URI.
    pub skaffold_config_path: std::string::String,

    /// Output only. File path of the rendered manifest relative to the URI for the
    /// stable phase.
    pub manifest_path: std::string::String,

    /// Output only. Map from the phase ID to the phase artifacts for the `Target`.
    pub phase_artifacts: std::collections::HashMap<
        std::string::String,
        crate::model::target_artifact::PhaseArtifact,
    >,

    pub uri: std::option::Option<crate::model::target_artifact::Uri>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skaffold_config_path][crate::model::TargetArtifact::skaffold_config_path].
    pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_path = v.into();
        self
    }

    /// Sets the value of [manifest_path][crate::model::TargetArtifact::manifest_path].
    pub fn set_manifest_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manifest_path = v.into();
        self
    }

    /// Sets the value of [phase_artifacts][crate::model::TargetArtifact::phase_artifacts].
    pub fn set_phase_artifacts<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::target_artifact::PhaseArtifact>,
    {
        use std::iter::Iterator;
        self.phase_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uri][crate::model::TargetArtifact::uri].
    ///
    /// Note that all the setters affecting `uri` are mutually
    /// exclusive.
    pub fn set_uri<
        T: std::convert::Into<std::option::Option<crate::model::target_artifact::Uri>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.uri = v.into();
        self
    }

    /// The value of [uri][crate::model::TargetArtifact::uri]
    /// if it holds a `ArtifactUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn artifact_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.uri.as_ref().and_then(|v| match v {
            crate::model::target_artifact::Uri::ArtifactUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [uri][crate::model::TargetArtifact::uri]
    /// to hold a `ArtifactUri`.
    ///
    /// Note that all the setters affecting `uri` are
    /// mutually exclusive.
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri =
            std::option::Option::Some(crate::model::target_artifact::Uri::ArtifactUri(v.into()));
        self
    }
}

impl wkt::message::Message for TargetArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetArtifact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __artifact_uri,
            __skaffold_config_path,
            __manifest_path,
            __phase_artifacts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "artifactUri" => Ok(__FieldTag::__artifact_uri),
                            "artifact_uri" => Ok(__FieldTag::__artifact_uri),
                            "skaffoldConfigPath" => Ok(__FieldTag::__skaffold_config_path),
                            "skaffold_config_path" => Ok(__FieldTag::__skaffold_config_path),
                            "manifestPath" => Ok(__FieldTag::__manifest_path),
                            "manifest_path" => Ok(__FieldTag::__manifest_path),
                            "phaseArtifacts" => Ok(__FieldTag::__phase_artifacts),
                            "phase_artifacts" => Ok(__FieldTag::__phase_artifacts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__artifact_uri => {
                            if !fields.insert(__FieldTag::__artifact_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_uri",
                                ));
                            }
                            if result.uri.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `uri`, a oneof with full ID .google.cloud.deploy.v1.TargetArtifact.artifact_uri, latest field was artifactUri",
                                ));
                            }
                            result.uri = std::option::Option::Some(
                                crate::model::target_artifact::Uri::ArtifactUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__skaffold_config_path => {
                            if !fields.insert(__FieldTag::__skaffold_config_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skaffold_config_path",
                                ));
                            }
                            result.skaffold_config_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manifest_path => {
                            if !fields.insert(__FieldTag::__manifest_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest_path",
                                ));
                            }
                            result.manifest_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase_artifacts => {
                            if !fields.insert(__FieldTag::__phase_artifacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_artifacts",
                                ));
                            }
                            result.phase_artifacts = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::target_artifact::PhaseArtifact,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetArtifact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.artifact_uri() {
            state.serialize_entry("artifactUri", value)?;
        }
        if !self.skaffold_config_path.is_empty() {
            state.serialize_entry("skaffoldConfigPath", &self.skaffold_config_path)?;
        }
        if !self.manifest_path.is_empty() {
            state.serialize_entry("manifestPath", &self.manifest_path)?;
        }
        if !self.phase_artifacts.is_empty() {
            state.serialize_entry("phaseArtifacts", &self.phase_artifacts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetArtifact");
        debug_struct.field("skaffold_config_path", &self.skaffold_config_path);
        debug_struct.field("manifest_path", &self.manifest_path);
        debug_struct.field("phase_artifacts", &self.phase_artifacts);
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TargetArtifact].
pub mod target_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Contains the paths to the artifacts, relative to the URI, for a phase.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PhaseArtifact {
        /// Output only. File path of the resolved Skaffold configuration relative to
        /// the URI.
        pub skaffold_config_path: std::string::String,

        /// Output only. File path of the rendered manifest relative to the URI.
        pub manifest_path: std::string::String,

        /// Output only. File path of the directory of rendered job manifests
        /// relative to the URI. This is only set if it is applicable.
        pub job_manifests_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PhaseArtifact {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [skaffold_config_path][crate::model::target_artifact::PhaseArtifact::skaffold_config_path].
        pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.skaffold_config_path = v.into();
            self
        }

        /// Sets the value of [manifest_path][crate::model::target_artifact::PhaseArtifact::manifest_path].
        pub fn set_manifest_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.manifest_path = v.into();
            self
        }

        /// Sets the value of [job_manifests_path][crate::model::target_artifact::PhaseArtifact::job_manifests_path].
        pub fn set_job_manifests_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.job_manifests_path = v.into();
            self
        }
    }

    impl wkt::message::Message for PhaseArtifact {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.TargetArtifact.PhaseArtifact"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PhaseArtifact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __skaffold_config_path,
                __manifest_path,
                __job_manifests_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PhaseArtifact")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "skaffoldConfigPath" => Ok(__FieldTag::__skaffold_config_path),
                                "skaffold_config_path" => Ok(__FieldTag::__skaffold_config_path),
                                "manifestPath" => Ok(__FieldTag::__manifest_path),
                                "manifest_path" => Ok(__FieldTag::__manifest_path),
                                "jobManifestsPath" => Ok(__FieldTag::__job_manifests_path),
                                "job_manifests_path" => Ok(__FieldTag::__job_manifests_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PhaseArtifact;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PhaseArtifact")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__skaffold_config_path => {
                                if !fields.insert(__FieldTag::__skaffold_config_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for skaffold_config_path",
                                    ));
                                }
                                result.skaffold_config_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__manifest_path => {
                                if !fields.insert(__FieldTag::__manifest_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for manifest_path",
                                    ));
                                }
                                result.manifest_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__job_manifests_path => {
                                if !fields.insert(__FieldTag::__job_manifests_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_manifests_path",
                                    ));
                                }
                                result.job_manifests_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PhaseArtifact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.skaffold_config_path.is_empty() {
                state.serialize_entry("skaffoldConfigPath", &self.skaffold_config_path)?;
            }
            if !self.manifest_path.is_empty() {
                state.serialize_entry("manifestPath", &self.manifest_path)?;
            }
            if !self.job_manifests_path.is_empty() {
                state.serialize_entry("jobManifestsPath", &self.job_manifests_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PhaseArtifact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PhaseArtifact");
            debug_struct.field("skaffold_config_path", &self.skaffold_config_path);
            debug_struct.field("manifest_path", &self.manifest_path);
            debug_struct.field("job_manifests_path", &self.job_manifests_path);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Uri {
        /// Output only. URI of a directory containing the artifacts. This contains
        /// deployment configuration used by Skaffold during a rollout, and all
        /// paths are relative to this location.
        ArtifactUri(std::string::String),
    }
}

/// The artifacts produced by a deploy operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployArtifact {
    /// Output only. URI of a directory containing the artifacts. All paths are
    /// relative to this location.
    pub artifact_uri: std::string::String,

    /// Output only. File paths of the manifests applied during the deploy
    /// operation relative to the URI.
    pub manifest_paths: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_uri][crate::model::DeployArtifact::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [manifest_paths][crate::model::DeployArtifact::manifest_paths].
    pub fn set_manifest_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.manifest_paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeployArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployArtifact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployArtifact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __artifact_uri,
            __manifest_paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployArtifact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "artifactUri" => Ok(__FieldTag::__artifact_uri),
                            "artifact_uri" => Ok(__FieldTag::__artifact_uri),
                            "manifestPaths" => Ok(__FieldTag::__manifest_paths),
                            "manifest_paths" => Ok(__FieldTag::__manifest_paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployArtifact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployArtifact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__artifact_uri => {
                            if !fields.insert(__FieldTag::__artifact_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_uri",
                                ));
                            }
                            result.artifact_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manifest_paths => {
                            if !fields.insert(__FieldTag::__manifest_paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest_paths",
                                ));
                            }
                            result.manifest_paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployArtifact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.artifact_uri.is_empty() {
            state.serialize_entry("artifactUri", &self.artifact_uri)?;
        }
        if !self.manifest_paths.is_empty() {
            state.serialize_entry("manifestPaths", &self.manifest_paths)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployArtifact");
        debug_struct.field("artifact_uri", &self.artifact_uri);
        debug_struct.field("manifest_paths", &self.manifest_paths);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloudRunRenderMetadata contains Cloud Run information associated with a
/// `Release` render.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunRenderMetadata {
    /// Output only. The name of the Cloud Run Service in the rendered manifest.
    /// Format is `projects/{project}/locations/{location}/services/{service}`.
    pub service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunRenderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRunRenderMetadata::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunRenderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunRenderMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunRenderMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunRenderMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunRenderMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunRenderMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunRenderMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunRenderMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunRenderMetadata");
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RenderMetadata includes information associated with a `Release` render.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RenderMetadata {
    /// Output only. Metadata associated with rendering for Cloud Run.
    pub cloud_run: std::option::Option<crate::model::CloudRunRenderMetadata>,

    /// Output only. Custom metadata provided by user-defined render operation.
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::RenderMetadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunRenderMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::RenderMetadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunRenderMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::RenderMetadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::RenderMetadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RenderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RenderMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenderMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_run,
            __custom,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenderMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            "custom" => Ok(__FieldTag::__custom),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenderMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenderMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            result.cloud_run = map.next_value::<std::option::Option<crate::model::CloudRunRenderMetadata>>()?
                                ;
                        }
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom",
                                ));
                            }
                            result.custom = map
                                .next_value::<std::option::Option<crate::model::CustomMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenderMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_run.is_some() {
            state.serialize_entry("cloudRun", &self.cloud_run)?;
        }
        if self.custom.is_some() {
            state.serialize_entry("custom", &self.custom)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RenderMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RenderMetadata");
        debug_struct.field("cloud_run", &self.cloud_run);
        debug_struct.field("custom", &self.custom);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListReleases`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReleasesRequest {
    /// Required. The `DeliveryPipeline` which owns this collection of `Release`
    /// objects.
    pub parent: std::string::String,

    /// Optional. The maximum number of `Release` objects to return. The service
    /// may return fewer than this value. If unspecified, at most 50 `Release`
    /// objects will be returned. The maximum value is 1000; values above 1000 will
    /// be set to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListReleases` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter releases to be returned. See <https://google.aip.dev/160>
    /// for more details.
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReleasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReleasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReleasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReleasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReleasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReleasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListReleasesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReleasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReleasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReleasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReleasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReleasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReleasesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReleasesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListReleases`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReleasesResponse {
    /// The `Release` objects.
    pub releases: std::vec::Vec<crate::model::Release>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [releases][crate::model::ListReleasesResponse::releases].
    pub fn set_releases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Release>,
    {
        use std::iter::Iterator;
        self.releases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReleasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReleasesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReleasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListReleasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReleasesResponse {
    type PageItem = crate::model::Release;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.releases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReleasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __releases,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReleasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "releases" => Ok(__FieldTag::__releases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReleasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReleasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__releases => {
                            if !fields.insert(__FieldTag::__releases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for releases",
                                ));
                            }
                            result.releases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Release>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReleasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.releases.is_empty() {
            state.serialize_entry("releases", &self.releases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReleasesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReleasesResponse");
        debug_struct.field("releases", &self.releases);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetRelease`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReleaseRequest {
    /// Required. Name of the `Release`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReleaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetReleaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReleaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReleaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReleaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReleaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReleaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReleaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReleaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `CreateRelease`,
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReleaseRequest {
    /// Required. The parent collection in which the `Release` is created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `Release`.
    pub release_id: std::string::String,

    /// Required. The `Release` to create.
    pub release: std::option::Option<crate::model::Release>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReleaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [release_id][crate::model::CreateReleaseRequest::release_id].
    pub fn set_release_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_id = v.into();
        self
    }

    /// Sets the value of [release][crate::model::CreateReleaseRequest::release].
    pub fn set_release<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Release>,
    {
        self.release = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release][crate::model::CreateReleaseRequest::release].
    pub fn set_or_clear_release<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Release>,
    {
        self.release = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReleaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateReleaseRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CreateReleaseRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateReleaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReleaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __release_id,
            __release,
            __request_id,
            __validate_only,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReleaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "releaseId" => Ok(__FieldTag::__release_id),
                            "release_id" => Ok(__FieldTag::__release_id),
                            "release" => Ok(__FieldTag::__release),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReleaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReleaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_id => {
                            if !fields.insert(__FieldTag::__release_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_id",
                                ));
                            }
                            result.release_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release =
                                map.next_value::<std::option::Option<crate::model::Release>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReleaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.release_id.is_empty() {
            state.serialize_entry("releaseId", &self.release_id)?;
        }
        if self.release.is_some() {
            state.serialize_entry("release", &self.release)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReleaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReleaseRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("release_id", &self.release_id);
        debug_struct.field("release", &self.release);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `Rollout` resource in the Cloud Deploy API.
///
/// A `Rollout` contains information around a specific deployment to a `Target`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rollout {
    /// Identifier. Name of the `Rollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    /// The `rollout` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Rollout`.
    pub uid: std::string::String,

    /// Optional. Description of the `Rollout` for user purposes. Max length is 255
    /// characters.
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the `Rollout` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` was approved.
    pub approve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` was enqueued.
    pub enqueue_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` started deploying.
    pub deploy_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` finished deploying.
    pub deploy_end_time: std::option::Option<wkt::Timestamp>,

    /// Required. The ID of Target to which this `Rollout` is deploying.
    pub target_id: std::string::String,

    /// Output only. Approval state of the `Rollout`.
    pub approval_state: crate::model::rollout::ApprovalState,

    /// Output only. Current state of the `Rollout`.
    pub state: crate::model::rollout::State,

    /// Output only. Additional information about the rollout failure, if
    /// available.
    pub failure_reason: std::string::String,

    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to deploy the Rollout. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    pub deploying_build: std::string::String,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. The reason this rollout failed. This will always be
    /// unspecified while the rollout is in progress.
    pub deploy_failure_cause: crate::model::rollout::FailureCause,

    /// Output only. The phases that represent the workflows of this `Rollout`.
    pub phases: std::vec::Vec<crate::model::Phase>,

    /// Output only. Metadata contains information about the rollout.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Output only. Name of the `ControllerRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub controller_rollout: std::string::String,

    /// Output only. Name of the `Rollout` that is rolled back by this `Rollout`.
    /// Empty if this `Rollout` wasn't created as a rollback.
    pub rollback_of_rollout: std::string::String,

    /// Output only. Names of `Rollouts` that rolled back this `Rollout`.
    pub rolled_back_by_rollouts: std::vec::Vec<std::string::String>,

    /// Output only. The AutomationRun actively repairing the rollout.
    pub active_repair_automation_run: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Rollout::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Rollout::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Rollout::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Rollout::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Rollout::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [approve_time][crate::model::Rollout::approve_time].
    pub fn set_approve_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approve_time][crate::model::Rollout::approve_time].
    pub fn set_or_clear_approve_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enqueue_time][crate::model::Rollout::enqueue_time].
    pub fn set_enqueue_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueue_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enqueue_time][crate::model::Rollout::enqueue_time].
    pub fn set_or_clear_enqueue_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueue_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_start_time][crate::model::Rollout::deploy_start_time].
    pub fn set_deploy_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_start_time][crate::model::Rollout::deploy_start_time].
    pub fn set_or_clear_deploy_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_end_time][crate::model::Rollout::deploy_end_time].
    pub fn set_deploy_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_end_time][crate::model::Rollout::deploy_end_time].
    pub fn set_or_clear_deploy_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::Rollout::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [approval_state][crate::model::Rollout::approval_state].
    pub fn set_approval_state<T: std::convert::Into<crate::model::rollout::ApprovalState>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval_state = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Rollout::state].
    pub fn set_state<T: std::convert::Into<crate::model::rollout::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [failure_reason][crate::model::Rollout::failure_reason].
    pub fn set_failure_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_reason = v.into();
        self
    }

    /// Sets the value of [deploying_build][crate::model::Rollout::deploying_build].
    pub fn set_deploying_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploying_build = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Rollout::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deploy_failure_cause][crate::model::Rollout::deploy_failure_cause].
    pub fn set_deploy_failure_cause<T: std::convert::Into<crate::model::rollout::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_failure_cause = v.into();
        self
    }

    /// Sets the value of [phases][crate::model::Rollout::phases].
    pub fn set_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Phase>,
    {
        use std::iter::Iterator;
        self.phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Rollout::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Rollout::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [controller_rollout][crate::model::Rollout::controller_rollout].
    pub fn set_controller_rollout<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.controller_rollout = v.into();
        self
    }

    /// Sets the value of [rollback_of_rollout][crate::model::Rollout::rollback_of_rollout].
    pub fn set_rollback_of_rollout<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollback_of_rollout = v.into();
        self
    }

    /// Sets the value of [rolled_back_by_rollouts][crate::model::Rollout::rolled_back_by_rollouts].
    pub fn set_rolled_back_by_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.rolled_back_by_rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_repair_automation_run][crate::model::Rollout::active_repair_automation_run].
    pub fn set_active_repair_automation_run<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_repair_automation_run = v.into();
        self
    }
}

impl wkt::message::Message for Rollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Rollout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rollout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __annotations,
            __labels,
            __create_time,
            __approve_time,
            __enqueue_time,
            __deploy_start_time,
            __deploy_end_time,
            __target_id,
            __approval_state,
            __state,
            __failure_reason,
            __deploying_build,
            __etag,
            __deploy_failure_cause,
            __phases,
            __metadata,
            __controller_rollout,
            __rollback_of_rollout,
            __rolled_back_by_rollouts,
            __active_repair_automation_run,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rollout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "approveTime" => Ok(__FieldTag::__approve_time),
                            "approve_time" => Ok(__FieldTag::__approve_time),
                            "enqueueTime" => Ok(__FieldTag::__enqueue_time),
                            "enqueue_time" => Ok(__FieldTag::__enqueue_time),
                            "deployStartTime" => Ok(__FieldTag::__deploy_start_time),
                            "deploy_start_time" => Ok(__FieldTag::__deploy_start_time),
                            "deployEndTime" => Ok(__FieldTag::__deploy_end_time),
                            "deploy_end_time" => Ok(__FieldTag::__deploy_end_time),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "approvalState" => Ok(__FieldTag::__approval_state),
                            "approval_state" => Ok(__FieldTag::__approval_state),
                            "state" => Ok(__FieldTag::__state),
                            "failureReason" => Ok(__FieldTag::__failure_reason),
                            "failure_reason" => Ok(__FieldTag::__failure_reason),
                            "deployingBuild" => Ok(__FieldTag::__deploying_build),
                            "deploying_build" => Ok(__FieldTag::__deploying_build),
                            "etag" => Ok(__FieldTag::__etag),
                            "deployFailureCause" => Ok(__FieldTag::__deploy_failure_cause),
                            "deploy_failure_cause" => Ok(__FieldTag::__deploy_failure_cause),
                            "phases" => Ok(__FieldTag::__phases),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "controllerRollout" => Ok(__FieldTag::__controller_rollout),
                            "controller_rollout" => Ok(__FieldTag::__controller_rollout),
                            "rollbackOfRollout" => Ok(__FieldTag::__rollback_of_rollout),
                            "rollback_of_rollout" => Ok(__FieldTag::__rollback_of_rollout),
                            "rolledBackByRollouts" => Ok(__FieldTag::__rolled_back_by_rollouts),
                            "rolled_back_by_rollouts" => Ok(__FieldTag::__rolled_back_by_rollouts),
                            "activeRepairAutomationRun" => {
                                Ok(__FieldTag::__active_repair_automation_run)
                            }
                            "active_repair_automation_run" => {
                                Ok(__FieldTag::__active_repair_automation_run)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rollout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rollout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__approve_time => {
                            if !fields.insert(__FieldTag::__approve_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approve_time",
                                ));
                            }
                            result.approve_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__enqueue_time => {
                            if !fields.insert(__FieldTag::__enqueue_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enqueue_time",
                                ));
                            }
                            result.enqueue_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__deploy_start_time => {
                            if !fields.insert(__FieldTag::__deploy_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_start_time",
                                ));
                            }
                            result.deploy_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__deploy_end_time => {
                            if !fields.insert(__FieldTag::__deploy_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_end_time",
                                ));
                            }
                            result.deploy_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_state => {
                            if !fields.insert(__FieldTag::__approval_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_state",
                                ));
                            }
                            result.approval_state = map.next_value::<std::option::Option<crate::model::rollout::ApprovalState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::rollout::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_reason => {
                            if !fields.insert(__FieldTag::__failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_reason",
                                ));
                            }
                            result.failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploying_build => {
                            if !fields.insert(__FieldTag::__deploying_build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploying_build",
                                ));
                            }
                            result.deploying_build = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_failure_cause => {
                            if !fields.insert(__FieldTag::__deploy_failure_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_failure_cause",
                                ));
                            }
                            result.deploy_failure_cause = map.next_value::<std::option::Option<crate::model::rollout::FailureCause>>()?.unwrap_or_default();
                        }
                        __FieldTag::__phases => {
                            if !fields.insert(__FieldTag::__phases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phases",
                                ));
                            }
                            result.phases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Phase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata =
                                map.next_value::<std::option::Option<crate::model::Metadata>>()?;
                        }
                        __FieldTag::__controller_rollout => {
                            if !fields.insert(__FieldTag::__controller_rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for controller_rollout",
                                ));
                            }
                            result.controller_rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollback_of_rollout => {
                            if !fields.insert(__FieldTag::__rollback_of_rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollback_of_rollout",
                                ));
                            }
                            result.rollback_of_rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rolled_back_by_rollouts => {
                            if !fields.insert(__FieldTag::__rolled_back_by_rollouts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rolled_back_by_rollouts",
                                ));
                            }
                            result.rolled_back_by_rollouts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__active_repair_automation_run => {
                            if !fields.insert(__FieldTag::__active_repair_automation_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_repair_automation_run",
                                ));
                            }
                            result.active_repair_automation_run = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rollout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.approve_time.is_some() {
            state.serialize_entry("approveTime", &self.approve_time)?;
        }
        if self.enqueue_time.is_some() {
            state.serialize_entry("enqueueTime", &self.enqueue_time)?;
        }
        if self.deploy_start_time.is_some() {
            state.serialize_entry("deployStartTime", &self.deploy_start_time)?;
        }
        if self.deploy_end_time.is_some() {
            state.serialize_entry("deployEndTime", &self.deploy_end_time)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !wkt::internal::is_default(&self.approval_state) {
            state.serialize_entry("approvalState", &self.approval_state)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.failure_reason.is_empty() {
            state.serialize_entry("failureReason", &self.failure_reason)?;
        }
        if !self.deploying_build.is_empty() {
            state.serialize_entry("deployingBuild", &self.deploying_build)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.deploy_failure_cause) {
            state.serialize_entry("deployFailureCause", &self.deploy_failure_cause)?;
        }
        if !self.phases.is_empty() {
            state.serialize_entry("phases", &self.phases)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.controller_rollout.is_empty() {
            state.serialize_entry("controllerRollout", &self.controller_rollout)?;
        }
        if !self.rollback_of_rollout.is_empty() {
            state.serialize_entry("rollbackOfRollout", &self.rollback_of_rollout)?;
        }
        if !self.rolled_back_by_rollouts.is_empty() {
            state.serialize_entry("rolledBackByRollouts", &self.rolled_back_by_rollouts)?;
        }
        if !self.active_repair_automation_run.is_empty() {
            state.serialize_entry(
                "activeRepairAutomationRun",
                &self.active_repair_automation_run,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rollout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rollout");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("approve_time", &self.approve_time);
        debug_struct.field("enqueue_time", &self.enqueue_time);
        debug_struct.field("deploy_start_time", &self.deploy_start_time);
        debug_struct.field("deploy_end_time", &self.deploy_end_time);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("approval_state", &self.approval_state);
        debug_struct.field("state", &self.state);
        debug_struct.field("failure_reason", &self.failure_reason);
        debug_struct.field("deploying_build", &self.deploying_build);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("deploy_failure_cause", &self.deploy_failure_cause);
        debug_struct.field("phases", &self.phases);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("controller_rollout", &self.controller_rollout);
        debug_struct.field("rollback_of_rollout", &self.rollback_of_rollout);
        debug_struct.field("rolled_back_by_rollouts", &self.rolled_back_by_rollouts);
        debug_struct.field(
            "active_repair_automation_run",
            &self.active_repair_automation_run,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Rollout].
pub mod rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Valid approval states of a `Rollout`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApprovalState {
        /// The `Rollout` has an unspecified approval state.
        Unspecified,
        /// The `Rollout` requires approval.
        NeedsApproval,
        /// The `Rollout` does not require approval.
        DoesNotNeedApproval,
        /// The `Rollout` has been approved.
        Approved,
        /// The `Rollout` has been rejected.
        Rejected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApprovalState::value] or
        /// [ApprovalState::name].
        UnknownValue(approval_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod approval_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApprovalState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NeedsApproval => std::option::Option::Some(1),
                Self::DoesNotNeedApproval => std::option::Option::Some(2),
                Self::Approved => std::option::Option::Some(3),
                Self::Rejected => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("APPROVAL_STATE_UNSPECIFIED"),
                Self::NeedsApproval => std::option::Option::Some("NEEDS_APPROVAL"),
                Self::DoesNotNeedApproval => std::option::Option::Some("DOES_NOT_NEED_APPROVAL"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApprovalState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApprovalState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApprovalState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NeedsApproval,
                2 => Self::DoesNotNeedApproval,
                3 => Self::Approved,
                4 => Self::Rejected,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApprovalState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Self::Unspecified,
                "NEEDS_APPROVAL" => Self::NeedsApproval,
                "DOES_NOT_NEED_APPROVAL" => Self::DoesNotNeedApproval,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApprovalState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NeedsApproval => serializer.serialize_i32(1),
                Self::DoesNotNeedApproval => serializer.serialize_i32(2),
                Self::Approved => serializer.serialize_i32(3),
                Self::Rejected => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApprovalState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApprovalState>::new(
                ".google.cloud.deploy.v1.Rollout.ApprovalState",
            ))
        }
    }

    /// Valid states of a `Rollout`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `Rollout` has an unspecified state.
        Unspecified,
        /// The `Rollout` has completed successfully.
        Succeeded,
        /// The `Rollout` has failed.
        Failed,
        /// The `Rollout` is being deployed.
        InProgress,
        /// The `Rollout` needs approval.
        PendingApproval,
        /// An approver rejected the `Rollout`.
        ApprovalRejected,
        /// The `Rollout` is waiting for an earlier Rollout(s) to complete on this
        /// `Target`.
        Pending,
        /// The `Rollout` is waiting for the `Release` to be fully rendered.
        PendingRelease,
        /// The `Rollout` is in the process of being cancelled.
        Cancelling,
        /// The `Rollout` has been cancelled.
        Cancelled,
        /// The `Rollout` is halted.
        Halted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::PendingApproval => std::option::Option::Some(4),
                Self::ApprovalRejected => std::option::Option::Some(5),
                Self::Pending => std::option::Option::Some(6),
                Self::PendingRelease => std::option::Option::Some(7),
                Self::Cancelling => std::option::Option::Some(8),
                Self::Cancelled => std::option::Option::Some(9),
                Self::Halted => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::PendingApproval => std::option::Option::Some("PENDING_APPROVAL"),
                Self::ApprovalRejected => std::option::Option::Some("APPROVAL_REJECTED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::PendingRelease => std::option::Option::Some("PENDING_RELEASE"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Halted => std::option::Option::Some("HALTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::InProgress,
                4 => Self::PendingApproval,
                5 => Self::ApprovalRejected,
                6 => Self::Pending,
                7 => Self::PendingRelease,
                8 => Self::Cancelling,
                9 => Self::Cancelled,
                10 => Self::Halted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                "PENDING_APPROVAL" => Self::PendingApproval,
                "APPROVAL_REJECTED" => Self::ApprovalRejected,
                "PENDING" => Self::Pending,
                "PENDING_RELEASE" => Self::PendingRelease,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "HALTED" => Self::Halted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::PendingApproval => serializer.serialize_i32(4),
                Self::ApprovalRejected => serializer.serialize_i32(5),
                Self::Pending => serializer.serialize_i32(6),
                Self::PendingRelease => serializer.serialize_i32(7),
                Self::Cancelling => serializer.serialize_i32(8),
                Self::Cancelled => serializer.serialize_i32(9),
                Self::Halted => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Rollout.State",
            ))
        }
    }

    /// Well-known rollout failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The deploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// Deployment did not complete within the allotted time.
        DeadlineExceeded,
        /// Release is in a failed state.
        ReleaseFailed,
        /// Release is abandoned.
        ReleaseAbandoned,
        /// No Skaffold verify configuration was found.
        VerificationConfigNotFound,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// A Rollout operation had a feature configured that is not supported.
        OperationFeatureNotSupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::ReleaseFailed => std::option::Option::Some(4),
                Self::ReleaseAbandoned => std::option::Option::Some(5),
                Self::VerificationConfigNotFound => std::option::Option::Some(6),
                Self::CloudBuildRequestFailed => std::option::Option::Some(7),
                Self::OperationFeatureNotSupported => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::ReleaseFailed => std::option::Option::Some("RELEASE_FAILED"),
                Self::ReleaseAbandoned => std::option::Option::Some("RELEASE_ABANDONED"),
                Self::VerificationConfigNotFound => {
                    std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::OperationFeatureNotSupported => {
                    std::option::Option::Some("OPERATION_FEATURE_NOT_SUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::ReleaseFailed,
                5 => Self::ReleaseAbandoned,
                6 => Self::VerificationConfigNotFound,
                7 => Self::CloudBuildRequestFailed,
                8 => Self::OperationFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "RELEASE_FAILED" => Self::ReleaseFailed,
                "RELEASE_ABANDONED" => Self::ReleaseAbandoned,
                "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                "OPERATION_FEATURE_NOT_SUPPORTED" => Self::OperationFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::ReleaseFailed => serializer.serialize_i32(4),
                Self::ReleaseAbandoned => serializer.serialize_i32(5),
                Self::VerificationConfigNotFound => serializer.serialize_i32(6),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(7),
                Self::OperationFeatureNotSupported => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.Rollout.FailureCause",
            ))
        }
    }
}

/// Metadata includes information associated with a `Rollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`.
    pub cloud_run: std::option::Option<crate::model::CloudRunMetadata>,

    /// Output only. AutomationRolloutMetadata contains the information about the
    /// interactions between Automation service and this rollout.
    pub automation: std::option::Option<crate::model::AutomationRolloutMetadata>,

    /// Output only. Custom metadata provided by user-defined `Rollout` operations.
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::Metadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::Metadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automation][crate::model::Metadata::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRolloutMetadata>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::Metadata::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRolloutMetadata>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::Metadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::Metadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Metadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Metadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_run,
            __automation,
            __custom,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            "automation" => Ok(__FieldTag::__automation),
                            "custom" => Ok(__FieldTag::__custom),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Metadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            result.cloud_run = map
                                .next_value::<std::option::Option<crate::model::CloudRunMetadata>>(
                                )?;
                        }
                        __FieldTag::__automation => {
                            if !fields.insert(__FieldTag::__automation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation",
                                ));
                            }
                            result.automation = map.next_value::<std::option::Option<crate::model::AutomationRolloutMetadata>>()?
                                ;
                        }
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom",
                                ));
                            }
                            result.custom = map
                                .next_value::<std::option::Option<crate::model::CustomMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Metadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_run.is_some() {
            state.serialize_entry("cloudRun", &self.cloud_run)?;
        }
        if self.automation.is_some() {
            state.serialize_entry("automation", &self.automation)?;
        }
        if self.custom.is_some() {
            state.serialize_entry("custom", &self.custom)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metadata");
        debug_struct.field("cloud_run", &self.cloud_run);
        debug_struct.field("automation", &self.automation);
        debug_struct.field("custom", &self.custom);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeployJobRunMetadata surfaces information associated with a `DeployJobRun` to
/// the user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployJobRunMetadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `DeployJobRun`.
    pub cloud_run: std::option::Option<crate::model::CloudRunMetadata>,

    /// Output only. Custom Target metadata associated with a `DeployJobRun`.
    pub custom_target: std::option::Option<crate::model::CustomTargetDeployMetadata>,

    /// Output only. Custom metadata provided by user-defined deploy operation.
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJobRunMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::DeployJobRunMetadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::DeployJobRunMetadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_target][crate::model::DeployJobRunMetadata::custom_target].
    pub fn set_custom_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetDeployMetadata>,
    {
        self.custom_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target][crate::model::DeployJobRunMetadata::custom_target].
    pub fn set_or_clear_custom_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetDeployMetadata>,
    {
        self.custom_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::DeployJobRunMetadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::DeployJobRunMetadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployJobRunMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJobRunMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployJobRunMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_run,
            __custom_target,
            __custom,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployJobRunMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudRun" => Ok(__FieldTag::__cloud_run),
                            "cloud_run" => Ok(__FieldTag::__cloud_run),
                            "customTarget" => Ok(__FieldTag::__custom_target),
                            "custom_target" => Ok(__FieldTag::__custom_target),
                            "custom" => Ok(__FieldTag::__custom),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployJobRunMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployJobRunMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_run => {
                            if !fields.insert(__FieldTag::__cloud_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run",
                                ));
                            }
                            result.cloud_run = map
                                .next_value::<std::option::Option<crate::model::CloudRunMetadata>>(
                                )?;
                        }
                        __FieldTag::__custom_target => {
                            if !fields.insert(__FieldTag::__custom_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target",
                                ));
                            }
                            result.custom_target = map.next_value::<std::option::Option<crate::model::CustomTargetDeployMetadata>>()?
                                ;
                        }
                        __FieldTag::__custom => {
                            if !fields.insert(__FieldTag::__custom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom",
                                ));
                            }
                            result.custom = map
                                .next_value::<std::option::Option<crate::model::CustomMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployJobRunMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_run.is_some() {
            state.serialize_entry("cloudRun", &self.cloud_run)?;
        }
        if self.custom_target.is_some() {
            state.serialize_entry("customTarget", &self.custom_target)?;
        }
        if self.custom.is_some() {
            state.serialize_entry("custom", &self.custom)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployJobRunMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployJobRunMetadata");
        debug_struct.field("cloud_run", &self.cloud_run);
        debug_struct.field("custom_target", &self.custom_target);
        debug_struct.field("custom", &self.custom);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloudRunMetadata contains information from a Cloud Run deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunMetadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/services/{service}`.
    pub service: std::string::String,

    /// Output only. The Cloud Run Service urls that are associated with a
    /// `Rollout`.
    pub service_urls: std::vec::Vec<std::string::String>,

    /// Output only. The Cloud Run Revision id associated with a `Rollout`.
    pub revision: std::string::String,

    /// Output only. The name of the Cloud Run job that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/jobs/{job_name}`.
    pub job: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRunMetadata::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_urls][crate::model::CloudRunMetadata::service_urls].
    pub fn set_service_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [revision][crate::model::CloudRunMetadata::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CloudRunMetadata::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __service_urls,
            __revision,
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "serviceUrls" => Ok(__FieldTag::__service_urls),
                            "service_urls" => Ok(__FieldTag::__service_urls),
                            "revision" => Ok(__FieldTag::__revision),
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_urls => {
                            if !fields.insert(__FieldTag::__service_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_urls",
                                ));
                            }
                            result.service_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.service_urls.is_empty() {
            state.serialize_entry("serviceUrls", &self.service_urls)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !self.job.is_empty() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunMetadata");
        debug_struct.field("service", &self.service);
        debug_struct.field("service_urls", &self.service_urls);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("job", &self.job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CustomTargetDeployMetadata contains information from a Custom Target
/// deploy operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomTargetDeployMetadata {
    /// Output only. Skip message provided in the results of a custom deploy
    /// operation.
    pub skip_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetDeployMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skip_message][crate::model::CustomTargetDeployMetadata::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }
}

impl wkt::message::Message for CustomTargetDeployMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetDeployMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomTargetDeployMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __skip_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomTargetDeployMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "skipMessage" => Ok(__FieldTag::__skip_message),
                            "skip_message" => Ok(__FieldTag::__skip_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomTargetDeployMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomTargetDeployMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__skip_message => {
                            if !fields.insert(__FieldTag::__skip_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_message",
                                ));
                            }
                            result.skip_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomTargetDeployMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.skip_message.is_empty() {
            state.serialize_entry("skipMessage", &self.skip_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomTargetDeployMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomTargetDeployMetadata");
        debug_struct.field("skip_message", &self.skip_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutomationRolloutMetadata contains Automation-related actions that
/// were performed on a rollout.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationRolloutMetadata {
    /// Output only. The name of the AutomationRun initiated by a promote release
    /// rule.
    pub promote_automation_run: std::string::String,

    /// Output only. The names of the AutomationRuns initiated by an advance
    /// rollout rule.
    pub advance_automation_runs: std::vec::Vec<std::string::String>,

    /// Output only. The names of the AutomationRuns initiated by a repair rollout
    /// rule.
    pub repair_automation_runs: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRolloutMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [promote_automation_run][crate::model::AutomationRolloutMetadata::promote_automation_run].
    pub fn set_promote_automation_run<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.promote_automation_run = v.into();
        self
    }

    /// Sets the value of [advance_automation_runs][crate::model::AutomationRolloutMetadata::advance_automation_runs].
    pub fn set_advance_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.advance_automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repair_automation_runs][crate::model::AutomationRolloutMetadata::repair_automation_runs].
    pub fn set_repair_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.repair_automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutomationRolloutMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRolloutMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationRolloutMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __promote_automation_run,
            __advance_automation_runs,
            __repair_automation_runs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationRolloutMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "promoteAutomationRun" => Ok(__FieldTag::__promote_automation_run),
                            "promote_automation_run" => Ok(__FieldTag::__promote_automation_run),
                            "advanceAutomationRuns" => Ok(__FieldTag::__advance_automation_runs),
                            "advance_automation_runs" => Ok(__FieldTag::__advance_automation_runs),
                            "repairAutomationRuns" => Ok(__FieldTag::__repair_automation_runs),
                            "repair_automation_runs" => Ok(__FieldTag::__repair_automation_runs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationRolloutMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationRolloutMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__promote_automation_run => {
                            if !fields.insert(__FieldTag::__promote_automation_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promote_automation_run",
                                ));
                            }
                            result.promote_automation_run = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advance_automation_runs => {
                            if !fields.insert(__FieldTag::__advance_automation_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_automation_runs",
                                ));
                            }
                            result.advance_automation_runs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__repair_automation_runs => {
                            if !fields.insert(__FieldTag::__repair_automation_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repair_automation_runs",
                                ));
                            }
                            result.repair_automation_runs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationRolloutMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.promote_automation_run.is_empty() {
            state.serialize_entry("promoteAutomationRun", &self.promote_automation_run)?;
        }
        if !self.advance_automation_runs.is_empty() {
            state.serialize_entry("advanceAutomationRuns", &self.advance_automation_runs)?;
        }
        if !self.repair_automation_runs.is_empty() {
            state.serialize_entry("repairAutomationRuns", &self.repair_automation_runs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationRolloutMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationRolloutMetadata");
        debug_struct.field("promote_automation_run", &self.promote_automation_run);
        debug_struct.field("advance_automation_runs", &self.advance_automation_runs);
        debug_struct.field("repair_automation_runs", &self.repair_automation_runs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CustomMetadata contains information from a user-defined operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomMetadata {
    /// Output only. Key-value pairs provided by the user-defined operation.
    pub values: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::CustomMetadata::values].
    pub fn set_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CustomMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomMetadata");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Phase represents a collection of jobs that are logically grouped together
/// for a `Rollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Phase {
    /// Output only. The ID of the Phase.
    pub id: std::string::String,

    /// Output only. Current state of the Phase.
    pub state: crate::model::phase::State,

    /// Output only. Additional information on why the Phase was skipped, if
    /// available.
    pub skip_message: std::string::String,

    /// The job composition of this Phase.
    pub jobs: std::option::Option<crate::model::phase::Jobs>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Phase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Phase::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Phase::state].
    pub fn set_state<T: std::convert::Into<crate::model::phase::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [skip_message][crate::model::Phase::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs].
    ///
    /// Note that all the setters affecting `jobs` are mutually
    /// exclusive.
    pub fn set_jobs<T: std::convert::Into<std::option::Option<crate::model::phase::Jobs>>>(
        mut self,
        v: T,
    ) -> Self {
        self.jobs = v.into();
        self
    }

    /// The value of [jobs][crate::model::Phase::jobs]
    /// if it holds a `DeploymentJobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment_jobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentJobs>> {
        #[allow(unreachable_patterns)]
        self.jobs.as_ref().and_then(|v| match v {
            crate::model::phase::Jobs::DeploymentJobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs]
    /// to hold a `DeploymentJobs`.
    ///
    /// Note that all the setters affecting `jobs` are
    /// mutually exclusive.
    pub fn set_deployment_jobs<
        T: std::convert::Into<std::boxed::Box<crate::model::DeploymentJobs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.jobs = std::option::Option::Some(crate::model::phase::Jobs::DeploymentJobs(v.into()));
        self
    }

    /// The value of [jobs][crate::model::Phase::jobs]
    /// if it holds a `ChildRolloutJobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn child_rollout_jobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ChildRolloutJobs>> {
        #[allow(unreachable_patterns)]
        self.jobs.as_ref().and_then(|v| match v {
            crate::model::phase::Jobs::ChildRolloutJobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs]
    /// to hold a `ChildRolloutJobs`.
    ///
    /// Note that all the setters affecting `jobs` are
    /// mutually exclusive.
    pub fn set_child_rollout_jobs<
        T: std::convert::Into<std::boxed::Box<crate::model::ChildRolloutJobs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.jobs =
            std::option::Option::Some(crate::model::phase::Jobs::ChildRolloutJobs(v.into()));
        self
    }
}

impl wkt::message::Message for Phase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Phase"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Phase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __state,
            __skip_message,
            __deployment_jobs,
            __child_rollout_jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Phase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "state" => Ok(__FieldTag::__state),
                            "skipMessage" => Ok(__FieldTag::__skip_message),
                            "skip_message" => Ok(__FieldTag::__skip_message),
                            "deploymentJobs" => Ok(__FieldTag::__deployment_jobs),
                            "deployment_jobs" => Ok(__FieldTag::__deployment_jobs),
                            "childRolloutJobs" => Ok(__FieldTag::__child_rollout_jobs),
                            "child_rollout_jobs" => Ok(__FieldTag::__child_rollout_jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Phase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Phase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::phase::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_message => {
                            if !fields.insert(__FieldTag::__skip_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_message",
                                ));
                            }
                            result.skip_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_jobs => {
                            if !fields.insert(__FieldTag::__deployment_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_jobs",
                                ));
                            }
                            if result.jobs.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `jobs`, a oneof with full ID .google.cloud.deploy.v1.Phase.deployment_jobs, latest field was deploymentJobs",
                                ));
                            }
                            result.jobs = std::option::Option::Some(
                                crate::model::phase::Jobs::DeploymentJobs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeploymentJobs>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__child_rollout_jobs => {
                            if !fields.insert(__FieldTag::__child_rollout_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for child_rollout_jobs",
                                ));
                            }
                            if result.jobs.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `jobs`, a oneof with full ID .google.cloud.deploy.v1.Phase.child_rollout_jobs, latest field was childRolloutJobs",
                                ));
                            }
                            result.jobs = std::option::Option::Some(
                                crate::model::phase::Jobs::ChildRolloutJobs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ChildRolloutJobs>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Phase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.skip_message.is_empty() {
            state.serialize_entry("skipMessage", &self.skip_message)?;
        }
        if let Some(value) = self.deployment_jobs() {
            state.serialize_entry("deploymentJobs", value)?;
        }
        if let Some(value) = self.child_rollout_jobs() {
            state.serialize_entry("childRolloutJobs", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Phase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Phase");
        debug_struct.field("id", &self.id);
        debug_struct.field("state", &self.state);
        debug_struct.field("skip_message", &self.skip_message);
        debug_struct.field("jobs", &self.jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Phase].
pub mod phase {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a Phase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Phase has an unspecified state.
        Unspecified,
        /// The Phase is waiting for an earlier Phase(s) to complete.
        Pending,
        /// The Phase is in progress.
        InProgress,
        /// The Phase has succeeded.
        Succeeded,
        /// The Phase has failed.
        Failed,
        /// The Phase was aborted.
        Aborted,
        /// The Phase was skipped.
        Skipped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::InProgress => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Aborted => std::option::Option::Some(5),
                Self::Skipped => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::InProgress,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Aborted,
                6 => Self::Skipped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "SKIPPED" => Self::Skipped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::InProgress => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Aborted => serializer.serialize_i32(5),
                Self::Skipped => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Phase.State",
            ))
        }
    }

    /// The job composition of this Phase.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Jobs {
        /// Output only. Deployment job composition.
        DeploymentJobs(std::boxed::Box<crate::model::DeploymentJobs>),
        /// Output only. ChildRollout job composition.
        ChildRolloutJobs(std::boxed::Box<crate::model::ChildRolloutJobs>),
    }
}

/// Deployment job composition.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeploymentJobs {
    /// Output only. The predeploy Job, which is the first job on the phase.
    pub predeploy_job: std::option::Option<crate::model::Job>,

    /// Output only. The deploy Job. This is the deploy job in the phase.
    pub deploy_job: std::option::Option<crate::model::Job>,

    /// Output only. The verify Job. Runs after a deploy if the deploy succeeds.
    pub verify_job: std::option::Option<crate::model::Job>,

    /// Output only. The postdeploy Job, which is the last job on the phase.
    pub postdeploy_job: std::option::Option<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentJobs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [predeploy_job][crate::model::DeploymentJobs::predeploy_job].
    pub fn set_predeploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.predeploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy_job][crate::model::DeploymentJobs::predeploy_job].
    pub fn set_or_clear_predeploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.predeploy_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_job][crate::model::DeploymentJobs::deploy_job].
    pub fn set_deploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.deploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_job][crate::model::DeploymentJobs::deploy_job].
    pub fn set_or_clear_deploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.deploy_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verify_job][crate::model::DeploymentJobs::verify_job].
    pub fn set_verify_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.verify_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_job][crate::model::DeploymentJobs::verify_job].
    pub fn set_or_clear_verify_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.verify_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy_job][crate::model::DeploymentJobs::postdeploy_job].
    pub fn set_postdeploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.postdeploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy_job][crate::model::DeploymentJobs::postdeploy_job].
    pub fn set_or_clear_postdeploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.postdeploy_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeploymentJobs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeploymentJobs"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeploymentJobs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __predeploy_job,
            __deploy_job,
            __verify_job,
            __postdeploy_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeploymentJobs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "predeployJob" => Ok(__FieldTag::__predeploy_job),
                            "predeploy_job" => Ok(__FieldTag::__predeploy_job),
                            "deployJob" => Ok(__FieldTag::__deploy_job),
                            "deploy_job" => Ok(__FieldTag::__deploy_job),
                            "verifyJob" => Ok(__FieldTag::__verify_job),
                            "verify_job" => Ok(__FieldTag::__verify_job),
                            "postdeployJob" => Ok(__FieldTag::__postdeploy_job),
                            "postdeploy_job" => Ok(__FieldTag::__postdeploy_job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeploymentJobs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeploymentJobs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__predeploy_job => {
                            if !fields.insert(__FieldTag::__predeploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predeploy_job",
                                ));
                            }
                            result.predeploy_job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__deploy_job => {
                            if !fields.insert(__FieldTag::__deploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_job",
                                ));
                            }
                            result.deploy_job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__verify_job => {
                            if !fields.insert(__FieldTag::__verify_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_job",
                                ));
                            }
                            result.verify_job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__postdeploy_job => {
                            if !fields.insert(__FieldTag::__postdeploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postdeploy_job",
                                ));
                            }
                            result.postdeploy_job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeploymentJobs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.predeploy_job.is_some() {
            state.serialize_entry("predeployJob", &self.predeploy_job)?;
        }
        if self.deploy_job.is_some() {
            state.serialize_entry("deployJob", &self.deploy_job)?;
        }
        if self.verify_job.is_some() {
            state.serialize_entry("verifyJob", &self.verify_job)?;
        }
        if self.postdeploy_job.is_some() {
            state.serialize_entry("postdeployJob", &self.postdeploy_job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeploymentJobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeploymentJobs");
        debug_struct.field("predeploy_job", &self.predeploy_job);
        debug_struct.field("deploy_job", &self.deploy_job);
        debug_struct.field("verify_job", &self.verify_job);
        debug_struct.field("postdeploy_job", &self.postdeploy_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ChildRollouts job composition
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChildRolloutJobs {
    /// Output only. List of CreateChildRolloutJobs
    pub create_rollout_jobs: std::vec::Vec<crate::model::Job>,

    /// Output only. List of AdvanceChildRolloutJobs
    pub advance_rollout_jobs: std::vec::Vec<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChildRolloutJobs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_rollout_jobs][crate::model::ChildRolloutJobs::create_rollout_jobs].
    pub fn set_create_rollout_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.create_rollout_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [advance_rollout_jobs][crate::model::ChildRolloutJobs::advance_rollout_jobs].
    pub fn set_advance_rollout_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.advance_rollout_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ChildRolloutJobs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ChildRolloutJobs"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChildRolloutJobs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_rollout_jobs,
            __advance_rollout_jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChildRolloutJobs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createRolloutJobs" => Ok(__FieldTag::__create_rollout_jobs),
                            "create_rollout_jobs" => Ok(__FieldTag::__create_rollout_jobs),
                            "advanceRolloutJobs" => Ok(__FieldTag::__advance_rollout_jobs),
                            "advance_rollout_jobs" => Ok(__FieldTag::__advance_rollout_jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChildRolloutJobs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChildRolloutJobs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_rollout_jobs => {
                            if !fields.insert(__FieldTag::__create_rollout_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_rollout_jobs",
                                ));
                            }
                            result.create_rollout_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__advance_rollout_jobs => {
                            if !fields.insert(__FieldTag::__advance_rollout_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_rollout_jobs",
                                ));
                            }
                            result.advance_rollout_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChildRolloutJobs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.create_rollout_jobs.is_empty() {
            state.serialize_entry("createRolloutJobs", &self.create_rollout_jobs)?;
        }
        if !self.advance_rollout_jobs.is_empty() {
            state.serialize_entry("advanceRolloutJobs", &self.advance_rollout_jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ChildRolloutJobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChildRolloutJobs");
        debug_struct.field("create_rollout_jobs", &self.create_rollout_jobs);
        debug_struct.field("advance_rollout_jobs", &self.advance_rollout_jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Job represents an operation for a `Rollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// Output only. The ID of the Job.
    pub id: std::string::String,

    /// Output only. The current state of the Job.
    pub state: crate::model::job::State,

    /// Output only. Additional information on why the Job was skipped, if
    /// available.
    pub skip_message: std::string::String,

    /// Output only. The name of the `JobRun` responsible for the most recent
    /// invocation of this Job.
    pub job_run: std::string::String,

    /// The type of Job.
    pub job_type: std::option::Option<crate::model::job::JobType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Job::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::job::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [skip_message][crate::model::Job::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::Job::job_run].
    pub fn set_job_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_run = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::Job::job_type].
    ///
    /// Note that all the setters affecting `job_type` are mutually
    /// exclusive.
    pub fn set_job_type<T: std::convert::Into<std::option::Option<crate::model::job::JobType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `DeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deploy_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::DeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `DeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_deploy_job<T: std::convert::Into<std::boxed::Box<crate::model::DeployJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = std::option::Option::Some(crate::model::job::JobType::DeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `VerifyJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn verify_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::VerifyJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::VerifyJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `VerifyJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_verify_job<T: std::convert::Into<std::boxed::Box<crate::model::VerifyJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = std::option::Option::Some(crate::model::job::JobType::VerifyJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `PredeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn predeploy_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::PredeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `PredeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_predeploy_job<T: std::convert::Into<std::boxed::Box<crate::model::PredeployJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::PredeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `PostdeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postdeploy_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostdeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::PostdeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `PostdeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_postdeploy_job<
        T: std::convert::Into<std::boxed::Box<crate::model::PostdeployJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::PostdeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `CreateChildRolloutJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_child_rollout_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateChildRolloutJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::CreateChildRolloutJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `CreateChildRolloutJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_create_child_rollout_job<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateChildRolloutJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::CreateChildRolloutJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `AdvanceChildRolloutJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_child_rollout_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceChildRolloutJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::AdvanceChildRolloutJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `AdvanceChildRolloutJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_advance_child_rollout_job<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceChildRolloutJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::AdvanceChildRolloutJob(v.into()));
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __state,
            __skip_message,
            __job_run,
            __deploy_job,
            __verify_job,
            __predeploy_job,
            __postdeploy_job,
            __create_child_rollout_job,
            __advance_child_rollout_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "state" => Ok(__FieldTag::__state),
                            "skipMessage" => Ok(__FieldTag::__skip_message),
                            "skip_message" => Ok(__FieldTag::__skip_message),
                            "jobRun" => Ok(__FieldTag::__job_run),
                            "job_run" => Ok(__FieldTag::__job_run),
                            "deployJob" => Ok(__FieldTag::__deploy_job),
                            "deploy_job" => Ok(__FieldTag::__deploy_job),
                            "verifyJob" => Ok(__FieldTag::__verify_job),
                            "verify_job" => Ok(__FieldTag::__verify_job),
                            "predeployJob" => Ok(__FieldTag::__predeploy_job),
                            "predeploy_job" => Ok(__FieldTag::__predeploy_job),
                            "postdeployJob" => Ok(__FieldTag::__postdeploy_job),
                            "postdeploy_job" => Ok(__FieldTag::__postdeploy_job),
                            "createChildRolloutJob" => Ok(__FieldTag::__create_child_rollout_job),
                            "create_child_rollout_job" => {
                                Ok(__FieldTag::__create_child_rollout_job)
                            }
                            "advanceChildRolloutJob" => Ok(__FieldTag::__advance_child_rollout_job),
                            "advance_child_rollout_job" => {
                                Ok(__FieldTag::__advance_child_rollout_job)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_message => {
                            if !fields.insert(__FieldTag::__skip_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_message",
                                ));
                            }
                            result.skip_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_run => {
                            if !fields.insert(__FieldTag::__job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_run",
                                ));
                            }
                            result.job_run = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_job => {
                            if !fields.insert(__FieldTag::__deploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.deploy_job, latest field was deployJob",
                                ));
                            }
                            result.job_type =
                                std::option::Option::Some(crate::model::job::JobType::DeployJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeployJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__verify_job => {
                            if !fields.insert(__FieldTag::__verify_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.verify_job, latest field was verifyJob",
                                ));
                            }
                            result.job_type =
                                std::option::Option::Some(crate::model::job::JobType::VerifyJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VerifyJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__predeploy_job => {
                            if !fields.insert(__FieldTag::__predeploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predeploy_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.predeploy_job, latest field was predeployJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::job::JobType::PredeployJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PredeployJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postdeploy_job => {
                            if !fields.insert(__FieldTag::__postdeploy_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postdeploy_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.postdeploy_job, latest field was postdeployJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::job::JobType::PostdeployJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostdeployJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_child_rollout_job => {
                            if !fields.insert(__FieldTag::__create_child_rollout_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_child_rollout_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.create_child_rollout_job, latest field was createChildRolloutJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::job::JobType::CreateChildRolloutJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateChildRolloutJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__advance_child_rollout_job => {
                            if !fields.insert(__FieldTag::__advance_child_rollout_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_child_rollout_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.deploy.v1.Job.advance_child_rollout_job, latest field was advanceChildRolloutJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::job::JobType::AdvanceChildRolloutJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdvanceChildRolloutJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.skip_message.is_empty() {
            state.serialize_entry("skipMessage", &self.skip_message)?;
        }
        if !self.job_run.is_empty() {
            state.serialize_entry("jobRun", &self.job_run)?;
        }
        if let Some(value) = self.deploy_job() {
            state.serialize_entry("deployJob", value)?;
        }
        if let Some(value) = self.verify_job() {
            state.serialize_entry("verifyJob", value)?;
        }
        if let Some(value) = self.predeploy_job() {
            state.serialize_entry("predeployJob", value)?;
        }
        if let Some(value) = self.postdeploy_job() {
            state.serialize_entry("postdeployJob", value)?;
        }
        if let Some(value) = self.create_child_rollout_job() {
            state.serialize_entry("createChildRolloutJob", value)?;
        }
        if let Some(value) = self.advance_child_rollout_job() {
            state.serialize_entry("advanceChildRolloutJob", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("id", &self.id);
        debug_struct.field("state", &self.state);
        debug_struct.field("skip_message", &self.skip_message);
        debug_struct.field("job_run", &self.job_run);
        debug_struct.field("job_type", &self.job_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a Job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Job has an unspecified state.
        Unspecified,
        /// The Job is waiting for an earlier Phase(s) or Job(s) to complete.
        Pending,
        /// The Job is disabled.
        Disabled,
        /// The Job is in progress.
        InProgress,
        /// The Job succeeded.
        Succeeded,
        /// The Job failed.
        Failed,
        /// The Job was aborted.
        Aborted,
        /// The Job was skipped.
        Skipped,
        /// The Job was ignored.
        Ignored,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::Skipped => std::option::Option::Some(7),
                Self::Ignored => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::Ignored => std::option::Option::Some("IGNORED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Disabled,
                3 => Self::InProgress,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Aborted,
                7 => Self::Skipped,
                8 => Self::Ignored,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "DISABLED" => Self::Disabled,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "SKIPPED" => Self::Skipped,
                "IGNORED" => Self::Ignored,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::Skipped => serializer.serialize_i32(7),
                Self::Ignored => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Job.State",
            ))
        }
    }

    /// The type of Job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobType {
        /// Output only. A deploy Job.
        DeployJob(std::boxed::Box<crate::model::DeployJob>),
        /// Output only. A verify Job.
        VerifyJob(std::boxed::Box<crate::model::VerifyJob>),
        /// Output only. A predeploy Job.
        PredeployJob(std::boxed::Box<crate::model::PredeployJob>),
        /// Output only. A postdeploy Job.
        PostdeployJob(std::boxed::Box<crate::model::PostdeployJob>),
        /// Output only. A createChildRollout Job.
        CreateChildRolloutJob(std::boxed::Box<crate::model::CreateChildRolloutJob>),
        /// Output only. An advanceChildRollout Job.
        AdvanceChildRolloutJob(std::boxed::Box<crate::model::AdvanceChildRolloutJob>),
    }
}

/// A deploy Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployJob {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployJob");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A verify Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyJob {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerifyJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.VerifyJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerifyJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyJob");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A predeploy Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PredeployJob {
    /// Output only. The custom actions that the predeploy Job executes.
    pub actions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::PredeployJob::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PredeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PredeployJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PredeployJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PredeployJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PredeployJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PredeployJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PredeployJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PredeployJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PredeployJob");
        debug_struct.field("actions", &self.actions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A postdeploy Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostdeployJob {
    /// Output only. The custom actions that the postdeploy Job executes.
    pub actions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostdeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::PostdeployJob::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostdeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PostdeployJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostdeployJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __actions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostdeployJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "actions" => Ok(__FieldTag::__actions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostdeployJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostdeployJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__actions => {
                            if !fields.insert(__FieldTag::__actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for actions",
                                ));
                            }
                            result.actions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostdeployJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostdeployJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostdeployJob");
        debug_struct.field("actions", &self.actions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A createChildRollout Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChildRolloutJob {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChildRolloutJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateChildRolloutJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateChildRolloutJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateChildRolloutJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChildRolloutJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateChildRolloutJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChildRolloutJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateChildRolloutJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateChildRolloutJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateChildRolloutJob");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An advanceChildRollout Job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceChildRolloutJob {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceChildRolloutJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdvanceChildRolloutJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceChildRolloutJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceChildRolloutJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceChildRolloutJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceChildRolloutJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceChildRolloutJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceChildRolloutJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceChildRolloutJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceChildRolloutJob");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListRolloutsRequest is the request object used by `ListRollouts`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRolloutsRequest {
    /// Required. The `Release` which owns this collection of `Rollout` objects.
    pub parent: std::string::String,

    /// Optional. The maximum number of `Rollout` objects to return. The service
    /// may return fewer than this value. If unspecified, at most 50 `Rollout`
    /// objects will be returned. The maximum value is 1000; values above 1000 will
    /// be set to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListRollouts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Filter rollouts to be returned. See <https://google.aip.dev/160>
    /// for more details.
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRolloutsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRolloutsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRolloutsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRolloutsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRolloutsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRolloutsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRolloutsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListRolloutsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRolloutsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRolloutsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRolloutsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRolloutsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRolloutsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRolloutsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRolloutsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListRolloutsResponse is the response object returned by `ListRollouts`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRolloutsResponse {
    /// The `Rollout` objects.
    pub rollouts: std::vec::Vec<crate::model::Rollout>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRolloutsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollouts][crate::model::ListRolloutsResponse::rollouts].
    pub fn set_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rollout>,
    {
        use std::iter::Iterator;
        self.rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRolloutsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRolloutsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRolloutsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListRolloutsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRolloutsResponse {
    type PageItem = crate::model::Rollout;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rollouts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRolloutsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollouts,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRolloutsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollouts" => Ok(__FieldTag::__rollouts),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRolloutsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRolloutsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollouts => {
                            if !fields.insert(__FieldTag::__rollouts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollouts",
                                ));
                            }
                            result.rollouts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Rollout>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRolloutsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollouts.is_empty() {
            state.serialize_entry("rollouts", &self.rollouts)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRolloutsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRolloutsResponse");
        debug_struct.field("rollouts", &self.rollouts);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetRolloutRequest is the request object used by `GetRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRolloutRequest {
    /// Required. Name of the `Rollout`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRolloutRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreateRolloutRequest is the request object used by `CreateRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRolloutRequest {
    /// Required. The parent collection in which the `Rollout` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `Rollout`.
    pub rollout_id: std::string::String,

    /// Required. The `Rollout` to create.
    pub rollout: std::option::Option<crate::model::Rollout>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    /// Optional. The starting phase ID for the `Rollout`. If empty the `Rollout`
    /// will start at the first phase.
    pub starting_phase_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRolloutRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::CreateRolloutRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::CreateRolloutRequest::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::CreateRolloutRequest::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateRolloutRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateRolloutRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CreateRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [starting_phase_id][crate::model::CreateRolloutRequest::starting_phase_id].
    pub fn set_starting_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.starting_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __rollout_id,
            __rollout,
            __request_id,
            __validate_only,
            __override_deploy_policy,
            __starting_phase_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "rolloutId" => Ok(__FieldTag::__rollout_id),
                            "rollout_id" => Ok(__FieldTag::__rollout_id),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            "startingPhaseId" => Ok(__FieldTag::__starting_phase_id),
                            "starting_phase_id" => Ok(__FieldTag::__starting_phase_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_id => {
                            if !fields.insert(__FieldTag::__rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_id",
                                ));
                            }
                            result.rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout =
                                map.next_value::<std::option::Option<crate::model::Rollout>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__starting_phase_id => {
                            if !fields.insert(__FieldTag::__starting_phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for starting_phase_id",
                                ));
                            }
                            result.starting_phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.rollout_id.is_empty() {
            state.serialize_entry("rolloutId", &self.rollout_id)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self.starting_phase_id.is_empty() {
            state.serialize_entry("startingPhaseId", &self.starting_phase_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateRolloutRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("rollout_id", &self.rollout_id);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        debug_struct.field("starting_phase_id", &self.starting_phase_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `ApproveRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub name: std::string::String,

    /// Required. True = approve; false = reject
    pub approved: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [approved][crate::model::ApproveRolloutRequest::approved].
    pub fn set_approved<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.approved = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::ApproveRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ApproveRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ApproveRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __approved,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "approved" => Ok(__FieldTag::__approved),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approved => {
                            if !fields.insert(__FieldTag::__approved) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approved",
                                ));
                            }
                            result.approved = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.approved) {
            state.serialize_entry("approved", &self.approved)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApproveRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApproveRolloutRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("approved", &self.approved);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ApproveRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveRolloutResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ApproveRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ApproveRolloutResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveRolloutResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveRolloutResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveRolloutResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveRolloutResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveRolloutResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApproveRolloutResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApproveRolloutResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `AdvanceRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub name: std::string::String,

    /// Required. The phase ID to advance the `Rollout` to.
    pub phase_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdvanceRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::AdvanceRolloutRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::AdvanceRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdvanceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __phase_id,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "phaseId" => Ok(__FieldTag::__phase_id),
                            "phase_id" => Ok(__FieldTag::__phase_id),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase_id => {
                            if !fields.insert(__FieldTag::__phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_id",
                                ));
                            }
                            result.phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.phase_id.is_empty() {
            state.serialize_entry("phaseId", &self.phase_id)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceRolloutRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("phase_id", &self.phase_id);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `AdvanceRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceRolloutResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdvanceRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceRolloutResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceRolloutResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceRolloutResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceRolloutResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceRolloutResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceRolloutResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceRolloutResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `CancelRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub name: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CancelRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CancelRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelRolloutRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `CancelRollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelRolloutResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelRolloutResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelRolloutResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelRolloutResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelRolloutResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelRolloutResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelRolloutResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelRolloutResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelRolloutResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `IgnoreJob`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IgnoreJobRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub rollout: std::string::String,

    /// Required. The phase ID the Job to ignore belongs to.
    pub phase_id: std::string::String,

    /// Required. The job ID for the Job to ignore.
    pub job_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IgnoreJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::IgnoreJobRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::IgnoreJobRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::IgnoreJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::IgnoreJobRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IgnoreJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.IgnoreJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IgnoreJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __phase_id,
            __job_id,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IgnoreJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "phaseId" => Ok(__FieldTag::__phase_id),
                            "phase_id" => Ok(__FieldTag::__phase_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IgnoreJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IgnoreJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase_id => {
                            if !fields.insert(__FieldTag::__phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_id",
                                ));
                            }
                            result.phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IgnoreJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.phase_id.is_empty() {
            state.serialize_entry("phaseId", &self.phase_id)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IgnoreJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IgnoreJobRequest");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("phase_id", &self.phase_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `IgnoreJob`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IgnoreJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IgnoreJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for IgnoreJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.IgnoreJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IgnoreJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IgnoreJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IgnoreJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IgnoreJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IgnoreJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IgnoreJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IgnoreJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RetryJobRequest is the request object used by `RetryJob`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryJobRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub rollout: std::string::String,

    /// Required. The phase ID the Job to retry belongs to.
    pub phase_id: std::string::String,

    /// Required. The job ID for the Job to retry.
    pub job_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RetryJobRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::RetryJobRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::RetryJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::RetryJobRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RetryJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __phase_id,
            __job_id,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "phaseId" => Ok(__FieldTag::__phase_id),
                            "phase_id" => Ok(__FieldTag::__phase_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase_id => {
                            if !fields.insert(__FieldTag::__phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_id",
                                ));
                            }
                            result.phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.phase_id.is_empty() {
            state.serialize_entry("phaseId", &self.phase_id)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryJobRequest");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("phase_id", &self.phase_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from 'RetryJob'.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RetryJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `AbandonRelease`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AbandonReleaseRequest {
    /// Required. Name of the Release. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AbandonReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AbandonReleaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AbandonReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AbandonReleaseRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AbandonReleaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AbandonReleaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AbandonReleaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AbandonReleaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AbandonReleaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AbandonReleaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AbandonReleaseRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object for `AbandonRelease`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AbandonReleaseResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AbandonReleaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AbandonReleaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AbandonReleaseResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AbandonReleaseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AbandonReleaseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AbandonReleaseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AbandonReleaseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AbandonReleaseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AbandonReleaseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AbandonReleaseResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `JobRun` resource in the Cloud Deploy API.
///
/// A `JobRun` contains information of a single `Rollout` job evaluation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JobRun {
    /// Output only. Name of the `JobRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{releases}/rollouts/{rollouts}/jobRuns/{uuid}`.
    pub name: std::string::String,

    /// Output only. Unique identifier of the `JobRun`.
    pub uid: std::string::String,

    /// Output only. ID of the `Rollout` phase this `JobRun` belongs in.
    pub phase_id: std::string::String,

    /// Output only. ID of the `Rollout` job this `JobRun` corresponds to.
    pub job_id: std::string::String,

    /// Output only. Time at which the `JobRun` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `JobRun` was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `JobRun` ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the `JobRun`.
    pub state: crate::model::job_run::State,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// The `JobRun` type and the information for that type.
    pub job_run: std::option::Option<crate::model::job_run::JobRun>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::JobRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::JobRun::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::JobRun::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobRun::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::JobRun::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::JobRun::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::JobRun::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::JobRun::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::JobRun::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::JobRun::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::JobRun::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_run::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::JobRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run].
    ///
    /// Note that all the setters affecting `job_run` are mutually
    /// exclusive.
    pub fn set_job_run<
        T: std::convert::Into<std::option::Option<crate::model::job_run::JobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = v.into();
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `DeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::DeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `DeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_deploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::DeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::DeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `VerifyJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn verify_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VerifyJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::VerifyJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `VerifyJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_verify_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::VerifyJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::VerifyJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `PredeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn predeploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::PredeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `PredeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_predeploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::PredeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::PredeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `PostdeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postdeploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostdeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::PostdeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `PostdeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_postdeploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::PostdeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::PostdeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `CreateChildRolloutJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_child_rollout_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateChildRolloutJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::CreateChildRolloutJobRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `CreateChildRolloutJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_create_child_rollout_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateChildRolloutJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = std::option::Option::Some(
            crate::model::job_run::JobRun::CreateChildRolloutJobRun(v.into()),
        );
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `AdvanceChildRolloutJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_child_rollout_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::AdvanceChildRolloutJobRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `AdvanceChildRolloutJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_advance_child_rollout_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = std::option::Option::Some(
            crate::model::job_run::JobRun::AdvanceChildRolloutJobRun(v.into()),
        );
        self
    }
}

impl wkt::message::Message for JobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.JobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __phase_id,
            __job_id,
            __create_time,
            __start_time,
            __end_time,
            __state,
            __deploy_job_run,
            __verify_job_run,
            __predeploy_job_run,
            __postdeploy_job_run,
            __create_child_rollout_job_run,
            __advance_child_rollout_job_run,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "phaseId" => Ok(__FieldTag::__phase_id),
                            "phase_id" => Ok(__FieldTag::__phase_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "state" => Ok(__FieldTag::__state),
                            "deployJobRun" => Ok(__FieldTag::__deploy_job_run),
                            "deploy_job_run" => Ok(__FieldTag::__deploy_job_run),
                            "verifyJobRun" => Ok(__FieldTag::__verify_job_run),
                            "verify_job_run" => Ok(__FieldTag::__verify_job_run),
                            "predeployJobRun" => Ok(__FieldTag::__predeploy_job_run),
                            "predeploy_job_run" => Ok(__FieldTag::__predeploy_job_run),
                            "postdeployJobRun" => Ok(__FieldTag::__postdeploy_job_run),
                            "postdeploy_job_run" => Ok(__FieldTag::__postdeploy_job_run),
                            "createChildRolloutJobRun" => {
                                Ok(__FieldTag::__create_child_rollout_job_run)
                            }
                            "create_child_rollout_job_run" => {
                                Ok(__FieldTag::__create_child_rollout_job_run)
                            }
                            "advanceChildRolloutJobRun" => {
                                Ok(__FieldTag::__advance_child_rollout_job_run)
                            }
                            "advance_child_rollout_job_run" => {
                                Ok(__FieldTag::__advance_child_rollout_job_run)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase_id => {
                            if !fields.insert(__FieldTag::__phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_id",
                                ));
                            }
                            result.phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job_run::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_job_run => {
                            if !fields.insert(__FieldTag::__deploy_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.deploy_job_run, latest field was deployJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::DeployJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeployJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__verify_job_run => {
                            if !fields.insert(__FieldTag::__verify_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verify_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.verify_job_run, latest field was verifyJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::VerifyJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VerifyJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__predeploy_job_run => {
                            if !fields.insert(__FieldTag::__predeploy_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predeploy_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.predeploy_job_run, latest field was predeployJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::PredeployJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PredeployJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postdeploy_job_run => {
                            if !fields.insert(__FieldTag::__postdeploy_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postdeploy_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.postdeploy_job_run, latest field was postdeployJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::PostdeployJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostdeployJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_child_rollout_job_run => {
                            if !fields.insert(__FieldTag::__create_child_rollout_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_child_rollout_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.create_child_rollout_job_run, latest field was createChildRolloutJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::CreateChildRolloutJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateChildRolloutJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__advance_child_rollout_job_run => {
                            if !fields.insert(__FieldTag::__advance_child_rollout_job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_child_rollout_job_run",
                                ));
                            }
                            if result.job_run.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_run`, a oneof with full ID .google.cloud.deploy.v1.JobRun.advance_child_rollout_job_run, latest field was advanceChildRolloutJobRun",
                                ));
                            }
                            result.job_run = std::option::Option::Some(
                                crate::model::job_run::JobRun::AdvanceChildRolloutJobRun(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.phase_id.is_empty() {
            state.serialize_entry("phaseId", &self.phase_id)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if let Some(value) = self.deploy_job_run() {
            state.serialize_entry("deployJobRun", value)?;
        }
        if let Some(value) = self.verify_job_run() {
            state.serialize_entry("verifyJobRun", value)?;
        }
        if let Some(value) = self.predeploy_job_run() {
            state.serialize_entry("predeployJobRun", value)?;
        }
        if let Some(value) = self.postdeploy_job_run() {
            state.serialize_entry("postdeployJobRun", value)?;
        }
        if let Some(value) = self.create_child_rollout_job_run() {
            state.serialize_entry("createChildRolloutJobRun", value)?;
        }
        if let Some(value) = self.advance_child_rollout_job_run() {
            state.serialize_entry("advanceChildRolloutJobRun", value)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobRun");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("phase_id", &self.phase_id);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("job_run", &self.job_run);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [JobRun].
pub mod job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a `JobRun`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `JobRun` has an unspecified state.
        Unspecified,
        /// The `JobRun` is in progress.
        InProgress,
        /// The `JobRun` has succeeded.
        Succeeded,
        /// The `JobRun` has failed.
        Failed,
        /// The `JobRun` is terminating.
        Terminating,
        /// The `JobRun` was terminated.
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Terminating,
                5 => Self::Terminated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.JobRun.State",
            ))
        }
    }

    /// The `JobRun` type and the information for that type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobRun {
        /// Output only. Information specific to a deploy `JobRun`.
        DeployJobRun(std::boxed::Box<crate::model::DeployJobRun>),
        /// Output only. Information specific to a verify `JobRun`.
        VerifyJobRun(std::boxed::Box<crate::model::VerifyJobRun>),
        /// Output only. Information specific to a predeploy `JobRun`.
        PredeployJobRun(std::boxed::Box<crate::model::PredeployJobRun>),
        /// Output only. Information specific to a postdeploy `JobRun`.
        PostdeployJobRun(std::boxed::Box<crate::model::PostdeployJobRun>),
        /// Output only. Information specific to a createChildRollout `JobRun`.
        CreateChildRolloutJobRun(std::boxed::Box<crate::model::CreateChildRolloutJobRun>),
        /// Output only. Information specific to an advanceChildRollout `JobRun`
        AdvanceChildRolloutJobRun(std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>),
    }
}

/// DeployJobRun contains information specific to a deploy `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to deploy. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    pub build: std::string::String,

    /// Output only. The reason the deploy failed. This will always be unspecified
    /// while the deploy is in progress or if it succeeded.
    pub failure_cause: crate::model::deploy_job_run::FailureCause,

    /// Output only. Additional information about the deploy failure, if available.
    pub failure_message: std::string::String,

    /// Output only. Metadata containing information about the deploy job run.
    pub metadata: std::option::Option<crate::model::DeployJobRunMetadata>,

    /// Output only. The artifact of a deploy job run, if available.
    pub artifact: std::option::Option<crate::model::DeployArtifact>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::DeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::DeployJobRun::failure_cause].
    pub fn set_failure_cause<T: std::convert::Into<crate::model::deploy_job_run::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::DeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::DeployJobRun::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployJobRunMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::DeployJobRun::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployJobRunMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [artifact][crate::model::DeployJobRun::artifact].
    pub fn set_artifact<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployArtifact>,
    {
        self.artifact = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifact][crate::model::DeployJobRun::artifact].
    pub fn set_or_clear_artifact<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployArtifact>,
    {
        self.artifact = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            __failure_cause,
            __failure_message,
            __metadata,
            __artifact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            "failureCause" => Ok(__FieldTag::__failure_cause),
                            "failure_cause" => Ok(__FieldTag::__failure_cause),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "artifact" => Ok(__FieldTag::__artifact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_cause => {
                            if !fields.insert(__FieldTag::__failure_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_cause",
                                ));
                            }
                            result.failure_cause = map.next_value::<std::option::Option<crate::model::deploy_job_run::FailureCause>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::DeployJobRunMetadata>>()?
                                ;
                        }
                        __FieldTag::__artifact => {
                            if !fields.insert(__FieldTag::__artifact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact",
                                ));
                            }
                            result.artifact = map
                                .next_value::<std::option::Option<crate::model::DeployArtifact>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build.is_empty() {
            state.serialize_entry("build", &self.build)?;
        }
        if !wkt::internal::is_default(&self.failure_cause) {
            state.serialize_entry("failureCause", &self.failure_cause)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.artifact.is_some() {
            state.serialize_entry("artifact", &self.artifact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployJobRun");
        debug_struct.field("build", &self.build);
        debug_struct.field("failure_cause", &self.failure_cause);
        debug_struct.field("failure_message", &self.failure_message);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("artifact", &self.artifact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeployJobRun].
pub mod deploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known deploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [Required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The deploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The deploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// There were missing resources in the runtime environment required for a
        /// canary deployment. Check the Cloud Build logs for more information.
        MissingResourcesForCanary,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// The deploy operation had a feature configured that is not supported.
        DeployFeatureNotSupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::MissingResourcesForCanary => std::option::Option::Some(4),
                Self::CloudBuildRequestFailed => std::option::Option::Some(5),
                Self::DeployFeatureNotSupported => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::MissingResourcesForCanary => {
                    std::option::Option::Some("MISSING_RESOURCES_FOR_CANARY")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::DeployFeatureNotSupported => {
                    std::option::Option::Some("DEPLOY_FEATURE_NOT_SUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::MissingResourcesForCanary,
                5 => Self::CloudBuildRequestFailed,
                6 => Self::DeployFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "MISSING_RESOURCES_FOR_CANARY" => Self::MissingResourcesForCanary,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                "DEPLOY_FEATURE_NOT_SUPPORTED" => Self::DeployFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::MissingResourcesForCanary => serializer.serialize_i32(4),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(5),
                Self::DeployFeatureNotSupported => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.DeployJobRun.FailureCause",
            ))
        }
    }
}

/// VerifyJobRun contains information specific to a verify `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to verify. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    pub build: std::string::String,

    /// Output only. URI of a directory containing the verify artifacts. This
    /// contains the Skaffold event log.
    pub artifact_uri: std::string::String,

    /// Output only. File path of the Skaffold event log relative to the artifact
    /// URI.
    pub event_log_path: std::string::String,

    /// Output only. The reason the verify failed. This will always be unspecified
    /// while the verify is in progress or if it succeeded.
    pub failure_cause: crate::model::verify_job_run::FailureCause,

    /// Output only. Additional information about the verify failure, if available.
    pub failure_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::VerifyJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [artifact_uri][crate::model::VerifyJobRun::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [event_log_path][crate::model::VerifyJobRun::event_log_path].
    pub fn set_event_log_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_log_path = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::VerifyJobRun::failure_cause].
    pub fn set_failure_cause<T: std::convert::Into<crate::model::verify_job_run::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::VerifyJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for VerifyJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.VerifyJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            __artifact_uri,
            __event_log_path,
            __failure_cause,
            __failure_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            "artifactUri" => Ok(__FieldTag::__artifact_uri),
                            "artifact_uri" => Ok(__FieldTag::__artifact_uri),
                            "eventLogPath" => Ok(__FieldTag::__event_log_path),
                            "event_log_path" => Ok(__FieldTag::__event_log_path),
                            "failureCause" => Ok(__FieldTag::__failure_cause),
                            "failure_cause" => Ok(__FieldTag::__failure_cause),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_uri => {
                            if !fields.insert(__FieldTag::__artifact_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_uri",
                                ));
                            }
                            result.artifact_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_log_path => {
                            if !fields.insert(__FieldTag::__event_log_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_log_path",
                                ));
                            }
                            result.event_log_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_cause => {
                            if !fields.insert(__FieldTag::__failure_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_cause",
                                ));
                            }
                            result.failure_cause = map.next_value::<std::option::Option<crate::model::verify_job_run::FailureCause>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build.is_empty() {
            state.serialize_entry("build", &self.build)?;
        }
        if !self.artifact_uri.is_empty() {
            state.serialize_entry("artifactUri", &self.artifact_uri)?;
        }
        if !self.event_log_path.is_empty() {
            state.serialize_entry("eventLogPath", &self.event_log_path)?;
        }
        if !wkt::internal::is_default(&self.failure_cause) {
            state.serialize_entry("failureCause", &self.failure_cause)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerifyJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyJobRun");
        debug_struct.field("build", &self.build);
        debug_struct.field("artifact_uri", &self.artifact_uri);
        debug_struct.field("event_log_path", &self.event_log_path);
        debug_struct.field("failure_cause", &self.failure_cause);
        debug_struct.field("failure_message", &self.failure_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VerifyJobRun].
pub mod verify_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known verify failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The verify operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The verify job run did not complete within the allotted time.
        DeadlineExceeded,
        /// No Skaffold verify configuration was found.
        VerificationConfigNotFound,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::VerificationConfigNotFound => std::option::Option::Some(4),
                Self::CloudBuildRequestFailed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::VerificationConfigNotFound => {
                    std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::VerificationConfigNotFound,
                5 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::VerificationConfigNotFound => serializer.serialize_i32(4),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.VerifyJobRun.FailureCause",
            ))
        }
    }
}

/// PredeployJobRun contains information specific to a predeploy `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PredeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to execute the custom actions associated with the predeploy Job.
    /// Format is `projects/{project}/locations/{location}/builds/{build}`.
    pub build: std::string::String,

    /// Output only. The reason the predeploy failed. This will always be
    /// unspecified while the predeploy is in progress or if it succeeded.
    pub failure_cause: crate::model::predeploy_job_run::FailureCause,

    /// Output only. Additional information about the predeploy failure, if
    /// available.
    pub failure_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::PredeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::PredeployJobRun::failure_cause].
    pub fn set_failure_cause<
        T: std::convert::Into<crate::model::predeploy_job_run::FailureCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PredeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PredeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PredeployJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PredeployJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            __failure_cause,
            __failure_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PredeployJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            "failureCause" => Ok(__FieldTag::__failure_cause),
                            "failure_cause" => Ok(__FieldTag::__failure_cause),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PredeployJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PredeployJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_cause => {
                            if !fields.insert(__FieldTag::__failure_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_cause",
                                ));
                            }
                            result.failure_cause =
                                map.next_value::<std::option::Option<
                                    crate::model::predeploy_job_run::FailureCause,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PredeployJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build.is_empty() {
            state.serialize_entry("build", &self.build)?;
        }
        if !wkt::internal::is_default(&self.failure_cause) {
            state.serialize_entry("failureCause", &self.failure_cause)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PredeployJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PredeployJobRun");
        debug_struct.field("build", &self.build);
        debug_struct.field("failure_cause", &self.failure_cause);
        debug_struct.field("failure_message", &self.failure_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PredeployJobRun].
pub mod predeploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known predeploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The predeploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The predeploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::CloudBuildRequestFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.PredeployJobRun.FailureCause",
            ))
        }
    }
}

/// PostdeployJobRun contains information specific to a postdeploy `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostdeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to execute the custom actions associated with the postdeploy Job.
    /// Format is `projects/{project}/locations/{location}/builds/{build}`.
    pub build: std::string::String,

    /// Output only. The reason the postdeploy failed. This will always be
    /// unspecified while the postdeploy is in progress or if it succeeded.
    pub failure_cause: crate::model::postdeploy_job_run::FailureCause,

    /// Output only. Additional information about the postdeploy failure, if
    /// available.
    pub failure_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostdeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::PostdeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::PostdeployJobRun::failure_cause].
    pub fn set_failure_cause<
        T: std::convert::Into<crate::model::postdeploy_job_run::FailureCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PostdeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PostdeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PostdeployJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostdeployJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build,
            __failure_cause,
            __failure_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostdeployJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "build" => Ok(__FieldTag::__build),
                            "failureCause" => Ok(__FieldTag::__failure_cause),
                            "failure_cause" => Ok(__FieldTag::__failure_cause),
                            "failureMessage" => Ok(__FieldTag::__failure_message),
                            "failure_message" => Ok(__FieldTag::__failure_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostdeployJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostdeployJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build => {
                            if !fields.insert(__FieldTag::__build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build",
                                ));
                            }
                            result.build = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_cause => {
                            if !fields.insert(__FieldTag::__failure_cause) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_cause",
                                ));
                            }
                            result.failure_cause =
                                map.next_value::<std::option::Option<
                                    crate::model::postdeploy_job_run::FailureCause,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_message => {
                            if !fields.insert(__FieldTag::__failure_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_message",
                                ));
                            }
                            result.failure_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostdeployJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.build.is_empty() {
            state.serialize_entry("build", &self.build)?;
        }
        if !wkt::internal::is_default(&self.failure_cause) {
            state.serialize_entry("failureCause", &self.failure_cause)?;
        }
        if !self.failure_message.is_empty() {
            state.serialize_entry("failureMessage", &self.failure_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostdeployJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostdeployJobRun");
        debug_struct.field("build", &self.build);
        debug_struct.field("failure_cause", &self.failure_cause);
        debug_struct.field("failure_message", &self.failure_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PostdeployJobRun].
pub mod postdeploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known postdeploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The postdeploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The postdeploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::CloudBuildRequestFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.PostdeployJobRun.FailureCause",
            ))
        }
    }
}

/// CreateChildRolloutJobRun contains information specific to a
/// createChildRollout `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChildRolloutJobRun {
    /// Output only. Name of the `ChildRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub rollout: std::string::String,

    /// Output only. The ID of the childRollout Phase initiated by this JobRun.
    pub rollout_phase_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChildRolloutJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::CreateChildRolloutJobRun::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [rollout_phase_id][crate::model::CreateChildRolloutJobRun::rollout_phase_id].
    pub fn set_rollout_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateChildRolloutJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateChildRolloutJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateChildRolloutJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __rollout_phase_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChildRolloutJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "rolloutPhaseId" => Ok(__FieldTag::__rollout_phase_id),
                            "rollout_phase_id" => Ok(__FieldTag::__rollout_phase_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateChildRolloutJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChildRolloutJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_phase_id => {
                            if !fields.insert(__FieldTag::__rollout_phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_phase_id",
                                ));
                            }
                            result.rollout_phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateChildRolloutJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.rollout_phase_id.is_empty() {
            state.serialize_entry("rolloutPhaseId", &self.rollout_phase_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateChildRolloutJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateChildRolloutJobRun");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("rollout_phase_id", &self.rollout_phase_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AdvanceChildRolloutJobRun contains information specific to a
/// advanceChildRollout `JobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceChildRolloutJobRun {
    /// Output only. Name of the `ChildRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    pub rollout: std::string::String,

    /// Output only. the ID of the ChildRollout's Phase.
    pub rollout_phase_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceChildRolloutJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::AdvanceChildRolloutJobRun::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [rollout_phase_id][crate::model::AdvanceChildRolloutJobRun::rollout_phase_id].
    pub fn set_rollout_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for AdvanceChildRolloutJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceChildRolloutJobRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceChildRolloutJobRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __rollout_phase_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceChildRolloutJobRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "rolloutPhaseId" => Ok(__FieldTag::__rollout_phase_id),
                            "rollout_phase_id" => Ok(__FieldTag::__rollout_phase_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceChildRolloutJobRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceChildRolloutJobRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_phase_id => {
                            if !fields.insert(__FieldTag::__rollout_phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_phase_id",
                                ));
                            }
                            result.rollout_phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceChildRolloutJobRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.rollout_phase_id.is_empty() {
            state.serialize_entry("rolloutPhaseId", &self.rollout_phase_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceChildRolloutJobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceChildRolloutJobRun");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("rollout_phase_id", &self.rollout_phase_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListJobRunsRequest is the request object used by `ListJobRuns`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobRunsRequest {
    /// Required. The `Rollout` which owns this collection of `JobRun` objects.
    pub parent: std::string::String,

    /// Optional. The maximum number of `JobRun` objects to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `JobRun` objects
    /// will be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListJobRuns` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match the call that provided
    /// the page token.
    pub page_token: std::string::String,

    /// Optional. Filter results to be returned. See <https://google.aip.dev/160> for
    /// more details.
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListJobRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListJobRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListJobRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListJobRunsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobRunsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListJobRunsResponse is the response object returned by `ListJobRuns`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobRunsResponse {
    /// The `JobRun` objects.
    pub job_runs: std::vec::Vec<crate::model::JobRun>,

    /// A token, which can be sent as `page_token` to retrieve the next page. If
    /// this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_runs][crate::model::ListJobRunsResponse::job_runs].
    pub fn set_job_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobRun>,
    {
        use std::iter::Iterator;
        self.job_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListJobRunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListJobRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobRunsResponse {
    type PageItem = crate::model::JobRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.job_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_runs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobRuns" => Ok(__FieldTag::__job_runs),
                            "job_runs" => Ok(__FieldTag::__job_runs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_runs => {
                            if !fields.insert(__FieldTag::__job_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_runs",
                                ));
                            }
                            result.job_runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_runs.is_empty() {
            state.serialize_entry("jobRuns", &self.job_runs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListJobRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobRunsResponse");
        debug_struct.field("job_runs", &self.job_runs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetJobRunRequest is the request object used by `GetJobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRunRequest {
    /// Required. Name of the `JobRun`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}/jobRuns/{job_run_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetJobRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetJobRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRunRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `TerminateJobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TerminateJobRunRequest {
    /// Required. Name of the `JobRun`. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}/jobRuns/{jobRun}`.
    pub name: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateJobRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TerminateJobRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::TerminateJobRunRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TerminateJobRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TerminateJobRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TerminateJobRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __override_deploy_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TerminateJobRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "overrideDeployPolicy" => Ok(__FieldTag::__override_deploy_policy),
                            "override_deploy_policy" => Ok(__FieldTag::__override_deploy_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TerminateJobRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TerminateJobRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_deploy_policy => {
                            if !fields.insert(__FieldTag::__override_deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_deploy_policy",
                                ));
                            }
                            result.override_deploy_policy = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TerminateJobRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.override_deploy_policy.is_empty() {
            state.serialize_entry("overrideDeployPolicy", &self.override_deploy_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TerminateJobRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TerminateJobRunRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("override_deploy_policy", &self.override_deploy_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `TerminateJobRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TerminateJobRunResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateJobRunResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for TerminateJobRunResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TerminateJobRunResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TerminateJobRunResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TerminateJobRunResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TerminateJobRunResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TerminateJobRunResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TerminateJobRunResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TerminateJobRunResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TerminateJobRunResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Service-wide configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Config {
    /// Name of the configuration.
    pub name: std::string::String,

    /// All supported versions of Skaffold.
    pub supported_versions: std::vec::Vec<crate::model::SkaffoldVersion>,

    /// Default Skaffold version that is assigned when a Release is created without
    /// specifying a Skaffold version.
    pub default_skaffold_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Config::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [supported_versions][crate::model::Config::supported_versions].
    pub fn set_supported_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SkaffoldVersion>,
    {
        use std::iter::Iterator;
        self.supported_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_skaffold_version][crate::model::Config::default_skaffold_version].
    pub fn set_default_skaffold_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_skaffold_version = v.into();
        self
    }
}

impl wkt::message::Message for Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Config"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __supported_versions,
            __default_skaffold_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "supportedVersions" => Ok(__FieldTag::__supported_versions),
                            "supported_versions" => Ok(__FieldTag::__supported_versions),
                            "defaultSkaffoldVersion" => Ok(__FieldTag::__default_skaffold_version),
                            "default_skaffold_version" => {
                                Ok(__FieldTag::__default_skaffold_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_versions => {
                            if !fields.insert(__FieldTag::__supported_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_versions",
                                ));
                            }
                            result.supported_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SkaffoldVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_skaffold_version => {
                            if !fields.insert(__FieldTag::__default_skaffold_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_skaffold_version",
                                ));
                            }
                            result.default_skaffold_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Config {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.supported_versions.is_empty() {
            state.serialize_entry("supportedVersions", &self.supported_versions)?;
        }
        if !self.default_skaffold_version.is_empty() {
            state.serialize_entry("defaultSkaffoldVersion", &self.default_skaffold_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Config");
        debug_struct.field("name", &self.name);
        debug_struct.field("supported_versions", &self.supported_versions);
        debug_struct.field("default_skaffold_version", &self.default_skaffold_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of a supported Skaffold version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SkaffoldVersion {
    /// Release version number. For example, "1.20.3".
    pub version: std::string::String,

    /// The time at which this version of Skaffold will enter maintenance mode.
    pub maintenance_mode_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this version of Skaffold will no longer be supported.
    pub support_expiration_time: std::option::Option<wkt::Timestamp>,

    /// Date when this version is expected to no longer be supported.
    pub support_end_date: std::option::Option<gtype::model::Date>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SkaffoldVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::SkaffoldVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [maintenance_mode_time][crate::model::SkaffoldVersion::maintenance_mode_time].
    pub fn set_maintenance_mode_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_mode_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_mode_time][crate::model::SkaffoldVersion::maintenance_mode_time].
    pub fn set_or_clear_maintenance_mode_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_mode_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [support_expiration_time][crate::model::SkaffoldVersion::support_expiration_time].
    pub fn set_support_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.support_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [support_expiration_time][crate::model::SkaffoldVersion::support_expiration_time].
    pub fn set_or_clear_support_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.support_expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [support_end_date][crate::model::SkaffoldVersion::support_end_date].
    pub fn set_support_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.support_end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [support_end_date][crate::model::SkaffoldVersion::support_end_date].
    pub fn set_or_clear_support_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.support_end_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SkaffoldVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SkaffoldVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SkaffoldVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __maintenance_mode_time,
            __support_expiration_time,
            __support_end_date,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SkaffoldVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "maintenanceModeTime" => Ok(__FieldTag::__maintenance_mode_time),
                            "maintenance_mode_time" => Ok(__FieldTag::__maintenance_mode_time),
                            "supportExpirationTime" => Ok(__FieldTag::__support_expiration_time),
                            "support_expiration_time" => Ok(__FieldTag::__support_expiration_time),
                            "supportEndDate" => Ok(__FieldTag::__support_end_date),
                            "support_end_date" => Ok(__FieldTag::__support_end_date),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SkaffoldVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SkaffoldVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_mode_time => {
                            if !fields.insert(__FieldTag::__maintenance_mode_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_mode_time",
                                ));
                            }
                            result.maintenance_mode_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__support_expiration_time => {
                            if !fields.insert(__FieldTag::__support_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_expiration_time",
                                ));
                            }
                            result.support_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__support_end_date => {
                            if !fields.insert(__FieldTag::__support_end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_end_date",
                                ));
                            }
                            result.support_end_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SkaffoldVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.maintenance_mode_time.is_some() {
            state.serialize_entry("maintenanceModeTime", &self.maintenance_mode_time)?;
        }
        if self.support_expiration_time.is_some() {
            state.serialize_entry("supportExpirationTime", &self.support_expiration_time)?;
        }
        if self.support_end_date.is_some() {
            state.serialize_entry("supportEndDate", &self.support_end_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SkaffoldVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SkaffoldVersion");
        debug_struct.field("version", &self.version);
        debug_struct.field("maintenance_mode_time", &self.maintenance_mode_time);
        debug_struct.field("support_expiration_time", &self.support_expiration_time);
        debug_struct.field("support_end_date", &self.support_end_date);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to get a configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConfigRequest {
    /// Required. Name of requested configuration.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An `Automation` resource in the Cloud Deploy API.
///
/// An `Automation` enables the automation of manually driven actions for
/// a Delivery Pipeline, which includes Release promotion among Targets,
/// Rollout repair and Rollout deployment strategy advancement. The intention
/// of Automation is to reduce manual intervention in the continuous delivery
/// process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Automation {
    /// Output only. Name of the `Automation`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automations/{automation}`.
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Automation`.
    pub uid: std::string::String,

    /// Optional. Description of the `Automation`. Max length is 255 characters.
    pub description: std::string::String,

    /// Output only. Time at which the automation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the automation was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. Annotations must meet the following
    /// constraints:
    ///
    /// * Annotations are key/value pairs.
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (`/`).
    /// * The name segment is required and must be 63 characters or less,
    ///   beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
    ///   dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
    /// * The prefix is optional. If specified, the prefix must be a DNS subdomain:
    ///   a series of DNS labels separated by dots(`.`), not longer than 253
    ///   characters in total, followed by a slash (`/`).
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set>
    /// for more details.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 63 characters.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The weak etag of the `Automation` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. When Suspended, automation is deactivated from execution.
    pub suspended: bool,

    /// Required. Email address of the user-managed IAM service account that
    /// creates Cloud Deploy release and rollout resources.
    pub service_account: std::string::String,

    /// Required. Selected resources to which the automation will be applied.
    pub selector: std::option::Option<crate::model::AutomationResourceSelector>,

    /// Required. List of Automation rules associated with the Automation resource.
    /// Must have at least one rule and limited to 250 rules per Delivery Pipeline.
    /// Note: the order of the rules here is not the same as the order of
    /// execution.
    pub rules: std::vec::Vec<crate::model::AutomationRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Automation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Automation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Automation::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Automation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Automation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Automation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Automation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Automation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::Automation::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Automation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Automation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::Automation::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Automation::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [selector][crate::model::Automation::selector].
    pub fn set_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationResourceSelector>,
    {
        self.selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [selector][crate::model::Automation::selector].
    pub fn set_or_clear_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationResourceSelector>,
    {
        self.selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rules][crate::model::Automation::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutomationRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Automation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Automation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Automation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __description,
            __create_time,
            __update_time,
            __annotations,
            __labels,
            __etag,
            __suspended,
            __service_account,
            __selector,
            __rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Automation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "suspended" => Ok(__FieldTag::__suspended),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "selector" => Ok(__FieldTag::__selector),
                            "rules" => Ok(__FieldTag::__rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Automation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Automation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selector => {
                            if !fields.insert(__FieldTag::__selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selector",
                                ));
                            }
                            result.selector = map.next_value::<std::option::Option<crate::model::AutomationResourceSelector>>()?
                                ;
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutomationRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Automation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.selector.is_some() {
            state.serialize_entry("selector", &self.selector)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Automation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Automation");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("suspended", &self.suspended);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("selector", &self.selector);
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutomationResourceSelector contains the information to select the resources
/// to which an Automation is going to be applied.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationResourceSelector {
    /// Optional. Contains attributes about a target.
    pub targets: std::vec::Vec<crate::model::TargetAttribute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationResourceSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets][crate::model::AutomationResourceSelector::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetAttribute>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutomationResourceSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationResourceSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationResourceSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __targets,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationResourceSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targets" => Ok(__FieldTag::__targets),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationResourceSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationResourceSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__targets => {
                            if !fields.insert(__FieldTag::__targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets",
                                ));
                            }
                            result.targets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TargetAttribute>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationResourceSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.targets.is_empty() {
            state.serialize_entry("targets", &self.targets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationResourceSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationResourceSelector");
        debug_struct.field("targets", &self.targets);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// `AutomationRule` defines the automation activities.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationRule {
    /// The configuration of the Automation rule.
    pub rule: std::option::Option<crate::model::automation_rule::Rule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule].
    ///
    /// Note that all the setters affecting `rule` are mutually
    /// exclusive.
    pub fn set_rule<
        T: std::convert::Into<std::option::Option<crate::model::automation_rule::Rule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `PromoteReleaseRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn promote_release_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PromoteReleaseRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::PromoteReleaseRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `PromoteReleaseRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_promote_release_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::PromoteReleaseRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::PromoteReleaseRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `AdvanceRolloutRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_rollout_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceRolloutRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::AdvanceRolloutRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `AdvanceRolloutRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_advance_rollout_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceRolloutRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::AdvanceRolloutRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `RepairRolloutRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repair_rollout_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RepairRolloutRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::RepairRolloutRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `RepairRolloutRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_repair_rollout_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::RepairRolloutRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::RepairRolloutRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `TimedPromoteReleaseRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::TimedPromoteReleaseRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `TimedPromoteReleaseRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::TimedPromoteReleaseRule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomationRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __promote_release_rule,
            __advance_rollout_rule,
            __repair_rollout_rule,
            __timed_promote_release_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "promoteReleaseRule" => Ok(__FieldTag::__promote_release_rule),
                            "promote_release_rule" => Ok(__FieldTag::__promote_release_rule),
                            "advanceRolloutRule" => Ok(__FieldTag::__advance_rollout_rule),
                            "advance_rollout_rule" => Ok(__FieldTag::__advance_rollout_rule),
                            "repairRolloutRule" => Ok(__FieldTag::__repair_rollout_rule),
                            "repair_rollout_rule" => Ok(__FieldTag::__repair_rollout_rule),
                            "timedPromoteReleaseRule" => {
                                Ok(__FieldTag::__timed_promote_release_rule)
                            }
                            "timed_promote_release_rule" => {
                                Ok(__FieldTag::__timed_promote_release_rule)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__promote_release_rule => {
                            if !fields.insert(__FieldTag::__promote_release_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promote_release_rule",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.cloud.deploy.v1.AutomationRule.promote_release_rule, latest field was promoteReleaseRule",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::automation_rule::Rule::PromoteReleaseRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PromoteReleaseRule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__advance_rollout_rule => {
                            if !fields.insert(__FieldTag::__advance_rollout_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_rollout_rule",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.cloud.deploy.v1.AutomationRule.advance_rollout_rule, latest field was advanceRolloutRule",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::automation_rule::Rule::AdvanceRolloutRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdvanceRolloutRule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repair_rollout_rule => {
                            if !fields.insert(__FieldTag::__repair_rollout_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repair_rollout_rule",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.cloud.deploy.v1.AutomationRule.repair_rollout_rule, latest field was repairRolloutRule",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::automation_rule::Rule::RepairRolloutRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RepairRolloutRule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timed_promote_release_rule => {
                            if !fields.insert(__FieldTag::__timed_promote_release_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timed_promote_release_rule",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.cloud.deploy.v1.AutomationRule.timed_promote_release_rule, latest field was timedPromoteReleaseRule",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::automation_rule::Rule::TimedPromoteReleaseRule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TimedPromoteReleaseRule>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.promote_release_rule() {
            state.serialize_entry("promoteReleaseRule", value)?;
        }
        if let Some(value) = self.advance_rollout_rule() {
            state.serialize_entry("advanceRolloutRule", value)?;
        }
        if let Some(value) = self.repair_rollout_rule() {
            state.serialize_entry("repairRolloutRule", value)?;
        }
        if let Some(value) = self.timed_promote_release_rule() {
            state.serialize_entry("timedPromoteReleaseRule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationRule");
        debug_struct.field("rule", &self.rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutomationRule].
pub mod automation_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of the Automation rule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Rule {
        /// Optional. `PromoteReleaseRule` will automatically promote a release from
        /// the current target to a specified target.
        PromoteReleaseRule(std::boxed::Box<crate::model::PromoteReleaseRule>),
        /// Optional. The `AdvanceRolloutRule` will automatically advance a
        /// successful Rollout.
        AdvanceRolloutRule(std::boxed::Box<crate::model::AdvanceRolloutRule>),
        /// Optional. The `RepairRolloutRule` will automatically repair a failed
        /// rollout.
        RepairRolloutRule(std::boxed::Box<crate::model::RepairRolloutRule>),
        /// Optional. The `TimedPromoteReleaseRule` will automatically promote a
        /// release from the current target(s) to the specified target(s) on a
        /// configured schedule.
        TimedPromoteReleaseRule(std::boxed::Box<crate::model::TimedPromoteReleaseRule>),
    }
}

/// The `TimedPromoteReleaseRule` will automatically promote a release from the
/// current target(s) to the specified target(s) on a configured schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimedPromoteReleaseRule {
    /// Required. ID of the rule. This ID must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub id: std::string::String,

    /// Optional. The ID of the stage in the pipeline to which this `Release` is
    /// deploying. If unspecified, default it to the next stage in the promotion
    /// flow. The value of this field could be one of the following:
    ///
    /// * The last segment of a target name
    /// * "@next", the next target in the promotion sequence
    pub destination_target_id: std::string::String,

    /// Required. Schedule in crontab format. e.g. "0 9 * * 1" for every Monday at
    /// 9am.
    pub schedule: std::string::String,

    /// Required. The time zone in IANA format [IANA Time Zone
    /// Database](https://www.iana.org/time-zones) (e.g. America/New_York).
    pub time_zone: std::string::String,

    /// Output only. Information around the state of the Automation rule.
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Optional. The starting phase of the rollout created by this rule. Default
    /// to the first phase.
    pub destination_phase: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TimedPromoteReleaseRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [destination_target_id][crate::model::TimedPromoteReleaseRule::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::TimedPromoteReleaseRule::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::TimedPromoteReleaseRule::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TimedPromoteReleaseRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::TimedPromoteReleaseRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_phase][crate::model::TimedPromoteReleaseRule::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimedPromoteReleaseRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __destination_target_id,
            __schedule,
            __time_zone,
            __condition,
            __destination_phase,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimedPromoteReleaseRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "destinationTargetId" => Ok(__FieldTag::__destination_target_id),
                            "destination_target_id" => Ok(__FieldTag::__destination_target_id),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "condition" => Ok(__FieldTag::__condition),
                            "destinationPhase" => Ok(__FieldTag::__destination_phase),
                            "destination_phase" => Ok(__FieldTag::__destination_phase),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimedPromoteReleaseRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimedPromoteReleaseRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_target_id => {
                            if !fields.insert(__FieldTag::__destination_target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_target_id",
                                ));
                            }
                            result.destination_target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::AutomationRuleCondition>>()?
                                ;
                        }
                        __FieldTag::__destination_phase => {
                            if !fields.insert(__FieldTag::__destination_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_phase",
                                ));
                            }
                            result.destination_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimedPromoteReleaseRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.destination_target_id.is_empty() {
            state.serialize_entry("destinationTargetId", &self.destination_target_id)?;
        }
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.destination_phase.is_empty() {
            state.serialize_entry("destinationPhase", &self.destination_phase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimedPromoteReleaseRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimedPromoteReleaseRule");
        debug_struct.field("id", &self.id);
        debug_struct.field("destination_target_id", &self.destination_target_id);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("time_zone", &self.time_zone);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("destination_phase", &self.destination_phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `PromoteRelease` rule will automatically promote a release from the
/// current target to a specified target.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PromoteReleaseRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub id: std::string::String,

    /// Optional. How long the release need to be paused until being promoted to
    /// the next target.
    pub wait: std::option::Option<wkt::Duration>,

    /// Optional. The ID of the stage in the pipeline to which this `Release` is
    /// deploying. If unspecified, default it to the next stage in the promotion
    /// flow. The value of this field could be one of the following:
    ///
    /// * The last segment of a target name
    /// * "@next", the next target in the promotion sequence
    pub destination_target_id: std::string::String,

    /// Output only. Information around the state of the Automation rule.
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Optional. The starting phase of the rollout created by this operation.
    /// Default to the first phase.
    pub destination_phase: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteReleaseRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::PromoteReleaseRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::PromoteReleaseRule::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::PromoteReleaseRule::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_target_id][crate::model::PromoteReleaseRule::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::PromoteReleaseRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::PromoteReleaseRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_phase][crate::model::PromoteReleaseRule::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for PromoteReleaseRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PromoteReleaseRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PromoteReleaseRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __wait,
            __destination_target_id,
            __condition,
            __destination_phase,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PromoteReleaseRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "wait" => Ok(__FieldTag::__wait),
                            "destinationTargetId" => Ok(__FieldTag::__destination_target_id),
                            "destination_target_id" => Ok(__FieldTag::__destination_target_id),
                            "condition" => Ok(__FieldTag::__condition),
                            "destinationPhase" => Ok(__FieldTag::__destination_phase),
                            "destination_phase" => Ok(__FieldTag::__destination_phase),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PromoteReleaseRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PromoteReleaseRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__destination_target_id => {
                            if !fields.insert(__FieldTag::__destination_target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_target_id",
                                ));
                            }
                            result.destination_target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::AutomationRuleCondition>>()?
                                ;
                        }
                        __FieldTag::__destination_phase => {
                            if !fields.insert(__FieldTag::__destination_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_phase",
                                ));
                            }
                            result.destination_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PromoteReleaseRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if !self.destination_target_id.is_empty() {
            state.serialize_entry("destinationTargetId", &self.destination_target_id)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.destination_phase.is_empty() {
            state.serialize_entry("destinationPhase", &self.destination_phase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PromoteReleaseRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PromoteReleaseRule");
        debug_struct.field("id", &self.id);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("destination_target_id", &self.destination_target_id);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("destination_phase", &self.destination_phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `AdvanceRollout` automation rule will automatically advance a successful
/// Rollout to the next phase.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub id: std::string::String,

    /// Optional. Proceeds only after phase name matched any one in the list.
    /// This value must consist of lower-case letters, numbers, and hyphens,
    /// start with a letter and end with a letter or a number, and have a max
    /// length of 63 characters. In other words, it must match the following
    /// regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    pub source_phases: std::vec::Vec<std::string::String>,

    /// Optional. How long to wait after a rollout is finished.
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. Information around the state of the Automation rule.
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AdvanceRolloutRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [source_phases][crate::model::AdvanceRolloutRule::source_phases].
    pub fn set_source_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [wait][crate::model::AdvanceRolloutRule::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::AdvanceRolloutRule::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::AdvanceRolloutRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::AdvanceRolloutRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvanceRolloutRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceRolloutRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __source_phases,
            __wait,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceRolloutRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "sourcePhases" => Ok(__FieldTag::__source_phases),
                            "source_phases" => Ok(__FieldTag::__source_phases),
                            "wait" => Ok(__FieldTag::__wait),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceRolloutRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceRolloutRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_phases => {
                            if !fields.insert(__FieldTag::__source_phases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_phases",
                                ));
                            }
                            result.source_phases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::AutomationRuleCondition>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceRolloutRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.source_phases.is_empty() {
            state.serialize_entry("sourcePhases", &self.source_phases)?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceRolloutRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceRolloutRule");
        debug_struct.field("id", &self.id);
        debug_struct.field("source_phases", &self.source_phases);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("condition", &self.condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The `RepairRolloutRule` automation rule will automatically repair a failed
/// `Rollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepairRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    pub id: std::string::String,

    /// Optional. Phases within which jobs are subject to automatic repair actions
    /// on failure. Proceeds only after phase name matched any one in the list, or
    /// for all phases if unspecified. This value must consist of lower-case
    /// letters, numbers, and hyphens, start with a letter and end with a letter or
    /// a number, and have a max length of 63 characters. In other words, it must
    /// match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    pub phases: std::vec::Vec<std::string::String>,

    /// Optional. Jobs to repair. Proceeds only after job name matched any one in
    /// the list, or for all jobs if unspecified or empty. The phase that includes
    /// the job must match the phase ID specified in `source_phase`. This value
    /// must consist of lower-case letters, numbers, and hyphens, start with a
    /// letter and end with a letter or a number, and have a max length of 63
    /// characters. In other words, it must match the following regex:
    /// `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    pub jobs: std::vec::Vec<std::string::String>,

    /// Output only. Information around the state of the 'Automation' rule.
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Required. Defines the types of automatic repair phases for failed jobs.
    pub repair_phases: std::vec::Vec<crate::model::RepairPhaseConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairRolloutRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RepairRolloutRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [phases][crate::model::RepairRolloutRule::phases].
    pub fn set_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jobs][crate::model::RepairRolloutRule::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::RepairRolloutRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::RepairRolloutRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repair_phases][crate::model::RepairRolloutRule::repair_phases].
    pub fn set_repair_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepairPhaseConfig>,
    {
        use std::iter::Iterator;
        self.repair_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RepairRolloutRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairRolloutRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepairRolloutRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __phases,
            __jobs,
            __condition,
            __repair_phases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepairRolloutRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "phases" => Ok(__FieldTag::__phases),
                            "jobs" => Ok(__FieldTag::__jobs),
                            "condition" => Ok(__FieldTag::__condition),
                            "repairPhases" => Ok(__FieldTag::__repair_phases),
                            "repair_phases" => Ok(__FieldTag::__repair_phases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepairRolloutRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepairRolloutRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phases => {
                            if !fields.insert(__FieldTag::__phases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phases",
                                ));
                            }
                            result.phases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map.next_value::<std::option::Option<crate::model::AutomationRuleCondition>>()?
                                ;
                        }
                        __FieldTag::__repair_phases => {
                            if !fields.insert(__FieldTag::__repair_phases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repair_phases",
                                ));
                            }
                            result.repair_phases =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RepairPhaseConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepairRolloutRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.phases.is_empty() {
            state.serialize_entry("phases", &self.phases)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.repair_phases.is_empty() {
            state.serialize_entry("repairPhases", &self.repair_phases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepairRolloutRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepairRolloutRule");
        debug_struct.field("id", &self.id);
        debug_struct.field("phases", &self.phases);
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("condition", &self.condition);
        debug_struct.field("repair_phases", &self.repair_phases);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of the repair phase.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepairPhaseConfig {
    /// The repair phase to perform.
    pub repair_phase: std::option::Option<crate::model::repair_phase_config::RepairPhase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairPhaseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase].
    ///
    /// Note that all the setters affecting `repair_phase` are mutually
    /// exclusive.
    pub fn set_repair_phase<
        T: std::convert::Into<std::option::Option<crate::model::repair_phase_config::RepairPhase>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = v.into();
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// if it holds a `Retry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retry(&self) -> std::option::Option<&std::boxed::Box<crate::model::Retry>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase_config::RepairPhase::Retry(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// to hold a `Retry`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_retry<T: std::convert::Into<std::boxed::Box<crate::model::Retry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = std::option::Option::Some(
            crate::model::repair_phase_config::RepairPhase::Retry(v.into()),
        );
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// if it holds a `Rollback`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollback(&self) -> std::option::Option<&std::boxed::Box<crate::model::Rollback>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase_config::RepairPhase::Rollback(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// to hold a `Rollback`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_rollback<T: std::convert::Into<std::boxed::Box<crate::model::Rollback>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = std::option::Option::Some(
            crate::model::repair_phase_config::RepairPhase::Rollback(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RepairPhaseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairPhaseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepairPhaseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retry,
            __rollback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepairPhaseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retry" => Ok(__FieldTag::__retry),
                            "rollback" => Ok(__FieldTag::__rollback),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepairPhaseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepairPhaseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retry => {
                            if !fields.insert(__FieldTag::__retry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry",
                                ));
                            }
                            if result.repair_phase.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repair_phase`, a oneof with full ID .google.cloud.deploy.v1.RepairPhaseConfig.retry, latest field was retry",
                                ));
                            }
                            result.repair_phase =
                                std::option::Option::Some(
                                    crate::model::repair_phase_config::RepairPhase::Retry(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Retry>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__rollback => {
                            if !fields.insert(__FieldTag::__rollback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollback",
                                ));
                            }
                            if result.repair_phase.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repair_phase`, a oneof with full ID .google.cloud.deploy.v1.RepairPhaseConfig.rollback, latest field was rollback",
                                ));
                            }
                            result.repair_phase = std::option::Option::Some(
                                crate::model::repair_phase_config::RepairPhase::Rollback(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Rollback>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepairPhaseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.retry() {
            state.serialize_entry("retry", value)?;
        }
        if let Some(value) = self.rollback() {
            state.serialize_entry("rollback", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepairPhaseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepairPhaseConfig");
        debug_struct.field("repair_phase", &self.repair_phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RepairPhaseConfig].
pub mod repair_phase_config {
    #[allow(unused_imports)]
    use super::*;

    /// The repair phase to perform.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepairPhase {
        /// Optional. Retries a failed job.
        Retry(std::boxed::Box<crate::model::Retry>),
        /// Optional. Rolls back a `Rollout`.
        Rollback(std::boxed::Box<crate::model::Rollback>),
    }
}

/// Retries the failed job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Retry {
    /// Required. Total number of retries. Retry is skipped if set to 0; The
    /// minimum value is 1, and the maximum value is 10.
    pub attempts: i64,

    /// Optional. How long to wait for the first retry. Default is 0, and the
    /// maximum value is 14d.
    pub wait: std::option::Option<wkt::Duration>,

    /// Optional. The pattern of how wait time will be increased. Default is
    /// linear. Backoff mode will be ignored if `wait` is 0.
    pub backoff_mode: crate::model::BackoffMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Retry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attempts][crate::model::Retry::attempts].
    pub fn set_attempts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempts = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::Retry::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::Retry::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backoff_mode][crate::model::Retry::backoff_mode].
    pub fn set_backoff_mode<T: std::convert::Into<crate::model::BackoffMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.backoff_mode = v.into();
        self
    }
}

impl wkt::message::Message for Retry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Retry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Retry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attempts,
            __wait,
            __backoff_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Retry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attempts" => Ok(__FieldTag::__attempts),
                            "wait" => Ok(__FieldTag::__wait),
                            "backoffMode" => Ok(__FieldTag::__backoff_mode),
                            "backoff_mode" => Ok(__FieldTag::__backoff_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Retry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Retry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attempts => {
                            if !fields.insert(__FieldTag::__attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempts",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attempts = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__backoff_mode => {
                            if !fields.insert(__FieldTag::__backoff_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backoff_mode",
                                ));
                            }
                            result.backoff_mode = map
                                .next_value::<std::option::Option<crate::model::BackoffMode>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Retry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.attempts) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attempts", &__With(&self.attempts))?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if !wkt::internal::is_default(&self.backoff_mode) {
            state.serialize_entry("backoffMode", &self.backoff_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Retry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Retry");
        debug_struct.field("attempts", &self.attempts);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("backoff_mode", &self.backoff_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Rolls back a `Rollout`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rollback {
    /// Optional. The starting phase ID for the `Rollout`. If unspecified, the
    /// `Rollout` will start in the stable phase.
    pub destination_phase: std::string::String,

    /// Optional. If pending rollout exists on the target, the rollback operation
    /// will be aborted.
    pub disable_rollback_if_rollout_pending: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_phase][crate::model::Rollback::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }

    /// Sets the value of [disable_rollback_if_rollout_pending][crate::model::Rollback::disable_rollback_if_rollout_pending].
    pub fn set_disable_rollback_if_rollout_pending<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_rollback_if_rollout_pending = v.into();
        self
    }
}

impl wkt::message::Message for Rollback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Rollback"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rollback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_phase,
            __disable_rollback_if_rollout_pending,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rollback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationPhase" => Ok(__FieldTag::__destination_phase),
                            "destination_phase" => Ok(__FieldTag::__destination_phase),
                            "disableRollbackIfRolloutPending" => {
                                Ok(__FieldTag::__disable_rollback_if_rollout_pending)
                            }
                            "disable_rollback_if_rollout_pending" => {
                                Ok(__FieldTag::__disable_rollback_if_rollout_pending)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rollback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rollback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_phase => {
                            if !fields.insert(__FieldTag::__destination_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_phase",
                                ));
                            }
                            result.destination_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_rollback_if_rollout_pending => {
                            if !fields.insert(__FieldTag::__disable_rollback_if_rollout_pending) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_rollback_if_rollout_pending",
                                ));
                            }
                            result.disable_rollback_if_rollout_pending = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rollback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_phase.is_empty() {
            state.serialize_entry("destinationPhase", &self.destination_phase)?;
        }
        if !wkt::internal::is_default(&self.disable_rollback_if_rollout_pending) {
            state.serialize_entry(
                "disableRollbackIfRolloutPending",
                &self.disable_rollback_if_rollout_pending,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rollback {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rollback");
        debug_struct.field("destination_phase", &self.destination_phase);
        debug_struct.field(
            "disable_rollback_if_rollout_pending",
            &self.disable_rollback_if_rollout_pending,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// `AutomationRuleCondition` contains conditions relevant to an
/// `Automation` rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationRuleCondition {
    /// Optional. Details around targets enumerated in the rule.
    pub targets_present_condition: std::option::Option<crate::model::TargetsPresentCondition>,

    /// Details specific to the automation rule type.
    pub rule_type_condition:
        std::option::Option<crate::model::automation_rule_condition::RuleTypeCondition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRuleCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets_present_condition][crate::model::AutomationRuleCondition::targets_present_condition].
    pub fn set_targets_present_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_present_condition][crate::model::AutomationRuleCondition::targets_present_condition].
    pub fn set_or_clear_targets_present_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition].
    ///
    /// Note that all the setters affecting `rule_type_condition` are mutually
    /// exclusive.
    pub fn set_rule_type_condition<
        T: std::convert::Into<
                std::option::Option<crate::model::automation_rule_condition::RuleTypeCondition>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type_condition = v.into();
        self
    }

    /// The value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition]
    /// if it holds a `TimedPromoteReleaseCondition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_condition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseCondition>> {
        #[allow(unreachable_patterns)]
        self.rule_type_condition.as_ref().and_then(|v| match v {
            crate::model::automation_rule_condition::RuleTypeCondition::TimedPromoteReleaseCondition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition]
    /// to hold a `TimedPromoteReleaseCondition`.
    ///
    /// Note that all the setters affecting `rule_type_condition` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_condition<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type_condition = std::option::Option::Some(
            crate::model::automation_rule_condition::RuleTypeCondition::TimedPromoteReleaseCondition(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for AutomationRuleCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRuleCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationRuleCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __targets_present_condition,
            __timed_promote_release_condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationRuleCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetsPresentCondition" => {
                                Ok(__FieldTag::__targets_present_condition)
                            }
                            "targets_present_condition" => {
                                Ok(__FieldTag::__targets_present_condition)
                            }
                            "timedPromoteReleaseCondition" => {
                                Ok(__FieldTag::__timed_promote_release_condition)
                            }
                            "timed_promote_release_condition" => {
                                Ok(__FieldTag::__timed_promote_release_condition)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationRuleCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationRuleCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__targets_present_condition => {
                            if !fields.insert(__FieldTag::__targets_present_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets_present_condition",
                                ));
                            }
                            result.targets_present_condition = map.next_value::<std::option::Option<crate::model::TargetsPresentCondition>>()?
                                ;
                        }
                        __FieldTag::__timed_promote_release_condition => {
                            if !fields.insert(__FieldTag::__timed_promote_release_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timed_promote_release_condition",
                                ));
                            }
                            if result.rule_type_condition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule_type_condition`, a oneof with full ID .google.cloud.deploy.v1.AutomationRuleCondition.timed_promote_release_condition, latest field was timedPromoteReleaseCondition",
                                ));
                            }
                            result.rule_type_condition = std::option::Option::Some(
                                crate::model::automation_rule_condition::RuleTypeCondition::TimedPromoteReleaseCondition(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TimedPromoteReleaseCondition>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationRuleCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.targets_present_condition.is_some() {
            state.serialize_entry("targetsPresentCondition", &self.targets_present_condition)?;
        }
        if let Some(value) = self.timed_promote_release_condition() {
            state.serialize_entry("timedPromoteReleaseCondition", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationRuleCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationRuleCondition");
        debug_struct.field("targets_present_condition", &self.targets_present_condition);
        debug_struct.field("rule_type_condition", &self.rule_type_condition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutomationRuleCondition].
pub mod automation_rule_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Details specific to the automation rule type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuleTypeCondition {
        /// Optional. TimedPromoteReleaseCondition contains rule conditions specific
        /// to a an Automation with a timed promote release rule defined.
        TimedPromoteReleaseCondition(std::boxed::Box<crate::model::TimedPromoteReleaseCondition>),
    }
}

/// `TimedPromoteReleaseCondition` contains conditions specific to an Automation
/// with a Timed Promote Release rule defined.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimedPromoteReleaseCondition {
    /// Output only. When the next scheduled promotion(s) will occur.
    pub next_promotion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of targets involved in the upcoming timed promotion(s).
    pub targets_list: std::vec::Vec<crate::model::timed_promote_release_condition::Targets>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_promotion_time][crate::model::TimedPromoteReleaseCondition::next_promotion_time].
    pub fn set_next_promotion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_promotion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_promotion_time][crate::model::TimedPromoteReleaseCondition::next_promotion_time].
    pub fn set_or_clear_next_promotion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_promotion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_list][crate::model::TimedPromoteReleaseCondition::targets_list].
    pub fn set_targets_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::timed_promote_release_condition::Targets>,
    {
        use std::iter::Iterator;
        self.targets_list = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimedPromoteReleaseCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __next_promotion_time,
            __targets_list,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimedPromoteReleaseCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nextPromotionTime" => Ok(__FieldTag::__next_promotion_time),
                            "next_promotion_time" => Ok(__FieldTag::__next_promotion_time),
                            "targetsList" => Ok(__FieldTag::__targets_list),
                            "targets_list" => Ok(__FieldTag::__targets_list),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimedPromoteReleaseCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimedPromoteReleaseCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__next_promotion_time => {
                            if !fields.insert(__FieldTag::__next_promotion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_promotion_time",
                                ));
                            }
                            result.next_promotion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__targets_list => {
                            if !fields.insert(__FieldTag::__targets_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets_list",
                                ));
                            }
                            result.targets_list = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::timed_promote_release_condition::Targets,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimedPromoteReleaseCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.next_promotion_time.is_some() {
            state.serialize_entry("nextPromotionTime", &self.next_promotion_time)?;
        }
        if !self.targets_list.is_empty() {
            state.serialize_entry("targetsList", &self.targets_list)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimedPromoteReleaseCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimedPromoteReleaseCondition");
        debug_struct.field("next_promotion_time", &self.next_promotion_time);
        debug_struct.field("targets_list", &self.targets_list);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimedPromoteReleaseCondition].
pub mod timed_promote_release_condition {
    #[allow(unused_imports)]
    use super::*;

    /// The targets involved in a single timed promotion.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Targets {
        /// Optional. The source target ID.
        pub source_target_id: std::string::String,

        /// Optional. The destination target ID.
        pub destination_target_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Targets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_target_id][crate::model::timed_promote_release_condition::Targets::source_target_id].
        pub fn set_source_target_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_target_id = v.into();
            self
        }

        /// Sets the value of [destination_target_id][crate::model::timed_promote_release_condition::Targets::destination_target_id].
        pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.destination_target_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Targets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseCondition.Targets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Targets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_target_id,
                __destination_target_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Targets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceTargetId" => Ok(__FieldTag::__source_target_id),
                                "source_target_id" => Ok(__FieldTag::__source_target_id),
                                "destinationTargetId" => Ok(__FieldTag::__destination_target_id),
                                "destination_target_id" => Ok(__FieldTag::__destination_target_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Targets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Targets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_target_id => {
                                if !fields.insert(__FieldTag::__source_target_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_target_id",
                                    ));
                                }
                                result.source_target_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__destination_target_id => {
                                if !fields.insert(__FieldTag::__destination_target_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for destination_target_id",
                                    ));
                                }
                                result.destination_target_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Targets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_target_id.is_empty() {
                state.serialize_entry("sourceTargetId", &self.source_target_id)?;
            }
            if !self.destination_target_id.is_empty() {
                state.serialize_entry("destinationTargetId", &self.destination_target_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Targets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Targets");
            debug_struct.field("source_target_id", &self.source_target_id);
            debug_struct.field("destination_target_id", &self.destination_target_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The request object for `CreateAutomation`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAutomationRequest {
    /// Required. The parent collection in which the `Automation` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub parent: std::string::String,

    /// Required. ID of the `Automation`.
    pub automation_id: std::string::String,

    /// Required. The `Automation` to create.
    pub automation: std::option::Option<crate::model::Automation>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutomationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::CreateAutomationRequest::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [automation][crate::model::CreateAutomationRequest::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::CreateAutomationRequest::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateAutomationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAutomationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __automation_id,
            __automation,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAutomationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "automationId" => Ok(__FieldTag::__automation_id),
                            "automation_id" => Ok(__FieldTag::__automation_id),
                            "automation" => Ok(__FieldTag::__automation),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAutomationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAutomationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation_id => {
                            if !fields.insert(__FieldTag::__automation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_id",
                                ));
                            }
                            result.automation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation => {
                            if !fields.insert(__FieldTag::__automation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation",
                                ));
                            }
                            result.automation =
                                map.next_value::<std::option::Option<crate::model::Automation>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAutomationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.automation_id.is_empty() {
            state.serialize_entry("automationId", &self.automation_id)?;
        }
        if self.automation.is_some() {
            state.serialize_entry("automation", &self.automation)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateAutomationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAutomationRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("automation_id", &self.automation_id);
        debug_struct.field("automation", &self.automation);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `UpdateAutomation`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAutomationRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `Automation` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `Automation` to update.
    pub automation: std::option::Option<crate::model::Automation>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `Automation` that does not exist will
    /// result in the creation of a new `Automation`.
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAutomationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAutomationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automation][crate::model::UpdateAutomationRequest::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::UpdateAutomationRequest::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateAutomationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateAutomationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAutomationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __automation,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAutomationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "automation" => Ok(__FieldTag::__automation),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAutomationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAutomationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__automation => {
                            if !fields.insert(__FieldTag::__automation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation",
                                ));
                            }
                            result.automation =
                                map.next_value::<std::option::Option<crate::model::Automation>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAutomationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.automation.is_some() {
            state.serialize_entry("automation", &self.automation)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAutomationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAutomationRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("automation", &self.automation);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `DeleteAutomation`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAutomationRequest {
    /// Required. The name of the `Automation` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `Automation` will succeed.
    pub allow_missing: bool,

    /// Optional. If set, validate the request and verify whether the resource
    /// exists, but do not actually post it.
    pub validate_only: bool,

    /// Optional. The weak etag of the request.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutomationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAutomationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAutomationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteAutomationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAutomationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __allow_missing,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAutomationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAutomationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAutomationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAutomationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteAutomationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAutomationRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListAutomations`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutomationsRequest {
    /// Required. The parent `Delivery Pipeline`, which owns this collection of
    /// automations. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    pub parent: std::string::String,

    /// The maximum number of automations to return. The service may return
    /// fewer than this value. If unspecified, at most 50 automations will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListAutomations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter automations to be returned. All fields can be used in the
    /// filter.
    pub filter: std::string::String,

    /// Field to sort by.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutomationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutomationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutomationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutomationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutomationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutomationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutomationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutomationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutomationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutomationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutomationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutomationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutomationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListAutomations`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutomationsResponse {
    /// The `Automation` objects.
    pub automations: std::vec::Vec<crate::model::Automation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automations][crate::model::ListAutomationsResponse::automations].
    pub fn set_automations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Automation>,
    {
        use std::iter::Iterator;
        self.automations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutomationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAutomationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutomationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutomationsResponse {
    type PageItem = crate::model::Automation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.automations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutomationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __automations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutomationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "automations" => Ok(__FieldTag::__automations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutomationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutomationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__automations => {
                            if !fields.insert(__FieldTag::__automations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automations",
                                ));
                            }
                            result.automations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Automation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutomationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.automations.is_empty() {
            state.serialize_entry("automations", &self.automations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutomationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutomationsResponse");
        debug_struct.field("automations", &self.automations);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetAutomation`
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutomationRequest {
    /// Required. Name of the `Automation`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutomationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetAutomationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAutomationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutomationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAutomationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutomationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAutomationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAutomationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAutomationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An `AutomationRun` resource in the Cloud Deploy API.
///
/// An `AutomationRun` represents an execution instance of an
/// automation rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomationRun {
    /// Output only. Name of the `AutomationRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    pub name: std::string::String,

    /// Output only. Time at which the `AutomationRun` was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the automationRun was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The weak etag of the `AutomationRun` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. Email address of the user-managed IAM service account that
    /// performs the operations against Cloud Deploy resources.
    pub service_account: std::string::String,

    /// Output only. Snapshot of the Automation taken at AutomationRun creation
    /// time.
    pub automation_snapshot: std::option::Option<crate::model::Automation>,

    /// Output only. The ID of the source target that initiates the
    /// `AutomationRun`. The value of this field is the last segment of a target
    /// name.
    pub target_id: std::string::String,

    /// Output only. Current state of the `AutomationRun`.
    pub state: crate::model::automation_run::State,

    /// Output only. Explains the current state of the `AutomationRun`. Present
    /// only when an explanation is needed.
    pub state_description: std::string::String,

    /// Output only. Contains information about what policies prevented the
    /// `AutomationRun` from proceeding.
    pub policy_violation: std::option::Option<crate::model::PolicyViolation>,

    /// Output only. Time the `AutomationRun` expires. An `AutomationRun` expires
    /// after 14 days from its creation date.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The ID of the automation rule that initiated the operation.
    pub rule_id: std::string::String,

    /// Output only. The ID of the automation that initiated the operation.
    pub automation_id: std::string::String,

    /// Output only. Earliest time the `AutomationRun` will attempt to resume.
    /// Wait-time is configured by `wait` in automation rule.
    pub wait_until_time: std::option::Option<wkt::Timestamp>,

    /// The operation that the `AutomationRun` will perform.
    pub operation: std::option::Option<crate::model::automation_run::Operation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutomationRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AutomationRun::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AutomationRun::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AutomationRun::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AutomationRun::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AutomationRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::AutomationRun::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [automation_snapshot][crate::model::AutomationRun::automation_snapshot].
    pub fn set_automation_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation_snapshot][crate::model::AutomationRun::automation_snapshot].
    pub fn set_or_clear_automation_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::AutomationRun::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutomationRun::state].
    pub fn set_state<T: std::convert::Into<crate::model::automation_run::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::AutomationRun::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [policy_violation][crate::model::AutomationRun::policy_violation].
    pub fn set_policy_violation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicyViolation>,
    {
        self.policy_violation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_violation][crate::model::AutomationRun::policy_violation].
    pub fn set_or_clear_policy_violation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicyViolation>,
    {
        self.policy_violation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::AutomationRun::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::AutomationRun::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_id][crate::model::AutomationRun::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::AutomationRun::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [wait_until_time][crate::model::AutomationRun::wait_until_time].
    pub fn set_wait_until_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.wait_until_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait_until_time][crate::model::AutomationRun::wait_until_time].
    pub fn set_or_clear_wait_until_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.wait_until_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation].
    ///
    /// Note that all the setters affecting `operation` are mutually
    /// exclusive.
    pub fn set_operation<
        T: std::convert::Into<std::option::Option<crate::model::automation_run::Operation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `PromoteReleaseOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn promote_release_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PromoteReleaseOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::PromoteReleaseOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `PromoteReleaseOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_promote_release_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::PromoteReleaseOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::PromoteReleaseOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `AdvanceRolloutOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_rollout_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceRolloutOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::AdvanceRolloutOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `AdvanceRolloutOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_advance_rollout_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceRolloutOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::AdvanceRolloutOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `RepairRolloutOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repair_rollout_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RepairRolloutOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::RepairRolloutOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `RepairRolloutOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_repair_rollout_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::RepairRolloutOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::RepairRolloutOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `TimedPromoteReleaseOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::TimedPromoteReleaseOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `TimedPromoteReleaseOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::TimedPromoteReleaseOperation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomationRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomationRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __etag,
            __service_account,
            __automation_snapshot,
            __target_id,
            __state,
            __state_description,
            __policy_violation,
            __expire_time,
            __rule_id,
            __automation_id,
            __promote_release_operation,
            __advance_rollout_operation,
            __repair_rollout_operation,
            __timed_promote_release_operation,
            __wait_until_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomationRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "automationSnapshot" => Ok(__FieldTag::__automation_snapshot),
                            "automation_snapshot" => Ok(__FieldTag::__automation_snapshot),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "state" => Ok(__FieldTag::__state),
                            "stateDescription" => Ok(__FieldTag::__state_description),
                            "state_description" => Ok(__FieldTag::__state_description),
                            "policyViolation" => Ok(__FieldTag::__policy_violation),
                            "policy_violation" => Ok(__FieldTag::__policy_violation),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "automationId" => Ok(__FieldTag::__automation_id),
                            "automation_id" => Ok(__FieldTag::__automation_id),
                            "promoteReleaseOperation" => {
                                Ok(__FieldTag::__promote_release_operation)
                            }
                            "promote_release_operation" => {
                                Ok(__FieldTag::__promote_release_operation)
                            }
                            "advanceRolloutOperation" => {
                                Ok(__FieldTag::__advance_rollout_operation)
                            }
                            "advance_rollout_operation" => {
                                Ok(__FieldTag::__advance_rollout_operation)
                            }
                            "repairRolloutOperation" => Ok(__FieldTag::__repair_rollout_operation),
                            "repair_rollout_operation" => {
                                Ok(__FieldTag::__repair_rollout_operation)
                            }
                            "timedPromoteReleaseOperation" => {
                                Ok(__FieldTag::__timed_promote_release_operation)
                            }
                            "timed_promote_release_operation" => {
                                Ok(__FieldTag::__timed_promote_release_operation)
                            }
                            "waitUntilTime" => Ok(__FieldTag::__wait_until_time),
                            "wait_until_time" => Ok(__FieldTag::__wait_until_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomationRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomationRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation_snapshot => {
                            if !fields.insert(__FieldTag::__automation_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_snapshot",
                                ));
                            }
                            result.automation_snapshot =
                                map.next_value::<std::option::Option<crate::model::Automation>>()?;
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::automation_run::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_description => {
                            if !fields.insert(__FieldTag::__state_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_description",
                                ));
                            }
                            result.state_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_violation => {
                            if !fields.insert(__FieldTag::__policy_violation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_violation",
                                ));
                            }
                            result.policy_violation = map
                                .next_value::<std::option::Option<crate::model::PolicyViolation>>(
                                )?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automation_id => {
                            if !fields.insert(__FieldTag::__automation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_id",
                                ));
                            }
                            result.automation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__promote_release_operation => {
                            if !fields.insert(__FieldTag::__promote_release_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promote_release_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.deploy.v1.AutomationRun.promote_release_operation, latest field was promoteReleaseOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::automation_run::Operation::PromoteReleaseOperation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PromoteReleaseOperation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__advance_rollout_operation => {
                            if !fields.insert(__FieldTag::__advance_rollout_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advance_rollout_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.deploy.v1.AutomationRun.advance_rollout_operation, latest field was advanceRolloutOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::automation_run::Operation::AdvanceRolloutOperation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdvanceRolloutOperation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__repair_rollout_operation => {
                            if !fields.insert(__FieldTag::__repair_rollout_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repair_rollout_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.deploy.v1.AutomationRun.repair_rollout_operation, latest field was repairRolloutOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::automation_run::Operation::RepairRolloutOperation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RepairRolloutOperation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timed_promote_release_operation => {
                            if !fields.insert(__FieldTag::__timed_promote_release_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timed_promote_release_operation",
                                ));
                            }
                            if result.operation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation`, a oneof with full ID .google.cloud.deploy.v1.AutomationRun.timed_promote_release_operation, latest field was timedPromoteReleaseOperation",
                                ));
                            }
                            result.operation = std::option::Option::Some(
                                crate::model::automation_run::Operation::TimedPromoteReleaseOperation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TimedPromoteReleaseOperation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__wait_until_time => {
                            if !fields.insert(__FieldTag::__wait_until_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_until_time",
                                ));
                            }
                            result.wait_until_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomationRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.automation_snapshot.is_some() {
            state.serialize_entry("automationSnapshot", &self.automation_snapshot)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_description.is_empty() {
            state.serialize_entry("stateDescription", &self.state_description)?;
        }
        if self.policy_violation.is_some() {
            state.serialize_entry("policyViolation", &self.policy_violation)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !self.automation_id.is_empty() {
            state.serialize_entry("automationId", &self.automation_id)?;
        }
        if let Some(value) = self.promote_release_operation() {
            state.serialize_entry("promoteReleaseOperation", value)?;
        }
        if let Some(value) = self.advance_rollout_operation() {
            state.serialize_entry("advanceRolloutOperation", value)?;
        }
        if let Some(value) = self.repair_rollout_operation() {
            state.serialize_entry("repairRolloutOperation", value)?;
        }
        if let Some(value) = self.timed_promote_release_operation() {
            state.serialize_entry("timedPromoteReleaseOperation", value)?;
        }
        if self.wait_until_time.is_some() {
            state.serialize_entry("waitUntilTime", &self.wait_until_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomationRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomationRun");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("automation_snapshot", &self.automation_snapshot);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_description", &self.state_description);
        debug_struct.field("policy_violation", &self.policy_violation);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("automation_id", &self.automation_id);
        debug_struct.field("wait_until_time", &self.wait_until_time);
        debug_struct.field("operation", &self.operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutomationRun].
pub mod automation_run {
    #[allow(unused_imports)]
    use super::*;

    /// Valid state of an `AutomationRun`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `AutomationRun` has an unspecified state.
        Unspecified,
        /// The `AutomationRun` has succeeded.
        Succeeded,
        /// The `AutomationRun` was cancelled.
        Cancelled,
        /// The `AutomationRun` has failed.
        Failed,
        /// The `AutomationRun` is in progress.
        InProgress,
        /// The `AutomationRun` is pending.
        Pending,
        /// The `AutomationRun` was aborted.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Cancelled => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::InProgress => std::option::Option::Some(4),
                Self::Pending => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Cancelled,
                3 => Self::Failed,
                4 => Self::InProgress,
                5 => Self::Pending,
                6 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                "PENDING" => Self::Pending,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Cancelled => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::InProgress => serializer.serialize_i32(4),
                Self::Pending => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.AutomationRun.State",
            ))
        }
    }

    /// The operation that the `AutomationRun` will perform.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// Output only. Promotes a release to a specified 'Target'.
        PromoteReleaseOperation(std::boxed::Box<crate::model::PromoteReleaseOperation>),
        /// Output only. Advances a rollout to the next phase.
        AdvanceRolloutOperation(std::boxed::Box<crate::model::AdvanceRolloutOperation>),
        /// Output only. Repairs a failed 'Rollout'.
        RepairRolloutOperation(std::boxed::Box<crate::model::RepairRolloutOperation>),
        /// Output only. Promotes a release to a specified 'Target' as defined in a
        /// Timed Promote Release rule.
        TimedPromoteReleaseOperation(std::boxed::Box<crate::model::TimedPromoteReleaseOperation>),
    }
}

/// Contains the information of an automated promote-release operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PromoteReleaseOperation {
    /// Output only. The ID of the target that represents the promotion stage to
    /// which the release will be promoted. The value of this field is the last
    /// segment of a target name.
    pub target_id: std::string::String,

    /// Output only. How long the operation will be paused.
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    pub rollout: std::string::String,

    /// Output only. The starting phase of the rollout created by this operation.
    pub phase: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteReleaseOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::PromoteReleaseOperation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::PromoteReleaseOperation::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::PromoteReleaseOperation::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::PromoteReleaseOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::PromoteReleaseOperation::phase].
    pub fn set_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase = v.into();
        self
    }
}

impl wkt::message::Message for PromoteReleaseOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PromoteReleaseOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PromoteReleaseOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_id,
            __wait,
            __rollout,
            __phase,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PromoteReleaseOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "wait" => Ok(__FieldTag::__wait),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "phase" => Ok(__FieldTag::__phase),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PromoteReleaseOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PromoteReleaseOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase => {
                            if !fields.insert(__FieldTag::__phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase",
                                ));
                            }
                            result.phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PromoteReleaseOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.phase.is_empty() {
            state.serialize_entry("phase", &self.phase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PromoteReleaseOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PromoteReleaseOperation");
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("phase", &self.phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains the information of an automated advance-rollout operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvanceRolloutOperation {
    /// Output only. The phase of a deployment that initiated the operation.
    pub source_phase: std::string::String,

    /// Output only. How long the operation will be paused.
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    pub rollout: std::string::String,

    /// Output only. The phase the rollout will be advanced to.
    pub destination_phase: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_phase][crate::model::AdvanceRolloutOperation::source_phase].
    pub fn set_source_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_phase = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::AdvanceRolloutOperation::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::AdvanceRolloutOperation::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::AdvanceRolloutOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [destination_phase][crate::model::AdvanceRolloutOperation::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for AdvanceRolloutOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvanceRolloutOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_phase,
            __wait,
            __rollout,
            __destination_phase,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvanceRolloutOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourcePhase" => Ok(__FieldTag::__source_phase),
                            "source_phase" => Ok(__FieldTag::__source_phase),
                            "wait" => Ok(__FieldTag::__wait),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "destinationPhase" => Ok(__FieldTag::__destination_phase),
                            "destination_phase" => Ok(__FieldTag::__destination_phase),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvanceRolloutOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvanceRolloutOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_phase => {
                            if !fields.insert(__FieldTag::__source_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_phase",
                                ));
                            }
                            result.source_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_phase => {
                            if !fields.insert(__FieldTag::__destination_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_phase",
                                ));
                            }
                            result.destination_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvanceRolloutOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_phase.is_empty() {
            state.serialize_entry("sourcePhase", &self.source_phase)?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.destination_phase.is_empty() {
            state.serialize_entry("destinationPhase", &self.destination_phase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvanceRolloutOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvanceRolloutOperation");
        debug_struct.field("source_phase", &self.source_phase);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("destination_phase", &self.destination_phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains the information for an automated `repair rollout` operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepairRolloutOperation {
    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    pub rollout: std::string::String,

    /// Output only. The index of the current repair action in the repair sequence.
    pub current_repair_phase_index: i64,

    /// Output only. Records of the repair attempts. Each repair phase may have
    /// multiple retry attempts or single rollback attempt.
    pub repair_phases: std::vec::Vec<crate::model::RepairPhase>,

    /// Output only. The phase ID of the phase that includes the job being
    /// repaired.
    pub phase_id: std::string::String,

    /// Output only. The job ID for the Job to repair.
    pub job_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairRolloutOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RepairRolloutOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [current_repair_phase_index][crate::model::RepairRolloutOperation::current_repair_phase_index].
    pub fn set_current_repair_phase_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.current_repair_phase_index = v.into();
        self
    }

    /// Sets the value of [repair_phases][crate::model::RepairRolloutOperation::repair_phases].
    pub fn set_repair_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepairPhase>,
    {
        use std::iter::Iterator;
        self.repair_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [phase_id][crate::model::RepairRolloutOperation::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::RepairRolloutOperation::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for RepairRolloutOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairRolloutOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepairRolloutOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout,
            __current_repair_phase_index,
            __repair_phases,
            __phase_id,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepairRolloutOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollout" => Ok(__FieldTag::__rollout),
                            "currentRepairPhaseIndex" => {
                                Ok(__FieldTag::__current_repair_phase_index)
                            }
                            "current_repair_phase_index" => {
                                Ok(__FieldTag::__current_repair_phase_index)
                            }
                            "repairPhases" => Ok(__FieldTag::__repair_phases),
                            "repair_phases" => Ok(__FieldTag::__repair_phases),
                            "phaseId" => Ok(__FieldTag::__phase_id),
                            "phase_id" => Ok(__FieldTag::__phase_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepairRolloutOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepairRolloutOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_repair_phase_index => {
                            if !fields.insert(__FieldTag::__current_repair_phase_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_repair_phase_index",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.current_repair_phase_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__repair_phases => {
                            if !fields.insert(__FieldTag::__repair_phases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repair_phases",
                                ));
                            }
                            result.repair_phases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RepairPhase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__phase_id => {
                            if !fields.insert(__FieldTag::__phase_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase_id",
                                ));
                            }
                            result.phase_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepairRolloutOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !wkt::internal::is_default(&self.current_repair_phase_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "currentRepairPhaseIndex",
                &__With(&self.current_repair_phase_index),
            )?;
        }
        if !self.repair_phases.is_empty() {
            state.serialize_entry("repairPhases", &self.repair_phases)?;
        }
        if !self.phase_id.is_empty() {
            state.serialize_entry("phaseId", &self.phase_id)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepairRolloutOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepairRolloutOperation");
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field(
            "current_repair_phase_index",
            &self.current_repair_phase_index,
        );
        debug_struct.field("repair_phases", &self.repair_phases);
        debug_struct.field("phase_id", &self.phase_id);
        debug_struct.field("job_id", &self.job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains the information of an automated timed promote-release operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimedPromoteReleaseOperation {
    /// Output only. The ID of the target that represents the promotion stage to
    /// which the release will be promoted. The value of this field is the last
    /// segment of a target name.
    pub target_id: std::string::String,

    /// Output only. The name of the release to be promoted.
    pub release: std::string::String,

    /// Output only. The starting phase of the rollout created by this operation.
    pub phase: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::TimedPromoteReleaseOperation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [release][crate::model::TimedPromoteReleaseOperation::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::TimedPromoteReleaseOperation::phase].
    pub fn set_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase = v.into();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimedPromoteReleaseOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_id,
            __release,
            __phase,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimedPromoteReleaseOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "release" => Ok(__FieldTag::__release),
                            "phase" => Ok(__FieldTag::__phase),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimedPromoteReleaseOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimedPromoteReleaseOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phase => {
                            if !fields.insert(__FieldTag::__phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase",
                                ));
                            }
                            result.phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimedPromoteReleaseOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !self.phase.is_empty() {
            state.serialize_entry("phase", &self.phase)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimedPromoteReleaseOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimedPromoteReleaseOperation");
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("release", &self.release);
        debug_struct.field("phase", &self.phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RepairPhase tracks the repair attempts that have been made for
/// each `RepairPhaseConfig` specified in the `Automation` resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RepairPhase {
    /// The `RepairPhase` type and the information for that type.
    pub repair_phase: std::option::Option<crate::model::repair_phase::RepairPhase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairPhase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase].
    ///
    /// Note that all the setters affecting `repair_phase` are mutually
    /// exclusive.
    pub fn set_repair_phase<
        T: std::convert::Into<std::option::Option<crate::model::repair_phase::RepairPhase>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = v.into();
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// if it holds a `Retry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retry(&self) -> std::option::Option<&std::boxed::Box<crate::model::RetryPhase>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase::RepairPhase::Retry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// to hold a `Retry`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_retry<T: std::convert::Into<std::boxed::Box<crate::model::RetryPhase>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase =
            std::option::Option::Some(crate::model::repair_phase::RepairPhase::Retry(v.into()));
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// if it holds a `Rollback`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollback(&self) -> std::option::Option<&std::boxed::Box<crate::model::RollbackAttempt>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase::RepairPhase::Rollback(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// to hold a `Rollback`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_rollback<T: std::convert::Into<std::boxed::Box<crate::model::RollbackAttempt>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase =
            std::option::Option::Some(crate::model::repair_phase::RepairPhase::Rollback(v.into()));
        self
    }
}

impl wkt::message::Message for RepairPhase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairPhase"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepairPhase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retry,
            __rollback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepairPhase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retry" => Ok(__FieldTag::__retry),
                            "rollback" => Ok(__FieldTag::__rollback),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepairPhase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepairPhase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retry => {
                            if !fields.insert(__FieldTag::__retry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry",
                                ));
                            }
                            if result.repair_phase.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repair_phase`, a oneof with full ID .google.cloud.deploy.v1.RepairPhase.retry, latest field was retry",
                                ));
                            }
                            result.repair_phase = std::option::Option::Some(
                                crate::model::repair_phase::RepairPhase::Retry(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RetryPhase>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__rollback => {
                            if !fields.insert(__FieldTag::__rollback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollback",
                                ));
                            }
                            if result.repair_phase.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `repair_phase`, a oneof with full ID .google.cloud.deploy.v1.RepairPhase.rollback, latest field was rollback",
                                ));
                            }
                            result.repair_phase = std::option::Option::Some(
                                crate::model::repair_phase::RepairPhase::Rollback(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RollbackAttempt>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepairPhase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.retry() {
            state.serialize_entry("retry", value)?;
        }
        if let Some(value) = self.rollback() {
            state.serialize_entry("rollback", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RepairPhase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepairPhase");
        debug_struct.field("repair_phase", &self.repair_phase);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RepairPhase].
pub mod repair_phase {
    #[allow(unused_imports)]
    use super::*;

    /// The `RepairPhase` type and the information for that type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RepairPhase {
        /// Output only. Records of the retry attempts for retry repair mode.
        Retry(std::boxed::Box<crate::model::RetryPhase>),
        /// Output only. Rollback attempt for rollback repair mode .
        Rollback(std::boxed::Box<crate::model::RollbackAttempt>),
    }
}

/// RetryPhase contains the retry attempts and the metadata for initiating a
/// new attempt.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryPhase {
    /// Output only. The number of attempts that have been made.
    pub total_attempts: i64,

    /// Output only. The pattern of how the wait time of the retry attempt is
    /// calculated.
    pub backoff_mode: crate::model::BackoffMode,

    /// Output only. Detail of a retry action.
    pub attempts: std::vec::Vec<crate::model::RetryAttempt>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryPhase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_attempts][crate::model::RetryPhase::total_attempts].
    pub fn set_total_attempts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_attempts = v.into();
        self
    }

    /// Sets the value of [backoff_mode][crate::model::RetryPhase::backoff_mode].
    pub fn set_backoff_mode<T: std::convert::Into<crate::model::BackoffMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.backoff_mode = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::RetryPhase::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RetryAttempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RetryPhase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryPhase"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryPhase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_attempts,
            __backoff_mode,
            __attempts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryPhase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalAttempts" => Ok(__FieldTag::__total_attempts),
                            "total_attempts" => Ok(__FieldTag::__total_attempts),
                            "backoffMode" => Ok(__FieldTag::__backoff_mode),
                            "backoff_mode" => Ok(__FieldTag::__backoff_mode),
                            "attempts" => Ok(__FieldTag::__attempts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryPhase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryPhase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_attempts => {
                            if !fields.insert(__FieldTag::__total_attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_attempts",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_attempts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__backoff_mode => {
                            if !fields.insert(__FieldTag::__backoff_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backoff_mode",
                                ));
                            }
                            result.backoff_mode = map
                                .next_value::<std::option::Option<crate::model::BackoffMode>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attempts => {
                            if !fields.insert(__FieldTag::__attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempts",
                                ));
                            }
                            result.attempts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RetryAttempt>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryPhase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_attempts) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalAttempts", &__With(&self.total_attempts))?;
        }
        if !wkt::internal::is_default(&self.backoff_mode) {
            state.serialize_entry("backoffMode", &self.backoff_mode)?;
        }
        if !self.attempts.is_empty() {
            state.serialize_entry("attempts", &self.attempts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryPhase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryPhase");
        debug_struct.field("total_attempts", &self.total_attempts);
        debug_struct.field("backoff_mode", &self.backoff_mode);
        debug_struct.field("attempts", &self.attempts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RetryAttempt represents an action of retrying the failed Cloud Deploy job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryAttempt {
    /// Output only. The index of this retry attempt.
    pub attempt: i64,

    /// Output only. How long the operation will be paused.
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. Valid state of this retry action.
    pub state: crate::model::RepairState,

    /// Output only. Description of the state of the Retry.
    pub state_desc: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attempt][crate::model::RetryAttempt::attempt].
    pub fn set_attempt<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempt = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::RetryAttempt::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::RetryAttempt::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::RetryAttempt::state].
    pub fn set_state<T: std::convert::Into<crate::model::RepairState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_desc][crate::model::RetryAttempt::state_desc].
    pub fn set_state_desc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_desc = v.into();
        self
    }
}

impl wkt::message::Message for RetryAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryAttempt"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryAttempt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attempt,
            __wait,
            __state,
            __state_desc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryAttempt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attempt" => Ok(__FieldTag::__attempt),
                            "wait" => Ok(__FieldTag::__wait),
                            "state" => Ok(__FieldTag::__state),
                            "stateDesc" => Ok(__FieldTag::__state_desc),
                            "state_desc" => Ok(__FieldTag::__state_desc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryAttempt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryAttempt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attempt => {
                            if !fields.insert(__FieldTag::__attempt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempt",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attempt = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__wait => {
                            if !fields.insert(__FieldTag::__wait) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait",
                                ));
                            }
                            result.wait = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::RepairState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_desc => {
                            if !fields.insert(__FieldTag::__state_desc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_desc",
                                ));
                            }
                            result.state_desc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryAttempt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.attempt) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attempt", &__With(&self.attempt))?;
        }
        if self.wait.is_some() {
            state.serialize_entry("wait", &self.wait)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_desc.is_empty() {
            state.serialize_entry("stateDesc", &self.state_desc)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryAttempt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryAttempt");
        debug_struct.field("attempt", &self.attempt);
        debug_struct.field("wait", &self.wait);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_desc", &self.state_desc);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RollbackAttempt represents an action of rolling back a Cloud Deploy 'Target'.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackAttempt {
    /// Output only. The phase to which the rollout will be rolled back to.
    pub destination_phase: std::string::String,

    /// Output only. ID of the rollback `Rollout` to create.
    pub rollout_id: std::string::String,

    /// Output only. Valid state of this rollback action.
    pub state: crate::model::RepairState,

    /// Output only. Description of the state of the Rollback.
    pub state_desc: std::string::String,

    /// Output only. If active rollout exists on the target, abort this rollback.
    pub disable_rollback_if_rollout_pending: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_phase][crate::model::RollbackAttempt::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::RollbackAttempt::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RollbackAttempt::state].
    pub fn set_state<T: std::convert::Into<crate::model::RepairState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_desc][crate::model::RollbackAttempt::state_desc].
    pub fn set_state_desc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_desc = v.into();
        self
    }

    /// Sets the value of [disable_rollback_if_rollout_pending][crate::model::RollbackAttempt::disable_rollback_if_rollout_pending].
    pub fn set_disable_rollback_if_rollout_pending<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_rollback_if_rollout_pending = v.into();
        self
    }
}

impl wkt::message::Message for RollbackAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackAttempt"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackAttempt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_phase,
            __rollout_id,
            __state,
            __state_desc,
            __disable_rollback_if_rollout_pending,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackAttempt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationPhase" => Ok(__FieldTag::__destination_phase),
                            "destination_phase" => Ok(__FieldTag::__destination_phase),
                            "rolloutId" => Ok(__FieldTag::__rollout_id),
                            "rollout_id" => Ok(__FieldTag::__rollout_id),
                            "state" => Ok(__FieldTag::__state),
                            "stateDesc" => Ok(__FieldTag::__state_desc),
                            "state_desc" => Ok(__FieldTag::__state_desc),
                            "disableRollbackIfRolloutPending" => {
                                Ok(__FieldTag::__disable_rollback_if_rollout_pending)
                            }
                            "disable_rollback_if_rollout_pending" => {
                                Ok(__FieldTag::__disable_rollback_if_rollout_pending)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackAttempt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackAttempt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_phase => {
                            if !fields.insert(__FieldTag::__destination_phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_phase",
                                ));
                            }
                            result.destination_phase = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_id => {
                            if !fields.insert(__FieldTag::__rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_id",
                                ));
                            }
                            result.rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::RepairState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_desc => {
                            if !fields.insert(__FieldTag::__state_desc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_desc",
                                ));
                            }
                            result.state_desc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_rollback_if_rollout_pending => {
                            if !fields.insert(__FieldTag::__disable_rollback_if_rollout_pending) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_rollback_if_rollout_pending",
                                ));
                            }
                            result.disable_rollback_if_rollout_pending = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackAttempt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_phase.is_empty() {
            state.serialize_entry("destinationPhase", &self.destination_phase)?;
        }
        if !self.rollout_id.is_empty() {
            state.serialize_entry("rolloutId", &self.rollout_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_desc.is_empty() {
            state.serialize_entry("stateDesc", &self.state_desc)?;
        }
        if !wkt::internal::is_default(&self.disable_rollback_if_rollout_pending) {
            state.serialize_entry(
                "disableRollbackIfRolloutPending",
                &self.disable_rollback_if_rollout_pending,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackAttempt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackAttempt");
        debug_struct.field("destination_phase", &self.destination_phase);
        debug_struct.field("rollout_id", &self.rollout_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_desc", &self.state_desc);
        debug_struct.field(
            "disable_rollback_if_rollout_pending",
            &self.disable_rollback_if_rollout_pending,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `ListAutomationRuns`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutomationRunsRequest {
    /// Required. The parent `Delivery Pipeline`, which owns this collection of
    /// automationRuns. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}`.
    pub parent: std::string::String,

    /// The maximum number of automationRuns to return. The service may return
    /// fewer than this value. If unspecified, at most 50 automationRuns will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListAutomationRuns` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Filter automationRuns to be returned. All fields can be used in the
    /// filter.
    pub filter: std::string::String,

    /// Field to sort by.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutomationRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutomationRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutomationRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutomationRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutomationRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutomationRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationRunsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutomationRunsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutomationRunsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutomationRunsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutomationRunsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutomationRunsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutomationRunsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutomationRunsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `ListAutomationRuns`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutomationRunsResponse {
    /// The `AutomationRuns` objects.
    pub automation_runs: std::vec::Vec<crate::model::AutomationRun>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automation_runs][crate::model::ListAutomationRunsResponse::automation_runs].
    pub fn set_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutomationRun>,
    {
        use std::iter::Iterator;
        self.automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutomationRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAutomationRunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutomationRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutomationRunsResponse {
    type PageItem = crate::model::AutomationRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.automation_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutomationRunsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __automation_runs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutomationRunsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "automationRuns" => Ok(__FieldTag::__automation_runs),
                            "automation_runs" => Ok(__FieldTag::__automation_runs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutomationRunsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutomationRunsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__automation_runs => {
                            if !fields.insert(__FieldTag::__automation_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automation_runs",
                                ));
                            }
                            result.automation_runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AutomationRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutomationRunsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.automation_runs.is_empty() {
            state.serialize_entry("automationRuns", &self.automation_runs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAutomationRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutomationRunsResponse");
        debug_struct.field("automation_runs", &self.automation_runs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object for `GetAutomationRun`
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutomationRunRequest {
    /// Required. Name of the `AutomationRun`. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutomationRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutomationRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutomationRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetAutomationRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAutomationRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutomationRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAutomationRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutomationRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAutomationRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAutomationRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAutomationRunRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The request object used by `CancelAutomationRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelAutomationRunRequest {
    /// Required. Name of the `AutomationRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelAutomationRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelAutomationRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelAutomationRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelAutomationRunRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelAutomationRunRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelAutomationRunRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelAutomationRunRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelAutomationRunRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelAutomationRunRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelAutomationRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelAutomationRunRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response object from `CancelAutomationRun`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelAutomationRunResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelAutomationRunResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelAutomationRunResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelAutomationRunResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelAutomationRunResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelAutomationRunResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelAutomationRunResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelAutomationRunResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelAutomationRunResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelAutomationRunResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelAutomationRunResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/customtargettype_notification"
/// Platform Log event that describes the failure to send a custom target type
/// status change Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomTargetTypeNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// Unique identifier of the `CustomTargetType`.
    pub custom_target_type_uid: std::string::String,

    /// The name of the `CustomTargetType`.
    pub custom_target_type: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetTypeNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::CustomTargetTypeNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [custom_target_type_uid][crate::model::CustomTargetTypeNotificationEvent::custom_target_type_uid].
    pub fn set_custom_target_type_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_uid = v.into();
        self
    }

    /// Sets the value of [custom_target_type][crate::model::CustomTargetTypeNotificationEvent::custom_target_type].
    pub fn set_custom_target_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CustomTargetTypeNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CustomTargetTypeNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetTypeNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomTargetTypeNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __custom_target_type_uid,
            __custom_target_type,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomTargetTypeNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "customTargetTypeUid" => Ok(__FieldTag::__custom_target_type_uid),
                            "custom_target_type_uid" => Ok(__FieldTag::__custom_target_type_uid),
                            "customTargetType" => Ok(__FieldTag::__custom_target_type),
                            "custom_target_type" => Ok(__FieldTag::__custom_target_type),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomTargetTypeNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomTargetTypeNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type_uid => {
                            if !fields.insert(__FieldTag::__custom_target_type_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type_uid",
                                ));
                            }
                            result.custom_target_type_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_target_type => {
                            if !fields.insert(__FieldTag::__custom_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_target_type",
                                ));
                            }
                            result.custom_target_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomTargetTypeNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.custom_target_type_uid.is_empty() {
            state.serialize_entry("customTargetTypeUid", &self.custom_target_type_uid)?;
        }
        if !self.custom_target_type.is_empty() {
            state.serialize_entry("customTargetType", &self.custom_target_type)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomTargetTypeNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomTargetTypeNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("custom_target_type_uid", &self.custom_target_type_uid);
        debug_struct.field("custom_target_type", &self.custom_target_type);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deliverypipeline_notification"
/// Platform Log event that describes the failure to send delivery pipeline
/// status change Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeliveryPipelineNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// The name of the `Delivery Pipeline`.
    pub delivery_pipeline: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipelineNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeliveryPipelineNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::DeliveryPipelineNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeliveryPipelineNotificationEvent::delivery_pipeline].
    pub fn set_delivery_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DeliveryPipelineNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for DeliveryPipelineNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipelineNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeliveryPipelineNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __pipeline_uid,
            __delivery_pipeline,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeliveryPipelineNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "deliveryPipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "delivery_pipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeliveryPipelineNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeliveryPipelineNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delivery_pipeline => {
                            if !fields.insert(__FieldTag::__delivery_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline",
                                ));
                            }
                            result.delivery_pipeline = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeliveryPipelineNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.delivery_pipeline.is_empty() {
            state.serialize_entry("deliveryPipeline", &self.delivery_pipeline)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeliveryPipelineNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeliveryPipelineNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("delivery_pipeline", &self.delivery_pipeline);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deploypolicy_evaluation"
/// Platform Log event that describes the deploy policy evaluation event.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployPolicyEvaluationEvent {
    /// Debug message for when a deploy policy event occurs.
    pub message: std::string::String,

    /// Rule type (e.g. Restrict Rollouts).
    pub rule_type: std::string::String,

    /// Rule id.
    pub rule: std::string::String,

    /// Unique identifier of the `Delivery Pipeline`.
    pub pipeline_uid: std::string::String,

    /// The name of the `Delivery Pipeline`.
    pub delivery_pipeline: std::string::String,

    /// Unique identifier of the `Target`. This is an optional field, as a `Target`
    /// may not always be applicable to a policy.
    pub target_uid: std::string::String,

    /// The name of the `Target`. This is an optional field, as a `Target` may not
    /// always be applicable to a policy.
    pub target: std::string::String,

    /// What invoked the action (e.g. a user or automation).
    pub invoker: crate::model::deploy_policy::Invoker,

    /// The name of the `DeployPolicy`.
    pub deploy_policy: std::string::String,

    /// Unique identifier of the `DeployPolicy`.
    pub deploy_policy_uid: std::string::String,

    /// Whether the request is allowed. Allowed is set as true if:
    /// (1) the request complies with the policy; or
    /// (2) the request doesn't comply with the policy but the policy was
    /// overridden; or
    /// (3) the request doesn't comply with the policy but the policy was suspended
    pub allowed: bool,

    /// The policy verdict of the request.
    pub verdict: crate::model::deploy_policy_evaluation_event::PolicyVerdict,

    /// Things that could have overridden the policy verdict. Overrides together
    /// with verdict decide whether the request is allowed.
    pub overrides:
        std::vec::Vec<crate::model::deploy_policy_evaluation_event::PolicyVerdictOverride>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyEvaluationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeployPolicyEvaluationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DeployPolicyEvaluationEvent::rule_type].
    pub fn set_rule_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_type = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::DeployPolicyEvaluationEvent::rule].
    pub fn set_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::DeployPolicyEvaluationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeployPolicyEvaluationEvent::delivery_pipeline].
    pub fn set_delivery_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline = v.into();
        self
    }

    /// Sets the value of [target_uid][crate::model::DeployPolicyEvaluationEvent::target_uid].
    pub fn set_target_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_uid = v.into();
        self
    }

    /// Sets the value of [target][crate::model::DeployPolicyEvaluationEvent::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [invoker][crate::model::DeployPolicyEvaluationEvent::invoker].
    pub fn set_invoker<T: std::convert::Into<crate::model::deploy_policy::Invoker>>(
        mut self,
        v: T,
    ) -> Self {
        self.invoker = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::DeployPolicyEvaluationEvent::deploy_policy].
    pub fn set_deploy_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_policy = v.into();
        self
    }

    /// Sets the value of [deploy_policy_uid][crate::model::DeployPolicyEvaluationEvent::deploy_policy_uid].
    pub fn set_deploy_policy_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_uid = v.into();
        self
    }

    /// Sets the value of [allowed][crate::model::DeployPolicyEvaluationEvent::allowed].
    pub fn set_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allowed = v.into();
        self
    }

    /// Sets the value of [verdict][crate::model::DeployPolicyEvaluationEvent::verdict].
    pub fn set_verdict<
        T: std::convert::Into<crate::model::deploy_policy_evaluation_event::PolicyVerdict>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.verdict = v.into();
        self
    }

    /// Sets the value of [overrides][crate::model::DeployPolicyEvaluationEvent::overrides].
    pub fn set_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::deploy_policy_evaluation_event::PolicyVerdictOverride>,
    {
        use std::iter::Iterator;
        self.overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeployPolicyEvaluationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyEvaluationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployPolicyEvaluationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __rule_type,
            __rule,
            __pipeline_uid,
            __delivery_pipeline,
            __target_uid,
            __target,
            __invoker,
            __deploy_policy,
            __deploy_policy_uid,
            __allowed,
            __verdict,
            __overrides,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployPolicyEvaluationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "ruleType" => Ok(__FieldTag::__rule_type),
                            "rule_type" => Ok(__FieldTag::__rule_type),
                            "rule" => Ok(__FieldTag::__rule),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "deliveryPipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "delivery_pipeline" => Ok(__FieldTag::__delivery_pipeline),
                            "targetUid" => Ok(__FieldTag::__target_uid),
                            "target_uid" => Ok(__FieldTag::__target_uid),
                            "target" => Ok(__FieldTag::__target),
                            "invoker" => Ok(__FieldTag::__invoker),
                            "deployPolicy" => Ok(__FieldTag::__deploy_policy),
                            "deploy_policy" => Ok(__FieldTag::__deploy_policy),
                            "deployPolicyUid" => Ok(__FieldTag::__deploy_policy_uid),
                            "deploy_policy_uid" => Ok(__FieldTag::__deploy_policy_uid),
                            "allowed" => Ok(__FieldTag::__allowed),
                            "verdict" => Ok(__FieldTag::__verdict),
                            "overrides" => Ok(__FieldTag::__overrides),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployPolicyEvaluationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployPolicyEvaluationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_type => {
                            if !fields.insert(__FieldTag::__rule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_type",
                                ));
                            }
                            result.rule_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            result.rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delivery_pipeline => {
                            if !fields.insert(__FieldTag::__delivery_pipeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delivery_pipeline",
                                ));
                            }
                            result.delivery_pipeline = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_uid => {
                            if !fields.insert(__FieldTag::__target_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_uid",
                                ));
                            }
                            result.target_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invoker => {
                            if !fields.insert(__FieldTag::__invoker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invoker",
                                ));
                            }
                            result.invoker = map.next_value::<std::option::Option<crate::model::deploy_policy::Invoker>>()?.unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy => {
                            if !fields.insert(__FieldTag::__deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy",
                                ));
                            }
                            result.deploy_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy_uid => {
                            if !fields.insert(__FieldTag::__deploy_policy_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy_uid",
                                ));
                            }
                            result.deploy_policy_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowed => {
                            if !fields.insert(__FieldTag::__allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed",
                                ));
                            }
                            result.allowed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verdict => {
                            if !fields.insert(__FieldTag::__verdict) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verdict",
                                ));
                            }
                            result.verdict = map
                                .next_value::<std::option::Option<
                                    crate::model::deploy_policy_evaluation_event::PolicyVerdict,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__overrides => {
                            if !fields.insert(__FieldTag::__overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overrides",
                                ));
                            }
                            result.overrides = map.next_value::<std::option::Option<std::vec::Vec<crate::model::deploy_policy_evaluation_event::PolicyVerdictOverride>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployPolicyEvaluationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.rule_type.is_empty() {
            state.serialize_entry("ruleType", &self.rule_type)?;
        }
        if !self.rule.is_empty() {
            state.serialize_entry("rule", &self.rule)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.delivery_pipeline.is_empty() {
            state.serialize_entry("deliveryPipeline", &self.delivery_pipeline)?;
        }
        if !self.target_uid.is_empty() {
            state.serialize_entry("targetUid", &self.target_uid)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !wkt::internal::is_default(&self.invoker) {
            state.serialize_entry("invoker", &self.invoker)?;
        }
        if !self.deploy_policy.is_empty() {
            state.serialize_entry("deployPolicy", &self.deploy_policy)?;
        }
        if !self.deploy_policy_uid.is_empty() {
            state.serialize_entry("deployPolicyUid", &self.deploy_policy_uid)?;
        }
        if !wkt::internal::is_default(&self.allowed) {
            state.serialize_entry("allowed", &self.allowed)?;
        }
        if !wkt::internal::is_default(&self.verdict) {
            state.serialize_entry("verdict", &self.verdict)?;
        }
        if !self.overrides.is_empty() {
            state.serialize_entry("overrides", &self.overrides)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployPolicyEvaluationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployPolicyEvaluationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("rule_type", &self.rule_type);
        debug_struct.field("rule", &self.rule);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("delivery_pipeline", &self.delivery_pipeline);
        debug_struct.field("target_uid", &self.target_uid);
        debug_struct.field("target", &self.target);
        debug_struct.field("invoker", &self.invoker);
        debug_struct.field("deploy_policy", &self.deploy_policy);
        debug_struct.field("deploy_policy_uid", &self.deploy_policy_uid);
        debug_struct.field("allowed", &self.allowed);
        debug_struct.field("verdict", &self.verdict);
        debug_struct.field("overrides", &self.overrides);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeployPolicyEvaluationEvent].
pub mod deploy_policy_evaluation_event {
    #[allow(unused_imports)]
    use super::*;

    /// The policy verdict of the request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyVerdict {
        /// This should never happen.
        Unspecified,
        /// Allowed by policy. This enum value is not currently used but may be used
        /// in the future. Currently logs are only generated when a request is denied
        /// by policy.
        AllowedByPolicy,
        /// Denied by policy.
        DeniedByPolicy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyVerdict::value] or
        /// [PolicyVerdict::name].
        UnknownValue(policy_verdict::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_verdict {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyVerdict {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllowedByPolicy => std::option::Option::Some(1),
                Self::DeniedByPolicy => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POLICY_VERDICT_UNSPECIFIED"),
                Self::AllowedByPolicy => std::option::Option::Some("ALLOWED_BY_POLICY"),
                Self::DeniedByPolicy => std::option::Option::Some("DENIED_BY_POLICY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyVerdict {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyVerdict {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyVerdict {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllowedByPolicy,
                2 => Self::DeniedByPolicy,
                _ => Self::UnknownValue(policy_verdict::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyVerdict {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_VERDICT_UNSPECIFIED" => Self::Unspecified,
                "ALLOWED_BY_POLICY" => Self::AllowedByPolicy,
                "DENIED_BY_POLICY" => Self::DeniedByPolicy,
                _ => Self::UnknownValue(policy_verdict::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyVerdict {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllowedByPolicy => serializer.serialize_i32(1),
                Self::DeniedByPolicy => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyVerdict {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyVerdict>::new(
                ".google.cloud.deploy.v1.DeployPolicyEvaluationEvent.PolicyVerdict",
            ))
        }
    }

    /// Things that could have overridden the policy verdict. When overrides are
    /// used, the request will be allowed even if it is DENIED_BY_POLICY.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyVerdictOverride {
        /// This should never happen.
        Unspecified,
        /// The policy was overridden.
        PolicyOverridden,
        /// The policy was suspended.
        PolicySuspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyVerdictOverride::value] or
        /// [PolicyVerdictOverride::name].
        UnknownValue(policy_verdict_override::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_verdict_override {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyVerdictOverride {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PolicyOverridden => std::option::Option::Some(1),
                Self::PolicySuspended => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("POLICY_VERDICT_OVERRIDE_UNSPECIFIED")
                }
                Self::PolicyOverridden => std::option::Option::Some("POLICY_OVERRIDDEN"),
                Self::PolicySuspended => std::option::Option::Some("POLICY_SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyVerdictOverride {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyVerdictOverride {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyVerdictOverride {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PolicyOverridden,
                2 => Self::PolicySuspended,
                _ => Self::UnknownValue(policy_verdict_override::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyVerdictOverride {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_VERDICT_OVERRIDE_UNSPECIFIED" => Self::Unspecified,
                "POLICY_OVERRIDDEN" => Self::PolicyOverridden,
                "POLICY_SUSPENDED" => Self::PolicySuspended,
                _ => Self::UnknownValue(policy_verdict_override::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyVerdictOverride {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PolicyOverridden => serializer.serialize_i32(1),
                Self::PolicySuspended => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyVerdictOverride {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyVerdictOverride>::new(
                ".google.cloud.deploy.v1.DeployPolicyEvaluationEvent.PolicyVerdictOverride",
            ))
        }
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deploypolicy_notification".
/// Platform Log event that describes the failure to send a pub/sub notification
/// when there is a DeployPolicy status change.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployPolicyNotificationEvent {
    /// Debug message for when a deploy policy fails to send a pub/sub
    /// notification.
    pub message: std::string::String,

    /// The name of the `DeployPolicy`.
    pub deploy_policy: std::string::String,

    /// Unique identifier of the deploy policy.
    pub deploy_policy_uid: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeployPolicyNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::DeployPolicyNotificationEvent::deploy_policy].
    pub fn set_deploy_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_policy = v.into();
        self
    }

    /// Sets the value of [deploy_policy_uid][crate::model::DeployPolicyNotificationEvent::deploy_policy_uid].
    pub fn set_deploy_policy_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_uid = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DeployPolicyNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for DeployPolicyNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployPolicyNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __deploy_policy,
            __deploy_policy_uid,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployPolicyNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "deployPolicy" => Ok(__FieldTag::__deploy_policy),
                            "deploy_policy" => Ok(__FieldTag::__deploy_policy),
                            "deployPolicyUid" => Ok(__FieldTag::__deploy_policy_uid),
                            "deploy_policy_uid" => Ok(__FieldTag::__deploy_policy_uid),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployPolicyNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployPolicyNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy => {
                            if !fields.insert(__FieldTag::__deploy_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy",
                                ));
                            }
                            result.deploy_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deploy_policy_uid => {
                            if !fields.insert(__FieldTag::__deploy_policy_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deploy_policy_uid",
                                ));
                            }
                            result.deploy_policy_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployPolicyNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.deploy_policy.is_empty() {
            state.serialize_entry("deployPolicy", &self.deploy_policy)?;
        }
        if !self.deploy_policy_uid.is_empty() {
            state.serialize_entry("deployPolicyUid", &self.deploy_policy_uid)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployPolicyNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployPolicyNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("deploy_policy", &self.deploy_policy);
        debug_struct.field("deploy_policy_uid", &self.deploy_policy_uid);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/jobrun_notification"
/// Platform Log event that describes the failure to send JobRun resource update
/// Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JobRunNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// The name of the `JobRun`.
    pub job_run: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    pub release: std::string::String,

    /// Unique identifier of the `Rollout`.
    pub rollout_uid: std::string::String,

    /// The name of the `Rollout`.
    pub rollout: std::string::String,

    /// ID of the `Target`.
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobRunNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::JobRunNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::JobRunNotificationEvent::job_run].
    pub fn set_job_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_run = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::JobRunNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::JobRunNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::JobRunNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout_uid][crate::model::JobRunNotificationEvent::rollout_uid].
    pub fn set_rollout_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_uid = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::JobRunNotificationEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::JobRunNotificationEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::JobRunNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for JobRunNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.JobRunNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobRunNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __job_run,
            __pipeline_uid,
            __release_uid,
            __release,
            __rollout_uid,
            __rollout,
            __target_id,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobRunNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "jobRun" => Ok(__FieldTag::__job_run),
                            "job_run" => Ok(__FieldTag::__job_run),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "releaseUid" => Ok(__FieldTag::__release_uid),
                            "release_uid" => Ok(__FieldTag::__release_uid),
                            "release" => Ok(__FieldTag::__release),
                            "rolloutUid" => Ok(__FieldTag::__rollout_uid),
                            "rollout_uid" => Ok(__FieldTag::__rollout_uid),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobRunNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobRunNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_run => {
                            if !fields.insert(__FieldTag::__job_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_run",
                                ));
                            }
                            result.job_run = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_uid => {
                            if !fields.insert(__FieldTag::__release_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_uid",
                                ));
                            }
                            result.release_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_uid => {
                            if !fields.insert(__FieldTag::__rollout_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_uid",
                                ));
                            }
                            result.rollout_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobRunNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.job_run.is_empty() {
            state.serialize_entry("jobRun", &self.job_run)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.release_uid.is_empty() {
            state.serialize_entry("releaseUid", &self.release_uid)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !self.rollout_uid.is_empty() {
            state.serialize_entry("rolloutUid", &self.rollout_uid)?;
        }
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JobRunNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobRunNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("job_run", &self.job_run);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("release_uid", &self.release_uid);
        debug_struct.field("release", &self.release);
        debug_struct.field("rollout_uid", &self.rollout_uid);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/release_notification"
/// Platform Log event that describes the failure to send release status change
/// Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReleaseNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    pub release: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ReleaseNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::ReleaseNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::ReleaseNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::ReleaseNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReleaseNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ReleaseNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReleaseNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __pipeline_uid,
            __release_uid,
            __release,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "releaseUid" => Ok(__FieldTag::__release_uid),
                            "release_uid" => Ok(__FieldTag::__release_uid),
                            "release" => Ok(__FieldTag::__release),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReleaseNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_uid => {
                            if !fields.insert(__FieldTag::__release_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_uid",
                                ));
                            }
                            result.release_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReleaseNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.release_uid.is_empty() {
            state.serialize_entry("releaseUid", &self.release_uid)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReleaseNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReleaseNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("release_uid", &self.release_uid);
        debug_struct.field("release", &self.release);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/release_render"
/// Platform Log event that describes the render status change.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReleaseRenderEvent {
    /// Debug message for when a render transition occurs. Provides further
    /// details as rendering progresses through render states.
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// The name of the release.
    /// release_uid is not in this log message because we write some of these log
    /// messages at release creation time, before we've generated the uid.
    pub release: std::string::String,

    /// Type of this notification, e.g. for a release render state change event.
    pub r#type: crate::model::Type,

    /// The state of the release render.
    pub release_render_state: crate::model::release::RenderState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseRenderEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ReleaseRenderEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::ReleaseRenderEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::ReleaseRenderEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReleaseRenderEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [release_render_state][crate::model::ReleaseRenderEvent::release_render_state].
    pub fn set_release_render_state<T: std::convert::Into<crate::model::release::RenderState>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_render_state = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseRenderEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ReleaseRenderEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReleaseRenderEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __pipeline_uid,
            __release,
            __type,
            __release_render_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseRenderEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "release" => Ok(__FieldTag::__release),
                            "type" => Ok(__FieldTag::__type),
                            "releaseRenderState" => Ok(__FieldTag::__release_render_state),
                            "release_render_state" => Ok(__FieldTag::__release_render_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReleaseRenderEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseRenderEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_render_state => {
                            if !fields.insert(__FieldTag::__release_render_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_render_state",
                                ));
                            }
                            result.release_render_state = map.next_value::<std::option::Option<crate::model::release::RenderState>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReleaseRenderEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.release_render_state) {
            state.serialize_entry("releaseRenderState", &self.release_render_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReleaseRenderEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReleaseRenderEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("release", &self.release);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("release_render_state", &self.release_render_state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/rollout_notification"
/// Platform Log event that describes the failure to send rollout status change
/// Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    pub release: std::string::String,

    /// Unique identifier of the `Rollout`.
    pub rollout_uid: std::string::String,

    /// The name of the `Rollout`.
    pub rollout: std::string::String,

    /// ID of the `Target` that the rollout is deployed to.
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::RolloutNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::RolloutNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::RolloutNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::RolloutNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout_uid][crate::model::RolloutNotificationEvent::rollout_uid].
    pub fn set_rollout_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_uid = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::RolloutNotificationEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RolloutNotificationEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::RolloutNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for RolloutNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __pipeline_uid,
            __release_uid,
            __release,
            __rollout_uid,
            __rollout,
            __target_id,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "releaseUid" => Ok(__FieldTag::__release_uid),
                            "release_uid" => Ok(__FieldTag::__release_uid),
                            "release" => Ok(__FieldTag::__release),
                            "rolloutUid" => Ok(__FieldTag::__rollout_uid),
                            "rollout_uid" => Ok(__FieldTag::__rollout_uid),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_uid => {
                            if !fields.insert(__FieldTag::__release_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_uid",
                                ));
                            }
                            result.release_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_uid => {
                            if !fields.insert(__FieldTag::__rollout_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_uid",
                                ));
                            }
                            result.rollout_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RolloutNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.release_uid.is_empty() {
            state.serialize_entry("releaseUid", &self.release_uid)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !self.rollout_uid.is_empty() {
            state.serialize_entry("rolloutUid", &self.rollout_uid)?;
        }
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RolloutNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("release_uid", &self.release_uid);
        debug_struct.field("release", &self.release);
        debug_struct.field("rollout_uid", &self.rollout_uid);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Payload proto for "clouddeploy.googleapis.com/rollout_update"
/// Platform Log event that describes the rollout update event.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutUpdateEvent {
    /// Debug message for when a rollout update event occurs.
    pub message: std::string::String,

    /// Unique identifier of the pipeline.
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the release.
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    pub release: std::string::String,

    /// The name of the rollout.
    /// rollout_uid is not in this log message because we write some of these log
    /// messages at rollout creation time, before we've generated the uid.
    pub rollout: std::string::String,

    /// ID of the target.
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a rollout update event.
    pub r#type: crate::model::Type,

    /// The type of the rollout update.
    pub rollout_update_type: crate::model::rollout_update_event::RolloutUpdateType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutUpdateEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::RolloutUpdateEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::RolloutUpdateEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::RolloutUpdateEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::RolloutUpdateEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::RolloutUpdateEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RolloutUpdateEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::RolloutUpdateEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [rollout_update_type][crate::model::RolloutUpdateEvent::rollout_update_type].
    pub fn set_rollout_update_type<
        T: std::convert::Into<crate::model::rollout_update_event::RolloutUpdateType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_update_type = v.into();
        self
    }
}

impl wkt::message::Message for RolloutUpdateEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutUpdateEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutUpdateEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __pipeline_uid,
            __release_uid,
            __release,
            __rollout,
            __target_id,
            __type,
            __rollout_update_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutUpdateEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "pipelineUid" => Ok(__FieldTag::__pipeline_uid),
                            "pipeline_uid" => Ok(__FieldTag::__pipeline_uid),
                            "releaseUid" => Ok(__FieldTag::__release_uid),
                            "release_uid" => Ok(__FieldTag::__release_uid),
                            "release" => Ok(__FieldTag::__release),
                            "rollout" => Ok(__FieldTag::__rollout),
                            "targetId" => Ok(__FieldTag::__target_id),
                            "target_id" => Ok(__FieldTag::__target_id),
                            "type" => Ok(__FieldTag::__type),
                            "rolloutUpdateType" => Ok(__FieldTag::__rollout_update_type),
                            "rollout_update_type" => Ok(__FieldTag::__rollout_update_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutUpdateEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutUpdateEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipeline_uid => {
                            if !fields.insert(__FieldTag::__pipeline_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipeline_uid",
                                ));
                            }
                            result.pipeline_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_uid => {
                            if !fields.insert(__FieldTag::__release_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_uid",
                                ));
                            }
                            result.release_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release => {
                            if !fields.insert(__FieldTag::__release) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release",
                                ));
                            }
                            result.release = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_id => {
                            if !fields.insert(__FieldTag::__target_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_id",
                                ));
                            }
                            result.target_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_update_type => {
                            if !fields.insert(__FieldTag::__rollout_update_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_update_type",
                                ));
                            }
                            result.rollout_update_type = map
                                .next_value::<std::option::Option<
                                    crate::model::rollout_update_event::RolloutUpdateType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RolloutUpdateEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.pipeline_uid.is_empty() {
            state.serialize_entry("pipelineUid", &self.pipeline_uid)?;
        }
        if !self.release_uid.is_empty() {
            state.serialize_entry("releaseUid", &self.release_uid)?;
        }
        if !self.release.is_empty() {
            state.serialize_entry("release", &self.release)?;
        }
        if !self.rollout.is_empty() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self.target_id.is_empty() {
            state.serialize_entry("targetId", &self.target_id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.rollout_update_type) {
            state.serialize_entry("rolloutUpdateType", &self.rollout_update_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RolloutUpdateEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RolloutUpdateEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("pipeline_uid", &self.pipeline_uid);
        debug_struct.field("release_uid", &self.release_uid);
        debug_struct.field("release", &self.release);
        debug_struct.field("rollout", &self.rollout);
        debug_struct.field("target_id", &self.target_id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("rollout_update_type", &self.rollout_update_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RolloutUpdateEvent].
pub mod rollout_update_event {
    #[allow(unused_imports)]
    use super::*;

    /// RolloutUpdateType indicates the type of the rollout update.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutUpdateType {
        /// Rollout update type unspecified.
        Unspecified,
        /// rollout state updated to pending.
        Pending,
        /// Rollout state updated to pending release.
        PendingRelease,
        /// Rollout state updated to in progress.
        InProgress,
        /// Rollout state updated to cancelling.
        Cancelling,
        /// Rollout state updated to cancelled.
        Cancelled,
        /// Rollout state updated to halted.
        Halted,
        /// Rollout state updated to succeeded.
        Succeeded,
        /// Rollout state updated to failed.
        Failed,
        /// Rollout requires approval.
        ApprovalRequired,
        /// Rollout has been approved.
        Approved,
        /// Rollout has been rejected.
        Rejected,
        /// Rollout requires advance to the next phase.
        AdvanceRequired,
        /// Rollout has been advanced.
        Advanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutUpdateType::value] or
        /// [RolloutUpdateType::name].
        UnknownValue(rollout_update_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_update_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutUpdateType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::PendingRelease => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Halted => std::option::Option::Some(6),
                Self::Succeeded => std::option::Option::Some(7),
                Self::Failed => std::option::Option::Some(8),
                Self::ApprovalRequired => std::option::Option::Some(9),
                Self::Approved => std::option::Option::Some(10),
                Self::Rejected => std::option::Option::Some(11),
                Self::AdvanceRequired => std::option::Option::Some(12),
                Self::Advanced => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_UPDATE_TYPE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::PendingRelease => std::option::Option::Some("PENDING_RELEASE"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Halted => std::option::Option::Some("HALTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::ApprovalRequired => std::option::Option::Some("APPROVAL_REQUIRED"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::AdvanceRequired => std::option::Option::Some("ADVANCE_REQUIRED"),
                Self::Advanced => std::option::Option::Some("ADVANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutUpdateType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutUpdateType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutUpdateType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::PendingRelease,
                3 => Self::InProgress,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                6 => Self::Halted,
                7 => Self::Succeeded,
                8 => Self::Failed,
                9 => Self::ApprovalRequired,
                10 => Self::Approved,
                11 => Self::Rejected,
                12 => Self::AdvanceRequired,
                13 => Self::Advanced,
                _ => Self::UnknownValue(rollout_update_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutUpdateType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_UPDATE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "PENDING_RELEASE" => Self::PendingRelease,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "HALTED" => Self::Halted,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "APPROVAL_REQUIRED" => Self::ApprovalRequired,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                "ADVANCE_REQUIRED" => Self::AdvanceRequired,
                "ADVANCED" => Self::Advanced,
                _ => Self::UnknownValue(rollout_update_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutUpdateType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::PendingRelease => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Halted => serializer.serialize_i32(6),
                Self::Succeeded => serializer.serialize_i32(7),
                Self::Failed => serializer.serialize_i32(8),
                Self::ApprovalRequired => serializer.serialize_i32(9),
                Self::Approved => serializer.serialize_i32(10),
                Self::Rejected => serializer.serialize_i32(11),
                Self::AdvanceRequired => serializer.serialize_i32(12),
                Self::Advanced => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutUpdateType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutUpdateType>::new(
                ".google.cloud.deploy.v1.RolloutUpdateEvent.RolloutUpdateType",
            ))
        }
    }
}

/// Payload proto for "clouddeploy.googleapis.com/target_notification"
/// Platform Log event that describes the failure to send target status change
/// Pub/Sub notification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetNotificationEvent {
    /// Debug message for when a notification fails to send.
    pub message: std::string::String,

    /// The name of the `Target`.
    pub target: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    pub r#type: crate::model::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::TargetNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [target][crate::model::TargetNotificationEvent::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TargetNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for TargetNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetNotificationEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetNotificationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __target,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetNotificationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "target" => Ok(__FieldTag::__target),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetNotificationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetNotificationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetNotificationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetNotificationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetNotificationEvent");
        debug_struct.field("message", &self.message);
        debug_struct.field("target", &self.target);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The support state of a specific Skaffold version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SkaffoldSupportState {
    /// Default value. This value is unused.
    Unspecified,
    /// This Skaffold version is currently supported.
    Supported,
    /// This Skaffold version is in maintenance mode.
    MaintenanceMode,
    /// This Skaffold version is no longer supported.
    Unsupported,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SkaffoldSupportState::value] or
    /// [SkaffoldSupportState::name].
    UnknownValue(skaffold_support_state::UnknownValue),
}

#[doc(hidden)]
pub mod skaffold_support_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SkaffoldSupportState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Supported => std::option::Option::Some(1),
            Self::MaintenanceMode => std::option::Option::Some(2),
            Self::Unsupported => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_UNSPECIFIED"),
            Self::Supported => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_SUPPORTED"),
            Self::MaintenanceMode => {
                std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE")
            }
            Self::Unsupported => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_UNSUPPORTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SkaffoldSupportState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SkaffoldSupportState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SkaffoldSupportState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Supported,
            2 => Self::MaintenanceMode,
            3 => Self::Unsupported,
            _ => Self::UnknownValue(skaffold_support_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SkaffoldSupportState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED" => Self::Unspecified,
            "SKAFFOLD_SUPPORT_STATE_SUPPORTED" => Self::Supported,
            "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE" => Self::MaintenanceMode,
            "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED" => Self::Unsupported,
            _ => Self::UnknownValue(skaffold_support_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SkaffoldSupportState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Supported => serializer.serialize_i32(1),
            Self::MaintenanceMode => serializer.serialize_i32(2),
            Self::Unsupported => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SkaffoldSupportState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SkaffoldSupportState>::new(
            ".google.cloud.deploy.v1.SkaffoldSupportState",
        ))
    }
}

/// The pattern of how wait time is increased.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackoffMode {
    /// No WaitMode is specified.
    Unspecified,
    /// Increases the wait time linearly.
    Linear,
    /// Increases the wait time exponentially.
    Exponential,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackoffMode::value] or
    /// [BackoffMode::name].
    UnknownValue(backoff_mode::UnknownValue),
}

#[doc(hidden)]
pub mod backoff_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackoffMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear => std::option::Option::Some(1),
            Self::Exponential => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKOFF_MODE_UNSPECIFIED"),
            Self::Linear => std::option::Option::Some("BACKOFF_MODE_LINEAR"),
            Self::Exponential => std::option::Option::Some("BACKOFF_MODE_EXPONENTIAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackoffMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackoffMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackoffMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear,
            2 => Self::Exponential,
            _ => Self::UnknownValue(backoff_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackoffMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKOFF_MODE_UNSPECIFIED" => Self::Unspecified,
            "BACKOFF_MODE_LINEAR" => Self::Linear,
            "BACKOFF_MODE_EXPONENTIAL" => Self::Exponential,
            _ => Self::UnknownValue(backoff_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackoffMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear => serializer.serialize_i32(1),
            Self::Exponential => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackoffMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackoffMode>::new(
            ".google.cloud.deploy.v1.BackoffMode",
        ))
    }
}

/// Valid state of a repair attempt.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RepairState {
    /// The `repair` has an unspecified state.
    Unspecified,
    /// The `repair` action has succeeded.
    Succeeded,
    /// The `repair` action was cancelled.
    Cancelled,
    /// The `repair` action has failed.
    Failed,
    /// The `repair` action is in progress.
    InProgress,
    /// The `repair` action is pending.
    Pending,
    /// The `repair` action was aborted.
    Aborted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RepairState::value] or
    /// [RepairState::name].
    UnknownValue(repair_state::UnknownValue),
}

#[doc(hidden)]
pub mod repair_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RepairState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Succeeded => std::option::Option::Some(1),
            Self::Cancelled => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::InProgress => std::option::Option::Some(4),
            Self::Pending => std::option::Option::Some(5),
            Self::Aborted => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("REPAIR_STATE_UNSPECIFIED"),
            Self::Succeeded => std::option::Option::Some("REPAIR_STATE_SUCCEEDED"),
            Self::Cancelled => std::option::Option::Some("REPAIR_STATE_CANCELLED"),
            Self::Failed => std::option::Option::Some("REPAIR_STATE_FAILED"),
            Self::InProgress => std::option::Option::Some("REPAIR_STATE_IN_PROGRESS"),
            Self::Pending => std::option::Option::Some("REPAIR_STATE_PENDING"),
            Self::Aborted => std::option::Option::Some("REPAIR_STATE_ABORTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RepairState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RepairState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RepairState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Succeeded,
            2 => Self::Cancelled,
            3 => Self::Failed,
            4 => Self::InProgress,
            5 => Self::Pending,
            7 => Self::Aborted,
            _ => Self::UnknownValue(repair_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RepairState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REPAIR_STATE_UNSPECIFIED" => Self::Unspecified,
            "REPAIR_STATE_SUCCEEDED" => Self::Succeeded,
            "REPAIR_STATE_CANCELLED" => Self::Cancelled,
            "REPAIR_STATE_FAILED" => Self::Failed,
            "REPAIR_STATE_IN_PROGRESS" => Self::InProgress,
            "REPAIR_STATE_PENDING" => Self::Pending,
            "REPAIR_STATE_ABORTED" => Self::Aborted,
            _ => Self::UnknownValue(repair_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RepairState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Succeeded => serializer.serialize_i32(1),
            Self::Cancelled => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::InProgress => serializer.serialize_i32(4),
            Self::Pending => serializer.serialize_i32(5),
            Self::Aborted => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RepairState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepairState>::new(
            ".google.cloud.deploy.v1.RepairState",
        ))
    }
}

/// Type indicates the type of the log entry and can be used as a filter.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Type {
    /// Type is unspecified.
    Unspecified,
    /// A Pub/Sub notification failed to be sent.
    PubsubNotificationFailure,
    /// Resource state changed.
    ResourceStateChange,
    /// A process aborted.
    ProcessAborted,
    /// Restriction check failed.
    RestrictionViolated,
    /// Resource deleted.
    ResourceDeleted,
    /// Rollout updated.
    RolloutUpdate,
    /// Deploy Policy evaluation.
    DeployPolicyEvaluation,
    /// Deprecated: This field is never used. Use release_render log type instead.
    #[deprecated]
    RenderStatuesChange,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Type::value] or
    /// [Type::name].
    UnknownValue(r#type::UnknownValue),
}

#[doc(hidden)]
pub mod r#type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Type {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PubsubNotificationFailure => std::option::Option::Some(1),
            Self::ResourceStateChange => std::option::Option::Some(3),
            Self::ProcessAborted => std::option::Option::Some(4),
            Self::RestrictionViolated => std::option::Option::Some(5),
            Self::ResourceDeleted => std::option::Option::Some(6),
            Self::RolloutUpdate => std::option::Option::Some(7),
            Self::DeployPolicyEvaluation => std::option::Option::Some(8),
            Self::RenderStatuesChange => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
            Self::PubsubNotificationFailure => {
                std::option::Option::Some("TYPE_PUBSUB_NOTIFICATION_FAILURE")
            }
            Self::ResourceStateChange => std::option::Option::Some("TYPE_RESOURCE_STATE_CHANGE"),
            Self::ProcessAborted => std::option::Option::Some("TYPE_PROCESS_ABORTED"),
            Self::RestrictionViolated => std::option::Option::Some("TYPE_RESTRICTION_VIOLATED"),
            Self::ResourceDeleted => std::option::Option::Some("TYPE_RESOURCE_DELETED"),
            Self::RolloutUpdate => std::option::Option::Some("TYPE_ROLLOUT_UPDATE"),
            Self::DeployPolicyEvaluation => {
                std::option::Option::Some("TYPE_DEPLOY_POLICY_EVALUATION")
            }
            Self::RenderStatuesChange => std::option::Option::Some("TYPE_RENDER_STATUES_CHANGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Type {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Type {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PubsubNotificationFailure,
            2 => Self::RenderStatuesChange,
            3 => Self::ResourceStateChange,
            4 => Self::ProcessAborted,
            5 => Self::RestrictionViolated,
            6 => Self::ResourceDeleted,
            7 => Self::RolloutUpdate,
            8 => Self::DeployPolicyEvaluation,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Type {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TYPE_UNSPECIFIED" => Self::Unspecified,
            "TYPE_PUBSUB_NOTIFICATION_FAILURE" => Self::PubsubNotificationFailure,
            "TYPE_RESOURCE_STATE_CHANGE" => Self::ResourceStateChange,
            "TYPE_PROCESS_ABORTED" => Self::ProcessAborted,
            "TYPE_RESTRICTION_VIOLATED" => Self::RestrictionViolated,
            "TYPE_RESOURCE_DELETED" => Self::ResourceDeleted,
            "TYPE_ROLLOUT_UPDATE" => Self::RolloutUpdate,
            "TYPE_DEPLOY_POLICY_EVALUATION" => Self::DeployPolicyEvaluation,
            "TYPE_RENDER_STATUES_CHANGE" => Self::RenderStatuesChange,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PubsubNotificationFailure => serializer.serialize_i32(1),
            Self::ResourceStateChange => serializer.serialize_i32(3),
            Self::ProcessAborted => serializer.serialize_i32(4),
            Self::RestrictionViolated => serializer.serialize_i32(5),
            Self::ResourceDeleted => serializer.serialize_i32(6),
            Self::RolloutUpdate => serializer.serialize_i32(7),
            Self::DeployPolicyEvaluation => serializer.serialize_i32(8),
            Self::RenderStatuesChange => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
            ".google.cloud.deploy.v1.Type",
        ))
    }
}
