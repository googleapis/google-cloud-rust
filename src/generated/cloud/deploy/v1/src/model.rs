// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Payload proto for "clouddeploy.googleapis.com/automation"
/// Platform Log event that describes the Automation related events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationEvent {
    /// Debug message for when there is an update on the AutomationRun.
    /// Provides further details about the resource creation or state change.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// The name of the `AutomationRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automation: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AutomationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [automation][crate::model::AutomationEvent::automation].
    pub fn set_automation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::AutomationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AutomationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for AutomationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/automation_run"
/// Platform Log event that describes the AutomationRun related events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationRunEvent {
    /// Debug message for when there is an update on the AutomationRun.
    /// Provides further details about the resource creation or state change.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// The name of the `AutomationRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automation_run: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Identifier of the `Automation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automation_id: std::string::String,

    /// Identifier of the `Automation` rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rule_id: std::string::String,

    /// ID of the `Target` to which the `AutomationRun` is created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRunEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::AutomationRunEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [automation_run][crate::model::AutomationRunEvent::automation_run].
    pub fn set_automation_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_run = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::AutomationRunEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::AutomationRunEvent::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::AutomationRunEvent::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [destination_target_id][crate::model::AutomationRunEvent::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AutomationRunEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for AutomationRunEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRunEvent"
    }
}

/// A `DeliveryPipeline` resource in the Cloud Deploy API.
///
/// A `DeliveryPipeline` defines a pipeline through which a Skaffold
/// configuration can progress.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeliveryPipeline {
    /// Identifier. Name of the `DeliveryPipeline`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}`.
    /// The `deliveryPipeline` component must match
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `DeliveryPipeline`. Max length is 255
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the pipeline was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the pipeline was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Information around the state of the Delivery Pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::PipelineCondition>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Optional. When suspended, no new releases or rollouts can be created,
    /// but in-progress ones will complete.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub suspended: bool,

    /// The ordering configuration of the `DeliveryPipeline`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline: std::option::Option<crate::model::delivery_pipeline::Pipeline>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeliveryPipeline::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DeliveryPipeline::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeliveryPipeline::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DeliveryPipeline::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DeliveryPipeline::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DeliveryPipeline::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeliveryPipeline::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeliveryPipeline::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeliveryPipeline::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::DeliveryPipeline::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PipelineCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::DeliveryPipeline::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PipelineCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::DeliveryPipeline::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::DeliveryPipeline::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [pipeline][crate::model::DeliveryPipeline::pipeline].
    ///
    /// Note that all the setters affecting `pipeline` are mutually
    /// exclusive.
    pub fn set_pipeline<
        T: std::convert::Into<std::option::Option<crate::model::delivery_pipeline::Pipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = v.into();
        self
    }

    /// The value of [pipeline][crate::model::DeliveryPipeline::pipeline]
    /// if it holds a `SerialPipeline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serial_pipeline(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SerialPipeline>> {
        #[allow(unreachable_patterns)]
        self.pipeline.as_ref().and_then(|v| match v {
            crate::model::delivery_pipeline::Pipeline::SerialPipeline(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [pipeline][crate::model::DeliveryPipeline::pipeline]
    /// to hold a `SerialPipeline`.
    ///
    /// Note that all the setters affecting `pipeline` are
    /// mutually exclusive.
    pub fn set_serial_pipeline<
        T: std::convert::Into<std::boxed::Box<crate::model::SerialPipeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pipeline = std::option::Option::Some(
            crate::model::delivery_pipeline::Pipeline::SerialPipeline(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DeliveryPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipeline"
    }
}

/// Defines additional types related to [DeliveryPipeline].
pub mod delivery_pipeline {
    #[allow(unused_imports)]
    use super::*;

    /// The ordering configuration of the `DeliveryPipeline`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Pipeline {
        /// Optional. SerialPipeline defines a sequential set of stages for a
        /// `DeliveryPipeline`.
        SerialPipeline(std::boxed::Box<crate::model::SerialPipeline>),
    }
}

/// SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SerialPipeline {
    /// Optional. Each stage specifies configuration for a `Target`. The ordering
    /// of this list defines the promotion flow.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub stages: std::vec::Vec<crate::model::Stage>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SerialPipeline {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stages][crate::model::SerialPipeline::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Stage>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SerialPipeline {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SerialPipeline"
    }
}

/// Stage specifies a location to which to deploy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Stage {
    /// Optional. The target_id to which this stage points. This field refers
    /// exclusively to the last segment of a target name. For example, this field
    /// would just be `my-target` (rather than
    /// `projects/project/locations/location/targets/my-target`). The location of
    /// the `Target` is inferred to be the same as the location of the
    /// `DeliveryPipeline` that contains this `Stage`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Optional. Skaffold profiles to use when rendering the manifest for this
    /// stage's `Target`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub profiles: std::vec::Vec<std::string::String>,

    /// Optional. The strategy to use for a `Rollout` to this stage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub strategy: std::option::Option<crate::model::Strategy>,

    /// Optional. The deploy parameters to use for the target in this stage.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub deploy_parameters: std::vec::Vec<crate::model::DeployParameters>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Stage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::Stage::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [profiles][crate::model::Stage::profiles].
    pub fn set_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [strategy][crate::model::Stage::strategy].
    pub fn set_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Strategy>,
    {
        self.strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [strategy][crate::model::Stage::strategy].
    pub fn set_or_clear_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Strategy>,
    {
        self.strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Stage::deploy_parameters].
    pub fn set_deploy_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployParameters>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Stage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Stage"
    }
}

/// DeployParameters contains deploy parameters information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployParameters {
    /// Required. Values are deploy parameters in key-value pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub values: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Deploy parameters are applied to targets with match labels.
    /// If unspecified, deploy parameters are applied to all targets (including
    /// child targets of a multi-target).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub match_target_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DeployParameters::values].
    pub fn set_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [match_target_labels][crate::model::DeployParameters::match_target_labels].
    pub fn set_match_target_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.match_target_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DeployParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployParameters"
    }
}

/// Strategy contains deployment strategy information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Strategy {
    /// Deployment strategy details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_strategy: std::option::Option<crate::model::strategy::DeploymentStrategy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Strategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy].
    ///
    /// Note that all the setters affecting `deployment_strategy` are mutually
    /// exclusive.
    pub fn set_deployment_strategy<
        T: std::convert::Into<std::option::Option<crate::model::strategy::DeploymentStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy = v.into();
        self
    }

    /// The value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// if it holds a `Standard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard(&self) -> std::option::Option<&std::boxed::Box<crate::model::Standard>> {
        #[allow(unreachable_patterns)]
        self.deployment_strategy.as_ref().and_then(|v| match v {
            crate::model::strategy::DeploymentStrategy::Standard(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// to hold a `Standard`.
    ///
    /// Note that all the setters affecting `deployment_strategy` are
    /// mutually exclusive.
    pub fn set_standard<T: std::convert::Into<std::boxed::Box<crate::model::Standard>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy = std::option::Option::Some(
            crate::model::strategy::DeploymentStrategy::Standard(v.into()),
        );
        self
    }

    /// The value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// if it holds a `Canary`, `None` if the field is not set or
    /// holds a different branch.
    pub fn canary(&self) -> std::option::Option<&std::boxed::Box<crate::model::Canary>> {
        #[allow(unreachable_patterns)]
        self.deployment_strategy.as_ref().and_then(|v| match v {
            crate::model::strategy::DeploymentStrategy::Canary(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_strategy][crate::model::Strategy::deployment_strategy]
    /// to hold a `Canary`.
    ///
    /// Note that all the setters affecting `deployment_strategy` are
    /// mutually exclusive.
    pub fn set_canary<T: std::convert::Into<std::boxed::Box<crate::model::Canary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_strategy =
            std::option::Option::Some(crate::model::strategy::DeploymentStrategy::Canary(v.into()));
        self
    }
}

impl wkt::message::Message for Strategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Strategy"
    }
}

/// Defines additional types related to [Strategy].
pub mod strategy {
    #[allow(unused_imports)]
    use super::*;

    /// Deployment strategy details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DeploymentStrategy {
        /// Optional. Standard deployment strategy executes a single deploy and
        /// allows verifying the deployment.
        Standard(std::boxed::Box<crate::model::Standard>),
        /// Optional. Canary deployment strategy provides progressive percentage
        /// based deployments to a Target.
        Canary(std::boxed::Box<crate::model::Canary>),
    }
}

/// Predeploy contains the predeploy job configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Predeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the predeploy job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Predeploy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::Predeploy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Predeploy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Predeploy"
    }
}

/// Postdeploy contains the postdeploy job configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Postdeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the postdeploy job.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Postdeploy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::Postdeploy::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Postdeploy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Postdeploy"
    }
}

/// Standard represents the standard deployment strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Standard {
    /// Optional. Whether to verify a deployment via `skaffold verify`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verify: bool,

    /// Optional. Configuration for the predeploy job. If this is not configured,
    /// the predeploy job will not be present.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predeploy: std::option::Option<crate::model::Predeploy>,

    /// Optional. Configuration for the postdeploy job. If this is not configured,
    /// the postdeploy job will not be present.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub postdeploy: std::option::Option<crate::model::Postdeploy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Standard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [verify][crate::model::Standard::verify].
    pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify = v.into();
        self
    }

    /// Sets the value of [predeploy][crate::model::Standard::predeploy].
    pub fn set_predeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy][crate::model::Standard::predeploy].
    pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy][crate::model::Standard::postdeploy].
    pub fn set_postdeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy][crate::model::Standard::postdeploy].
    pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Standard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Standard"
    }
}

/// Canary represents the canary deployment strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Canary {
    /// Optional. Runtime specific configurations for the deployment strategy. The
    /// runtime configuration is used to determine how Cloud Deploy will split
    /// traffic to enable a progressive deployment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// The mode to use for the canary deployment strategy.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::canary::Mode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Canary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_config][crate::model::Canary::runtime_config].
    pub fn set_runtime_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_config][crate::model::Canary::runtime_config].
    pub fn set_or_clear_runtime_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mode][crate::model::Canary::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<T: std::convert::Into<std::option::Option<crate::model::canary::Mode>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::Canary::mode]
    /// if it holds a `CanaryDeployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn canary_deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CanaryDeployment>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::canary::Mode::CanaryDeployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Canary::mode]
    /// to hold a `CanaryDeployment`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_canary_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::CanaryDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::canary::Mode::CanaryDeployment(v.into()));
        self
    }

    /// The value of [mode][crate::model::Canary::mode]
    /// if it holds a `CustomCanaryDeployment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_canary_deployment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomCanaryDeployment>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::canary::Mode::CustomCanaryDeployment(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Canary::mode]
    /// to hold a `CustomCanaryDeployment`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_custom_canary_deployment<
        T: std::convert::Into<std::boxed::Box<crate::model::CustomCanaryDeployment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode =
            std::option::Option::Some(crate::model::canary::Mode::CustomCanaryDeployment(v.into()));
        self
    }
}

impl wkt::message::Message for Canary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Canary"
    }
}

/// Defines additional types related to [Canary].
pub mod canary {
    #[allow(unused_imports)]
    use super::*;

    /// The mode to use for the canary deployment strategy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Optional. Configures the progressive based deployment for a Target.
        CanaryDeployment(std::boxed::Box<crate::model::CanaryDeployment>),
        /// Optional. Configures the progressive based deployment for a Target, but
        /// allows customizing at the phase level where a phase represents each of
        /// the percentage deployments.
        CustomCanaryDeployment(std::boxed::Box<crate::model::CustomCanaryDeployment>),
    }
}

/// CanaryDeployment represents the canary deployment configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CanaryDeployment {
    /// Required. The percentage based deployments that will occur as a part of a
    /// `Rollout`. List is expected in ascending order and each integer n is
    /// 0 <= n < 100.
    /// If the GatewayServiceMesh is configured for Kubernetes, then the range for
    /// n is 0 <= n <= 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<wkt::internal::I32>>")]
    pub percentages: std::vec::Vec<i32>,

    /// Optional. Whether to run verify tests after each percentage deployment via
    /// `skaffold verify`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verify: bool,

    /// Optional. Configuration for the predeploy job of the first phase. If this
    /// is not configured, there will be no predeploy job for this phase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predeploy: std::option::Option<crate::model::Predeploy>,

    /// Optional. Configuration for the postdeploy job of the last phase. If this
    /// is not configured, there will be no postdeploy job for this phase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub postdeploy: std::option::Option<crate::model::Postdeploy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CanaryDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [percentages][crate::model::CanaryDeployment::percentages].
    pub fn set_percentages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.percentages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [verify][crate::model::CanaryDeployment::verify].
    pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verify = v.into();
        self
    }

    /// Sets the value of [predeploy][crate::model::CanaryDeployment::predeploy].
    pub fn set_predeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy][crate::model::CanaryDeployment::predeploy].
    pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Predeploy>,
    {
        self.predeploy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy][crate::model::CanaryDeployment::postdeploy].
    pub fn set_postdeploy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy][crate::model::CanaryDeployment::postdeploy].
    pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Postdeploy>,
    {
        self.postdeploy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CanaryDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CanaryDeployment"
    }
}

/// CustomCanaryDeployment represents the custom canary deployment
/// configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomCanaryDeployment {
    /// Required. Configuration for each phase in the canary deployment in the
    /// order executed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub phase_configs: std::vec::Vec<crate::model::custom_canary_deployment::PhaseConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomCanaryDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phase_configs][crate::model::CustomCanaryDeployment::phase_configs].
    pub fn set_phase_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_canary_deployment::PhaseConfig>,
    {
        use std::iter::Iterator;
        self.phase_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomCanaryDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomCanaryDeployment"
    }
}

/// Defines additional types related to [CustomCanaryDeployment].
pub mod custom_canary_deployment {
    #[allow(unused_imports)]
    use super::*;

    /// PhaseConfig represents the configuration for a phase in the custom
    /// canary deployment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PhaseConfig {
        /// Required. The ID to assign to the `Rollout` phase.
        /// This value must consist of lower-case letters, numbers, and hyphens,
        /// start with a letter and end with a letter or a number, and have a max
        /// length of 63 characters. In other words, it must match the following
        /// regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub phase_id: std::string::String,

        /// Required. Percentage deployment for the phase.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
        pub percentage: i32,

        /// Optional. Skaffold profiles to use when rendering the manifest for this
        /// phase. These are in addition to the profiles list specified in the
        /// `DeliveryPipeline` stage.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
        pub profiles: std::vec::Vec<std::string::String>,

        /// Optional. Whether to run verify tests after the deployment via `skaffold
        /// verify`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub verify: bool,

        /// Optional. Configuration for the predeploy job of this phase. If this is
        /// not configured, there will be no predeploy job for this phase.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub predeploy: std::option::Option<crate::model::Predeploy>,

        /// Optional. Configuration for the postdeploy job of this phase. If this is
        /// not configured, there will be no postdeploy job for this phase.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub postdeploy: std::option::Option<crate::model::Postdeploy>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PhaseConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [phase_id][crate::model::custom_canary_deployment::PhaseConfig::phase_id].
        pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.phase_id = v.into();
            self
        }

        /// Sets the value of [percentage][crate::model::custom_canary_deployment::PhaseConfig::percentage].
        pub fn set_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.percentage = v.into();
            self
        }

        /// Sets the value of [profiles][crate::model::custom_canary_deployment::PhaseConfig::profiles].
        pub fn set_profiles<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.profiles = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [verify][crate::model::custom_canary_deployment::PhaseConfig::verify].
        pub fn set_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.verify = v.into();
            self
        }

        /// Sets the value of [predeploy][crate::model::custom_canary_deployment::PhaseConfig::predeploy].
        pub fn set_predeploy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Predeploy>,
        {
            self.predeploy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [predeploy][crate::model::custom_canary_deployment::PhaseConfig::predeploy].
        pub fn set_or_clear_predeploy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Predeploy>,
        {
            self.predeploy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [postdeploy][crate::model::custom_canary_deployment::PhaseConfig::postdeploy].
        pub fn set_postdeploy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Postdeploy>,
        {
            self.postdeploy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [postdeploy][crate::model::custom_canary_deployment::PhaseConfig::postdeploy].
        pub fn set_or_clear_postdeploy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Postdeploy>,
        {
            self.postdeploy = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PhaseConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.CustomCanaryDeployment.PhaseConfig"
        }
    }
}

/// KubernetesConfig contains the Kubernetes runtime configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KubernetesConfig {
    /// The service definition configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub service_definition: std::option::Option<crate::model::kubernetes_config::ServiceDefinition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition].
    ///
    /// Note that all the setters affecting `service_definition` are mutually
    /// exclusive.
    pub fn set_service_definition<
        T: std::convert::Into<std::option::Option<crate::model::kubernetes_config::ServiceDefinition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = v.into();
        self
    }

    /// The value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// if it holds a `GatewayServiceMesh`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gateway_service_mesh(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>>
    {
        #[allow(unreachable_patterns)]
        self.service_definition.as_ref().and_then(|v| match v {
            crate::model::kubernetes_config::ServiceDefinition::GatewayServiceMesh(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// to hold a `GatewayServiceMesh`.
    ///
    /// Note that all the setters affecting `service_definition` are
    /// mutually exclusive.
    pub fn set_gateway_service_mesh<
        T: std::convert::Into<std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = std::option::Option::Some(
            crate::model::kubernetes_config::ServiceDefinition::GatewayServiceMesh(v.into()),
        );
        self
    }

    /// The value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// if it holds a `ServiceNetworking`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_networking(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>>
    {
        #[allow(unreachable_patterns)]
        self.service_definition.as_ref().and_then(|v| match v {
            crate::model::kubernetes_config::ServiceDefinition::ServiceNetworking(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [service_definition][crate::model::KubernetesConfig::service_definition]
    /// to hold a `ServiceNetworking`.
    ///
    /// Note that all the setters affecting `service_definition` are
    /// mutually exclusive.
    pub fn set_service_networking<
        T: std::convert::Into<std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_definition = std::option::Option::Some(
            crate::model::kubernetes_config::ServiceDefinition::ServiceNetworking(v.into()),
        );
        self
    }
}

impl wkt::message::Message for KubernetesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig"
    }
}

/// Defines additional types related to [KubernetesConfig].
pub mod kubernetes_config {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the Kubernetes Gateway API service mesh configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GatewayServiceMesh {
        /// Required. Name of the Gateway API HTTPRoute.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub http_route: std::string::String,

        /// Required. Name of the Kubernetes Service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub service: std::string::String,

        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified HTTPRoute and Service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub deployment: std::string::String,

        /// Optional. The time to wait for route updates to propagate. The maximum
        /// configurable time is 3 hours, in seconds format. If unspecified, there is
        /// no wait time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub route_update_wait_time: std::option::Option<wkt::Duration>,

        /// Optional. The amount of time to migrate traffic back from the canary
        /// Service to the original Service during the stable phase deployment. If
        /// specified, must be between 15s and 3600s. If unspecified, there is no
        /// cutback time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stable_cutback_duration: std::option::Option<wkt::Duration>,

        /// Optional. The label to use when selecting Pods for the Deployment and
        /// Service resources. This label must already be present in both resources.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub pod_selector_label: std::string::String,

        /// Optional. Route destinations allow configuring the Gateway API HTTPRoute
        /// to be deployed to additional clusters. This option is available for
        /// multi-cluster service mesh set ups that require the route to exist in the
        /// clusters that call the service. If unspecified, the HTTPRoute will only
        /// be deployed to the Target cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub route_destinations: std::option::Option<
            crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GatewayServiceMesh {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [http_route][crate::model::kubernetes_config::GatewayServiceMesh::http_route].
        pub fn set_http_route<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.http_route = v.into();
            self
        }

        /// Sets the value of [service][crate::model::kubernetes_config::GatewayServiceMesh::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [deployment][crate::model::kubernetes_config::GatewayServiceMesh::deployment].
        pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.deployment = v.into();
            self
        }

        /// Sets the value of [route_update_wait_time][crate::model::kubernetes_config::GatewayServiceMesh::route_update_wait_time].
        pub fn set_route_update_wait_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.route_update_wait_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [route_update_wait_time][crate::model::kubernetes_config::GatewayServiceMesh::route_update_wait_time].
        pub fn set_or_clear_route_update_wait_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.route_update_wait_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stable_cutback_duration][crate::model::kubernetes_config::GatewayServiceMesh::stable_cutback_duration].
        pub fn set_stable_cutback_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.stable_cutback_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [stable_cutback_duration][crate::model::kubernetes_config::GatewayServiceMesh::stable_cutback_duration].
        pub fn set_or_clear_stable_cutback_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.stable_cutback_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [pod_selector_label][crate::model::kubernetes_config::GatewayServiceMesh::pod_selector_label].
        pub fn set_pod_selector_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pod_selector_label = v.into();
            self
        }

        /// Sets the value of [route_destinations][crate::model::kubernetes_config::GatewayServiceMesh::route_destinations].
        pub fn set_route_destinations<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
                >,
        {
            self.route_destinations = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [route_destinations][crate::model::kubernetes_config::GatewayServiceMesh::route_destinations].
        pub fn set_or_clear_route_destinations<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations,
                >,
        {
            self.route_destinations = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GatewayServiceMesh {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.GatewayServiceMesh"
        }
    }

    /// Defines additional types related to [GatewayServiceMesh].
    pub mod gateway_service_mesh {
        #[allow(unused_imports)]
        use super::*;

        /// Information about route destinations for the Gateway API service mesh.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RouteDestinations {
            /// Required. The clusters where the Gateway API HTTPRoute resource will be
            /// deployed to. Valid entries include the associated entities IDs
            /// configured in the Target resource and "@self" to include the Target
            /// cluster.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
            pub destination_ids: std::vec::Vec<std::string::String>,

            /// Optional. Whether to propagate the Kubernetes Service to the route
            /// destination clusters. The Service will always be deployed to the Target
            /// cluster even if the HTTPRoute is not. This option may be used to
            /// facilitate successful DNS lookup in the route destination clusters. Can
            /// only be set to true if destinations are specified.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DefaultOnNull<_>")]
            pub propagate_service: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RouteDestinations {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [destination_ids][crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations::destination_ids].
            pub fn set_destination_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.destination_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [propagate_service][crate::model::kubernetes_config::gateway_service_mesh::RouteDestinations::propagate_service].
            pub fn set_propagate_service<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.propagate_service = v.into();
                self
            }
        }

        impl wkt::message::Message for RouteDestinations {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.GatewayServiceMesh.RouteDestinations"
            }
        }
    }

    /// Information about the Kubernetes Service networking configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ServiceNetworking {
        /// Required. Name of the Kubernetes Service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub service: std::string::String,

        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified Service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub deployment: std::string::String,

        /// Optional. Whether to disable Pod overprovisioning. If Pod
        /// overprovisioning is disabled then Cloud Deploy will limit the number of
        /// total Pods used for the deployment strategy to the number of Pods the
        /// Deployment has on the cluster.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub disable_pod_overprovisioning: bool,

        /// Optional. The label to use when selecting Pods for the Deployment
        /// resource. This label must already be present in the Deployment.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub pod_selector_label: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServiceNetworking {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::kubernetes_config::ServiceNetworking::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [deployment][crate::model::kubernetes_config::ServiceNetworking::deployment].
        pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.deployment = v.into();
            self
        }

        /// Sets the value of [disable_pod_overprovisioning][crate::model::kubernetes_config::ServiceNetworking::disable_pod_overprovisioning].
        pub fn set_disable_pod_overprovisioning<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_pod_overprovisioning = v.into();
            self
        }

        /// Sets the value of [pod_selector_label][crate::model::kubernetes_config::ServiceNetworking::pod_selector_label].
        pub fn set_pod_selector_label<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pod_selector_label = v.into();
            self
        }
    }

    impl wkt::message::Message for ServiceNetworking {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.KubernetesConfig.ServiceNetworking"
        }
    }

    /// The service definition configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ServiceDefinition {
        /// Optional. Kubernetes Gateway API service mesh configuration.
        GatewayServiceMesh(std::boxed::Box<crate::model::kubernetes_config::GatewayServiceMesh>),
        /// Optional. Kubernetes Service networking configuration.
        ServiceNetworking(std::boxed::Box<crate::model::kubernetes_config::ServiceNetworking>),
    }
}

/// CloudRunConfig contains the Cloud Run runtime configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunConfig {
    /// Optional. Whether Cloud Deploy should update the traffic stanza in a Cloud
    /// Run Service on the user's behalf to facilitate traffic splitting. This is
    /// required to be true for CanaryDeployments, but optional for
    /// CustomCanaryDeployments.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automatic_traffic_control: bool,

    /// Optional. A list of tags that are added to the canary revision while the
    /// canary phase is in progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub canary_revision_tags: std::vec::Vec<std::string::String>,

    /// Optional. A list of tags that are added to the prior revision while the
    /// canary phase is in progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub prior_revision_tags: std::vec::Vec<std::string::String>,

    /// Optional. A list of tags that are added to the final stable revision when
    /// the stable phase is applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub stable_revision_tags: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic_traffic_control][crate::model::CloudRunConfig::automatic_traffic_control].
    pub fn set_automatic_traffic_control<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.automatic_traffic_control = v.into();
        self
    }

    /// Sets the value of [canary_revision_tags][crate::model::CloudRunConfig::canary_revision_tags].
    pub fn set_canary_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.canary_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [prior_revision_tags][crate::model::CloudRunConfig::prior_revision_tags].
    pub fn set_prior_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prior_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stable_revision_tags][crate::model::CloudRunConfig::stable_revision_tags].
    pub fn set_stable_revision_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.stable_revision_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudRunConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunConfig"
    }
}

/// RuntimeConfig contains the runtime specific configurations for a deployment
/// strategy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// The runtime configuration details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::runtime_config::RuntimeConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config].
    ///
    /// Note that all the setters affecting `runtime_config` are mutually
    /// exclusive.
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::runtime_config::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// The value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// if it holds a `Kubernetes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kubernetes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KubernetesConfig>> {
        #[allow(unreachable_patterns)]
        self.runtime_config.as_ref().and_then(|v| match v {
            crate::model::runtime_config::RuntimeConfig::Kubernetes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// to hold a `Kubernetes`.
    ///
    /// Note that all the setters affecting `runtime_config` are
    /// mutually exclusive.
    pub fn set_kubernetes<
        T: std::convert::Into<std::boxed::Box<crate::model::KubernetesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = std::option::Option::Some(
            crate::model::runtime_config::RuntimeConfig::Kubernetes(v.into()),
        );
        self
    }

    /// The value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// if it holds a `CloudRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunConfig>> {
        #[allow(unreachable_patterns)]
        self.runtime_config.as_ref().and_then(|v| match v {
            crate::model::runtime_config::RuntimeConfig::CloudRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime_config][crate::model::RuntimeConfig::runtime_config]
    /// to hold a `CloudRun`.
    ///
    /// Note that all the setters affecting `runtime_config` are
    /// mutually exclusive.
    pub fn set_cloud_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRunConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = std::option::Option::Some(
            crate::model::runtime_config::RuntimeConfig::CloudRun(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RuntimeConfig"
    }
}

/// Defines additional types related to [RuntimeConfig].
pub mod runtime_config {
    #[allow(unused_imports)]
    use super::*;

    /// The runtime configuration details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuntimeConfig {
        /// Optional. Kubernetes runtime configuration.
        Kubernetes(std::boxed::Box<crate::model::KubernetesConfig>),
        /// Optional. Cloud Run runtime configuration.
        CloudRun(std::boxed::Box<crate::model::CloudRunConfig>),
    }
}

/// PipelineReadyCondition contains information around the status of the
/// Pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineReadyCondition {
    /// True if the Pipeline is in a valid state. Otherwise at least one condition
    /// in `PipelineCondition` is in an invalid state. Iterate over those
    /// conditions and see which condition(s) has status = false to find out what
    /// is wrong with the Pipeline.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: bool,

    /// Last time the condition was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PipelineReadyCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::PipelineReadyCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PipelineReadyCondition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PipelineReadyCondition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PipelineReadyCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PipelineReadyCondition"
    }
}

/// `TargetsPresentCondition` contains information on any Targets referenced in
/// the Delivery Pipeline that do not actually exist.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetsPresentCondition {
    /// True if there aren't any missing Targets.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: bool,

    /// The list of Target names that do not exist. For example,
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub missing_targets: std::vec::Vec<std::string::String>,

    /// Last time the condition was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetsPresentCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TargetsPresentCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [missing_targets][crate::model::TargetsPresentCondition::missing_targets].
    pub fn set_missing_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::TargetsPresentCondition::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetsPresentCondition::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetsPresentCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetsPresentCondition"
    }
}

/// TargetsTypeCondition contains information on whether the Targets defined in
/// the Delivery Pipeline are of the same type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetsTypeCondition {
    /// True if the targets are all a comparable type. For example this is true if
    /// all targets are GKE clusters. This is false if some targets are Cloud Run
    /// targets and others are GKE clusters.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status: bool,

    /// Human readable error message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub error_details: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetsTypeCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TargetsTypeCondition::status].
    pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [error_details][crate::model::TargetsTypeCondition::error_details].
    pub fn set_error_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_details = v.into();
        self
    }
}

impl wkt::message::Message for TargetsTypeCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetsTypeCondition"
    }
}

/// PipelineCondition contains all conditions relevant to a Delivery Pipeline.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PipelineCondition {
    /// Details around the Pipeline's overall status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pipeline_ready_condition: std::option::Option<crate::model::PipelineReadyCondition>,

    /// Details around targets enumerated in the pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub targets_present_condition: std::option::Option<crate::model::TargetsPresentCondition>,

    /// Details on the whether the targets enumerated in the pipeline are of the
    /// same type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub targets_type_condition: std::option::Option<crate::model::TargetsTypeCondition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PipelineCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pipeline_ready_condition][crate::model::PipelineCondition::pipeline_ready_condition].
    pub fn set_pipeline_ready_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PipelineReadyCondition>,
    {
        self.pipeline_ready_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pipeline_ready_condition][crate::model::PipelineCondition::pipeline_ready_condition].
    pub fn set_or_clear_pipeline_ready_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PipelineReadyCondition>,
    {
        self.pipeline_ready_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_present_condition][crate::model::PipelineCondition::targets_present_condition].
    pub fn set_targets_present_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_present_condition][crate::model::PipelineCondition::targets_present_condition].
    pub fn set_or_clear_targets_present_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_type_condition][crate::model::PipelineCondition::targets_type_condition].
    pub fn set_targets_type_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsTypeCondition>,
    {
        self.targets_type_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_type_condition][crate::model::PipelineCondition::targets_type_condition].
    pub fn set_or_clear_targets_type_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsTypeCondition>,
    {
        self.targets_type_condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PipelineCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PipelineCondition"
    }
}

/// The request object for `ListDeliveryPipelines`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeliveryPipelinesRequest {
    /// Required. The parent, which owns this collection of pipelines. Format must
    /// be `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of pipelines to return. The service may return
    /// fewer than this value. If unspecified, at most 50 pipelines will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListDeliveryPipelines` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter pipelines to be returned. See <https://google.aip.dev/160> for more
    /// details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeliveryPipelinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeliveryPipelinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeliveryPipelinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeliveryPipelinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeliveryPipelinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeliveryPipelinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDeliveryPipelinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeliveryPipelinesRequest"
    }
}

/// The response object from `ListDeliveryPipelines`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeliveryPipelinesResponse {
    /// The `DeliveryPipeline` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub delivery_pipelines: std::vec::Vec<crate::model::DeliveryPipeline>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeliveryPipelinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [delivery_pipelines][crate::model::ListDeliveryPipelinesResponse::delivery_pipelines].
    pub fn set_delivery_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        use std::iter::Iterator;
        self.delivery_pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeliveryPipelinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDeliveryPipelinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeliveryPipelinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeliveryPipelinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeliveryPipelinesResponse {
    type PageItem = crate::model::DeliveryPipeline;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.delivery_pipelines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetDeliveryPipeline`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeliveryPipelineRequest {
    /// Required. Name of the `DeliveryPipeline`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeliveryPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetDeliveryPipelineRequest"
    }
}

/// The request object for `CreateDeliveryPipeline`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeliveryPipelineRequest {
    /// Required. The parent collection in which the `DeliveryPipeline` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub delivery_pipeline_id: std::string::String,

    /// Required. The `DeliveryPipeline` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipeline>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeliveryPipelineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline_id][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline_id].
    pub fn set_delivery_pipeline_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline_id = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::CreateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateDeliveryPipelineRequest"
    }
}

/// The request object for `UpdateDeliveryPipeline`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeliveryPipelineRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `DeliveryPipeline` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `DeliveryPipeline` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipeline>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `DeliveryPipeline` that does not exist
    /// will result in the creation of a new `DeliveryPipeline`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeliveryPipelineRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeliveryPipelineRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::UpdateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::UpdateDeliveryPipelineRequest::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDeliveryPipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateDeliveryPipelineRequest"
    }
}

/// The request object for `DeleteDeliveryPipeline`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeliveryPipelineRequest {
    /// Required. The name of the `DeliveryPipeline` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `DeliveryPipeline` will succeed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. If set to true, all child resources under this pipeline will also
    /// be deleted. Otherwise, the request will only work if the pipeline has no
    /// child resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub force: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeliveryPipelineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeliveryPipelineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDeliveryPipelineRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteDeliveryPipelineRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteDeliveryPipelineRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteDeliveryPipelineRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDeliveryPipelineRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeliveryPipelineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteDeliveryPipelineRequest"
    }
}

/// Configs for the Rollback rollout.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackTargetConfig {
    /// Optional. The rollback `Rollout` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::Rollout>,

    /// Optional. The starting phase ID for the `Rollout`. If unspecified, the
    /// `Rollout` will start in the stable phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub starting_phase_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RollbackTargetConfig::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::RollbackTargetConfig::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [starting_phase_id][crate::model::RollbackTargetConfig::starting_phase_id].
    pub fn set_starting_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.starting_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackTargetConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetConfig"
    }
}

/// The request object for `RollbackTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackTargetRequest {
    /// Required. The `DeliveryPipeline` for which the rollback `Rollout` must be
    /// created. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. ID of the `Target` that is being rolled back.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Required. ID of the rollback `Rollout` to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_id: std::string::String,

    /// Optional. ID of the `Release` to roll back to. If this isn't specified, the
    /// previous successful `Rollout` to the specified target will be used to
    /// determine the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_id: std::string::String,

    /// Optional. If provided, this must be the latest `Rollout` that is on the
    /// `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_to_roll_back: std::string::String,

    /// Optional. Configs for the rollback `Rollout`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollback_config: std::option::Option<crate::model::RollbackTargetConfig>,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with a `RollbackTargetResponse`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deploy_policy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RollbackTargetRequest::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::RollbackTargetRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [release_id][crate::model::RollbackTargetRequest::release_id].
    pub fn set_release_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_id = v.into();
        self
    }

    /// Sets the value of [rollout_to_roll_back][crate::model::RollbackTargetRequest::rollout_to_roll_back].
    pub fn set_rollout_to_roll_back<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_to_roll_back = v.into();
        self
    }

    /// Sets the value of [rollback_config][crate::model::RollbackTargetRequest::rollback_config].
    pub fn set_rollback_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollback_config][crate::model::RollbackTargetRequest::rollback_config].
    pub fn set_or_clear_rollback_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::RollbackTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::RollbackTargetRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RollbackTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetRequest"
    }
}

/// The response object from `RollbackTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackTargetResponse {
    /// The config of the rollback `Rollout` created or will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollback_config: std::option::Option<crate::model::RollbackTargetConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackTargetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollback_config][crate::model::RollbackTargetResponse::rollback_config].
    pub fn set_rollback_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollback_config][crate::model::RollbackTargetResponse::rollback_config].
    pub fn set_or_clear_rollback_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RollbackTargetConfig>,
    {
        self.rollback_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RollbackTargetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackTargetResponse"
    }
}

/// A `Target` resource in the Cloud Deploy API.
///
/// A `Target` defines a location to which a Skaffold configuration
/// can be deployed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Target {
    /// Identifier. Name of the `Target`. Format is
    /// `projects/{project}/locations/{location}/targets/{target}`.
    /// The `target` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Resource id of the `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Output only. Unique identifier of the `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `Target`. Max length is 255 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Whether or not the `Target` requires approval.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub require_approval: bool,

    /// Output only. Time at which the `Target` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the `Target` was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Map of entity IDs to their associated entities. Associated
    /// entities allows specifying places other than the deployment target for
    /// specific features. For example, the Gateway API canary can be configured to
    /// deploy the HTTPRoute to a different cluster(s) than the deployment cluster
    /// using associated entities. An entity ID must consist of lower-case letters,
    /// numbers, and hyphens, start with a letter and end with a letter or a
    /// number, and have a max length of 63 characters. In other words, it must
    /// match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub associated_entities:
        std::collections::HashMap<std::string::String, crate::model::AssociatedEntities>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Optional. Configurations for all execution that relates to this `Target`.
    /// Each `ExecutionEnvironmentUsage` value may only be used in a single
    /// configuration; using the same value multiple times is an error.
    /// When one or more configurations are specified, they must include the
    /// `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values.
    /// When no configurations are specified, execution will use the default
    /// specified in `DefaultPool`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub execution_configs: std::vec::Vec<crate::model::ExecutionConfig>,

    /// Optional. The deploy parameters to use for this target.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub deploy_parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_target: std::option::Option<crate::model::target::DeploymentTarget>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Target {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Target::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::Target::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Target::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Target::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Target::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Target::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [require_approval][crate::model::Target::require_approval].
    pub fn set_require_approval<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_approval = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Target::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Target::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Target::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Target::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [associated_entities][crate::model::Target::associated_entities].
    pub fn set_associated_entities<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::AssociatedEntities>,
    {
        use std::iter::Iterator;
        self.associated_entities = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Target::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [execution_configs][crate::model::Target::execution_configs].
    pub fn set_execution_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExecutionConfig>,
    {
        use std::iter::Iterator;
        self.execution_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Target::deploy_parameters].
    pub fn set_deploy_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target].
    ///
    /// Note that all the setters affecting `deployment_target` are mutually
    /// exclusive.
    pub fn set_deployment_target<
        T: std::convert::Into<std::option::Option<crate::model::target::DeploymentTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = v.into();
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `Gke`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke(&self) -> std::option::Option<&std::boxed::Box<crate::model::GkeCluster>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::Gke(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `Gke`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_gke<T: std::convert::Into<std::boxed::Box<crate::model::GkeCluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target =
            std::option::Option::Some(crate::model::target::DeploymentTarget::Gke(v.into()));
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `AnthosCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn anthos_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AnthosCluster>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::AnthosCluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `AnthosCluster`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_anthos_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::AnthosCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::AnthosCluster(v.into()),
        );
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `Run`, `None` if the field is not set or
    /// holds a different branch.
    pub fn run(&self) -> std::option::Option<&std::boxed::Box<crate::model::CloudRunLocation>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::Run(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `Run`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_run<T: std::convert::Into<std::boxed::Box<crate::model::CloudRunLocation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target =
            std::option::Option::Some(crate::model::target::DeploymentTarget::Run(v.into()));
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `MultiTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_target(&self) -> std::option::Option<&std::boxed::Box<crate::model::MultiTarget>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::MultiTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `MultiTarget`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_multi_target<T: std::convert::Into<std::boxed::Box<crate::model::MultiTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::MultiTarget(v.into()),
        );
        self
    }

    /// The value of [deployment_target][crate::model::Target::deployment_target]
    /// if it holds a `CustomTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomTarget>> {
        #[allow(unreachable_patterns)]
        self.deployment_target.as_ref().and_then(|v| match v {
            crate::model::target::DeploymentTarget::CustomTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [deployment_target][crate::model::Target::deployment_target]
    /// to hold a `CustomTarget`.
    ///
    /// Note that all the setters affecting `deployment_target` are
    /// mutually exclusive.
    pub fn set_custom_target<T: std::convert::Into<std::boxed::Box<crate::model::CustomTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_target = std::option::Option::Some(
            crate::model::target::DeploymentTarget::CustomTarget(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Target {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Target"
    }
}

/// Defines additional types related to [Target].
pub mod target {
    #[allow(unused_imports)]
    use super::*;

    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DeploymentTarget {
        /// Optional. Information specifying a GKE Cluster.
        Gke(std::boxed::Box<crate::model::GkeCluster>),
        /// Optional. Information specifying an Anthos Cluster.
        AnthosCluster(std::boxed::Box<crate::model::AnthosCluster>),
        /// Optional. Information specifying a Cloud Run deployment target.
        Run(std::boxed::Box<crate::model::CloudRunLocation>),
        /// Optional. Information specifying a multiTarget.
        MultiTarget(std::boxed::Box<crate::model::MultiTarget>),
        /// Optional. Information specifying a Custom Target.
        CustomTarget(std::boxed::Box<crate::model::CustomTarget>),
    }
}

/// Configuration of the environment to use when calling Skaffold.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutionConfig {
    /// Required. Usages when this configuration should be applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub usages: std::vec::Vec<crate::model::execution_config::ExecutionEnvironmentUsage>,

    /// Optional. The resource name of the `WorkerPool`, with the format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// If this optional field is unspecified, the default Cloud Build pool will be
    /// used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool: std::string::String,

    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location in which to store execution outputs. This
    /// can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_storage: std::string::String,

    /// Optional. Execution timeout for a Cloud Build Execution. This must be
    /// between 10m and 24h in seconds format. If unspecified, a default timeout of
    /// 1h is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_timeout: std::option::Option<wkt::Duration>,

    /// Optional. If true, additional logging will be enabled when running builds
    /// in this execution environment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verbose: bool,

    /// Details of the environment.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub execution_environment:
        std::option::Option<crate::model::execution_config::ExecutionEnvironment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [usages][crate::model::ExecutionConfig::usages].
    pub fn set_usages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::execution_config::ExecutionEnvironmentUsage>,
    {
        use std::iter::Iterator;
        self.usages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [worker_pool][crate::model::ExecutionConfig::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::ExecutionConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::ExecutionConfig::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::ExecutionConfig::execution_timeout].
    pub fn set_execution_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_timeout][crate::model::ExecutionConfig::execution_timeout].
    pub fn set_or_clear_execution_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verbose][crate::model::ExecutionConfig::verbose].
    pub fn set_verbose<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.verbose = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment].
    ///
    /// Note that all the setters affecting `execution_environment` are mutually
    /// exclusive.
    pub fn set_execution_environment<
        T: std::convert::Into<
                std::option::Option<crate::model::execution_config::ExecutionEnvironment>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// The value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// if it holds a `DefaultPool`, `None` if the field is not set or
    /// holds a different branch.
    pub fn default_pool(&self) -> std::option::Option<&std::boxed::Box<crate::model::DefaultPool>> {
        #[allow(unreachable_patterns)]
        self.execution_environment.as_ref().and_then(|v| match v {
            crate::model::execution_config::ExecutionEnvironment::DefaultPool(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// to hold a `DefaultPool`.
    ///
    /// Note that all the setters affecting `execution_environment` are
    /// mutually exclusive.
    pub fn set_default_pool<T: std::convert::Into<std::boxed::Box<crate::model::DefaultPool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = std::option::Option::Some(
            crate::model::execution_config::ExecutionEnvironment::DefaultPool(v.into()),
        );
        self
    }

    /// The value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// if it holds a `PrivatePool`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_pool(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrivatePool>> {
        #[allow(unreachable_patterns)]
        self.execution_environment.as_ref().and_then(|v| match v {
            crate::model::execution_config::ExecutionEnvironment::PrivatePool(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_environment][crate::model::ExecutionConfig::execution_environment]
    /// to hold a `PrivatePool`.
    ///
    /// Note that all the setters affecting `execution_environment` are
    /// mutually exclusive.
    pub fn set_private_pool<T: std::convert::Into<std::boxed::Box<crate::model::PrivatePool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = std::option::Option::Some(
            crate::model::execution_config::ExecutionEnvironment::PrivatePool(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecutionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ExecutionConfig"
    }
}

/// Defines additional types related to [ExecutionConfig].
pub mod execution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible usages of this configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionEnvironmentUsage {
        /// Default value. This value is unused.
        Unspecified,
        /// Use for rendering.
        Render,
        /// Use for deploying and deployment hooks.
        Deploy,
        /// Use for deployment verification.
        Verify,
        /// Use for predeploy job execution.
        Predeploy,
        /// Use for postdeploy job execution.
        Postdeploy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionEnvironmentUsage::value] or
        /// [ExecutionEnvironmentUsage::name].
        UnknownValue(execution_environment_usage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_environment_usage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionEnvironmentUsage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Render => std::option::Option::Some(1),
                Self::Deploy => std::option::Option::Some(2),
                Self::Verify => std::option::Option::Some(3),
                Self::Predeploy => std::option::Option::Some(4),
                Self::Postdeploy => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED")
                }
                Self::Render => std::option::Option::Some("RENDER"),
                Self::Deploy => std::option::Option::Some("DEPLOY"),
                Self::Verify => std::option::Option::Some("VERIFY"),
                Self::Predeploy => std::option::Option::Some("PREDEPLOY"),
                Self::Postdeploy => std::option::Option::Some("POSTDEPLOY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionEnvironmentUsage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionEnvironmentUsage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionEnvironmentUsage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Render,
                2 => Self::Deploy,
                3 => Self::Verify,
                4 => Self::Predeploy,
                5 => Self::Postdeploy,
                _ => Self::UnknownValue(execution_environment_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionEnvironmentUsage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED" => Self::Unspecified,
                "RENDER" => Self::Render,
                "DEPLOY" => Self::Deploy,
                "VERIFY" => Self::Verify,
                "PREDEPLOY" => Self::Predeploy,
                "POSTDEPLOY" => Self::Postdeploy,
                _ => Self::UnknownValue(execution_environment_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionEnvironmentUsage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Render => serializer.serialize_i32(1),
                Self::Deploy => serializer.serialize_i32(2),
                Self::Verify => serializer.serialize_i32(3),
                Self::Predeploy => serializer.serialize_i32(4),
                Self::Postdeploy => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionEnvironmentUsage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ExecutionEnvironmentUsage>::new(
                    ".google.cloud.deploy.v1.ExecutionConfig.ExecutionEnvironmentUsage",
                ),
            )
        }
    }

    /// Details of the environment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ExecutionEnvironment {
        /// Optional. Use default Cloud Build pool.
        DefaultPool(std::boxed::Box<crate::model::DefaultPool>),
        /// Optional. Use private Cloud Build pool.
        PrivatePool(std::boxed::Box<crate::model::PrivatePool>),
    }
}

/// Execution using the default Cloud Build pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DefaultPool {
    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_storage: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DefaultPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::DefaultPool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::DefaultPool::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }
}

impl wkt::message::Message for DefaultPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DefaultPool"
    }
}

/// Execution using a private Cloud Build pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivatePool {
    /// Required. Resource name of the Cloud Build worker pool to use. The format
    /// is `projects/{project}/locations/{location}/workerPools/{pool}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub worker_pool: std::string::String,

    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_storage: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivatePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [worker_pool][crate::model::PrivatePool::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::PrivatePool::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::PrivatePool::artifact_storage].
    pub fn set_artifact_storage<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }
}

impl wkt::message::Message for PrivatePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PrivatePool"
    }
}

/// Information specifying a GKE Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GkeCluster {
    /// Optional. Information specifying a GKE Cluster. Format is
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub cluster: std::string::String,

    /// Optional. If true, `cluster` is accessed using the private IP address of
    /// the control plane endpoint. Otherwise, the default IP address of the
    /// control plane endpoint is used. The default IP address is the private IP
    /// address for clusters with private control-plane endpoints and the public IP
    /// address otherwise.
    ///
    /// Only specify this option when `cluster` is a [private GKE
    /// cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
    /// Note that `internal_ip` and `dns_endpoint` cannot both be set to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub internal_ip: bool,

    /// Optional. If set, used to configure a
    /// [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy)
    /// to the Kubernetes server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub proxy_url: std::string::String,

    /// Optional. If set, the cluster will be accessed using the DNS endpoint. Note
    /// that both `dns_endpoint` and `internal_ip` cannot be set to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub dns_endpoint: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GkeCluster::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::GkeCluster::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [proxy_url][crate::model::GkeCluster::proxy_url].
    pub fn set_proxy_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_url = v.into();
        self
    }

    /// Sets the value of [dns_endpoint][crate::model::GkeCluster::dns_endpoint].
    pub fn set_dns_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dns_endpoint = v.into();
        self
    }
}

impl wkt::message::Message for GkeCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GkeCluster"
    }
}

/// Information specifying an Anthos Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnthosCluster {
    /// Optional. Membership of the GKE Hub-registered cluster to which to apply
    /// the Skaffold configuration. Format is
    /// `projects/{project}/locations/{location}/memberships/{membership_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub membership: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnthosCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [membership][crate::model::AnthosCluster::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for AnthosCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AnthosCluster"
    }
}

/// Information specifying where to deploy a Cloud Run Service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunLocation {
    /// Required. The location for the Cloud Run Service. Format must be
    /// `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::CloudRunLocation::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunLocation"
    }
}

/// Information specifying a multiTarget.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MultiTarget {
    /// Required. The target_ids of this multiTarget.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub target_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_ids][crate::model::MultiTarget::target_ids].
    pub fn set_target_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MultiTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.MultiTarget"
    }
}

/// Information specifying a Custom Target.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTarget {
    /// Required. The name of the CustomTargetType. Format must be
    /// `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub custom_target_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_target_type][crate::model::CustomTarget::custom_target_type].
    pub fn set_custom_target_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type = v.into();
        self
    }
}

impl wkt::message::Message for CustomTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTarget"
    }
}

/// Information about entities associated with a `Target`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssociatedEntities {
    /// Optional. Information specifying GKE clusters as associated entities.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub gke_clusters: std::vec::Vec<crate::model::GkeCluster>,

    /// Optional. Information specifying Anthos clusters as associated entities.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub anthos_clusters: std::vec::Vec<crate::model::AnthosCluster>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssociatedEntities {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_clusters][crate::model::AssociatedEntities::gke_clusters].
    pub fn set_gke_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GkeCluster>,
    {
        use std::iter::Iterator;
        self.gke_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [anthos_clusters][crate::model::AssociatedEntities::anthos_clusters].
    pub fn set_anthos_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnthosCluster>,
    {
        use std::iter::Iterator;
        self.anthos_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssociatedEntities {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AssociatedEntities"
    }
}

/// The request object for `ListTargets`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetsRequest {
    /// Required. The parent, which owns this collection of targets. Format must be
    /// `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `Target` objects to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Target` objects
    /// will be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter targets to be returned. See <https://google.aip.dev/160> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTargetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTargetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListTargetsRequest"
    }
}

/// The response object from `ListTargets`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetsResponse {
    /// The `Target` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub targets: std::vec::Vec<crate::model::Target>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets][crate::model::ListTargetsResponse::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Target>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTargetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTargetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListTargetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetsResponse {
    type PageItem = crate::model::Target;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.targets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTargetRequest {
    /// Required. Name of the `Target`. Format must be
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetTargetRequest"
    }
}

/// The request object for `CreateTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTargetRequest {
    /// Required. The parent collection in which the `Target` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Required. The `Target` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::Target>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::CreateTargetRequest::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [target][crate::model::CreateTargetRequest::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::CreateTargetRequest::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateTargetRequest"
    }
}

/// The request object for `UpdateTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTargetRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `Target` resource. The fields specified in the update_mask
    /// are relative to the resource, not the full request. A field will be
    /// overwritten if it's in the mask. If the user doesn't provide a mask then
    /// all fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `Target` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::Target>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `Target` that does not exist will
    /// result in the creation of a new `Target`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTargetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTargetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::UpdateTargetRequest::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::UpdateTargetRequest::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateTargetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateTargetRequest"
    }
}

/// The request object for `DeleteTarget`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTargetRequest {
    /// Required. The name of the `Target` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `Target` will succeed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTargetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteTargetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteTargetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteTargetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteTargetRequest"
    }
}

/// A `CustomTargetType` resource in the Cloud Deploy API.
///
/// A `CustomTargetType` defines a type of custom target that can be referenced
/// in a `Target` in order to facilitate deploying to other systems besides the
/// supported runtimes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTargetType {
    /// Identifier. Name of the `CustomTargetType`. Format is
    /// `projects/{project}/locations/{location}/customTargetTypes/{customTargetType}`.
    /// The `customTargetType` component must match
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Resource id of the `CustomTargetType`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub custom_target_type_id: std::string::String,

    /// Output only. Unique identifier of the `CustomTargetType`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `CustomTargetType`. Max length is 255
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the `CustomTargetType` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the `CustomTargetType` was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Defines the `CustomTargetType` renderer and deployer.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub definition: std::option::Option<crate::model::custom_target_type::Definition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomTargetType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [custom_target_type_id][crate::model::CustomTargetType::custom_target_type_id].
    pub fn set_custom_target_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_id = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::CustomTargetType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CustomTargetType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::CustomTargetType::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::CustomTargetType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomTargetType::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CustomTargetType::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CustomTargetType::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CustomTargetType::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::CustomTargetType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::CustomTargetType::definition].
    ///
    /// Note that all the setters affecting `definition` are mutually
    /// exclusive.
    pub fn set_definition<
        T: std::convert::Into<std::option::Option<crate::model::custom_target_type::Definition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.definition = v.into();
        self
    }

    /// The value of [definition][crate::model::CustomTargetType::definition]
    /// if it holds a `CustomActions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_actions(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CustomTargetSkaffoldActions>> {
        #[allow(unreachable_patterns)]
        self.definition.as_ref().and_then(|v| match v {
            crate::model::custom_target_type::Definition::CustomActions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [definition][crate::model::CustomTargetType::definition]
    /// to hold a `CustomActions`.
    ///
    /// Note that all the setters affecting `definition` are
    /// mutually exclusive.
    pub fn set_custom_actions<
        T: std::convert::Into<std::boxed::Box<crate::model::CustomTargetSkaffoldActions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.definition = std::option::Option::Some(
            crate::model::custom_target_type::Definition::CustomActions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CustomTargetType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetType"
    }
}

/// Defines additional types related to [CustomTargetType].
pub mod custom_target_type {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the `CustomTargetType` renderer and deployer.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Definition {
        /// Optional. Configures render and deploy for the `CustomTargetType` using
        /// Skaffold custom actions.
        CustomActions(std::boxed::Box<crate::model::CustomTargetSkaffoldActions>),
    }
}

/// CustomTargetSkaffoldActions represents the `CustomTargetType` configuration
/// using Skaffold custom actions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTargetSkaffoldActions {
    /// Optional. The Skaffold custom action responsible for render operations. If
    /// not provided then Cloud Deploy will perform the render operations via
    /// `skaffold render`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub render_action: std::string::String,

    /// Required. The Skaffold custom action responsible for deploy operations.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_action: std::string::String,

    /// Optional. List of Skaffold modules Cloud Deploy will include in the
    /// Skaffold Config as required before performing diagnose.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub include_skaffold_modules: std::vec::Vec<crate::model::SkaffoldModules>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetSkaffoldActions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [render_action][crate::model::CustomTargetSkaffoldActions::render_action].
    pub fn set_render_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.render_action = v.into();
        self
    }

    /// Sets the value of [deploy_action][crate::model::CustomTargetSkaffoldActions::deploy_action].
    pub fn set_deploy_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_action = v.into();
        self
    }

    /// Sets the value of [include_skaffold_modules][crate::model::CustomTargetSkaffoldActions::include_skaffold_modules].
    pub fn set_include_skaffold_modules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SkaffoldModules>,
    {
        use std::iter::Iterator;
        self.include_skaffold_modules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomTargetSkaffoldActions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetSkaffoldActions"
    }
}

/// Skaffold Config modules and their remote source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SkaffoldModules {
    /// Optional. The Skaffold Config modules to use from the specified source.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub configs: std::vec::Vec<std::string::String>,

    /// The source that contains the Skaffold Config modules.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::skaffold_modules::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SkaffoldModules {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [configs][crate::model::SkaffoldModules::configs].
    pub fn set_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::skaffold_modules::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `Git`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::Git(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `Git`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::skaffold_modules::Source::Git(v.into()));
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `GoogleCloudStorage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cloud_storage(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::GoogleCloudStorage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `GoogleCloudStorage`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_google_cloud_storage<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::skaffold_modules::Source::GoogleCloudStorage(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::SkaffoldModules::source]
    /// if it holds a `GoogleCloudBuildRepo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cloud_build_repo(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::skaffold_modules::Source::GoogleCloudBuildRepo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SkaffoldModules::source]
    /// to hold a `GoogleCloudBuildRepo`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_google_cloud_build_repo<
        T: std::convert::Into<std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::skaffold_modules::Source::GoogleCloudBuildRepo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SkaffoldModules {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules"
    }
}

/// Defines additional types related to [SkaffoldModules].
pub mod skaffold_modules {
    #[allow(unused_imports)]
    use super::*;

    /// Git repository containing Skaffold Config modules.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SkaffoldGitSource {
        /// Required. Git repository the package should be cloned from.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repo: std::string::String,

        /// Optional. Relative path from the repository root to the Skaffold file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub path: std::string::String,

        /// Optional. Git branch or tag to use when cloning the repository.
        #[serde(rename = "ref")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub r#ref: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGitSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repo][crate::model::skaffold_modules::SkaffoldGitSource::repo].
        pub fn set_repo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repo = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGitSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [r#ref][crate::model::skaffold_modules::SkaffoldGitSource::ref].
        pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#ref = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGitSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGitSource"
        }
    }

    /// Cloud Storage bucket containing Skaffold Config modules.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SkaffoldGCSSource {
        /// Required. Cloud Storage source paths to copy recursively. For example,
        /// providing "gs://my-bucket/dir/configs/*" will result in Skaffold copying
        /// all files within the "dir/configs" directory in the bucket "my-bucket".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub source: std::string::String,

        /// Optional. Relative path from the source to the Skaffold file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGCSSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::skaffold_modules::SkaffoldGCSSource::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGCSSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGCSSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGCSSource"
        }
    }

    /// Cloud Build V2 Repository containing Skaffold Configs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SkaffoldGCBRepoSource {
        /// Required. Name of the Cloud Build V2 Repository.
        /// Format is
        /// projects/{project}/locations/{location}/connections/{connection}/repositories/{repository}.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub repository: std::string::String,

        /// Optional. Relative path from the repository root to the Skaffold Config
        /// file.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub path: std::string::String,

        /// Optional. Branch or tag to use when cloning the repository.
        #[serde(rename = "ref")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub r#ref: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldGCBRepoSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [repository][crate::model::skaffold_modules::SkaffoldGCBRepoSource::repository].
        pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.repository = v.into();
            self
        }

        /// Sets the value of [path][crate::model::skaffold_modules::SkaffoldGCBRepoSource::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [r#ref][crate::model::skaffold_modules::SkaffoldGCBRepoSource::ref].
        pub fn set_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#ref = v.into();
            self
        }
    }

    impl wkt::message::Message for SkaffoldGCBRepoSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.SkaffoldModules.SkaffoldGCBRepoSource"
        }
    }

    /// The source that contains the Skaffold Config modules.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Remote git repository containing the Skaffold Config modules.
        Git(std::boxed::Box<crate::model::skaffold_modules::SkaffoldGitSource>),
        /// Optional. Cloud Storage bucket containing the Skaffold Config modules.
        GoogleCloudStorage(std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCSSource>),
        /// Optional. Cloud Build V2 repository containing the Skaffold Config
        /// modules.
        GoogleCloudBuildRepo(
            std::boxed::Box<crate::model::skaffold_modules::SkaffoldGCBRepoSource>,
        ),
    }
}

/// The request object for `ListCustomTargetTypes`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomTargetTypesRequest {
    /// Required. The parent that owns this collection of custom target types.
    /// Format must be `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `CustomTargetType` objects to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `CustomTargetType` objects will be returned. The maximum value is 1000;
    /// values above 1000 will be set to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListCustomTargetTypes`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter custom target types to be returned. See
    /// <https://google.aip.dev/160> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomTargetTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomTargetTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomTargetTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomTargetTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomTargetTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomTargetTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomTargetTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListCustomTargetTypesRequest"
    }
}

/// The response object from `ListCustomTargetTypes.`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomTargetTypesResponse {
    /// The `CustomTargetType` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub custom_target_types: std::vec::Vec<crate::model::CustomTargetType>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomTargetTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_target_types][crate::model::ListCustomTargetTypesResponse::custom_target_types].
    pub fn set_custom_target_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomTargetType>,
    {
        use std::iter::Iterator;
        self.custom_target_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomTargetTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomTargetTypesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomTargetTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListCustomTargetTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomTargetTypesResponse {
    type PageItem = crate::model::CustomTargetType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_target_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetCustomTargetType`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomTargetTypeRequest {
    /// Required. Name of the `CustomTargetType`. Format must be
    /// `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomTargetTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetCustomTargetTypeRequest"
    }
}

/// The request object for `CreateCustomTargetType`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomTargetTypeRequest {
    /// Required. The parent collection in which the `CustomTargetType` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `CustomTargetType`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub custom_target_type_id: std::string::String,

    /// Required. The `CustomTargetType` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_target_type: std::option::Option<crate::model::CustomTargetType>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomTargetTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [custom_target_type_id][crate::model::CreateCustomTargetTypeRequest::custom_target_type_id].
    pub fn set_custom_target_type_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_id = v.into();
        self
    }

    /// Sets the value of [custom_target_type][crate::model::CreateCustomTargetTypeRequest::custom_target_type].
    pub fn set_custom_target_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target_type][crate::model::CreateCustomTargetTypeRequest::custom_target_type].
    pub fn set_or_clear_custom_target_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateCustomTargetTypeRequest"
    }
}

/// The request object for `UpdateCustomTargetType`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCustomTargetTypeRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `CustomTargetType` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `CustomTargetType` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_target_type: std::option::Option<crate::model::CustomTargetType>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `CustomTargetType` that does not exist
    /// will result in the creation of a new `CustomTargetType`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomTargetTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCustomTargetTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_target_type][crate::model::UpdateCustomTargetTypeRequest::custom_target_type].
    pub fn set_custom_target_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target_type][crate::model::UpdateCustomTargetTypeRequest::custom_target_type].
    pub fn set_or_clear_custom_target_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetType>,
    {
        self.custom_target_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateCustomTargetTypeRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateCustomTargetTypeRequest"
    }
}

/// The request object for `DeleteCustomTargetType`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomTargetTypeRequest {
    /// Required. The name of the `CustomTargetType` to delete. Format must be
    /// `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `CustomTargetType` will succeed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated but no actual change is
    /// made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomTargetTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomTargetTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCustomTargetTypeRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteCustomTargetTypeRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteCustomTargetTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteCustomTargetTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomTargetTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteCustomTargetTypeRequest"
    }
}

/// A `DeployPolicy` resource in the Cloud Deploy API.
///
/// A `DeployPolicy` inhibits manual or automation-driven actions within a
/// Delivery Pipeline or Target.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployPolicy {
    /// Output only. Name of the `DeployPolicy`. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    /// The `deployPolicy` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `DeployPolicy`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `DeployPolicy`. Max length is 255 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. Annotations must meet the following
    /// constraints:
    ///
    /// * Annotations are key/value pairs.
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (`/`).
    /// * The name segment is required and must be 63 characters or less,
    ///   beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
    ///   dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
    /// * The prefix is optional. If specified, the prefix must be a DNS subdomain:
    ///   a series of DNS labels separated by dots(`.`), not longer than 253
    ///   characters in total, followed by a slash (`/`).
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set>
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the deploy policy was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Most recent time at which the deploy policy was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. When suspended, the policy will not prevent actions from
    /// occurring, even if the action violates the policy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub suspended: bool,

    /// Required. Selected resources to which the policy will be applied. At least
    /// one selector is required. If one selector matches the resource the policy
    /// applies. For example, if there are two selectors and the action being
    /// attempted matches one of them, the policy will apply to that action.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub selectors: std::vec::Vec<crate::model::DeployPolicyResourceSelector>,

    /// Required. Rules to apply. At least one rule must be present.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub rules: std::vec::Vec<crate::model::PolicyRule>,

    /// The weak etag of the `DeployPolicy` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DeployPolicy::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DeployPolicy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::DeployPolicy::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::DeployPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployPolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeployPolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeployPolicy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeployPolicy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suspended][crate::model::DeployPolicy::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [selectors][crate::model::DeployPolicy::selectors].
    pub fn set_selectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployPolicyResourceSelector>,
    {
        use std::iter::Iterator;
        self.selectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::DeployPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::DeployPolicy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeployPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicy"
    }
}

/// Defines additional types related to [DeployPolicy].
pub mod deploy_policy {
    #[allow(unused_imports)]
    use super::*;

    /// What invoked the action. Filters enforcing the policy depending on what
    /// invoked the action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Invoker {
        /// Unspecified.
        Unspecified,
        /// The action is user-driven. For example, creating a rollout manually via a
        /// gcloud create command.
        User,
        /// Automated action by Cloud Deploy.
        DeployAutomation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Invoker::value] or
        /// [Invoker::name].
        UnknownValue(invoker::UnknownValue),
    }

    #[doc(hidden)]
    pub mod invoker {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Invoker {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::User => std::option::Option::Some(1),
                Self::DeployAutomation => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INVOKER_UNSPECIFIED"),
                Self::User => std::option::Option::Some("USER"),
                Self::DeployAutomation => std::option::Option::Some("DEPLOY_AUTOMATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Invoker {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Invoker {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Invoker {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::User,
                2 => Self::DeployAutomation,
                _ => Self::UnknownValue(invoker::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Invoker {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INVOKER_UNSPECIFIED" => Self::Unspecified,
                "USER" => Self::User,
                "DEPLOY_AUTOMATION" => Self::DeployAutomation,
                _ => Self::UnknownValue(invoker::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Invoker {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::User => serializer.serialize_i32(1),
                Self::DeployAutomation => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Invoker {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Invoker>::new(
                ".google.cloud.deploy.v1.DeployPolicy.Invoker",
            ))
        }
    }
}

/// Contains information on the resources to select for a deploy policy.
/// Attributes provided must all match the resource in order for policy
/// restrictions to apply. For example, if delivery pipelines attributes given
/// are an id "prod" and labels "foo: bar", a delivery pipeline resource must
/// match both that id and have that label in order to be subject to the policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployPolicyResourceSelector {
    /// Optional. Contains attributes about a delivery pipeline.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delivery_pipeline: std::option::Option<crate::model::DeliveryPipelineAttribute>,

    /// Optional. Contains attributes about a target.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::TargetAttribute>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyResourceSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeployPolicyResourceSelector::delivery_pipeline].
    pub fn set_delivery_pipeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipelineAttribute>,
    {
        self.delivery_pipeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline][crate::model::DeployPolicyResourceSelector::delivery_pipeline].
    pub fn set_or_clear_delivery_pipeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipelineAttribute>,
    {
        self.delivery_pipeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::DeployPolicyResourceSelector::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetAttribute>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::DeployPolicyResourceSelector::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetAttribute>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployPolicyResourceSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyResourceSelector"
    }
}

/// Contains criteria for selecting DeliveryPipelines.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeliveryPipelineAttribute {
    /// Optional. ID of the `DeliveryPipeline`. The value of this field could be
    /// one of the following:
    ///
    /// * The last segment of a pipeline name
    /// * "*", all delivery pipelines in a location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// DeliveryPipeline labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipelineAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::DeliveryPipelineAttribute::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DeliveryPipelineAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DeliveryPipelineAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipelineAttribute"
    }
}

/// Contains criteria for selecting Targets. This could be used to select targets
/// for a Deploy Policy or for an Automation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetAttribute {
    /// Optional. ID of the `Target`. The value of this field could be one of the
    /// following:
    ///
    /// * The last segment of a target name
    /// * "*", all targets in a location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Target labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TargetAttribute::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TargetAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TargetAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetAttribute"
    }
}

/// Deploy Policy rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyRule {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::policy_rule::Rule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::PolicyRule::rule].
    ///
    /// Note that all the setters affecting `rule` are mutually
    /// exclusive.
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::policy_rule::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// The value of [rule][crate::model::PolicyRule::rule]
    /// if it holds a `RolloutRestriction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollout_restriction(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RolloutRestriction>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::policy_rule::Rule::RolloutRestriction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::PolicyRule::rule]
    /// to hold a `RolloutRestriction`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_rollout_restriction<
        T: std::convert::Into<std::boxed::Box<crate::model::RolloutRestriction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(crate::model::policy_rule::Rule::RolloutRestriction(
            v.into(),
        ));
        self
    }
}

impl wkt::message::Message for PolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyRule"
    }
}

/// Defines additional types related to [PolicyRule].
pub mod policy_rule {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Rule {
        /// Optional. Rollout restrictions.
        RolloutRestriction(std::boxed::Box<crate::model::RolloutRestriction>),
    }
}

/// Rollout restrictions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RolloutRestriction {
    /// Required. Restriction rule ID. Required and must be unique within a
    /// DeployPolicy. The format is `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Optional. What invoked the action. If left empty, all invoker types will be
    /// restricted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub invokers: std::vec::Vec<crate::model::deploy_policy::Invoker>,

    /// Optional. Rollout actions to be restricted as part of the policy. If left
    /// empty, all actions will be restricted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<crate::model::rollout_restriction::RolloutActions>,

    /// Required. Time window within which actions are restricted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_windows: std::option::Option<crate::model::TimeWindows>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutRestriction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RolloutRestriction::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [invokers][crate::model::RolloutRestriction::invokers].
    pub fn set_invokers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::deploy_policy::Invoker>,
    {
        use std::iter::Iterator;
        self.invokers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [actions][crate::model::RolloutRestriction::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rollout_restriction::RolloutActions>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [time_windows][crate::model::RolloutRestriction::time_windows].
    pub fn set_time_windows<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindows>,
    {
        self.time_windows = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_windows][crate::model::RolloutRestriction::time_windows].
    pub fn set_or_clear_time_windows<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindows>,
    {
        self.time_windows = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RolloutRestriction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutRestriction"
    }
}

/// Defines additional types related to [RolloutRestriction].
pub mod rollout_restriction {
    #[allow(unused_imports)]
    use super::*;

    /// Rollout actions to be restricted as part of the policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutActions {
        /// Unspecified.
        Unspecified,
        /// Advance the rollout to the next phase.
        Advance,
        /// Approve the rollout.
        Approve,
        /// Cancel the rollout.
        Cancel,
        /// Create a rollout.
        Create,
        /// Ignore a job result on the rollout.
        IgnoreJob,
        /// Retry a job for a rollout.
        RetryJob,
        /// Rollback a rollout.
        Rollback,
        /// Terminate a jobrun.
        TerminateJobrun,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutActions::value] or
        /// [RolloutActions::name].
        UnknownValue(rollout_actions::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_actions {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutActions {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Advance => std::option::Option::Some(1),
                Self::Approve => std::option::Option::Some(2),
                Self::Cancel => std::option::Option::Some(3),
                Self::Create => std::option::Option::Some(4),
                Self::IgnoreJob => std::option::Option::Some(5),
                Self::RetryJob => std::option::Option::Some(6),
                Self::Rollback => std::option::Option::Some(7),
                Self::TerminateJobrun => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_ACTIONS_UNSPECIFIED"),
                Self::Advance => std::option::Option::Some("ADVANCE"),
                Self::Approve => std::option::Option::Some("APPROVE"),
                Self::Cancel => std::option::Option::Some("CANCEL"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::IgnoreJob => std::option::Option::Some("IGNORE_JOB"),
                Self::RetryJob => std::option::Option::Some("RETRY_JOB"),
                Self::Rollback => std::option::Option::Some("ROLLBACK"),
                Self::TerminateJobrun => std::option::Option::Some("TERMINATE_JOBRUN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutActions {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutActions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutActions {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Advance,
                2 => Self::Approve,
                3 => Self::Cancel,
                4 => Self::Create,
                5 => Self::IgnoreJob,
                6 => Self::RetryJob,
                7 => Self::Rollback,
                8 => Self::TerminateJobrun,
                _ => Self::UnknownValue(rollout_actions::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutActions {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_ACTIONS_UNSPECIFIED" => Self::Unspecified,
                "ADVANCE" => Self::Advance,
                "APPROVE" => Self::Approve,
                "CANCEL" => Self::Cancel,
                "CREATE" => Self::Create,
                "IGNORE_JOB" => Self::IgnoreJob,
                "RETRY_JOB" => Self::RetryJob,
                "ROLLBACK" => Self::Rollback,
                "TERMINATE_JOBRUN" => Self::TerminateJobrun,
                _ => Self::UnknownValue(rollout_actions::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutActions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Advance => serializer.serialize_i32(1),
                Self::Approve => serializer.serialize_i32(2),
                Self::Cancel => serializer.serialize_i32(3),
                Self::Create => serializer.serialize_i32(4),
                Self::IgnoreJob => serializer.serialize_i32(5),
                Self::RetryJob => serializer.serialize_i32(6),
                Self::Rollback => serializer.serialize_i32(7),
                Self::TerminateJobrun => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutActions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutActions>::new(
                ".google.cloud.deploy.v1.RolloutRestriction.RolloutActions",
            ))
        }
    }
}

/// Time windows within which actions are restricted. See the
/// [documentation](https://cloud.google.com/deploy/docs/deploy-policy#dates_times)
/// for more information on how to configure dates/times.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeWindows {
    /// Required. The time zone in IANA format [IANA Time Zone
    /// Database](https://www.iana.org/time-zones) (e.g. America/New_York).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub time_zone: std::string::String,

    /// Optional. One-time windows within which actions are restricted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub one_time_windows: std::vec::Vec<crate::model::OneTimeWindow>,

    /// Optional. Recurring weekly windows within which actions are restricted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub weekly_windows: std::vec::Vec<crate::model::WeeklyWindow>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindows {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::TimeWindows::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [one_time_windows][crate::model::TimeWindows::one_time_windows].
    pub fn set_one_time_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OneTimeWindow>,
    {
        use std::iter::Iterator;
        self.one_time_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [weekly_windows][crate::model::TimeWindows::weekly_windows].
    pub fn set_weekly_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WeeklyWindow>,
    {
        use std::iter::Iterator;
        self.weekly_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimeWindows {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimeWindows"
    }
}

/// One-time window within which actions are restricted. For example, blocking
/// actions over New Year's Eve from December 31st at 5pm to January 1st at 9am.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OneTimeWindow {
    /// Required. Start date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_date: std::option::Option<gtype::model::Date>,

    /// Required. Start time (inclusive). Use 00:00 for the beginning of the day.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Required. End date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_date: std::option::Option<gtype::model::Date>,

    /// Required. End time (exclusive). You may use 24:00 for the end of the day.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<gtype::model::TimeOfDay>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OneTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_date][crate::model::OneTimeWindow::start_date].
    pub fn set_start_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_date][crate::model::OneTimeWindow::start_date].
    pub fn set_or_clear_start_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::OneTimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OneTimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_date][crate::model::OneTimeWindow::end_date].
    pub fn set_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_date][crate::model::OneTimeWindow::end_date].
    pub fn set_or_clear_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OneTimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OneTimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OneTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.OneTimeWindow"
    }
}

/// Weekly windows. For example, blocking actions every Saturday and Sunday.
/// Another example would be blocking actions every weekday from 5pm to midnight.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WeeklyWindow {
    /// Optional. Days of week. If left empty, all days of the week will be
    /// included.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Optional. Start time (inclusive). Use 00:00 for the beginning of the day.
    /// If you specify start_time you must also specify end_time. If left empty,
    /// this will block for the entire day for the days specified in days_of_week.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Optional. End time (exclusive). Use 24:00 to indicate midnight. If you
    /// specify end_time you must also specify start_time. If left empty, this will
    /// block for the entire day for the days specified in days_of_week.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<gtype::model::TimeOfDay>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WeeklyWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [days_of_week][crate::model::WeeklyWindow::days_of_week].
    pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.days_of_week = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::WeeklyWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WeeklyWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::WeeklyWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::WeeklyWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WeeklyWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.WeeklyWindow"
    }
}

/// Returned from an action if one or more policies were
/// violated, and therefore the action was prevented. Contains information about
/// what policies were violated and why.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyViolation {
    /// Policy violation details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub policy_violation_details: std::vec::Vec<crate::model::PolicyViolationDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyViolation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_violation_details][crate::model::PolicyViolation::policy_violation_details].
    pub fn set_policy_violation_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PolicyViolationDetails>,
    {
        use std::iter::Iterator;
        self.policy_violation_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyViolation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyViolation"
    }
}

/// Policy violation details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyViolationDetails {
    /// Name of the policy that was violated.
    /// Policy resource will be in the format of
    /// `projects/{project}/locations/{location}/policies/{policy}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub policy: std::string::String,

    /// Id of the rule that triggered the policy violation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rule_id: std::string::String,

    /// User readable message about why the request violated a policy. This is not
    /// intended for machine parsing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyViolationDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::PolicyViolationDetails::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [rule_id][crate::model::PolicyViolationDetails::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PolicyViolationDetails::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PolicyViolationDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PolicyViolationDetails"
    }
}

/// A `Release` resource in the Cloud Deploy API.
///
/// A `Release` defines a specific Skaffold configuration instance
/// that can be deployed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Release {
    /// Identifier. Name of the `Release`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
    /// The `release` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `Release`. Max length is 255 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Indicates whether this is an abandoned release.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub abandoned: bool,

    /// Output only. Time at which the `Release` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the render began.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub render_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the render completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub render_end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Cloud Storage URI of tar.gz archive containing Skaffold
    /// configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skaffold_config_uri: std::string::String,

    /// Optional. Filepath of the Skaffold config inside of the config URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skaffold_config_path: std::string::String,

    /// Optional. List of artifacts to pass through to Skaffold command.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub build_artifacts: std::vec::Vec<crate::model::BuildArtifact>,

    /// Output only. Snapshot of the parent pipeline taken at release creation
    /// time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delivery_pipeline_snapshot: std::option::Option<crate::model::DeliveryPipeline>,

    /// Output only. Snapshot of the targets taken at release creation time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub target_snapshots: std::vec::Vec<crate::model::Target>,

    /// Output only. Snapshot of the custom target types referenced by the targets
    /// taken at release creation time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub custom_target_type_snapshots: std::vec::Vec<crate::model::CustomTargetType>,

    /// Output only. Current state of the render operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub render_state: crate::model::release::RenderState,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Optional. The Skaffold version to use when operating on this release, such
    /// as "1.20.0". Not all versions are valid; Cloud Deploy supports a specific
    /// set of versions.
    ///
    /// If unset, the most recent supported Skaffold version will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skaffold_version: std::string::String,

    /// Output only. Map from target ID to the target artifacts created
    /// during the render operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub target_artifacts:
        std::collections::HashMap<std::string::String, crate::model::TargetArtifact>,

    /// Output only. Map from target ID to details of the render operation for that
    /// target.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub target_renders:
        std::collections::HashMap<std::string::String, crate::model::release::TargetRender>,

    /// Output only. Information around the state of the Release.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::release::ReleaseCondition>,

    /// Optional. The deploy parameters to use for all targets in this release.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub deploy_parameters: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Release {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Release::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Release::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Release::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Release::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Release::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [abandoned][crate::model::Release::abandoned].
    pub fn set_abandoned<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.abandoned = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Release::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Release::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [render_start_time][crate::model::Release::render_start_time].
    pub fn set_render_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [render_start_time][crate::model::Release::render_start_time].
    pub fn set_or_clear_render_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [render_end_time][crate::model::Release::render_end_time].
    pub fn set_render_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [render_end_time][crate::model::Release::render_end_time].
    pub fn set_or_clear_render_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.render_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skaffold_config_uri][crate::model::Release::skaffold_config_uri].
    pub fn set_skaffold_config_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_uri = v.into();
        self
    }

    /// Sets the value of [skaffold_config_path][crate::model::Release::skaffold_config_path].
    pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_path = v.into();
        self
    }

    /// Sets the value of [build_artifacts][crate::model::Release::build_artifacts].
    pub fn set_build_artifacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BuildArtifact>,
    {
        use std::iter::Iterator;
        self.build_artifacts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [delivery_pipeline_snapshot][crate::model::Release::delivery_pipeline_snapshot].
    pub fn set_delivery_pipeline_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delivery_pipeline_snapshot][crate::model::Release::delivery_pipeline_snapshot].
    pub fn set_or_clear_delivery_pipeline_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeliveryPipeline>,
    {
        self.delivery_pipeline_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_snapshots][crate::model::Release::target_snapshots].
    pub fn set_target_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Target>,
    {
        use std::iter::Iterator;
        self.target_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_target_type_snapshots][crate::model::Release::custom_target_type_snapshots].
    pub fn set_custom_target_type_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomTargetType>,
    {
        use std::iter::Iterator;
        self.custom_target_type_snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [render_state][crate::model::Release::render_state].
    pub fn set_render_state<T: std::convert::Into<crate::model::release::RenderState>>(
        mut self,
        v: T,
    ) -> Self {
        self.render_state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Release::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [skaffold_version][crate::model::Release::skaffold_version].
    pub fn set_skaffold_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_version = v.into();
        self
    }

    /// Sets the value of [target_artifacts][crate::model::Release::target_artifacts].
    pub fn set_target_artifacts<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TargetArtifact>,
    {
        use std::iter::Iterator;
        self.target_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [target_renders][crate::model::Release::target_renders].
    pub fn set_target_renders<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::release::TargetRender>,
    {
        use std::iter::Iterator;
        self.target_renders = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [condition][crate::model::Release::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::release::ReleaseCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Release::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::release::ReleaseCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_parameters][crate::model::Release::deploy_parameters].
    pub fn set_deploy_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.deploy_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Release {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Release"
    }
}

/// Defines additional types related to [Release].
pub mod release {
    #[allow(unused_imports)]
    use super::*;

    /// Details of rendering for a single target.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TargetRender {
        /// Output only. The resource name of the Cloud Build `Build` object that is
        /// used to render the manifest for this target. Format is
        /// `projects/{project}/locations/{location}/builds/{build}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub rendering_build: std::string::String,

        /// Output only. Current state of the render operation for this Target.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub rendering_state: crate::model::release::target_render::TargetRenderState,

        /// Output only. Metadata related to the `Release` render for this Target.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub metadata: std::option::Option<crate::model::RenderMetadata>,

        /// Output only. Reason this render failed. This will always be unspecified
        /// while the render in progress.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub failure_cause: crate::model::release::target_render::FailureCause,

        /// Output only. Additional information about the render failure, if
        /// available.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub failure_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TargetRender {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rendering_build][crate::model::release::TargetRender::rendering_build].
        pub fn set_rendering_build<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rendering_build = v.into();
            self
        }

        /// Sets the value of [rendering_state][crate::model::release::TargetRender::rendering_state].
        pub fn set_rendering_state<
            T: std::convert::Into<crate::model::release::target_render::TargetRenderState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rendering_state = v.into();
            self
        }

        /// Sets the value of [metadata][crate::model::release::TargetRender::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RenderMetadata>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::release::TargetRender::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RenderMetadata>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }

        /// Sets the value of [failure_cause][crate::model::release::TargetRender::failure_cause].
        pub fn set_failure_cause<
            T: std::convert::Into<crate::model::release::target_render::FailureCause>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.failure_cause = v.into();
            self
        }

        /// Sets the value of [failure_message][crate::model::release::TargetRender::failure_message].
        pub fn set_failure_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.failure_message = v.into();
            self
        }
    }

    impl wkt::message::Message for TargetRender {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.TargetRender"
        }
    }

    /// Defines additional types related to [TargetRender].
    pub mod target_render {
        #[allow(unused_imports)]
        use super::*;

        /// Valid states of the render operation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TargetRenderState {
            /// The render operation state is unspecified.
            Unspecified,
            /// The render operation has completed successfully.
            Succeeded,
            /// The render operation has failed.
            Failed,
            /// The render operation is in progress.
            InProgress,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TargetRenderState::value] or
            /// [TargetRenderState::name].
            UnknownValue(target_render_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod target_render_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TargetRenderState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Succeeded => std::option::Option::Some(1),
                    Self::Failed => std::option::Option::Some(2),
                    Self::InProgress => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("TARGET_RENDER_STATE_UNSPECIFIED")
                    }
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TargetRenderState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TargetRenderState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TargetRenderState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Succeeded,
                    2 => Self::Failed,
                    3 => Self::InProgress,
                    _ => Self::UnknownValue(target_render_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TargetRenderState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TARGET_RENDER_STATE_UNSPECIFIED" => Self::Unspecified,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    "IN_PROGRESS" => Self::InProgress,
                    _ => Self::UnknownValue(target_render_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TargetRenderState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Succeeded => serializer.serialize_i32(1),
                    Self::Failed => serializer.serialize_i32(2),
                    Self::InProgress => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TargetRenderState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetRenderState>::new(
                    ".google.cloud.deploy.v1.Release.TargetRender.TargetRenderState",
                ))
            }
        }

        /// Well-known rendering failures.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FailureCause {
            /// No reason for failure is specified.
            Unspecified,
            /// Cloud Build is not available, either because it is not enabled or
            /// because Cloud Deploy has insufficient permissions. See [required
            /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
            CloudBuildUnavailable,
            /// The render operation did not complete successfully; check Cloud Build
            /// logs.
            ExecutionFailed,
            /// Cloud Build failed to fulfill Cloud Deploy's request. See
            /// failure_message for additional details.
            CloudBuildRequestFailed,
            /// The render operation did not complete successfully because the
            /// verification stanza required for verify was not found on the Skaffold
            /// configuration.
            VerificationConfigNotFound,
            /// The render operation did not complete successfully because the custom
            /// action(s) required for Rollout jobs were not found in the Skaffold
            /// configuration. See failure_message for additional details.
            CustomActionNotFound,
            /// Release failed during rendering because the release configuration is
            /// not supported with the specified deployment strategy.
            DeploymentStrategyNotSupported,
            /// The render operation had a feature configured that is not supported.
            RenderFeatureNotSupported,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FailureCause::value] or
            /// [FailureCause::name].
            UnknownValue(failure_cause::UnknownValue),
        }

        #[doc(hidden)]
        pub mod failure_cause {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FailureCause {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::CloudBuildUnavailable => std::option::Option::Some(1),
                    Self::ExecutionFailed => std::option::Option::Some(2),
                    Self::CloudBuildRequestFailed => std::option::Option::Some(3),
                    Self::VerificationConfigNotFound => std::option::Option::Some(4),
                    Self::CustomActionNotFound => std::option::Option::Some(5),
                    Self::DeploymentStrategyNotSupported => std::option::Option::Some(6),
                    Self::RenderFeatureNotSupported => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                    Self::CloudBuildUnavailable => {
                        std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE")
                    }
                    Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                    Self::CloudBuildRequestFailed => {
                        std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                    }
                    Self::VerificationConfigNotFound => {
                        std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                    }
                    Self::CustomActionNotFound => {
                        std::option::Option::Some("CUSTOM_ACTION_NOT_FOUND")
                    }
                    Self::DeploymentStrategyNotSupported => {
                        std::option::Option::Some("DEPLOYMENT_STRATEGY_NOT_SUPPORTED")
                    }
                    Self::RenderFeatureNotSupported => {
                        std::option::Option::Some("RENDER_FEATURE_NOT_SUPPORTED")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FailureCause {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FailureCause {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FailureCause {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::CloudBuildUnavailable,
                    2 => Self::ExecutionFailed,
                    3 => Self::CloudBuildRequestFailed,
                    4 => Self::VerificationConfigNotFound,
                    5 => Self::CustomActionNotFound,
                    6 => Self::DeploymentStrategyNotSupported,
                    7 => Self::RenderFeatureNotSupported,
                    _ => Self::UnknownValue(failure_cause::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FailureCause {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                    "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                    "EXECUTION_FAILED" => Self::ExecutionFailed,
                    "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                    "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                    "CUSTOM_ACTION_NOT_FOUND" => Self::CustomActionNotFound,
                    "DEPLOYMENT_STRATEGY_NOT_SUPPORTED" => Self::DeploymentStrategyNotSupported,
                    "RENDER_FEATURE_NOT_SUPPORTED" => Self::RenderFeatureNotSupported,
                    _ => Self::UnknownValue(failure_cause::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FailureCause {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                    Self::ExecutionFailed => serializer.serialize_i32(2),
                    Self::CloudBuildRequestFailed => serializer.serialize_i32(3),
                    Self::VerificationConfigNotFound => serializer.serialize_i32(4),
                    Self::CustomActionNotFound => serializer.serialize_i32(5),
                    Self::DeploymentStrategyNotSupported => serializer.serialize_i32(6),
                    Self::RenderFeatureNotSupported => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FailureCause {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                    ".google.cloud.deploy.v1.Release.TargetRender.FailureCause",
                ))
            }
        }
    }

    /// ReleaseReadyCondition contains information around the status of the
    /// Release. If a release is not ready, you cannot create a rollout with the
    /// release.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReleaseReadyCondition {
        /// True if the Release is in a valid state. Otherwise at least one condition
        /// in `ReleaseCondition` is in an invalid state. Iterate over those
        /// conditions and see which condition(s) has status = false to find out what
        /// is wrong with the Release.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub status: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseReadyCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::release::ReleaseReadyCondition::status].
        pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for ReleaseReadyCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.ReleaseReadyCondition"
        }
    }

    /// SkaffoldSupportedCondition contains information about when support for the
    /// release's version of Skaffold ends.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SkaffoldSupportedCondition {
        /// True if the version of Skaffold used by this release is supported.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub status: bool,

        /// The Skaffold support state for this release's version of Skaffold.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub skaffold_support_state: crate::model::SkaffoldSupportState,

        /// The time at which this release's version of Skaffold will enter
        /// maintenance mode.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub maintenance_mode_time: std::option::Option<wkt::Timestamp>,

        /// The time at which this release's version of Skaffold will no longer be
        /// supported.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub support_expiration_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SkaffoldSupportedCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::release::SkaffoldSupportedCondition::status].
        pub fn set_status<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [skaffold_support_state][crate::model::release::SkaffoldSupportedCondition::skaffold_support_state].
        pub fn set_skaffold_support_state<
            T: std::convert::Into<crate::model::SkaffoldSupportState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.skaffold_support_state = v.into();
            self
        }

        /// Sets the value of [maintenance_mode_time][crate::model::release::SkaffoldSupportedCondition::maintenance_mode_time].
        pub fn set_maintenance_mode_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.maintenance_mode_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [maintenance_mode_time][crate::model::release::SkaffoldSupportedCondition::maintenance_mode_time].
        pub fn set_or_clear_maintenance_mode_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.maintenance_mode_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [support_expiration_time][crate::model::release::SkaffoldSupportedCondition::support_expiration_time].
        pub fn set_support_expiration_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.support_expiration_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [support_expiration_time][crate::model::release::SkaffoldSupportedCondition::support_expiration_time].
        pub fn set_or_clear_support_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.support_expiration_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SkaffoldSupportedCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.SkaffoldSupportedCondition"
        }
    }

    /// ReleaseCondition contains all conditions relevant to a Release.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReleaseCondition {
        /// Details around the Releases's overall status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub release_ready_condition:
            std::option::Option<crate::model::release::ReleaseReadyCondition>,

        /// Details around the support state of the release's Skaffold
        /// version.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub skaffold_supported_condition:
            std::option::Option<crate::model::release::SkaffoldSupportedCondition>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseCondition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [release_ready_condition][crate::model::release::ReleaseCondition::release_ready_condition].
        pub fn set_release_ready_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::release::ReleaseReadyCondition>,
        {
            self.release_ready_condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [release_ready_condition][crate::model::release::ReleaseCondition::release_ready_condition].
        pub fn set_or_clear_release_ready_condition<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::release::ReleaseReadyCondition>,
        {
            self.release_ready_condition = v.map(|x| x.into());
            self
        }

        /// Sets the value of [skaffold_supported_condition][crate::model::release::ReleaseCondition::skaffold_supported_condition].
        pub fn set_skaffold_supported_condition<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::release::SkaffoldSupportedCondition>,
        {
            self.skaffold_supported_condition = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [skaffold_supported_condition][crate::model::release::ReleaseCondition::skaffold_supported_condition].
        pub fn set_or_clear_skaffold_supported_condition<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::release::SkaffoldSupportedCondition>,
        {
            self.skaffold_supported_condition = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReleaseCondition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.Release.ReleaseCondition"
        }
    }

    /// Valid states of the render operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RenderState {
        /// The render state is unspecified.
        Unspecified,
        /// All rendering operations have completed successfully.
        Succeeded,
        /// All rendering operations have completed, and one or more have failed.
        Failed,
        /// Rendering has started and is not complete.
        InProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RenderState::value] or
        /// [RenderState::name].
        UnknownValue(render_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod render_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RenderState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RENDER_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RenderState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RenderState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RenderState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::InProgress,
                _ => Self::UnknownValue(render_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RenderState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RENDER_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                _ => Self::UnknownValue(render_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RenderState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RenderState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RenderState>::new(
                ".google.cloud.deploy.v1.Release.RenderState",
            ))
        }
    }
}

/// The request object for `CreateDeployPolicy`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDeployPolicyRequest {
    /// Required. The parent collection in which the `DeployPolicy` must be
    /// created. The format is `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `DeployPolicy`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_policy_id: std::string::String,

    /// Required. The `DeployPolicy` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_policy: std::option::Option<crate::model::DeployPolicy>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDeployPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [deploy_policy_id][crate::model::CreateDeployPolicyRequest::deploy_policy_id].
    pub fn set_deploy_policy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_id = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::CreateDeployPolicyRequest::deploy_policy].
    pub fn set_deploy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_policy][crate::model::CreateDeployPolicyRequest::deploy_policy].
    pub fn set_or_clear_deploy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateDeployPolicyRequest"
    }
}

/// The request object for `UpdateDeployPolicy`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDeployPolicyRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `DeployPolicy` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `DeployPolicy` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_policy: std::option::Option<crate::model::DeployPolicy>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `DeployPolicy` that does not exist
    /// will result in the creation of a new `DeployPolicy`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDeployPolicyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDeployPolicyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_policy][crate::model::UpdateDeployPolicyRequest::deploy_policy].
    pub fn set_deploy_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_policy][crate::model::UpdateDeployPolicyRequest::deploy_policy].
    pub fn set_or_clear_deploy_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployPolicy>,
    {
        self.deploy_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDeployPolicyRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateDeployPolicyRequest"
    }
}

/// The request object for `DeleteDeployPolicy`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDeployPolicyRequest {
    /// Required. The name of the `DeployPolicy` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `DeployPolicy` will succeed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDeployPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDeployPolicyRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteDeployPolicyRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteDeployPolicyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDeployPolicyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteDeployPolicyRequest"
    }
}

/// The request object for `ListDeployPolicies`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeployPoliciesRequest {
    /// Required. The parent, which owns this collection of deploy policies. Format
    /// must be `projects/{project_id}/locations/{location_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of deploy policies to return. The service may return
    /// fewer than this value. If unspecified, at most 50 deploy policies will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListDeployPolicies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter deploy policies to be returned. See <https://google.aip.dev/160> for
    /// more details. All fields can be used in the filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Field to sort by. See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeployPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeployPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeployPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeployPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDeployPoliciesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDeployPoliciesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDeployPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeployPoliciesRequest"
    }
}

/// The response object from `ListDeployPolicies`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDeployPoliciesResponse {
    /// The `DeployPolicy` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub deploy_policies: std::vec::Vec<crate::model::DeployPolicy>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDeployPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deploy_policies][crate::model::ListDeployPoliciesResponse::deploy_policies].
    pub fn set_deploy_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DeployPolicy>,
    {
        use std::iter::Iterator;
        self.deploy_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeployPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDeployPoliciesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDeployPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListDeployPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeployPoliciesResponse {
    type PageItem = crate::model::DeployPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deploy_policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetDeployPolicy`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDeployPolicyRequest {
    /// Required. Name of the `DeployPolicy`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDeployPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeployPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDeployPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetDeployPolicyRequest"
    }
}

/// Description of an a image to use during Skaffold rendering.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildArtifact {
    /// Optional. Image name in Skaffold configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub image: std::string::String,

    /// Optional. Image tag to use. This will generally be the full path to an
    /// image, such as "gcr.io/my-project/busybox:1.2.3" or
    /// "gcr.io/my-project/busybox@sha256:abc123".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub tag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::BuildArtifact::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::BuildArtifact::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for BuildArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.BuildArtifact"
    }
}

/// The artifacts produced by a target render operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetArtifact {
    /// Output only. File path of the resolved Skaffold configuration for the
    /// stable phase, relative to the URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skaffold_config_path: std::string::String,

    /// Output only. File path of the rendered manifest relative to the URI for the
    /// stable phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub manifest_path: std::string::String,

    /// Output only. Map from the phase ID to the phase artifacts for the `Target`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub phase_artifacts: std::collections::HashMap<
        std::string::String,
        crate::model::target_artifact::PhaseArtifact,
    >,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub uri: std::option::Option<crate::model::target_artifact::Uri>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skaffold_config_path][crate::model::TargetArtifact::skaffold_config_path].
    pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.skaffold_config_path = v.into();
        self
    }

    /// Sets the value of [manifest_path][crate::model::TargetArtifact::manifest_path].
    pub fn set_manifest_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.manifest_path = v.into();
        self
    }

    /// Sets the value of [phase_artifacts][crate::model::TargetArtifact::phase_artifacts].
    pub fn set_phase_artifacts<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::target_artifact::PhaseArtifact>,
    {
        use std::iter::Iterator;
        self.phase_artifacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uri][crate::model::TargetArtifact::uri].
    ///
    /// Note that all the setters affecting `uri` are mutually
    /// exclusive.
    pub fn set_uri<
        T: std::convert::Into<std::option::Option<crate::model::target_artifact::Uri>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.uri = v.into();
        self
    }

    /// The value of [uri][crate::model::TargetArtifact::uri]
    /// if it holds a `ArtifactUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn artifact_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.uri.as_ref().and_then(|v| match v {
            crate::model::target_artifact::Uri::ArtifactUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [uri][crate::model::TargetArtifact::uri]
    /// to hold a `ArtifactUri`.
    ///
    /// Note that all the setters affecting `uri` are
    /// mutually exclusive.
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri =
            std::option::Option::Some(crate::model::target_artifact::Uri::ArtifactUri(v.into()));
        self
    }
}

impl wkt::message::Message for TargetArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetArtifact"
    }
}

/// Defines additional types related to [TargetArtifact].
pub mod target_artifact {
    #[allow(unused_imports)]
    use super::*;

    /// Contains the paths to the artifacts, relative to the URI, for a phase.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PhaseArtifact {
        /// Output only. File path of the resolved Skaffold configuration relative to
        /// the URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub skaffold_config_path: std::string::String,

        /// Output only. File path of the rendered manifest relative to the URI.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub manifest_path: std::string::String,

        /// Output only. File path of the directory of rendered job manifests
        /// relative to the URI. This is only set if it is applicable.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub job_manifests_path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PhaseArtifact {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [skaffold_config_path][crate::model::target_artifact::PhaseArtifact::skaffold_config_path].
        pub fn set_skaffold_config_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.skaffold_config_path = v.into();
            self
        }

        /// Sets the value of [manifest_path][crate::model::target_artifact::PhaseArtifact::manifest_path].
        pub fn set_manifest_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.manifest_path = v.into();
            self
        }

        /// Sets the value of [job_manifests_path][crate::model::target_artifact::PhaseArtifact::job_manifests_path].
        pub fn set_job_manifests_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.job_manifests_path = v.into();
            self
        }
    }

    impl wkt::message::Message for PhaseArtifact {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.TargetArtifact.PhaseArtifact"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Uri {
        /// Output only. URI of a directory containing the artifacts. This contains
        /// deployment configuration used by Skaffold during a rollout, and all
        /// paths are relative to this location.
        ArtifactUri(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// The artifacts produced by a deploy operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployArtifact {
    /// Output only. URI of a directory containing the artifacts. All paths are
    /// relative to this location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_uri: std::string::String,

    /// Output only. File paths of the manifests applied during the deploy
    /// operation relative to the URI.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub manifest_paths: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployArtifact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [artifact_uri][crate::model::DeployArtifact::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [manifest_paths][crate::model::DeployArtifact::manifest_paths].
    pub fn set_manifest_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.manifest_paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeployArtifact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployArtifact"
    }
}

/// CloudRunRenderMetadata contains Cloud Run information associated with a
/// `Release` render.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunRenderMetadata {
    /// Output only. The name of the Cloud Run Service in the rendered manifest.
    /// Format is `projects/{project}/locations/{location}/services/{service}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunRenderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRunRenderMetadata::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunRenderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunRenderMetadata"
    }
}

/// RenderMetadata includes information associated with a `Release` render.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenderMetadata {
    /// Output only. Metadata associated with rendering for Cloud Run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_run: std::option::Option<crate::model::CloudRunRenderMetadata>,

    /// Output only. Custom metadata provided by user-defined render operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::RenderMetadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunRenderMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::RenderMetadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunRenderMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::RenderMetadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::RenderMetadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RenderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RenderMetadata"
    }
}

/// The request object for `ListReleases`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReleasesRequest {
    /// Required. The `DeliveryPipeline` which owns this collection of `Release`
    /// objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `Release` objects to return. The service
    /// may return fewer than this value. If unspecified, at most 50 `Release`
    /// objects will be returned. The maximum value is 1000; values above 1000 will
    /// be set to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListReleases` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter releases to be returned. See <https://google.aip.dev/160>
    /// for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReleasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReleasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReleasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReleasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReleasesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReleasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListReleasesRequest"
    }
}

/// The response object from `ListReleases`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReleasesResponse {
    /// The `Release` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub releases: std::vec::Vec<crate::model::Release>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [releases][crate::model::ListReleasesResponse::releases].
    pub fn set_releases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Release>,
    {
        use std::iter::Iterator;
        self.releases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReleasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReleasesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReleasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListReleasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReleasesResponse {
    type PageItem = crate::model::Release;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.releases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetRelease`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReleaseRequest {
    /// Required. Name of the `Release`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReleaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetReleaseRequest"
    }
}

/// The request object for `CreateRelease`,
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReleaseRequest {
    /// Required. The parent collection in which the `Release` is created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_id: std::string::String,

    /// Required. The `Release` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub release: std::option::Option<crate::model::Release>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReleaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [release_id][crate::model::CreateReleaseRequest::release_id].
    pub fn set_release_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_id = v.into();
        self
    }

    /// Sets the value of [release][crate::model::CreateReleaseRequest::release].
    pub fn set_release<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Release>,
    {
        self.release = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release][crate::model::CreateReleaseRequest::release].
    pub fn set_or_clear_release<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Release>,
    {
        self.release = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReleaseRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateReleaseRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CreateReleaseRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateReleaseRequest"
    }
}

/// A `Rollout` resource in the Cloud Deploy API.
///
/// A `Rollout` contains information around a specific deployment to a `Target`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Rollout {
    /// Identifier. Name of the `Rollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    /// The `rollout` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `Rollout` for user purposes. Max length is 255
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time at which the `Rollout` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` was approved.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` was enqueued.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enqueue_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` started deploying.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `Rollout` finished deploying.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_end_time: std::option::Option<wkt::Timestamp>,

    /// Required. The ID of Target to which this `Rollout` is deploying.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Output only. Approval state of the `Rollout`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub approval_state: crate::model::rollout::ApprovalState,

    /// Output only. Current state of the `Rollout`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::rollout::State,

    /// Output only. Additional information about the rollout failure, if
    /// available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_reason: std::string::String,

    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to deploy the Rollout. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploying_build: std::string::String,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Output only. The reason this rollout failed. This will always be
    /// unspecified while the rollout is in progress.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_failure_cause: crate::model::rollout::FailureCause,

    /// Output only. The phases that represent the workflows of this `Rollout`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub phases: std::vec::Vec<crate::model::Phase>,

    /// Output only. Metadata contains information about the rollout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Output only. Name of the `ControllerRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub controller_rollout: std::string::String,

    /// Output only. Name of the `Rollout` that is rolled back by this `Rollout`.
    /// Empty if this `Rollout` wasn't created as a rollback.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollback_of_rollout: std::string::String,

    /// Output only. Names of `Rollouts` that rolled back this `Rollout`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub rolled_back_by_rollouts: std::vec::Vec<std::string::String>,

    /// Output only. The AutomationRun actively repairing the rollout.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub active_repair_automation_run: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Rollout::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Rollout::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Rollout::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Rollout::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Rollout::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [approve_time][crate::model::Rollout::approve_time].
    pub fn set_approve_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approve_time][crate::model::Rollout::approve_time].
    pub fn set_or_clear_approve_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enqueue_time][crate::model::Rollout::enqueue_time].
    pub fn set_enqueue_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueue_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enqueue_time][crate::model::Rollout::enqueue_time].
    pub fn set_or_clear_enqueue_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enqueue_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_start_time][crate::model::Rollout::deploy_start_time].
    pub fn set_deploy_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_start_time][crate::model::Rollout::deploy_start_time].
    pub fn set_or_clear_deploy_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_end_time][crate::model::Rollout::deploy_end_time].
    pub fn set_deploy_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_end_time][crate::model::Rollout::deploy_end_time].
    pub fn set_or_clear_deploy_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.deploy_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::Rollout::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [approval_state][crate::model::Rollout::approval_state].
    pub fn set_approval_state<T: std::convert::Into<crate::model::rollout::ApprovalState>>(
        mut self,
        v: T,
    ) -> Self {
        self.approval_state = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Rollout::state].
    pub fn set_state<T: std::convert::Into<crate::model::rollout::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [failure_reason][crate::model::Rollout::failure_reason].
    pub fn set_failure_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_reason = v.into();
        self
    }

    /// Sets the value of [deploying_build][crate::model::Rollout::deploying_build].
    pub fn set_deploying_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploying_build = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Rollout::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deploy_failure_cause][crate::model::Rollout::deploy_failure_cause].
    pub fn set_deploy_failure_cause<T: std::convert::Into<crate::model::rollout::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_failure_cause = v.into();
        self
    }

    /// Sets the value of [phases][crate::model::Rollout::phases].
    pub fn set_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Phase>,
    {
        use std::iter::Iterator;
        self.phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Rollout::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Rollout::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [controller_rollout][crate::model::Rollout::controller_rollout].
    pub fn set_controller_rollout<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.controller_rollout = v.into();
        self
    }

    /// Sets the value of [rollback_of_rollout][crate::model::Rollout::rollback_of_rollout].
    pub fn set_rollback_of_rollout<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollback_of_rollout = v.into();
        self
    }

    /// Sets the value of [rolled_back_by_rollouts][crate::model::Rollout::rolled_back_by_rollouts].
    pub fn set_rolled_back_by_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.rolled_back_by_rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_repair_automation_run][crate::model::Rollout::active_repair_automation_run].
    pub fn set_active_repair_automation_run<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_repair_automation_run = v.into();
        self
    }
}

impl wkt::message::Message for Rollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Rollout"
    }
}

/// Defines additional types related to [Rollout].
pub mod rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Valid approval states of a `Rollout`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApprovalState {
        /// The `Rollout` has an unspecified approval state.
        Unspecified,
        /// The `Rollout` requires approval.
        NeedsApproval,
        /// The `Rollout` does not require approval.
        DoesNotNeedApproval,
        /// The `Rollout` has been approved.
        Approved,
        /// The `Rollout` has been rejected.
        Rejected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApprovalState::value] or
        /// [ApprovalState::name].
        UnknownValue(approval_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod approval_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ApprovalState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NeedsApproval => std::option::Option::Some(1),
                Self::DoesNotNeedApproval => std::option::Option::Some(2),
                Self::Approved => std::option::Option::Some(3),
                Self::Rejected => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("APPROVAL_STATE_UNSPECIFIED"),
                Self::NeedsApproval => std::option::Option::Some("NEEDS_APPROVAL"),
                Self::DoesNotNeedApproval => std::option::Option::Some("DOES_NOT_NEED_APPROVAL"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ApprovalState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ApprovalState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ApprovalState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NeedsApproval,
                2 => Self::DoesNotNeedApproval,
                3 => Self::Approved,
                4 => Self::Rejected,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ApprovalState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Self::Unspecified,
                "NEEDS_APPROVAL" => Self::NeedsApproval,
                "DOES_NOT_NEED_APPROVAL" => Self::DoesNotNeedApproval,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                _ => Self::UnknownValue(approval_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ApprovalState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NeedsApproval => serializer.serialize_i32(1),
                Self::DoesNotNeedApproval => serializer.serialize_i32(2),
                Self::Approved => serializer.serialize_i32(3),
                Self::Rejected => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ApprovalState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApprovalState>::new(
                ".google.cloud.deploy.v1.Rollout.ApprovalState",
            ))
        }
    }

    /// Valid states of a `Rollout`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `Rollout` has an unspecified state.
        Unspecified,
        /// The `Rollout` has completed successfully.
        Succeeded,
        /// The `Rollout` has failed.
        Failed,
        /// The `Rollout` is being deployed.
        InProgress,
        /// The `Rollout` needs approval.
        PendingApproval,
        /// An approver rejected the `Rollout`.
        ApprovalRejected,
        /// The `Rollout` is waiting for an earlier Rollout(s) to complete on this
        /// `Target`.
        Pending,
        /// The `Rollout` is waiting for the `Release` to be fully rendered.
        PendingRelease,
        /// The `Rollout` is in the process of being cancelled.
        Cancelling,
        /// The `Rollout` has been cancelled.
        Cancelled,
        /// The `Rollout` is halted.
        Halted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::PendingApproval => std::option::Option::Some(4),
                Self::ApprovalRejected => std::option::Option::Some(5),
                Self::Pending => std::option::Option::Some(6),
                Self::PendingRelease => std::option::Option::Some(7),
                Self::Cancelling => std::option::Option::Some(8),
                Self::Cancelled => std::option::Option::Some(9),
                Self::Halted => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::PendingApproval => std::option::Option::Some("PENDING_APPROVAL"),
                Self::ApprovalRejected => std::option::Option::Some("APPROVAL_REJECTED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::PendingRelease => std::option::Option::Some("PENDING_RELEASE"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Halted => std::option::Option::Some("HALTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::InProgress,
                4 => Self::PendingApproval,
                5 => Self::ApprovalRejected,
                6 => Self::Pending,
                7 => Self::PendingRelease,
                8 => Self::Cancelling,
                9 => Self::Cancelled,
                10 => Self::Halted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                "PENDING_APPROVAL" => Self::PendingApproval,
                "APPROVAL_REJECTED" => Self::ApprovalRejected,
                "PENDING" => Self::Pending,
                "PENDING_RELEASE" => Self::PendingRelease,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "HALTED" => Self::Halted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::PendingApproval => serializer.serialize_i32(4),
                Self::ApprovalRejected => serializer.serialize_i32(5),
                Self::Pending => serializer.serialize_i32(6),
                Self::PendingRelease => serializer.serialize_i32(7),
                Self::Cancelling => serializer.serialize_i32(8),
                Self::Cancelled => serializer.serialize_i32(9),
                Self::Halted => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Rollout.State",
            ))
        }
    }

    /// Well-known rollout failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The deploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// Deployment did not complete within the allotted time.
        DeadlineExceeded,
        /// Release is in a failed state.
        ReleaseFailed,
        /// Release is abandoned.
        ReleaseAbandoned,
        /// No Skaffold verify configuration was found.
        VerificationConfigNotFound,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// A Rollout operation had a feature configured that is not supported.
        OperationFeatureNotSupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::ReleaseFailed => std::option::Option::Some(4),
                Self::ReleaseAbandoned => std::option::Option::Some(5),
                Self::VerificationConfigNotFound => std::option::Option::Some(6),
                Self::CloudBuildRequestFailed => std::option::Option::Some(7),
                Self::OperationFeatureNotSupported => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::ReleaseFailed => std::option::Option::Some("RELEASE_FAILED"),
                Self::ReleaseAbandoned => std::option::Option::Some("RELEASE_ABANDONED"),
                Self::VerificationConfigNotFound => {
                    std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::OperationFeatureNotSupported => {
                    std::option::Option::Some("OPERATION_FEATURE_NOT_SUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::ReleaseFailed,
                5 => Self::ReleaseAbandoned,
                6 => Self::VerificationConfigNotFound,
                7 => Self::CloudBuildRequestFailed,
                8 => Self::OperationFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "RELEASE_FAILED" => Self::ReleaseFailed,
                "RELEASE_ABANDONED" => Self::ReleaseAbandoned,
                "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                "OPERATION_FEATURE_NOT_SUPPORTED" => Self::OperationFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::ReleaseFailed => serializer.serialize_i32(4),
                Self::ReleaseAbandoned => serializer.serialize_i32(5),
                Self::VerificationConfigNotFound => serializer.serialize_i32(6),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(7),
                Self::OperationFeatureNotSupported => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.Rollout.FailureCause",
            ))
        }
    }
}

/// Metadata includes information associated with a `Rollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Metadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_run: std::option::Option<crate::model::CloudRunMetadata>,

    /// Output only. AutomationRolloutMetadata contains the information about the
    /// interactions between Automation service and this rollout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automation: std::option::Option<crate::model::AutomationRolloutMetadata>,

    /// Output only. Custom metadata provided by user-defined `Rollout` operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::Metadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::Metadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automation][crate::model::Metadata::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRolloutMetadata>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::Metadata::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRolloutMetadata>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::Metadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::Metadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Metadata"
    }
}

/// DeployJobRunMetadata surfaces information associated with a `DeployJobRun` to
/// the user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployJobRunMetadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `DeployJobRun`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cloud_run: std::option::Option<crate::model::CloudRunMetadata>,

    /// Output only. Custom Target metadata associated with a `DeployJobRun`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_target: std::option::Option<crate::model::CustomTargetDeployMetadata>,

    /// Output only. Custom metadata provided by user-defined deploy operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom: std::option::Option<crate::model::CustomMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJobRunMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_run][crate::model::DeployJobRunMetadata::cloud_run].
    pub fn set_cloud_run<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run][crate::model::DeployJobRunMetadata::cloud_run].
    pub fn set_or_clear_cloud_run<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunMetadata>,
    {
        self.cloud_run = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_target][crate::model::DeployJobRunMetadata::custom_target].
    pub fn set_custom_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetDeployMetadata>,
    {
        self.custom_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_target][crate::model::DeployJobRunMetadata::custom_target].
    pub fn set_or_clear_custom_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomTargetDeployMetadata>,
    {
        self.custom_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom][crate::model::DeployJobRunMetadata::custom].
    pub fn set_custom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom][crate::model::DeployJobRunMetadata::custom].
    pub fn set_or_clear_custom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomMetadata>,
    {
        self.custom = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployJobRunMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJobRunMetadata"
    }
}

/// CloudRunMetadata contains information from a Cloud Run deployment.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudRunMetadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/services/{service}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service: std::string::String,

    /// Output only. The Cloud Run Service urls that are associated with a
    /// `Rollout`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub service_urls: std::vec::Vec<std::string::String>,

    /// Output only. The Cloud Run Revision id associated with a `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub revision: std::string::String,

    /// Output only. The name of the Cloud Run job that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/jobs/{job_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CloudRunMetadata::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_urls][crate::model::CloudRunMetadata::service_urls].
    pub fn set_service_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [revision][crate::model::CloudRunMetadata::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CloudRunMetadata::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CloudRunMetadata"
    }
}

/// CustomTargetDeployMetadata contains information from a Custom Target
/// deploy operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTargetDeployMetadata {
    /// Output only. Skip message provided in the results of a custom deploy
    /// operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skip_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetDeployMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skip_message][crate::model::CustomTargetDeployMetadata::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }
}

impl wkt::message::Message for CustomTargetDeployMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetDeployMetadata"
    }
}

/// AutomationRolloutMetadata contains Automation-related actions that
/// were performed on a rollout.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationRolloutMetadata {
    /// Output only. The name of the AutomationRun initiated by a promote release
    /// rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub promote_automation_run: std::string::String,

    /// Output only. The names of the AutomationRuns initiated by an advance
    /// rollout rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub advance_automation_runs: std::vec::Vec<std::string::String>,

    /// Output only. The names of the AutomationRuns initiated by a repair rollout
    /// rule.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub repair_automation_runs: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRolloutMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [promote_automation_run][crate::model::AutomationRolloutMetadata::promote_automation_run].
    pub fn set_promote_automation_run<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.promote_automation_run = v.into();
        self
    }

    /// Sets the value of [advance_automation_runs][crate::model::AutomationRolloutMetadata::advance_automation_runs].
    pub fn set_advance_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.advance_automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [repair_automation_runs][crate::model::AutomationRolloutMetadata::repair_automation_runs].
    pub fn set_repair_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.repair_automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutomationRolloutMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRolloutMetadata"
    }
}

/// CustomMetadata contains information from a user-defined operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomMetadata {
    /// Output only. Key-value pairs provided by the user-defined operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub values: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::CustomMetadata::values].
    pub fn set_values<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CustomMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomMetadata"
    }
}

/// Phase represents a collection of jobs that are logically grouped together
/// for a `Rollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Phase {
    /// Output only. The ID of the Phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Output only. Current state of the Phase.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::phase::State,

    /// Output only. Additional information on why the Phase was skipped, if
    /// available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skip_message: std::string::String,

    /// The job composition of this Phase.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub jobs: std::option::Option<crate::model::phase::Jobs>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Phase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Phase::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Phase::state].
    pub fn set_state<T: std::convert::Into<crate::model::phase::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [skip_message][crate::model::Phase::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs].
    ///
    /// Note that all the setters affecting `jobs` are mutually
    /// exclusive.
    pub fn set_jobs<T: std::convert::Into<std::option::Option<crate::model::phase::Jobs>>>(
        mut self,
        v: T,
    ) -> Self {
        self.jobs = v.into();
        self
    }

    /// The value of [jobs][crate::model::Phase::jobs]
    /// if it holds a `DeploymentJobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deployment_jobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeploymentJobs>> {
        #[allow(unreachable_patterns)]
        self.jobs.as_ref().and_then(|v| match v {
            crate::model::phase::Jobs::DeploymentJobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs]
    /// to hold a `DeploymentJobs`.
    ///
    /// Note that all the setters affecting `jobs` are
    /// mutually exclusive.
    pub fn set_deployment_jobs<
        T: std::convert::Into<std::boxed::Box<crate::model::DeploymentJobs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.jobs = std::option::Option::Some(crate::model::phase::Jobs::DeploymentJobs(v.into()));
        self
    }

    /// The value of [jobs][crate::model::Phase::jobs]
    /// if it holds a `ChildRolloutJobs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn child_rollout_jobs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ChildRolloutJobs>> {
        #[allow(unreachable_patterns)]
        self.jobs.as_ref().and_then(|v| match v {
            crate::model::phase::Jobs::ChildRolloutJobs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [jobs][crate::model::Phase::jobs]
    /// to hold a `ChildRolloutJobs`.
    ///
    /// Note that all the setters affecting `jobs` are
    /// mutually exclusive.
    pub fn set_child_rollout_jobs<
        T: std::convert::Into<std::boxed::Box<crate::model::ChildRolloutJobs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.jobs =
            std::option::Option::Some(crate::model::phase::Jobs::ChildRolloutJobs(v.into()));
        self
    }
}

impl wkt::message::Message for Phase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Phase"
    }
}

/// Defines additional types related to [Phase].
pub mod phase {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a Phase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Phase has an unspecified state.
        Unspecified,
        /// The Phase is waiting for an earlier Phase(s) to complete.
        Pending,
        /// The Phase is in progress.
        InProgress,
        /// The Phase has succeeded.
        Succeeded,
        /// The Phase has failed.
        Failed,
        /// The Phase was aborted.
        Aborted,
        /// The Phase was skipped.
        Skipped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::InProgress => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Aborted => std::option::Option::Some(5),
                Self::Skipped => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::InProgress,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Aborted,
                6 => Self::Skipped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "SKIPPED" => Self::Skipped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::InProgress => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Aborted => serializer.serialize_i32(5),
                Self::Skipped => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Phase.State",
            ))
        }
    }

    /// The job composition of this Phase.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Jobs {
        /// Output only. Deployment job composition.
        DeploymentJobs(std::boxed::Box<crate::model::DeploymentJobs>),
        /// Output only. ChildRollout job composition.
        ChildRolloutJobs(std::boxed::Box<crate::model::ChildRolloutJobs>),
    }
}

/// Deployment job composition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeploymentJobs {
    /// Output only. The predeploy Job, which is the first job on the phase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub predeploy_job: std::option::Option<crate::model::Job>,

    /// Output only. The deploy Job. This is the deploy job in the phase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deploy_job: std::option::Option<crate::model::Job>,

    /// Output only. The verify Job. Runs after a deploy if the deploy succeeds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_job: std::option::Option<crate::model::Job>,

    /// Output only. The postdeploy Job, which is the last job on the phase.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub postdeploy_job: std::option::Option<crate::model::Job>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeploymentJobs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [predeploy_job][crate::model::DeploymentJobs::predeploy_job].
    pub fn set_predeploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.predeploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predeploy_job][crate::model::DeploymentJobs::predeploy_job].
    pub fn set_or_clear_predeploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.predeploy_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deploy_job][crate::model::DeploymentJobs::deploy_job].
    pub fn set_deploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.deploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deploy_job][crate::model::DeploymentJobs::deploy_job].
    pub fn set_or_clear_deploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.deploy_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verify_job][crate::model::DeploymentJobs::verify_job].
    pub fn set_verify_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.verify_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_job][crate::model::DeploymentJobs::verify_job].
    pub fn set_or_clear_verify_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.verify_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [postdeploy_job][crate::model::DeploymentJobs::postdeploy_job].
    pub fn set_postdeploy_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.postdeploy_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postdeploy_job][crate::model::DeploymentJobs::postdeploy_job].
    pub fn set_or_clear_postdeploy_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.postdeploy_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeploymentJobs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeploymentJobs"
    }
}

/// ChildRollouts job composition
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChildRolloutJobs {
    /// Output only. List of CreateChildRolloutJobs
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub create_rollout_jobs: std::vec::Vec<crate::model::Job>,

    /// Output only. List of AdvanceChildRolloutJobs
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub advance_rollout_jobs: std::vec::Vec<crate::model::Job>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChildRolloutJobs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_rollout_jobs][crate::model::ChildRolloutJobs::create_rollout_jobs].
    pub fn set_create_rollout_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.create_rollout_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [advance_rollout_jobs][crate::model::ChildRolloutJobs::advance_rollout_jobs].
    pub fn set_advance_rollout_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.advance_rollout_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ChildRolloutJobs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ChildRolloutJobs"
    }
}

/// Job represents an operation for a `Rollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Job {
    /// Output only. The ID of the Job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Output only. The current state of the Job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::job::State,

    /// Output only. Additional information on why the Job was skipped, if
    /// available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub skip_message: std::string::String,

    /// Output only. The name of the `JobRun` responsible for the most recent
    /// invocation of this Job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_run: std::string::String,

    /// The type of Job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job_type: std::option::Option<crate::model::job::JobType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Job::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::job::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [skip_message][crate::model::Job::skip_message].
    pub fn set_skip_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_message = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::Job::job_run].
    pub fn set_job_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_run = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::Job::job_type].
    ///
    /// Note that all the setters affecting `job_type` are mutually
    /// exclusive.
    pub fn set_job_type<T: std::convert::Into<std::option::Option<crate::model::job::JobType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `DeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deploy_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::DeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::DeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `DeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_deploy_job<T: std::convert::Into<std::boxed::Box<crate::model::DeployJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = std::option::Option::Some(crate::model::job::JobType::DeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `VerifyJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn verify_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::VerifyJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::VerifyJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `VerifyJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_verify_job<T: std::convert::Into<std::boxed::Box<crate::model::VerifyJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = std::option::Option::Some(crate::model::job::JobType::VerifyJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `PredeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn predeploy_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::PredeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `PredeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_predeploy_job<T: std::convert::Into<std::boxed::Box<crate::model::PredeployJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::PredeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `PostdeployJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postdeploy_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostdeployJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::PostdeployJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `PostdeployJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_postdeploy_job<
        T: std::convert::Into<std::boxed::Box<crate::model::PostdeployJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::PostdeployJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `CreateChildRolloutJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_child_rollout_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateChildRolloutJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::CreateChildRolloutJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `CreateChildRolloutJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_create_child_rollout_job<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateChildRolloutJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::CreateChildRolloutJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::Job::job_type]
    /// if it holds a `AdvanceChildRolloutJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_child_rollout_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceChildRolloutJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::job::JobType::AdvanceChildRolloutJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::Job::job_type]
    /// to hold a `AdvanceChildRolloutJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_advance_child_rollout_job<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceChildRolloutJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::job::JobType::AdvanceChildRolloutJob(v.into()));
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Job"
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a Job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Job has an unspecified state.
        Unspecified,
        /// The Job is waiting for an earlier Phase(s) or Job(s) to complete.
        Pending,
        /// The Job is disabled.
        Disabled,
        /// The Job is in progress.
        InProgress,
        /// The Job succeeded.
        Succeeded,
        /// The Job failed.
        Failed,
        /// The Job was aborted.
        Aborted,
        /// The Job was skipped.
        Skipped,
        /// The Job was ignored.
        Ignored,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::Skipped => std::option::Option::Some(7),
                Self::Ignored => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::Ignored => std::option::Option::Some("IGNORED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Disabled,
                3 => Self::InProgress,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Aborted,
                7 => Self::Skipped,
                8 => Self::Ignored,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "DISABLED" => Self::Disabled,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                "SKIPPED" => Self::Skipped,
                "IGNORED" => Self::Ignored,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::Skipped => serializer.serialize_i32(7),
                Self::Ignored => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.Job.State",
            ))
        }
    }

    /// The type of Job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum JobType {
        /// Output only. A deploy Job.
        DeployJob(std::boxed::Box<crate::model::DeployJob>),
        /// Output only. A verify Job.
        VerifyJob(std::boxed::Box<crate::model::VerifyJob>),
        /// Output only. A predeploy Job.
        PredeployJob(std::boxed::Box<crate::model::PredeployJob>),
        /// Output only. A postdeploy Job.
        PostdeployJob(std::boxed::Box<crate::model::PostdeployJob>),
        /// Output only. A createChildRollout Job.
        CreateChildRolloutJob(std::boxed::Box<crate::model::CreateChildRolloutJob>),
        /// Output only. An advanceChildRollout Job.
        AdvanceChildRolloutJob(std::boxed::Box<crate::model::AdvanceChildRolloutJob>),
    }
}

/// A deploy Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployJob {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJob"
    }
}

/// A verify Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyJob {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VerifyJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.VerifyJob"
    }
}

/// A predeploy Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredeployJob {
    /// Output only. The custom actions that the predeploy Job executes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::PredeployJob::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PredeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PredeployJob"
    }
}

/// A postdeploy Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostdeployJob {
    /// Output only. The custom actions that the postdeploy Job executes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub actions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostdeployJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::PostdeployJob::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PostdeployJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PostdeployJob"
    }
}

/// A createChildRollout Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateChildRolloutJob {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChildRolloutJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreateChildRolloutJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateChildRolloutJob"
    }
}

/// An advanceChildRollout Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceChildRolloutJob {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceChildRolloutJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdvanceChildRolloutJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceChildRolloutJob"
    }
}

/// ListRolloutsRequest is the request object used by `ListRollouts`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRolloutsRequest {
    /// Required. The `Release` which owns this collection of `Rollout` objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `Rollout` objects to return. The service
    /// may return fewer than this value. If unspecified, at most 50 `Rollout`
    /// objects will be returned. The maximum value is 1000; values above 1000 will
    /// be set to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListRollouts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter rollouts to be returned. See <https://google.aip.dev/160>
    /// for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRolloutsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRolloutsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRolloutsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRolloutsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRolloutsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRolloutsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRolloutsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListRolloutsRequest"
    }
}

/// ListRolloutsResponse is the response object returned by `ListRollouts`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRolloutsResponse {
    /// The `Rollout` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub rollouts: std::vec::Vec<crate::model::Rollout>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRolloutsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollouts][crate::model::ListRolloutsResponse::rollouts].
    pub fn set_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rollout>,
    {
        use std::iter::Iterator;
        self.rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRolloutsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRolloutsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRolloutsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListRolloutsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRolloutsResponse {
    type PageItem = crate::model::Rollout;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rollouts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetRolloutRequest is the request object used by `GetRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRolloutRequest {
    /// Required. Name of the `Rollout`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetRolloutRequest"
    }
}

/// CreateRolloutRequest is the request object used by `CreateRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRolloutRequest {
    /// Required. The parent collection in which the `Rollout` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_id: std::string::String,

    /// Required. The `Rollout` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::Rollout>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    /// Optional. The starting phase ID for the `Rollout`. If empty the `Rollout`
    /// will start at the first phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub starting_phase_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRolloutRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::CreateRolloutRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::CreateRolloutRequest::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::CreateRolloutRequest::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateRolloutRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateRolloutRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CreateRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [starting_phase_id][crate::model::CreateRolloutRequest::starting_phase_id].
    pub fn set_starting_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.starting_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateRolloutRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.OperationMetadata"
    }
}

/// The request object used by `ApproveRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. True = approve; false = reject
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub approved: bool,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [approved][crate::model::ApproveRolloutRequest::approved].
    pub fn set_approved<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.approved = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::ApproveRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ApproveRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ApproveRolloutRequest"
    }
}

/// The response object from `ApproveRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveRolloutResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ApproveRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ApproveRolloutResponse"
    }
}

/// The request object used by `AdvanceRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. The phase ID to advance the `Rollout` to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdvanceRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::AdvanceRolloutRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::AdvanceRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdvanceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutRequest"
    }
}

/// The response object from `AdvanceRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceRolloutResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdvanceRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutResponse"
    }
}

/// The request object used by `CancelRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelRolloutRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelRolloutRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::CancelRolloutRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CancelRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelRolloutRequest"
    }
}

/// The response object from `CancelRollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelRolloutResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelRolloutResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelRolloutResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelRolloutResponse"
    }
}

/// The request object used by `IgnoreJob`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IgnoreJobRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Required. The phase ID the Job to ignore belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase_id: std::string::String,

    /// Required. The job ID for the Job to ignore.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IgnoreJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::IgnoreJobRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::IgnoreJobRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::IgnoreJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::IgnoreJobRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IgnoreJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.IgnoreJobRequest"
    }
}

/// The response object from `IgnoreJob`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IgnoreJobResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IgnoreJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for IgnoreJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.IgnoreJobResponse"
    }
}

/// RetryJobRequest is the request object used by `RetryJob`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryJobRequest {
    /// Required. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Required. The phase ID the Job to retry belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase_id: std::string::String,

    /// Required. The job ID for the Job to retry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_id: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RetryJobRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::RetryJobRequest::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::RetryJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::RetryJobRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RetryJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryJobRequest"
    }
}

/// The response object from 'RetryJob'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryJobResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RetryJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryJobResponse"
    }
}

/// The request object used by `AbandonRelease`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AbandonReleaseRequest {
    /// Required. Name of the Release. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AbandonReleaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AbandonReleaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AbandonReleaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AbandonReleaseRequest"
    }
}

/// The response object for `AbandonRelease`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AbandonReleaseResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AbandonReleaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AbandonReleaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AbandonReleaseResponse"
    }
}

/// A `JobRun` resource in the Cloud Deploy API.
///
/// A `JobRun` contains information of a single `Rollout` job evaluation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobRun {
    /// Output only. Name of the `JobRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{releases}/rollouts/{rollouts}/jobRuns/{uuid}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `JobRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Output only. ID of the `Rollout` phase this `JobRun` belongs in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase_id: std::string::String,

    /// Output only. ID of the `Rollout` job this `JobRun` corresponds to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_id: std::string::String,

    /// Output only. Time at which the `JobRun` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `JobRun` was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the `JobRun` ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the `JobRun`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::job_run::State,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// The `JobRun` type and the information for that type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job_run: std::option::Option<crate::model::job_run::JobRun>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::JobRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::JobRun::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [phase_id][crate::model::JobRun::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobRun::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::JobRun::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::JobRun::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::JobRun::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::JobRun::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::JobRun::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::JobRun::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::JobRun::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_run::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::JobRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run].
    ///
    /// Note that all the setters affecting `job_run` are mutually
    /// exclusive.
    pub fn set_job_run<
        T: std::convert::Into<std::option::Option<crate::model::job_run::JobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = v.into();
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `DeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn deploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::DeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `DeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_deploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::DeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::DeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `VerifyJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn verify_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VerifyJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::VerifyJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `VerifyJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_verify_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::VerifyJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::VerifyJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `PredeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn predeploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PredeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::PredeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `PredeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_predeploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::PredeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::PredeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `PostdeployJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postdeploy_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostdeployJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::PostdeployJobRun(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `PostdeployJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_postdeploy_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::PostdeployJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run =
            std::option::Option::Some(crate::model::job_run::JobRun::PostdeployJobRun(v.into()));
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `CreateChildRolloutJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_child_rollout_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateChildRolloutJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::CreateChildRolloutJobRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `CreateChildRolloutJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_create_child_rollout_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateChildRolloutJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = std::option::Option::Some(
            crate::model::job_run::JobRun::CreateChildRolloutJobRun(v.into()),
        );
        self
    }

    /// The value of [job_run][crate::model::JobRun::job_run]
    /// if it holds a `AdvanceChildRolloutJobRun`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_child_rollout_job_run(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>> {
        #[allow(unreachable_patterns)]
        self.job_run.as_ref().and_then(|v| match v {
            crate::model::job_run::JobRun::AdvanceChildRolloutJobRun(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_run][crate::model::JobRun::job_run]
    /// to hold a `AdvanceChildRolloutJobRun`.
    ///
    /// Note that all the setters affecting `job_run` are
    /// mutually exclusive.
    pub fn set_advance_child_rollout_job_run<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_run = std::option::Option::Some(
            crate::model::job_run::JobRun::AdvanceChildRolloutJobRun(v.into()),
        );
        self
    }
}

impl wkt::message::Message for JobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.JobRun"
    }
}

/// Defines additional types related to [JobRun].
pub mod job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Valid states of a `JobRun`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `JobRun` has an unspecified state.
        Unspecified,
        /// The `JobRun` is in progress.
        InProgress,
        /// The `JobRun` has succeeded.
        Succeeded,
        /// The `JobRun` has failed.
        Failed,
        /// The `JobRun` is terminating.
        Terminating,
        /// The `JobRun` was terminated.
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Terminating => std::option::Option::Some(4),
                Self::Terminated => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Terminating,
                5 => Self::Terminated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Terminating => serializer.serialize_i32(4),
                Self::Terminated => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.JobRun.State",
            ))
        }
    }

    /// The `JobRun` type and the information for that type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum JobRun {
        /// Output only. Information specific to a deploy `JobRun`.
        DeployJobRun(std::boxed::Box<crate::model::DeployJobRun>),
        /// Output only. Information specific to a verify `JobRun`.
        VerifyJobRun(std::boxed::Box<crate::model::VerifyJobRun>),
        /// Output only. Information specific to a predeploy `JobRun`.
        PredeployJobRun(std::boxed::Box<crate::model::PredeployJobRun>),
        /// Output only. Information specific to a postdeploy `JobRun`.
        PostdeployJobRun(std::boxed::Box<crate::model::PostdeployJobRun>),
        /// Output only. Information specific to a createChildRollout `JobRun`.
        CreateChildRolloutJobRun(std::boxed::Box<crate::model::CreateChildRolloutJobRun>),
        /// Output only. Information specific to an advanceChildRollout `JobRun`
        AdvanceChildRolloutJobRun(std::boxed::Box<crate::model::AdvanceChildRolloutJobRun>),
    }
}

/// DeployJobRun contains information specific to a deploy `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to deploy. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub build: std::string::String,

    /// Output only. The reason the deploy failed. This will always be unspecified
    /// while the deploy is in progress or if it succeeded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_cause: crate::model::deploy_job_run::FailureCause,

    /// Output only. Additional information about the deploy failure, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    /// Output only. Metadata containing information about the deploy job run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::DeployJobRunMetadata>,

    /// Output only. The artifact of a deploy job run, if available.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub artifact: std::option::Option<crate::model::DeployArtifact>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::DeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::DeployJobRun::failure_cause].
    pub fn set_failure_cause<T: std::convert::Into<crate::model::deploy_job_run::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::DeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::DeployJobRun::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployJobRunMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::DeployJobRun::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployJobRunMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [artifact][crate::model::DeployJobRun::artifact].
    pub fn set_artifact<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeployArtifact>,
    {
        self.artifact = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [artifact][crate::model::DeployJobRun::artifact].
    pub fn set_or_clear_artifact<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeployArtifact>,
    {
        self.artifact = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployJobRun"
    }
}

/// Defines additional types related to [DeployJobRun].
pub mod deploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known deploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [Required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The deploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The deploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// There were missing resources in the runtime environment required for a
        /// canary deployment. Check the Cloud Build logs for more information.
        MissingResourcesForCanary,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// The deploy operation had a feature configured that is not supported.
        DeployFeatureNotSupported,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::MissingResourcesForCanary => std::option::Option::Some(4),
                Self::CloudBuildRequestFailed => std::option::Option::Some(5),
                Self::DeployFeatureNotSupported => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::MissingResourcesForCanary => {
                    std::option::Option::Some("MISSING_RESOURCES_FOR_CANARY")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::DeployFeatureNotSupported => {
                    std::option::Option::Some("DEPLOY_FEATURE_NOT_SUPPORTED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::MissingResourcesForCanary,
                5 => Self::CloudBuildRequestFailed,
                6 => Self::DeployFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "MISSING_RESOURCES_FOR_CANARY" => Self::MissingResourcesForCanary,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                "DEPLOY_FEATURE_NOT_SUPPORTED" => Self::DeployFeatureNotSupported,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::MissingResourcesForCanary => serializer.serialize_i32(4),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(5),
                Self::DeployFeatureNotSupported => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.DeployJobRun.FailureCause",
            ))
        }
    }
}

/// VerifyJobRun contains information specific to a verify `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to verify. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub build: std::string::String,

    /// Output only. URI of a directory containing the verify artifacts. This
    /// contains the Skaffold event log.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub artifact_uri: std::string::String,

    /// Output only. File path of the Skaffold event log relative to the artifact
    /// URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub event_log_path: std::string::String,

    /// Output only. The reason the verify failed. This will always be unspecified
    /// while the verify is in progress or if it succeeded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_cause: crate::model::verify_job_run::FailureCause,

    /// Output only. Additional information about the verify failure, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::VerifyJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [artifact_uri][crate::model::VerifyJobRun::artifact_uri].
    pub fn set_artifact_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.artifact_uri = v.into();
        self
    }

    /// Sets the value of [event_log_path][crate::model::VerifyJobRun::event_log_path].
    pub fn set_event_log_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_log_path = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::VerifyJobRun::failure_cause].
    pub fn set_failure_cause<T: std::convert::Into<crate::model::verify_job_run::FailureCause>>(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::VerifyJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for VerifyJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.VerifyJobRun"
    }
}

/// Defines additional types related to [VerifyJobRun].
pub mod verify_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known verify failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The verify operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The verify job run did not complete within the allotted time.
        DeadlineExceeded,
        /// No Skaffold verify configuration was found.
        VerificationConfigNotFound,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::VerificationConfigNotFound => std::option::Option::Some(4),
                Self::CloudBuildRequestFailed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::VerificationConfigNotFound => {
                    std::option::Option::Some("VERIFICATION_CONFIG_NOT_FOUND")
                }
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::VerificationConfigNotFound,
                5 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "VERIFICATION_CONFIG_NOT_FOUND" => Self::VerificationConfigNotFound,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::VerificationConfigNotFound => serializer.serialize_i32(4),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.VerifyJobRun.FailureCause",
            ))
        }
    }
}

/// PredeployJobRun contains information specific to a predeploy `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to execute the custom actions associated with the predeploy Job.
    /// Format is `projects/{project}/locations/{location}/builds/{build}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub build: std::string::String,

    /// Output only. The reason the predeploy failed. This will always be
    /// unspecified while the predeploy is in progress or if it succeeded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_cause: crate::model::predeploy_job_run::FailureCause,

    /// Output only. Additional information about the predeploy failure, if
    /// available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::PredeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::PredeployJobRun::failure_cause].
    pub fn set_failure_cause<
        T: std::convert::Into<crate::model::predeploy_job_run::FailureCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PredeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PredeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PredeployJobRun"
    }
}

/// Defines additional types related to [PredeployJobRun].
pub mod predeploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known predeploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The predeploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The predeploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::CloudBuildRequestFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.PredeployJobRun.FailureCause",
            ))
        }
    }
}

/// PostdeployJobRun contains information specific to a postdeploy `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostdeployJobRun {
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to execute the custom actions associated with the postdeploy Job.
    /// Format is `projects/{project}/locations/{location}/builds/{build}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub build: std::string::String,

    /// Output only. The reason the postdeploy failed. This will always be
    /// unspecified while the postdeploy is in progress or if it succeeded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_cause: crate::model::postdeploy_job_run::FailureCause,

    /// Output only. Additional information about the postdeploy failure, if
    /// available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub failure_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostdeployJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build][crate::model::PostdeployJobRun::build].
    pub fn set_build<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.build = v.into();
        self
    }

    /// Sets the value of [failure_cause][crate::model::PostdeployJobRun::failure_cause].
    pub fn set_failure_cause<
        T: std::convert::Into<crate::model::postdeploy_job_run::FailureCause>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_cause = v.into();
        self
    }

    /// Sets the value of [failure_message][crate::model::PostdeployJobRun::failure_message].
    pub fn set_failure_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_message = v.into();
        self
    }
}

impl wkt::message::Message for PostdeployJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PostdeployJobRun"
    }
}

/// Defines additional types related to [PostdeployJobRun].
pub mod postdeploy_job_run {
    #[allow(unused_imports)]
    use super::*;

    /// Well-known postdeploy failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
        CloudBuildUnavailable,
        /// The postdeploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed,
        /// The postdeploy job run did not complete within the allotted time.
        DeadlineExceeded,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FailureCause::value] or
        /// [FailureCause::name].
        UnknownValue(failure_cause::UnknownValue),
    }

    #[doc(hidden)]
    pub mod failure_cause {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FailureCause {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudBuildUnavailable => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::DeadlineExceeded => std::option::Option::Some(3),
                Self::CloudBuildRequestFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAILURE_CAUSE_UNSPECIFIED"),
                Self::CloudBuildUnavailable => std::option::Option::Some("CLOUD_BUILD_UNAVAILABLE"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::DeadlineExceeded => std::option::Option::Some("DEADLINE_EXCEEDED"),
                Self::CloudBuildRequestFailed => {
                    std::option::Option::Some("CLOUD_BUILD_REQUEST_FAILED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FailureCause {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FailureCause {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FailureCause {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudBuildUnavailable,
                2 => Self::ExecutionFailed,
                3 => Self::DeadlineExceeded,
                4 => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FailureCause {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_BUILD_UNAVAILABLE" => Self::CloudBuildUnavailable,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "DEADLINE_EXCEEDED" => Self::DeadlineExceeded,
                "CLOUD_BUILD_REQUEST_FAILED" => Self::CloudBuildRequestFailed,
                _ => Self::UnknownValue(failure_cause::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FailureCause {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudBuildUnavailable => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::DeadlineExceeded => serializer.serialize_i32(3),
                Self::CloudBuildRequestFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FailureCause {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureCause>::new(
                ".google.cloud.deploy.v1.PostdeployJobRun.FailureCause",
            ))
        }
    }
}

/// CreateChildRolloutJobRun contains information specific to a
/// createChildRollout `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateChildRolloutJobRun {
    /// Output only. Name of the `ChildRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Output only. The ID of the childRollout Phase initiated by this JobRun.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_phase_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChildRolloutJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::CreateChildRolloutJobRun::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [rollout_phase_id][crate::model::CreateChildRolloutJobRun::rollout_phase_id].
    pub fn set_rollout_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateChildRolloutJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateChildRolloutJobRun"
    }
}

/// AdvanceChildRolloutJobRun contains information specific to a
/// advanceChildRollout `JobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceChildRolloutJobRun {
    /// Output only. Name of the `ChildRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Output only. the ID of the ChildRollout's Phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_phase_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceChildRolloutJobRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::AdvanceChildRolloutJobRun::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [rollout_phase_id][crate::model::AdvanceChildRolloutJobRun::rollout_phase_id].
    pub fn set_rollout_phase_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_phase_id = v.into();
        self
    }
}

impl wkt::message::Message for AdvanceChildRolloutJobRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceChildRolloutJobRun"
    }
}

/// ListJobRunsRequest is the request object used by `ListJobRuns`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobRunsRequest {
    /// Required. The `Rollout` which owns this collection of `JobRun` objects.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of `JobRun` objects to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `JobRun` objects
    /// will be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListJobRuns` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter results to be returned. See <https://google.aip.dev/160> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Field to sort by. See <https://google.aip.dev/132#ordering> for
    /// more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListJobRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListJobRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListJobRunsRequest"
    }
}

/// ListJobRunsResponse is the response object returned by `ListJobRuns`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobRunsResponse {
    /// The `JobRun` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub job_runs: std::vec::Vec<crate::model::JobRun>,

    /// A token, which can be sent as `page_token` to retrieve the next page. If
    /// this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_runs][crate::model::ListJobRunsResponse::job_runs].
    pub fn set_job_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobRun>,
    {
        use std::iter::Iterator;
        self.job_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListJobRunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListJobRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobRunsResponse {
    type PageItem = crate::model::JobRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.job_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// GetJobRunRequest is the request object used by `GetJobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobRunRequest {
    /// Required. Name of the `JobRun`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}/jobRuns/{job_run_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetJobRunRequest"
    }
}

/// The request object used by `TerminateJobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TerminateJobRunRequest {
    /// Required. Name of the `JobRun`. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}/jobRuns/{jobRun}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. Deploy policies to override. Format is
    /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub override_deploy_policy: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateJobRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TerminateJobRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [override_deploy_policy][crate::model::TerminateJobRunRequest::override_deploy_policy].
    pub fn set_override_deploy_policy<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.override_deploy_policy = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TerminateJobRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TerminateJobRunRequest"
    }
}

/// The response object from `TerminateJobRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TerminateJobRunResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateJobRunResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for TerminateJobRunResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TerminateJobRunResponse"
    }
}

/// Service-wide configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Config {
    /// Name of the configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// All supported versions of Skaffold.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub supported_versions: std::vec::Vec<crate::model::SkaffoldVersion>,

    /// Default Skaffold version that is assigned when a Release is created without
    /// specifying a Skaffold version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub default_skaffold_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Config::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [supported_versions][crate::model::Config::supported_versions].
    pub fn set_supported_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SkaffoldVersion>,
    {
        use std::iter::Iterator;
        self.supported_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_skaffold_version][crate::model::Config::default_skaffold_version].
    pub fn set_default_skaffold_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_skaffold_version = v.into();
        self
    }
}

impl wkt::message::Message for Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Config"
    }
}

/// Details of a supported Skaffold version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SkaffoldVersion {
    /// Release version number. For example, "1.20.3".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub version: std::string::String,

    /// The time at which this version of Skaffold will enter maintenance mode.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_mode_time: std::option::Option<wkt::Timestamp>,

    /// The time at which this version of Skaffold will no longer be supported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub support_expiration_time: std::option::Option<wkt::Timestamp>,

    /// Date when this version is expected to no longer be supported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub support_end_date: std::option::Option<gtype::model::Date>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SkaffoldVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::SkaffoldVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [maintenance_mode_time][crate::model::SkaffoldVersion::maintenance_mode_time].
    pub fn set_maintenance_mode_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_mode_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_mode_time][crate::model::SkaffoldVersion::maintenance_mode_time].
    pub fn set_or_clear_maintenance_mode_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.maintenance_mode_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [support_expiration_time][crate::model::SkaffoldVersion::support_expiration_time].
    pub fn set_support_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.support_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [support_expiration_time][crate::model::SkaffoldVersion::support_expiration_time].
    pub fn set_or_clear_support_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.support_expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [support_end_date][crate::model::SkaffoldVersion::support_end_date].
    pub fn set_support_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.support_end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [support_end_date][crate::model::SkaffoldVersion::support_end_date].
    pub fn set_or_clear_support_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.support_end_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SkaffoldVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.SkaffoldVersion"
    }
}

/// Request to get a configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConfigRequest {
    /// Required. Name of requested configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetConfigRequest"
    }
}

/// An `Automation` resource in the Cloud Deploy API.
///
/// An `Automation` enables the automation of manually driven actions for
/// a Delivery Pipeline, which includes Release promotion among Targets,
/// Rollout repair and Rollout deployment strategy advancement. The intention
/// of Automation is to reduce manual intervention in the continuous delivery
/// process.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Automation {
    /// Output only. Name of the `Automation`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automations/{automation}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Unique identifier of the `Automation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub uid: std::string::String,

    /// Optional. Description of the `Automation`. Max length is 255 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Output only. Time at which the automation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the automation was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. Annotations must meet the following
    /// constraints:
    ///
    /// * Annotations are key/value pairs.
    /// * Valid annotation keys have two segments: an optional prefix and name,
    ///   separated by a slash (`/`).
    /// * The name segment is required and must be 63 characters or less,
    ///   beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
    ///   dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
    /// * The prefix is optional. If specified, the prefix must be a DNS subdomain:
    ///   a series of DNS labels separated by dots(`.`), not longer than 253
    ///   characters in total, followed by a slash (`/`).
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set>
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 63 characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The weak etag of the `Automation` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Optional. When Suspended, automation is deactivated from execution.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub suspended: bool,

    /// Required. Email address of the user-managed IAM service account that
    /// creates Cloud Deploy release and rollout resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Required. Selected resources to which the automation will be applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub selector: std::option::Option<crate::model::AutomationResourceSelector>,

    /// Required. List of Automation rules associated with the Automation resource.
    /// Must have at least one rule and limited to 250 rules per Delivery Pipeline.
    /// Note: the order of the rules here is not the same as the order of
    /// execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub rules: std::vec::Vec<crate::model::AutomationRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Automation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Automation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Automation::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Automation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Automation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Automation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Automation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Automation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::Automation::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Automation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Automation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::Automation::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Automation::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [selector][crate::model::Automation::selector].
    pub fn set_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationResourceSelector>,
    {
        self.selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [selector][crate::model::Automation::selector].
    pub fn set_or_clear_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationResourceSelector>,
    {
        self.selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rules][crate::model::Automation::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutomationRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Automation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Automation"
    }
}

/// AutomationResourceSelector contains the information to select the resources
/// to which an Automation is going to be applied.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationResourceSelector {
    /// Optional. Contains attributes about a target.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub targets: std::vec::Vec<crate::model::TargetAttribute>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationResourceSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets][crate::model::AutomationResourceSelector::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetAttribute>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutomationResourceSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationResourceSelector"
    }
}

/// `AutomationRule` defines the automation activities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationRule {
    /// The configuration of the Automation rule.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::automation_rule::Rule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule].
    ///
    /// Note that all the setters affecting `rule` are mutually
    /// exclusive.
    pub fn set_rule<
        T: std::convert::Into<std::option::Option<crate::model::automation_rule::Rule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `PromoteReleaseRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn promote_release_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PromoteReleaseRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::PromoteReleaseRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `PromoteReleaseRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_promote_release_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::PromoteReleaseRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::PromoteReleaseRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `AdvanceRolloutRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_rollout_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceRolloutRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::AdvanceRolloutRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `AdvanceRolloutRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_advance_rollout_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceRolloutRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::AdvanceRolloutRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `RepairRolloutRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repair_rollout_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RepairRolloutRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::RepairRolloutRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `RepairRolloutRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_repair_rollout_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::RepairRolloutRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::RepairRolloutRule(v.into()),
        );
        self
    }

    /// The value of [rule][crate::model::AutomationRule::rule]
    /// if it holds a `TimedPromoteReleaseRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseRule>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::automation_rule::Rule::TimedPromoteReleaseRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::AutomationRule::rule]
    /// to hold a `TimedPromoteReleaseRule`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(
            crate::model::automation_rule::Rule::TimedPromoteReleaseRule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomationRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRule"
    }
}

/// Defines additional types related to [AutomationRule].
pub mod automation_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of the Automation rule.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Rule {
        /// Optional. `PromoteReleaseRule` will automatically promote a release from
        /// the current target to a specified target.
        PromoteReleaseRule(std::boxed::Box<crate::model::PromoteReleaseRule>),
        /// Optional. The `AdvanceRolloutRule` will automatically advance a
        /// successful Rollout.
        AdvanceRolloutRule(std::boxed::Box<crate::model::AdvanceRolloutRule>),
        /// Optional. The `RepairRolloutRule` will automatically repair a failed
        /// rollout.
        RepairRolloutRule(std::boxed::Box<crate::model::RepairRolloutRule>),
        /// Optional. The `TimedPromoteReleaseRule` will automatically promote a
        /// release from the current target(s) to the specified target(s) on a
        /// configured schedule.
        TimedPromoteReleaseRule(std::boxed::Box<crate::model::TimedPromoteReleaseRule>),
    }
}

/// The `TimedPromoteReleaseRule` will automatically promote a release from the
/// current target(s) to the specified target(s) on a configured schedule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimedPromoteReleaseRule {
    /// Required. ID of the rule. This ID must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Optional. The ID of the stage in the pipeline to which this `Release` is
    /// deploying. If unspecified, default it to the next stage in the promotion
    /// flow. The value of this field could be one of the following:
    ///
    /// * The last segment of a target name
    /// * "@next", the next target in the promotion sequence
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_target_id: std::string::String,

    /// Required. Schedule in crontab format. e.g. "0 9 * * 1" for every Monday at
    /// 9am.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub schedule: std::string::String,

    /// Required. The time zone in IANA format [IANA Time Zone
    /// Database](https://www.iana.org/time-zones) (e.g. America/New_York).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub time_zone: std::string::String,

    /// Output only. Information around the state of the Automation rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Optional. The starting phase of the rollout created by this rule. Default
    /// to the first phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_phase: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::TimedPromoteReleaseRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [destination_target_id][crate::model::TimedPromoteReleaseRule::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::TimedPromoteReleaseRule::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::TimedPromoteReleaseRule::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TimedPromoteReleaseRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::TimedPromoteReleaseRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_phase][crate::model::TimedPromoteReleaseRule::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseRule"
    }
}

/// The `PromoteRelease` rule will automatically promote a release from the
/// current target to a specified target.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteReleaseRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Optional. How long the release need to be paused until being promoted to
    /// the next target.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Optional. The ID of the stage in the pipeline to which this `Release` is
    /// deploying. If unspecified, default it to the next stage in the promotion
    /// flow. The value of this field could be one of the following:
    ///
    /// * The last segment of a target name
    /// * "@next", the next target in the promotion sequence
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_target_id: std::string::String,

    /// Output only. Information around the state of the Automation rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Optional. The starting phase of the rollout created by this operation.
    /// Default to the first phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_phase: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteReleaseRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::PromoteReleaseRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::PromoteReleaseRule::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::PromoteReleaseRule::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_target_id][crate::model::PromoteReleaseRule::destination_target_id].
    pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_target_id = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::PromoteReleaseRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::PromoteReleaseRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_phase][crate::model::PromoteReleaseRule::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for PromoteReleaseRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PromoteReleaseRule"
    }
}

/// The `AdvanceRollout` automation rule will automatically advance a successful
/// Rollout to the next phase.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Optional. Proceeds only after phase name matched any one in the list.
    /// This value must consist of lower-case letters, numbers, and hyphens,
    /// start with a letter and end with a letter or a number, and have a max
    /// length of 63 characters. In other words, it must match the following
    /// regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub source_phases: std::vec::Vec<std::string::String>,

    /// Optional. How long to wait after a rollout is finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. Information around the state of the Automation rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AdvanceRolloutRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [source_phases][crate::model::AdvanceRolloutRule::source_phases].
    pub fn set_source_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [wait][crate::model::AdvanceRolloutRule::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::AdvanceRolloutRule::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [condition][crate::model::AdvanceRolloutRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::AdvanceRolloutRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvanceRolloutRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutRule"
    }
}

/// The `RepairRolloutRule` automation rule will automatically repair a failed
/// `Rollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is
    /// `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Optional. Phases within which jobs are subject to automatic repair actions
    /// on failure. Proceeds only after phase name matched any one in the list, or
    /// for all phases if unspecified. This value must consist of lower-case
    /// letters, numbers, and hyphens, start with a letter and end with a letter or
    /// a number, and have a max length of 63 characters. In other words, it must
    /// match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub phases: std::vec::Vec<std::string::String>,

    /// Optional. Jobs to repair. Proceeds only after job name matched any one in
    /// the list, or for all jobs if unspecified or empty. The phase that includes
    /// the job must match the phase ID specified in `source_phase`. This value
    /// must consist of lower-case letters, numbers, and hyphens, start with a
    /// letter and end with a letter or a number, and have a max length of 63
    /// characters. In other words, it must match the following regex:
    /// `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub jobs: std::vec::Vec<std::string::String>,

    /// Output only. Information around the state of the 'Automation' rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::AutomationRuleCondition>,

    /// Required. Defines the types of automatic repair phases for failed jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub repair_phases: std::vec::Vec<crate::model::RepairPhaseConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairRolloutRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RepairRolloutRule::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [phases][crate::model::RepairRolloutRule::phases].
    pub fn set_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jobs][crate::model::RepairRolloutRule::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::RepairRolloutRule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::RepairRolloutRule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomationRuleCondition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repair_phases][crate::model::RepairRolloutRule::repair_phases].
    pub fn set_repair_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepairPhaseConfig>,
    {
        use std::iter::Iterator;
        self.repair_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RepairRolloutRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairRolloutRule"
    }
}

/// Configuration of the repair phase.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairPhaseConfig {
    /// The repair phase to perform.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub repair_phase: std::option::Option<crate::model::repair_phase_config::RepairPhase>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairPhaseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase].
    ///
    /// Note that all the setters affecting `repair_phase` are mutually
    /// exclusive.
    pub fn set_repair_phase<
        T: std::convert::Into<std::option::Option<crate::model::repair_phase_config::RepairPhase>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = v.into();
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// if it holds a `Retry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retry(&self) -> std::option::Option<&std::boxed::Box<crate::model::Retry>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase_config::RepairPhase::Retry(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// to hold a `Retry`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_retry<T: std::convert::Into<std::boxed::Box<crate::model::Retry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = std::option::Option::Some(
            crate::model::repair_phase_config::RepairPhase::Retry(v.into()),
        );
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// if it holds a `Rollback`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollback(&self) -> std::option::Option<&std::boxed::Box<crate::model::Rollback>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase_config::RepairPhase::Rollback(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhaseConfig::repair_phase]
    /// to hold a `Rollback`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_rollback<T: std::convert::Into<std::boxed::Box<crate::model::Rollback>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = std::option::Option::Some(
            crate::model::repair_phase_config::RepairPhase::Rollback(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RepairPhaseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairPhaseConfig"
    }
}

/// Defines additional types related to [RepairPhaseConfig].
pub mod repair_phase_config {
    #[allow(unused_imports)]
    use super::*;

    /// The repair phase to perform.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RepairPhase {
        /// Optional. Retries a failed job.
        Retry(std::boxed::Box<crate::model::Retry>),
        /// Optional. Rolls back a `Rollout`.
        Rollback(std::boxed::Box<crate::model::Rollback>),
    }
}

/// Retries the failed job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Retry {
    /// Required. Total number of retries. Retry is skipped if set to 0; The
    /// minimum value is 1, and the maximum value is 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub attempts: i64,

    /// Optional. How long to wait for the first retry. Default is 0, and the
    /// maximum value is 14d.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Optional. The pattern of how wait time will be increased. Default is
    /// linear. Backoff mode will be ignored if `wait` is 0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub backoff_mode: crate::model::BackoffMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Retry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attempts][crate::model::Retry::attempts].
    pub fn set_attempts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempts = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::Retry::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::Retry::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backoff_mode][crate::model::Retry::backoff_mode].
    pub fn set_backoff_mode<T: std::convert::Into<crate::model::BackoffMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.backoff_mode = v.into();
        self
    }
}

impl wkt::message::Message for Retry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Retry"
    }
}

/// Rolls back a `Rollout`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Rollback {
    /// Optional. The starting phase ID for the `Rollout`. If unspecified, the
    /// `Rollout` will start in the stable phase.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_phase: std::string::String,

    /// Optional. If pending rollout exists on the target, the rollback operation
    /// will be aborted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub disable_rollback_if_rollout_pending: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_phase][crate::model::Rollback::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }

    /// Sets the value of [disable_rollback_if_rollout_pending][crate::model::Rollback::disable_rollback_if_rollout_pending].
    pub fn set_disable_rollback_if_rollout_pending<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_rollback_if_rollout_pending = v.into();
        self
    }
}

impl wkt::message::Message for Rollback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.Rollback"
    }
}

/// `AutomationRuleCondition` contains conditions relevant to an
/// `Automation` rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationRuleCondition {
    /// Optional. Details around targets enumerated in the rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub targets_present_condition: std::option::Option<crate::model::TargetsPresentCondition>,

    /// Details specific to the automation rule type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rule_type_condition:
        std::option::Option<crate::model::automation_rule_condition::RuleTypeCondition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRuleCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [targets_present_condition][crate::model::AutomationRuleCondition::targets_present_condition].
    pub fn set_targets_present_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [targets_present_condition][crate::model::AutomationRuleCondition::targets_present_condition].
    pub fn set_or_clear_targets_present_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetsPresentCondition>,
    {
        self.targets_present_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition].
    ///
    /// Note that all the setters affecting `rule_type_condition` are mutually
    /// exclusive.
    pub fn set_rule_type_condition<
        T: std::convert::Into<
                std::option::Option<crate::model::automation_rule_condition::RuleTypeCondition>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type_condition = v.into();
        self
    }

    /// The value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition]
    /// if it holds a `TimedPromoteReleaseCondition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_condition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseCondition>> {
        #[allow(unreachable_patterns)]
        self.rule_type_condition.as_ref().and_then(|v| match v {
            crate::model::automation_rule_condition::RuleTypeCondition::TimedPromoteReleaseCondition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type_condition][crate::model::AutomationRuleCondition::rule_type_condition]
    /// to hold a `TimedPromoteReleaseCondition`.
    ///
    /// Note that all the setters affecting `rule_type_condition` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_condition<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseCondition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type_condition = std::option::Option::Some(
            crate::model::automation_rule_condition::RuleTypeCondition::TimedPromoteReleaseCondition(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for AutomationRuleCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRuleCondition"
    }
}

/// Defines additional types related to [AutomationRuleCondition].
pub mod automation_rule_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Details specific to the automation rule type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuleTypeCondition {
        /// Optional. TimedPromoteReleaseCondition contains rule conditions specific
        /// to a an Automation with a timed promote release rule defined.
        TimedPromoteReleaseCondition(std::boxed::Box<crate::model::TimedPromoteReleaseCondition>),
    }
}

/// `TimedPromoteReleaseCondition` contains conditions specific to an Automation
/// with a Timed Promote Release rule defined.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimedPromoteReleaseCondition {
    /// Output only. When the next scheduled promotion(s) will occur.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_promotion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A list of targets involved in the upcoming timed promotion(s).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub targets_list: std::vec::Vec<crate::model::timed_promote_release_condition::Targets>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_promotion_time][crate::model::TimedPromoteReleaseCondition::next_promotion_time].
    pub fn set_next_promotion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_promotion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_promotion_time][crate::model::TimedPromoteReleaseCondition::next_promotion_time].
    pub fn set_or_clear_next_promotion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_promotion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [targets_list][crate::model::TimedPromoteReleaseCondition::targets_list].
    pub fn set_targets_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::timed_promote_release_condition::Targets>,
    {
        use std::iter::Iterator;
        self.targets_list = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseCondition"
    }
}

/// Defines additional types related to [TimedPromoteReleaseCondition].
pub mod timed_promote_release_condition {
    #[allow(unused_imports)]
    use super::*;

    /// The targets involved in a single timed promotion.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Targets {
        /// Optional. The source target ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub source_target_id: std::string::String,

        /// Optional. The destination target ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub destination_target_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Targets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_target_id][crate::model::timed_promote_release_condition::Targets::source_target_id].
        pub fn set_source_target_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_target_id = v.into();
            self
        }

        /// Sets the value of [destination_target_id][crate::model::timed_promote_release_condition::Targets::destination_target_id].
        pub fn set_destination_target_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.destination_target_id = v.into();
            self
        }
    }

    impl wkt::message::Message for Targets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseCondition.Targets"
        }
    }
}

/// The request object for `CreateAutomation`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAutomationRequest {
    /// Required. The parent collection in which the `Automation` must be created.
    /// The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. ID of the `Automation`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automation_id: std::string::String,

    /// Required. The `Automation` to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automation: std::option::Option<crate::model::Automation>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutomationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::CreateAutomationRequest::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [automation][crate::model::CreateAutomationRequest::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::CreateAutomationRequest::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CreateAutomationRequest"
    }
}

/// The request object for `UpdateAutomation`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAutomationRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the `Automation` resource. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it's in the mask. If the user doesn't provide a mask
    /// then all fields are overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The `Automation` to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automation: std::option::Option<crate::model::Automation>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, updating a `Automation` that does not exist will
    /// result in the creation of a new `Automation`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, the request is validated and the user is provided
    /// with an expected result, but no actual change is made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAutomationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAutomationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automation][crate::model::UpdateAutomationRequest::automation].
    pub fn set_automation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation][crate::model::UpdateAutomationRequest::automation].
    pub fn set_or_clear_automation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateAutomationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.UpdateAutomationRequest"
    }
}

/// The request object for `DeleteAutomation`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAutomationRequest {
    /// Required. The name of the `Automation` to delete. The format is
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server knows to ignore the
    /// request if it has already been completed. The server guarantees that for
    /// at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_id: std::string::String,

    /// Optional. If set to true, then deleting an already deleted or non-existing
    /// `Automation` will succeed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set, validate the request and verify whether the resource
    /// exists, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// Optional. The weak etag of the request.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutomationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAutomationRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteAutomationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAutomationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAutomationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeleteAutomationRequest"
    }
}

/// The request object for `ListAutomations`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutomationsRequest {
    /// Required. The parent `Delivery Pipeline`, which owns this collection of
    /// automations. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of automations to return. The service may return
    /// fewer than this value. If unspecified, at most 50 automations will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListAutomations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter automations to be returned. All fields can be used in the
    /// filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Field to sort by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutomationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutomationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutomationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutomationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutomationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutomationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationsRequest"
    }
}

/// The response object from `ListAutomations`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutomationsResponse {
    /// The `Automation` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub automations: std::vec::Vec<crate::model::Automation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automations][crate::model::ListAutomationsResponse::automations].
    pub fn set_automations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Automation>,
    {
        use std::iter::Iterator;
        self.automations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutomationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAutomationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutomationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutomationsResponse {
    type PageItem = crate::model::Automation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.automations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetAutomation`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutomationRequest {
    /// Required. Name of the `Automation`. Format must be
    /// `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutomationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutomationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutomationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetAutomationRequest"
    }
}

/// An `AutomationRun` resource in the Cloud Deploy API.
///
/// An `AutomationRun` represents an execution instance of an
/// automation rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomationRun {
    /// Output only. Name of the `AutomationRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Time at which the `AutomationRun` was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time at which the automationRun was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The weak etag of the `AutomationRun` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Output only. Email address of the user-managed IAM service account that
    /// performs the operations against Cloud Deploy resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_account: std::string::String,

    /// Output only. Snapshot of the Automation taken at AutomationRun creation
    /// time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automation_snapshot: std::option::Option<crate::model::Automation>,

    /// Output only. The ID of the source target that initiates the
    /// `AutomationRun`. The value of this field is the last segment of a target
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Output only. Current state of the `AutomationRun`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::automation_run::State,

    /// Output only. Explains the current state of the `AutomationRun`. Present
    /// only when an explanation is needed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state_description: std::string::String,

    /// Output only. Contains information about what policies prevented the
    /// `AutomationRun` from proceeding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_violation: std::option::Option<crate::model::PolicyViolation>,

    /// Output only. Time the `AutomationRun` expires. An `AutomationRun` expires
    /// after 14 days from its creation date.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The ID of the automation rule that initiated the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rule_id: std::string::String,

    /// Output only. The ID of the automation that initiated the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub automation_id: std::string::String,

    /// Output only. Earliest time the `AutomationRun` will attempt to resume.
    /// Wait-time is configured by `wait` in automation rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait_until_time: std::option::Option<wkt::Timestamp>,

    /// The operation that the `AutomationRun` will perform.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::automation_run::Operation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomationRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AutomationRun::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AutomationRun::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AutomationRun::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AutomationRun::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AutomationRun::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::AutomationRun::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::AutomationRun::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [automation_snapshot][crate::model::AutomationRun::automation_snapshot].
    pub fn set_automation_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automation_snapshot][crate::model::AutomationRun::automation_snapshot].
    pub fn set_or_clear_automation_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Automation>,
    {
        self.automation_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::AutomationRun::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AutomationRun::state].
    pub fn set_state<T: std::convert::Into<crate::model::automation_run::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::AutomationRun::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [policy_violation][crate::model::AutomationRun::policy_violation].
    pub fn set_policy_violation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PolicyViolation>,
    {
        self.policy_violation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy_violation][crate::model::AutomationRun::policy_violation].
    pub fn set_or_clear_policy_violation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PolicyViolation>,
    {
        self.policy_violation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::AutomationRun::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::AutomationRun::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_id][crate::model::AutomationRun::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [automation_id][crate::model::AutomationRun::automation_id].
    pub fn set_automation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.automation_id = v.into();
        self
    }

    /// Sets the value of [wait_until_time][crate::model::AutomationRun::wait_until_time].
    pub fn set_wait_until_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.wait_until_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait_until_time][crate::model::AutomationRun::wait_until_time].
    pub fn set_or_clear_wait_until_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.wait_until_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation].
    ///
    /// Note that all the setters affecting `operation` are mutually
    /// exclusive.
    pub fn set_operation<
        T: std::convert::Into<std::option::Option<crate::model::automation_run::Operation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `PromoteReleaseOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn promote_release_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PromoteReleaseOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::PromoteReleaseOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `PromoteReleaseOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_promote_release_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::PromoteReleaseOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::PromoteReleaseOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `AdvanceRolloutOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn advance_rollout_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdvanceRolloutOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::AdvanceRolloutOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `AdvanceRolloutOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_advance_rollout_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::AdvanceRolloutOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::AdvanceRolloutOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `RepairRolloutOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn repair_rollout_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RepairRolloutOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::RepairRolloutOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `RepairRolloutOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_repair_rollout_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::RepairRolloutOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::RepairRolloutOperation(v.into()),
        );
        self
    }

    /// The value of [operation][crate::model::AutomationRun::operation]
    /// if it holds a `TimedPromoteReleaseOperation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timed_promote_release_operation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TimedPromoteReleaseOperation>> {
        #[allow(unreachable_patterns)]
        self.operation.as_ref().and_then(|v| match v {
            crate::model::automation_run::Operation::TimedPromoteReleaseOperation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation][crate::model::AutomationRun::operation]
    /// to hold a `TimedPromoteReleaseOperation`.
    ///
    /// Note that all the setters affecting `operation` are
    /// mutually exclusive.
    pub fn set_timed_promote_release_operation<
        T: std::convert::Into<std::boxed::Box<crate::model::TimedPromoteReleaseOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = std::option::Option::Some(
            crate::model::automation_run::Operation::TimedPromoteReleaseOperation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomationRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AutomationRun"
    }
}

/// Defines additional types related to [AutomationRun].
pub mod automation_run {
    #[allow(unused_imports)]
    use super::*;

    /// Valid state of an `AutomationRun`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The `AutomationRun` has an unspecified state.
        Unspecified,
        /// The `AutomationRun` has succeeded.
        Succeeded,
        /// The `AutomationRun` was cancelled.
        Cancelled,
        /// The `AutomationRun` has failed.
        Failed,
        /// The `AutomationRun` is in progress.
        InProgress,
        /// The `AutomationRun` is pending.
        Pending,
        /// The `AutomationRun` was aborted.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Cancelled => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::InProgress => std::option::Option::Some(4),
                Self::Pending => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Cancelled,
                3 => Self::Failed,
                4 => Self::InProgress,
                5 => Self::Pending,
                6 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "IN_PROGRESS" => Self::InProgress,
                "PENDING" => Self::Pending,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Cancelled => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::InProgress => serializer.serialize_i32(4),
                Self::Pending => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.deploy.v1.AutomationRun.State",
            ))
        }
    }

    /// The operation that the `AutomationRun` will perform.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Operation {
        /// Output only. Promotes a release to a specified 'Target'.
        PromoteReleaseOperation(std::boxed::Box<crate::model::PromoteReleaseOperation>),
        /// Output only. Advances a rollout to the next phase.
        AdvanceRolloutOperation(std::boxed::Box<crate::model::AdvanceRolloutOperation>),
        /// Output only. Repairs a failed 'Rollout'.
        RepairRolloutOperation(std::boxed::Box<crate::model::RepairRolloutOperation>),
        /// Output only. Promotes a release to a specified 'Target' as defined in a
        /// Timed Promote Release rule.
        TimedPromoteReleaseOperation(std::boxed::Box<crate::model::TimedPromoteReleaseOperation>),
    }
}

/// Contains the information of an automated promote-release operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteReleaseOperation {
    /// Output only. The ID of the target that represents the promotion stage to
    /// which the release will be promoted. The value of this field is the last
    /// segment of a target name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Output only. How long the operation will be paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Output only. The starting phase of the rollout created by this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteReleaseOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::PromoteReleaseOperation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::PromoteReleaseOperation::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::PromoteReleaseOperation::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::PromoteReleaseOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::PromoteReleaseOperation::phase].
    pub fn set_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase = v.into();
        self
    }
}

impl wkt::message::Message for PromoteReleaseOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.PromoteReleaseOperation"
    }
}

/// Contains the information of an automated advance-rollout operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvanceRolloutOperation {
    /// Output only. The phase of a deployment that initiated the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub source_phase: std::string::String,

    /// Output only. How long the operation will be paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Output only. The phase the rollout will be advanced to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_phase: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvanceRolloutOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_phase][crate::model::AdvanceRolloutOperation::source_phase].
    pub fn set_source_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_phase = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::AdvanceRolloutOperation::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::AdvanceRolloutOperation::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout][crate::model::AdvanceRolloutOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [destination_phase][crate::model::AdvanceRolloutOperation::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }
}

impl wkt::message::Message for AdvanceRolloutOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.AdvanceRolloutOperation"
    }
}

/// Contains the information for an automated `repair rollout` operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairRolloutOperation {
    /// Output only. The name of the rollout that initiates the `AutomationRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// Output only. The index of the current repair action in the repair sequence.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub current_repair_phase_index: i64,

    /// Output only. Records of the repair attempts. Each repair phase may have
    /// multiple retry attempts or single rollback attempt.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub repair_phases: std::vec::Vec<crate::model::RepairPhase>,

    /// Output only. The phase ID of the phase that includes the job being
    /// repaired.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase_id: std::string::String,

    /// Output only. The job ID for the Job to repair.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairRolloutOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout][crate::model::RepairRolloutOperation::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [current_repair_phase_index][crate::model::RepairRolloutOperation::current_repair_phase_index].
    pub fn set_current_repair_phase_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.current_repair_phase_index = v.into();
        self
    }

    /// Sets the value of [repair_phases][crate::model::RepairRolloutOperation::repair_phases].
    pub fn set_repair_phases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepairPhase>,
    {
        use std::iter::Iterator;
        self.repair_phases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [phase_id][crate::model::RepairRolloutOperation::phase_id].
    pub fn set_phase_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::RepairRolloutOperation::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for RepairRolloutOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairRolloutOperation"
    }
}

/// Contains the information of an automated timed promote-release operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimedPromoteReleaseOperation {
    /// Output only. The ID of the target that represents the promotion stage to
    /// which the release will be promoted. The value of this field is the last
    /// segment of a target name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Output only. The name of the release to be promoted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// Output only. The starting phase of the rollout created by this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub phase: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimedPromoteReleaseOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_id][crate::model::TimedPromoteReleaseOperation::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [release][crate::model::TimedPromoteReleaseOperation::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::TimedPromoteReleaseOperation::phase].
    pub fn set_phase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phase = v.into();
        self
    }
}

impl wkt::message::Message for TimedPromoteReleaseOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TimedPromoteReleaseOperation"
    }
}

/// RepairPhase tracks the repair attempts that have been made for
/// each `RepairPhaseConfig` specified in the `Automation` resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepairPhase {
    /// The `RepairPhase` type and the information for that type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub repair_phase: std::option::Option<crate::model::repair_phase::RepairPhase>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepairPhase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase].
    ///
    /// Note that all the setters affecting `repair_phase` are mutually
    /// exclusive.
    pub fn set_repair_phase<
        T: std::convert::Into<std::option::Option<crate::model::repair_phase::RepairPhase>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase = v.into();
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// if it holds a `Retry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retry(&self) -> std::option::Option<&std::boxed::Box<crate::model::RetryPhase>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase::RepairPhase::Retry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// to hold a `Retry`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_retry<T: std::convert::Into<std::boxed::Box<crate::model::RetryPhase>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase =
            std::option::Option::Some(crate::model::repair_phase::RepairPhase::Retry(v.into()));
        self
    }

    /// The value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// if it holds a `Rollback`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rollback(&self) -> std::option::Option<&std::boxed::Box<crate::model::RollbackAttempt>> {
        #[allow(unreachable_patterns)]
        self.repair_phase.as_ref().and_then(|v| match v {
            crate::model::repair_phase::RepairPhase::Rollback(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [repair_phase][crate::model::RepairPhase::repair_phase]
    /// to hold a `Rollback`.
    ///
    /// Note that all the setters affecting `repair_phase` are
    /// mutually exclusive.
    pub fn set_rollback<T: std::convert::Into<std::boxed::Box<crate::model::RollbackAttempt>>>(
        mut self,
        v: T,
    ) -> Self {
        self.repair_phase =
            std::option::Option::Some(crate::model::repair_phase::RepairPhase::Rollback(v.into()));
        self
    }
}

impl wkt::message::Message for RepairPhase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RepairPhase"
    }
}

/// Defines additional types related to [RepairPhase].
pub mod repair_phase {
    #[allow(unused_imports)]
    use super::*;

    /// The `RepairPhase` type and the information for that type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RepairPhase {
        /// Output only. Records of the retry attempts for retry repair mode.
        Retry(std::boxed::Box<crate::model::RetryPhase>),
        /// Output only. Rollback attempt for rollback repair mode .
        Rollback(std::boxed::Box<crate::model::RollbackAttempt>),
    }
}

/// RetryPhase contains the retry attempts and the metadata for initiating a
/// new attempt.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryPhase {
    /// Output only. The number of attempts that have been made.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub total_attempts: i64,

    /// Output only. The pattern of how the wait time of the retry attempt is
    /// calculated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub backoff_mode: crate::model::BackoffMode,

    /// Output only. Detail of a retry action.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub attempts: std::vec::Vec<crate::model::RetryAttempt>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryPhase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_attempts][crate::model::RetryPhase::total_attempts].
    pub fn set_total_attempts<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_attempts = v.into();
        self
    }

    /// Sets the value of [backoff_mode][crate::model::RetryPhase::backoff_mode].
    pub fn set_backoff_mode<T: std::convert::Into<crate::model::BackoffMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.backoff_mode = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::RetryPhase::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RetryAttempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RetryPhase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryPhase"
    }
}

/// RetryAttempt represents an action of retrying the failed Cloud Deploy job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryAttempt {
    /// Output only. The index of this retry attempt.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub attempt: i64,

    /// Output only. How long the operation will be paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub wait: std::option::Option<wkt::Duration>,

    /// Output only. Valid state of this retry action.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::RepairState,

    /// Output only. Description of the state of the Retry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state_desc: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attempt][crate::model::RetryAttempt::attempt].
    pub fn set_attempt<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.attempt = v.into();
        self
    }

    /// Sets the value of [wait][crate::model::RetryAttempt::wait].
    pub fn set_wait<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [wait][crate::model::RetryAttempt::wait].
    pub fn set_or_clear_wait<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.wait = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::RetryAttempt::state].
    pub fn set_state<T: std::convert::Into<crate::model::RepairState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_desc][crate::model::RetryAttempt::state_desc].
    pub fn set_state_desc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_desc = v.into();
        self
    }
}

impl wkt::message::Message for RetryAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RetryAttempt"
    }
}

/// RollbackAttempt represents an action of rolling back a Cloud Deploy 'Target'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackAttempt {
    /// Output only. The phase to which the rollout will be rolled back to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub destination_phase: std::string::String,

    /// Output only. ID of the rollback `Rollout` to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_id: std::string::String,

    /// Output only. Valid state of this rollback action.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::RepairState,

    /// Output only. Description of the state of the Rollback.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state_desc: std::string::String,

    /// Output only. If active rollout exists on the target, abort this rollback.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub disable_rollback_if_rollout_pending: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_phase][crate::model::RollbackAttempt::destination_phase].
    pub fn set_destination_phase<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_phase = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::RollbackAttempt::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RollbackAttempt::state].
    pub fn set_state<T: std::convert::Into<crate::model::RepairState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_desc][crate::model::RollbackAttempt::state_desc].
    pub fn set_state_desc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_desc = v.into();
        self
    }

    /// Sets the value of [disable_rollback_if_rollout_pending][crate::model::RollbackAttempt::disable_rollback_if_rollout_pending].
    pub fn set_disable_rollback_if_rollout_pending<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_rollback_if_rollout_pending = v.into();
        self
    }
}

impl wkt::message::Message for RollbackAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RollbackAttempt"
    }
}

/// The request object for `ListAutomationRuns`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutomationRunsRequest {
    /// Required. The parent `Delivery Pipeline`, which owns this collection of
    /// automationRuns. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of automationRuns to return. The service may return
    /// fewer than this value. If unspecified, at most 50 automationRuns will
    /// be returned. The maximum value is 1000; values above 1000 will be set
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListAutomationRuns` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other provided parameters match
    /// the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter automationRuns to be returned. All fields can be used in the
    /// filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Field to sort by.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationRunsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutomationRunsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutomationRunsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutomationRunsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAutomationRunsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAutomationRunsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAutomationRunsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationRunsRequest"
    }
}

/// The response object from `ListAutomationRuns`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutomationRunsResponse {
    /// The `AutomationRuns` objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub automation_runs: std::vec::Vec<crate::model::AutomationRun>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutomationRunsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automation_runs][crate::model::ListAutomationRunsResponse::automation_runs].
    pub fn set_automation_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutomationRun>,
    {
        use std::iter::Iterator;
        self.automation_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutomationRunsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAutomationRunsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAutomationRunsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ListAutomationRunsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutomationRunsResponse {
    type PageItem = crate::model::AutomationRun;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.automation_runs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request object for `GetAutomationRun`
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutomationRunRequest {
    /// Required. Name of the `AutomationRun`. Format must be
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutomationRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutomationRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutomationRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.GetAutomationRunRequest"
    }
}

/// The request object used by `CancelAutomationRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelAutomationRunRequest {
    /// Required. Name of the `AutomationRun`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelAutomationRunRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelAutomationRunRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelAutomationRunRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelAutomationRunRequest"
    }
}

/// The response object from `CancelAutomationRun`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelAutomationRunResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelAutomationRunResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelAutomationRunResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CancelAutomationRunResponse"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/customtargettype_notification"
/// Platform Log event that describes the failure to send a custom target type
/// status change Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTargetTypeNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the `CustomTargetType`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub custom_target_type_uid: std::string::String,

    /// The name of the `CustomTargetType`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub custom_target_type: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTargetTypeNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::CustomTargetTypeNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [custom_target_type_uid][crate::model::CustomTargetTypeNotificationEvent::custom_target_type_uid].
    pub fn set_custom_target_type_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type_uid = v.into();
        self
    }

    /// Sets the value of [custom_target_type][crate::model::CustomTargetTypeNotificationEvent::custom_target_type].
    pub fn set_custom_target_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_target_type = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CustomTargetTypeNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CustomTargetTypeNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.CustomTargetTypeNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deliverypipeline_notification"
/// Platform Log event that describes the failure to send delivery pipeline
/// status change Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeliveryPipelineNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// The name of the `Delivery Pipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub delivery_pipeline: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeliveryPipelineNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeliveryPipelineNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::DeliveryPipelineNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeliveryPipelineNotificationEvent::delivery_pipeline].
    pub fn set_delivery_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DeliveryPipelineNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for DeliveryPipelineNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeliveryPipelineNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deploypolicy_evaluation"
/// Platform Log event that describes the deploy policy evaluation event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployPolicyEvaluationEvent {
    /// Debug message for when a deploy policy event occurs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Rule type (e.g. Restrict Rollouts).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rule_type: std::string::String,

    /// Rule id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rule: std::string::String,

    /// Unique identifier of the `Delivery Pipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// The name of the `Delivery Pipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub delivery_pipeline: std::string::String,

    /// Unique identifier of the `Target`. This is an optional field, as a `Target`
    /// may not always be applicable to a policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_uid: std::string::String,

    /// The name of the `Target`. This is an optional field, as a `Target` may not
    /// always be applicable to a policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// What invoked the action (e.g. a user or automation).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub invoker: crate::model::deploy_policy::Invoker,

    /// The name of the `DeployPolicy`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_policy: std::string::String,

    /// Unique identifier of the `DeployPolicy`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_policy_uid: std::string::String,

    /// Whether the request is allowed. Allowed is set as true if:
    /// (1) the request complies with the policy; or
    /// (2) the request doesn't comply with the policy but the policy was
    /// overridden; or
    /// (3) the request doesn't comply with the policy but the policy was suspended
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allowed: bool,

    /// The policy verdict of the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verdict: crate::model::deploy_policy_evaluation_event::PolicyVerdict,

    /// Things that could have overridden the policy verdict. Overrides together
    /// with verdict decide whether the request is allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub overrides:
        std::vec::Vec<crate::model::deploy_policy_evaluation_event::PolicyVerdictOverride>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyEvaluationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeployPolicyEvaluationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DeployPolicyEvaluationEvent::rule_type].
    pub fn set_rule_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_type = v.into();
        self
    }

    /// Sets the value of [rule][crate::model::DeployPolicyEvaluationEvent::rule].
    pub fn set_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::DeployPolicyEvaluationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [delivery_pipeline][crate::model::DeployPolicyEvaluationEvent::delivery_pipeline].
    pub fn set_delivery_pipeline<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.delivery_pipeline = v.into();
        self
    }

    /// Sets the value of [target_uid][crate::model::DeployPolicyEvaluationEvent::target_uid].
    pub fn set_target_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_uid = v.into();
        self
    }

    /// Sets the value of [target][crate::model::DeployPolicyEvaluationEvent::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [invoker][crate::model::DeployPolicyEvaluationEvent::invoker].
    pub fn set_invoker<T: std::convert::Into<crate::model::deploy_policy::Invoker>>(
        mut self,
        v: T,
    ) -> Self {
        self.invoker = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::DeployPolicyEvaluationEvent::deploy_policy].
    pub fn set_deploy_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_policy = v.into();
        self
    }

    /// Sets the value of [deploy_policy_uid][crate::model::DeployPolicyEvaluationEvent::deploy_policy_uid].
    pub fn set_deploy_policy_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_uid = v.into();
        self
    }

    /// Sets the value of [allowed][crate::model::DeployPolicyEvaluationEvent::allowed].
    pub fn set_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allowed = v.into();
        self
    }

    /// Sets the value of [verdict][crate::model::DeployPolicyEvaluationEvent::verdict].
    pub fn set_verdict<
        T: std::convert::Into<crate::model::deploy_policy_evaluation_event::PolicyVerdict>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.verdict = v.into();
        self
    }

    /// Sets the value of [overrides][crate::model::DeployPolicyEvaluationEvent::overrides].
    pub fn set_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::deploy_policy_evaluation_event::PolicyVerdictOverride>,
    {
        use std::iter::Iterator;
        self.overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DeployPolicyEvaluationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyEvaluationEvent"
    }
}

/// Defines additional types related to [DeployPolicyEvaluationEvent].
pub mod deploy_policy_evaluation_event {
    #[allow(unused_imports)]
    use super::*;

    /// The policy verdict of the request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyVerdict {
        /// This should never happen.
        Unspecified,
        /// Allowed by policy. This enum value is not currently used but may be used
        /// in the future. Currently logs are only generated when a request is denied
        /// by policy.
        AllowedByPolicy,
        /// Denied by policy.
        DeniedByPolicy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyVerdict::value] or
        /// [PolicyVerdict::name].
        UnknownValue(policy_verdict::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_verdict {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyVerdict {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllowedByPolicy => std::option::Option::Some(1),
                Self::DeniedByPolicy => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POLICY_VERDICT_UNSPECIFIED"),
                Self::AllowedByPolicy => std::option::Option::Some("ALLOWED_BY_POLICY"),
                Self::DeniedByPolicy => std::option::Option::Some("DENIED_BY_POLICY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyVerdict {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyVerdict {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyVerdict {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllowedByPolicy,
                2 => Self::DeniedByPolicy,
                _ => Self::UnknownValue(policy_verdict::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyVerdict {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_VERDICT_UNSPECIFIED" => Self::Unspecified,
                "ALLOWED_BY_POLICY" => Self::AllowedByPolicy,
                "DENIED_BY_POLICY" => Self::DeniedByPolicy,
                _ => Self::UnknownValue(policy_verdict::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyVerdict {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllowedByPolicy => serializer.serialize_i32(1),
                Self::DeniedByPolicy => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyVerdict {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyVerdict>::new(
                ".google.cloud.deploy.v1.DeployPolicyEvaluationEvent.PolicyVerdict",
            ))
        }
    }

    /// Things that could have overridden the policy verdict. When overrides are
    /// used, the request will be allowed even if it is DENIED_BY_POLICY.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PolicyVerdictOverride {
        /// This should never happen.
        Unspecified,
        /// The policy was overridden.
        PolicyOverridden,
        /// The policy was suspended.
        PolicySuspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PolicyVerdictOverride::value] or
        /// [PolicyVerdictOverride::name].
        UnknownValue(policy_verdict_override::UnknownValue),
    }

    #[doc(hidden)]
    pub mod policy_verdict_override {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PolicyVerdictOverride {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PolicyOverridden => std::option::Option::Some(1),
                Self::PolicySuspended => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("POLICY_VERDICT_OVERRIDE_UNSPECIFIED")
                }
                Self::PolicyOverridden => std::option::Option::Some("POLICY_OVERRIDDEN"),
                Self::PolicySuspended => std::option::Option::Some("POLICY_SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PolicyVerdictOverride {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PolicyVerdictOverride {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PolicyVerdictOverride {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PolicyOverridden,
                2 => Self::PolicySuspended,
                _ => Self::UnknownValue(policy_verdict_override::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PolicyVerdictOverride {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POLICY_VERDICT_OVERRIDE_UNSPECIFIED" => Self::Unspecified,
                "POLICY_OVERRIDDEN" => Self::PolicyOverridden,
                "POLICY_SUSPENDED" => Self::PolicySuspended,
                _ => Self::UnknownValue(policy_verdict_override::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PolicyVerdictOverride {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PolicyOverridden => serializer.serialize_i32(1),
                Self::PolicySuspended => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PolicyVerdictOverride {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PolicyVerdictOverride>::new(
                ".google.cloud.deploy.v1.DeployPolicyEvaluationEvent.PolicyVerdictOverride",
            ))
        }
    }
}

/// Payload proto for "clouddeploy.googleapis.com/deploypolicy_notification".
/// Platform Log event that describes the failure to send a pub/sub notification
/// when there is a DeployPolicy status change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeployPolicyNotificationEvent {
    /// Debug message for when a deploy policy fails to send a pub/sub
    /// notification.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// The name of the `DeployPolicy`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_policy: std::string::String,

    /// Unique identifier of the deploy policy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub deploy_policy_uid: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployPolicyNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DeployPolicyNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [deploy_policy][crate::model::DeployPolicyNotificationEvent::deploy_policy].
    pub fn set_deploy_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deploy_policy = v.into();
        self
    }

    /// Sets the value of [deploy_policy_uid][crate::model::DeployPolicyNotificationEvent::deploy_policy_uid].
    pub fn set_deploy_policy_uid<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deploy_policy_uid = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DeployPolicyNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for DeployPolicyNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.DeployPolicyNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/jobrun_notification"
/// Platform Log event that describes the failure to send JobRun resource update
/// Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobRunNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// The name of the `JobRun`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub job_run: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// Unique identifier of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_uid: std::string::String,

    /// The name of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// ID of the `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobRunNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::JobRunNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [job_run][crate::model::JobRunNotificationEvent::job_run].
    pub fn set_job_run<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_run = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::JobRunNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::JobRunNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::JobRunNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout_uid][crate::model::JobRunNotificationEvent::rollout_uid].
    pub fn set_rollout_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_uid = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::JobRunNotificationEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::JobRunNotificationEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::JobRunNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for JobRunNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.JobRunNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/release_notification"
/// Platform Log event that describes the failure to send release status change
/// Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReleaseNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ReleaseNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::ReleaseNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::ReleaseNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::ReleaseNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReleaseNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ReleaseNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/release_render"
/// Platform Log event that describes the render status change.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReleaseRenderEvent {
    /// Debug message for when a render transition occurs. Provides further
    /// details as rendering progresses through render states.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// The name of the release.
    /// release_uid is not in this log message because we write some of these log
    /// messages at release creation time, before we've generated the uid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// Type of this notification, e.g. for a release render state change event.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    /// The state of the release render.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_render_state: crate::model::release::RenderState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseRenderEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ReleaseRenderEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::ReleaseRenderEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::ReleaseRenderEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ReleaseRenderEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [release_render_state][crate::model::ReleaseRenderEvent::release_render_state].
    pub fn set_release_render_state<T: std::convert::Into<crate::model::release::RenderState>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_render_state = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseRenderEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.ReleaseRenderEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/rollout_notification"
/// Platform Log event that describes the failure to send rollout status change
/// Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RolloutNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the `DeliveryPipeline`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// Unique identifier of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_uid: std::string::String,

    /// The name of the `Rollout`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// ID of the `Target` that the rollout is deployed to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::RolloutNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::RolloutNotificationEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::RolloutNotificationEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::RolloutNotificationEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout_uid][crate::model::RolloutNotificationEvent::rollout_uid].
    pub fn set_rollout_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_uid = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::RolloutNotificationEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RolloutNotificationEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::RolloutNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for RolloutNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutNotificationEvent"
    }
}

/// Payload proto for "clouddeploy.googleapis.com/rollout_update"
/// Platform Log event that describes the rollout update event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RolloutUpdateEvent {
    /// Debug message for when a rollout update event occurs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// Unique identifier of the pipeline.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub pipeline_uid: std::string::String,

    /// Unique identifier of the release.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release_uid: std::string::String,

    /// The name of the `Release`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub release: std::string::String,

    /// The name of the rollout.
    /// rollout_uid is not in this log message because we write some of these log
    /// messages at rollout creation time, before we've generated the uid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout: std::string::String,

    /// ID of the target.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target_id: std::string::String,

    /// Type of this notification, e.g. for a rollout update event.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    /// The type of the rollout update.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub rollout_update_type: crate::model::rollout_update_event::RolloutUpdateType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutUpdateEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::RolloutUpdateEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [pipeline_uid][crate::model::RolloutUpdateEvent::pipeline_uid].
    pub fn set_pipeline_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pipeline_uid = v.into();
        self
    }

    /// Sets the value of [release_uid][crate::model::RolloutUpdateEvent::release_uid].
    pub fn set_release_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_uid = v.into();
        self
    }

    /// Sets the value of [release][crate::model::RolloutUpdateEvent::release].
    pub fn set_release<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::RolloutUpdateEvent::rollout].
    pub fn set_rollout<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout = v.into();
        self
    }

    /// Sets the value of [target_id][crate::model::RolloutUpdateEvent::target_id].
    pub fn set_target_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::RolloutUpdateEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [rollout_update_type][crate::model::RolloutUpdateEvent::rollout_update_type].
    pub fn set_rollout_update_type<
        T: std::convert::Into<crate::model::rollout_update_event::RolloutUpdateType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_update_type = v.into();
        self
    }
}

impl wkt::message::Message for RolloutUpdateEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.RolloutUpdateEvent"
    }
}

/// Defines additional types related to [RolloutUpdateEvent].
pub mod rollout_update_event {
    #[allow(unused_imports)]
    use super::*;

    /// RolloutUpdateType indicates the type of the rollout update.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutUpdateType {
        /// Rollout update type unspecified.
        Unspecified,
        /// rollout state updated to pending.
        Pending,
        /// Rollout state updated to pending release.
        PendingRelease,
        /// Rollout state updated to in progress.
        InProgress,
        /// Rollout state updated to cancelling.
        Cancelling,
        /// Rollout state updated to cancelled.
        Cancelled,
        /// Rollout state updated to halted.
        Halted,
        /// Rollout state updated to succeeded.
        Succeeded,
        /// Rollout state updated to failed.
        Failed,
        /// Rollout requires approval.
        ApprovalRequired,
        /// Rollout has been approved.
        Approved,
        /// Rollout has been rejected.
        Rejected,
        /// Rollout requires advance to the next phase.
        AdvanceRequired,
        /// Rollout has been advanced.
        Advanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutUpdateType::value] or
        /// [RolloutUpdateType::name].
        UnknownValue(rollout_update_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_update_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutUpdateType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::PendingRelease => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Halted => std::option::Option::Some(6),
                Self::Succeeded => std::option::Option::Some(7),
                Self::Failed => std::option::Option::Some(8),
                Self::ApprovalRequired => std::option::Option::Some(9),
                Self::Approved => std::option::Option::Some(10),
                Self::Rejected => std::option::Option::Some(11),
                Self::AdvanceRequired => std::option::Option::Some(12),
                Self::Advanced => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_UPDATE_TYPE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::PendingRelease => std::option::Option::Some("PENDING_RELEASE"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Halted => std::option::Option::Some("HALTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::ApprovalRequired => std::option::Option::Some("APPROVAL_REQUIRED"),
                Self::Approved => std::option::Option::Some("APPROVED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::AdvanceRequired => std::option::Option::Some("ADVANCE_REQUIRED"),
                Self::Advanced => std::option::Option::Some("ADVANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutUpdateType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutUpdateType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutUpdateType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::PendingRelease,
                3 => Self::InProgress,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                6 => Self::Halted,
                7 => Self::Succeeded,
                8 => Self::Failed,
                9 => Self::ApprovalRequired,
                10 => Self::Approved,
                11 => Self::Rejected,
                12 => Self::AdvanceRequired,
                13 => Self::Advanced,
                _ => Self::UnknownValue(rollout_update_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutUpdateType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_UPDATE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "PENDING_RELEASE" => Self::PendingRelease,
                "IN_PROGRESS" => Self::InProgress,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "HALTED" => Self::Halted,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "APPROVAL_REQUIRED" => Self::ApprovalRequired,
                "APPROVED" => Self::Approved,
                "REJECTED" => Self::Rejected,
                "ADVANCE_REQUIRED" => Self::AdvanceRequired,
                "ADVANCED" => Self::Advanced,
                _ => Self::UnknownValue(rollout_update_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutUpdateType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::PendingRelease => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Halted => serializer.serialize_i32(6),
                Self::Succeeded => serializer.serialize_i32(7),
                Self::Failed => serializer.serialize_i32(8),
                Self::ApprovalRequired => serializer.serialize_i32(9),
                Self::Approved => serializer.serialize_i32(10),
                Self::Rejected => serializer.serialize_i32(11),
                Self::AdvanceRequired => serializer.serialize_i32(12),
                Self::Advanced => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutUpdateType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutUpdateType>::new(
                ".google.cloud.deploy.v1.RolloutUpdateEvent.RolloutUpdateType",
            ))
        }
    }
}

/// Payload proto for "clouddeploy.googleapis.com/target_notification"
/// Platform Log event that describes the failure to send target status change
/// Pub/Sub notification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetNotificationEvent {
    /// Debug message for when a notification fails to send.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub message: std::string::String,

    /// The name of the `Target`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Type of this notification, e.g. for a Pub/Sub failure.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::Type,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetNotificationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::TargetNotificationEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [target][crate::model::TargetNotificationEvent::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TargetNotificationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for TargetNotificationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.deploy.v1.TargetNotificationEvent"
    }
}

/// The support state of a specific Skaffold version.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SkaffoldSupportState {
    /// Default value. This value is unused.
    Unspecified,
    /// This Skaffold version is currently supported.
    Supported,
    /// This Skaffold version is in maintenance mode.
    MaintenanceMode,
    /// This Skaffold version is no longer supported.
    Unsupported,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SkaffoldSupportState::value] or
    /// [SkaffoldSupportState::name].
    UnknownValue(skaffold_support_state::UnknownValue),
}

#[doc(hidden)]
pub mod skaffold_support_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SkaffoldSupportState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Supported => std::option::Option::Some(1),
            Self::MaintenanceMode => std::option::Option::Some(2),
            Self::Unsupported => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_UNSPECIFIED"),
            Self::Supported => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_SUPPORTED"),
            Self::MaintenanceMode => {
                std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE")
            }
            Self::Unsupported => std::option::Option::Some("SKAFFOLD_SUPPORT_STATE_UNSUPPORTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SkaffoldSupportState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SkaffoldSupportState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SkaffoldSupportState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Supported,
            2 => Self::MaintenanceMode,
            3 => Self::Unsupported,
            _ => Self::UnknownValue(skaffold_support_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SkaffoldSupportState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED" => Self::Unspecified,
            "SKAFFOLD_SUPPORT_STATE_SUPPORTED" => Self::Supported,
            "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE" => Self::MaintenanceMode,
            "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED" => Self::Unsupported,
            _ => Self::UnknownValue(skaffold_support_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SkaffoldSupportState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Supported => serializer.serialize_i32(1),
            Self::MaintenanceMode => serializer.serialize_i32(2),
            Self::Unsupported => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SkaffoldSupportState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SkaffoldSupportState>::new(
            ".google.cloud.deploy.v1.SkaffoldSupportState",
        ))
    }
}

/// The pattern of how wait time is increased.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackoffMode {
    /// No WaitMode is specified.
    Unspecified,
    /// Increases the wait time linearly.
    Linear,
    /// Increases the wait time exponentially.
    Exponential,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackoffMode::value] or
    /// [BackoffMode::name].
    UnknownValue(backoff_mode::UnknownValue),
}

#[doc(hidden)]
pub mod backoff_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackoffMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear => std::option::Option::Some(1),
            Self::Exponential => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKOFF_MODE_UNSPECIFIED"),
            Self::Linear => std::option::Option::Some("BACKOFF_MODE_LINEAR"),
            Self::Exponential => std::option::Option::Some("BACKOFF_MODE_EXPONENTIAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackoffMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackoffMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackoffMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear,
            2 => Self::Exponential,
            _ => Self::UnknownValue(backoff_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackoffMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKOFF_MODE_UNSPECIFIED" => Self::Unspecified,
            "BACKOFF_MODE_LINEAR" => Self::Linear,
            "BACKOFF_MODE_EXPONENTIAL" => Self::Exponential,
            _ => Self::UnknownValue(backoff_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackoffMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear => serializer.serialize_i32(1),
            Self::Exponential => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackoffMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackoffMode>::new(
            ".google.cloud.deploy.v1.BackoffMode",
        ))
    }
}

/// Valid state of a repair attempt.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RepairState {
    /// The `repair` has an unspecified state.
    Unspecified,
    /// The `repair` action has succeeded.
    Succeeded,
    /// The `repair` action was cancelled.
    Cancelled,
    /// The `repair` action has failed.
    Failed,
    /// The `repair` action is in progress.
    InProgress,
    /// The `repair` action is pending.
    Pending,
    /// The `repair` action was aborted.
    Aborted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RepairState::value] or
    /// [RepairState::name].
    UnknownValue(repair_state::UnknownValue),
}

#[doc(hidden)]
pub mod repair_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RepairState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Succeeded => std::option::Option::Some(1),
            Self::Cancelled => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::InProgress => std::option::Option::Some(4),
            Self::Pending => std::option::Option::Some(5),
            Self::Aborted => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("REPAIR_STATE_UNSPECIFIED"),
            Self::Succeeded => std::option::Option::Some("REPAIR_STATE_SUCCEEDED"),
            Self::Cancelled => std::option::Option::Some("REPAIR_STATE_CANCELLED"),
            Self::Failed => std::option::Option::Some("REPAIR_STATE_FAILED"),
            Self::InProgress => std::option::Option::Some("REPAIR_STATE_IN_PROGRESS"),
            Self::Pending => std::option::Option::Some("REPAIR_STATE_PENDING"),
            Self::Aborted => std::option::Option::Some("REPAIR_STATE_ABORTED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RepairState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RepairState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RepairState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Succeeded,
            2 => Self::Cancelled,
            3 => Self::Failed,
            4 => Self::InProgress,
            5 => Self::Pending,
            7 => Self::Aborted,
            _ => Self::UnknownValue(repair_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RepairState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REPAIR_STATE_UNSPECIFIED" => Self::Unspecified,
            "REPAIR_STATE_SUCCEEDED" => Self::Succeeded,
            "REPAIR_STATE_CANCELLED" => Self::Cancelled,
            "REPAIR_STATE_FAILED" => Self::Failed,
            "REPAIR_STATE_IN_PROGRESS" => Self::InProgress,
            "REPAIR_STATE_PENDING" => Self::Pending,
            "REPAIR_STATE_ABORTED" => Self::Aborted,
            _ => Self::UnknownValue(repair_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RepairState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Succeeded => serializer.serialize_i32(1),
            Self::Cancelled => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::InProgress => serializer.serialize_i32(4),
            Self::Pending => serializer.serialize_i32(5),
            Self::Aborted => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RepairState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RepairState>::new(
            ".google.cloud.deploy.v1.RepairState",
        ))
    }
}

/// Type indicates the type of the log entry and can be used as a filter.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Type {
    /// Type is unspecified.
    Unspecified,
    /// A Pub/Sub notification failed to be sent.
    PubsubNotificationFailure,
    /// Resource state changed.
    ResourceStateChange,
    /// A process aborted.
    ProcessAborted,
    /// Restriction check failed.
    RestrictionViolated,
    /// Resource deleted.
    ResourceDeleted,
    /// Rollout updated.
    RolloutUpdate,
    /// Deploy Policy evaluation.
    DeployPolicyEvaluation,
    /// Deprecated: This field is never used. Use release_render log type instead.
    #[deprecated]
    RenderStatuesChange,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Type::value] or
    /// [Type::name].
    UnknownValue(r#type::UnknownValue),
}

#[doc(hidden)]
pub mod r#type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Type {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PubsubNotificationFailure => std::option::Option::Some(1),
            Self::ResourceStateChange => std::option::Option::Some(3),
            Self::ProcessAborted => std::option::Option::Some(4),
            Self::RestrictionViolated => std::option::Option::Some(5),
            Self::ResourceDeleted => std::option::Option::Some(6),
            Self::RolloutUpdate => std::option::Option::Some(7),
            Self::DeployPolicyEvaluation => std::option::Option::Some(8),
            Self::RenderStatuesChange => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
            Self::PubsubNotificationFailure => {
                std::option::Option::Some("TYPE_PUBSUB_NOTIFICATION_FAILURE")
            }
            Self::ResourceStateChange => std::option::Option::Some("TYPE_RESOURCE_STATE_CHANGE"),
            Self::ProcessAborted => std::option::Option::Some("TYPE_PROCESS_ABORTED"),
            Self::RestrictionViolated => std::option::Option::Some("TYPE_RESTRICTION_VIOLATED"),
            Self::ResourceDeleted => std::option::Option::Some("TYPE_RESOURCE_DELETED"),
            Self::RolloutUpdate => std::option::Option::Some("TYPE_ROLLOUT_UPDATE"),
            Self::DeployPolicyEvaluation => {
                std::option::Option::Some("TYPE_DEPLOY_POLICY_EVALUATION")
            }
            Self::RenderStatuesChange => std::option::Option::Some("TYPE_RENDER_STATUES_CHANGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Type {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Type {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PubsubNotificationFailure,
            2 => Self::RenderStatuesChange,
            3 => Self::ResourceStateChange,
            4 => Self::ProcessAborted,
            5 => Self::RestrictionViolated,
            6 => Self::ResourceDeleted,
            7 => Self::RolloutUpdate,
            8 => Self::DeployPolicyEvaluation,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Type {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TYPE_UNSPECIFIED" => Self::Unspecified,
            "TYPE_PUBSUB_NOTIFICATION_FAILURE" => Self::PubsubNotificationFailure,
            "TYPE_RESOURCE_STATE_CHANGE" => Self::ResourceStateChange,
            "TYPE_PROCESS_ABORTED" => Self::ProcessAborted,
            "TYPE_RESTRICTION_VIOLATED" => Self::RestrictionViolated,
            "TYPE_RESOURCE_DELETED" => Self::ResourceDeleted,
            "TYPE_ROLLOUT_UPDATE" => Self::RolloutUpdate,
            "TYPE_DEPLOY_POLICY_EVALUATION" => Self::DeployPolicyEvaluation,
            "TYPE_RENDER_STATUES_CHANGE" => Self::RenderStatuesChange,
            _ => Self::UnknownValue(r#type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PubsubNotificationFailure => serializer.serialize_i32(1),
            Self::ResourceStateChange => serializer.serialize_i32(3),
            Self::ProcessAborted => serializer.serialize_i32(4),
            Self::RestrictionViolated => serializer.serialize_i32(5),
            Self::ResourceDeleted => serializer.serialize_i32(6),
            Self::RolloutUpdate => serializer.serialize_i32(7),
            Self::DeployPolicyEvaluation => serializer.serialize_i32(8),
            Self::RenderStatuesChange => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
            ".google.cloud.deploy.v1.Type",
        ))
    }
}
