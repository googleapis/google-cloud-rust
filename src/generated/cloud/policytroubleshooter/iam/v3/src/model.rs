// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate iam_v1;
extern crate iam_v2;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for
/// [TroubleshootIamPolicy][google.cloud.policytroubleshooter.iam.v3.PolicyTroubleshooter.TroubleshootIamPolicy].
///
/// [google.cloud.policytroubleshooter.iam.v3.PolicyTroubleshooter.TroubleshootIamPolicy]: crate::client::PolicyTroubleshooter::troubleshoot_iam_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TroubleshootIamPolicyRequest {
    /// The information to use for checking whether a principal has a permission
    /// for a resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_tuple: std::option::Option<crate::model::AccessTuple>,
}

impl TroubleshootIamPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_tuple][crate::model::TroubleshootIamPolicyRequest::access_tuple].
    pub fn set_access_tuple<
        T: std::convert::Into<std::option::Option<crate::model::AccessTuple>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_tuple = v.into();
        self
    }
}

impl wkt::message::Message for TroubleshootIamPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyRequest"
    }
}

/// Response for
/// [TroubleshootIamPolicy][google.cloud.policytroubleshooter.iam.v3.PolicyTroubleshooter.TroubleshootIamPolicy].
///
/// [google.cloud.policytroubleshooter.iam.v3.PolicyTroubleshooter.TroubleshootIamPolicy]: crate::client::PolicyTroubleshooter::troubleshoot_iam_policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TroubleshootIamPolicyResponse {
    /// Indicates whether the principal has the specified permission for the
    /// specified resource, based on evaluating all types of the applicable IAM
    /// policies.
    pub overall_access_state: crate::model::troubleshoot_iam_policy_response::OverallAccessState,

    /// The access tuple from the request, including any provided context used to
    /// evaluate the condition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_tuple: std::option::Option<crate::model::AccessTuple>,

    /// An explanation of how the applicable IAM allow policies affect the final
    /// access state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_policy_explanation: std::option::Option<crate::model::AllowPolicyExplanation>,

    /// An explanation of how the applicable IAM deny policies affect the final
    /// access state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deny_policy_explanation: std::option::Option<crate::model::DenyPolicyExplanation>,
}

impl TroubleshootIamPolicyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [overall_access_state][crate::model::TroubleshootIamPolicyResponse::overall_access_state].
    pub fn set_overall_access_state<
        T: std::convert::Into<crate::model::troubleshoot_iam_policy_response::OverallAccessState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overall_access_state = v.into();
        self
    }

    /// Sets the value of [access_tuple][crate::model::TroubleshootIamPolicyResponse::access_tuple].
    pub fn set_access_tuple<
        T: std::convert::Into<std::option::Option<crate::model::AccessTuple>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_tuple = v.into();
        self
    }

    /// Sets the value of [allow_policy_explanation][crate::model::TroubleshootIamPolicyResponse::allow_policy_explanation].
    pub fn set_allow_policy_explanation<
        T: std::convert::Into<std::option::Option<crate::model::AllowPolicyExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.allow_policy_explanation = v.into();
        self
    }

    /// Sets the value of [deny_policy_explanation][crate::model::TroubleshootIamPolicyResponse::deny_policy_explanation].
    pub fn set_deny_policy_explanation<
        T: std::convert::Into<std::option::Option<crate::model::DenyPolicyExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deny_policy_explanation = v.into();
        self
    }
}

impl wkt::message::Message for TroubleshootIamPolicyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse"
    }
}

/// Defines additional types related to TroubleshootIamPolicyResponse
pub mod troubleshoot_iam_policy_response {
    #[allow(unused_imports)]
    use super::*;

    /// Whether the principal has the permission on the resource.
    #[derive(Clone, Debug, PartialEq)]
    pub struct OverallAccessState(wkt::enumerations::Enumeration);

    /// Useful constants to work with [OverallAccessState](OverallAccessState)
    pub mod overall_access_state {
        use super::OverallAccessState;

        /// Not specified.
        pub const OVERALL_ACCESS_STATE_UNSPECIFIED: OverallAccessState =
            OverallAccessState::known("OVERALL_ACCESS_STATE_UNSPECIFIED", 0);

        /// The principal has the permission.
        pub const CAN_ACCESS: OverallAccessState = OverallAccessState::known("CAN_ACCESS", 1);

        /// The principal doesn't have the permission.
        pub const CANNOT_ACCESS: OverallAccessState = OverallAccessState::known("CANNOT_ACCESS", 2);

        /// The principal might have the permission, but the sender can't access all
        /// of the information needed to fully evaluate the principal's access.
        pub const UNKNOWN_INFO: OverallAccessState = OverallAccessState::known("UNKNOWN_INFO", 3);

        /// The principal might have the permission, but Policy Troubleshooter can't
        /// fully evaluate the principal's access because the sender didn't provide
        /// the required context to evaluate the condition.
        pub const UNKNOWN_CONDITIONAL: OverallAccessState =
            OverallAccessState::known("UNKNOWN_CONDITIONAL", 4);
    }

    impl OverallAccessState {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for OverallAccessState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OverallAccessState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(OverallAccessState::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(OverallAccessState::from(val)),
                Enumeration::UnknownNum { str } => Ok(OverallAccessState::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for OverallAccessState {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "OVERALL_ACCESS_STATE_UNSPECIFIED" => {
                    overall_access_state::OVERALL_ACCESS_STATE_UNSPECIFIED
                }
                "CAN_ACCESS" => overall_access_state::CAN_ACCESS,
                "CANNOT_ACCESS" => overall_access_state::CANNOT_ACCESS,
                "UNKNOWN_INFO" => overall_access_state::UNKNOWN_INFO,
                "UNKNOWN_CONDITIONAL" => overall_access_state::UNKNOWN_CONDITIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for OverallAccessState {
        fn from(value: i32) -> Self {
            match value {
                0 => overall_access_state::OVERALL_ACCESS_STATE_UNSPECIFIED,
                1 => overall_access_state::CAN_ACCESS,
                2 => overall_access_state::CANNOT_ACCESS,
                3 => overall_access_state::UNKNOWN_INFO,
                4 => overall_access_state::UNKNOWN_CONDITIONAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for OverallAccessState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Information about the principal, resource, and permission to check.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessTuple {
    /// Required. The email address of the principal whose access you want to
    /// check. For example, `alice@example.com` or
    /// `my-service-account@my-project.iam.gserviceaccount.com`.
    ///
    /// The principal must be a Google Account or a service account. Other types of
    /// principals are not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub principal: std::string::String,

    /// Required. The full resource name that identifies the resource. For example,
    /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
    ///
    /// For examples of full resource names for Google Cloud services, see
    /// <https://cloud.google.com/iam/help/troubleshooter/full-resource-names>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource_name: std::string::String,

    /// Required. The IAM permission to check for, either in the `v1` permission
    /// format or the `v2` permission format.
    ///
    /// For a complete list of IAM permissions in the `v1` format, see
    /// <https://cloud.google.com/iam/help/permissions/reference>.
    ///
    /// For a list of IAM permissions in the `v2` format, see
    /// <https://cloud.google.com/iam/help/deny/supported-permissions>.
    ///
    /// For a complete list of predefined IAM roles and the permissions in each
    /// role, see <https://cloud.google.com/iam/help/roles/reference>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub permission: std::string::String,

    /// Output only. The permission that Policy Troubleshooter checked for, in
    /// the `v2` format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub permission_fqdn: std::string::String,

    /// Optional. Additional context for the request, such as the request time or
    /// IP address. This context allows Policy Troubleshooter to troubleshoot
    /// conditional role bindings and deny rules.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition_context: std::option::Option<crate::model::ConditionContext>,
}

impl AccessTuple {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal][crate::model::AccessTuple::principal].
    pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal = v.into();
        self
    }

    /// Sets the value of [full_resource_name][crate::model::AccessTuple::full_resource_name].
    pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.full_resource_name = v.into();
        self
    }

    /// Sets the value of [permission][crate::model::AccessTuple::permission].
    pub fn set_permission<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.permission = v.into();
        self
    }

    /// Sets the value of [permission_fqdn][crate::model::AccessTuple::permission_fqdn].
    pub fn set_permission_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.permission_fqdn = v.into();
        self
    }

    /// Sets the value of [condition_context][crate::model::AccessTuple::condition_context].
    pub fn set_condition_context<
        T: std::convert::Into<std::option::Option<crate::model::ConditionContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_context = v.into();
        self
    }
}

impl wkt::message::Message for AccessTuple {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.AccessTuple"
    }
}

/// Additional context for troubleshooting conditional role bindings and deny
/// rules.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConditionContext {
    /// Represents a target resource that is involved with a network activity.
    /// If multiple resources are involved with an activity, this must be the
    /// primary one.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource: std::option::Option<crate::model::condition_context::Resource>,

    /// The destination of a network activity, such as accepting a TCP connection.
    /// In a multi-hop network activity, the destination represents the receiver of
    /// the last hop.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::condition_context::Peer>,

    /// Represents a network request, such as an HTTP request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::condition_context::Request>,

    /// Output only. The effective tags on the resource. The effective tags are
    /// fetched during troubleshooting.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub effective_tags: std::vec::Vec<crate::model::condition_context::EffectiveTag>,
}

impl ConditionContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::ConditionContext::resource].
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::condition_context::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ConditionContext::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::condition_context::Peer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [request][crate::model::ConditionContext::request].
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::condition_context::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [effective_tags][crate::model::ConditionContext::effective_tags].
    pub fn set_effective_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition_context::EffectiveTag>,
    {
        use std::iter::Iterator;
        self.effective_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConditionContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionContext"
    }
}

/// Defines additional types related to ConditionContext
pub mod condition_context {
    #[allow(unused_imports)]
    use super::*;

    /// Core attributes for a resource. A resource is an
    /// addressable (named) entity provided by the destination service. For
    /// example, a Compute Engine instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Resource {
        /// The name of the service that this resource belongs to, such as
        /// `compute.googleapis.com`. The service name might not match the DNS
        /// hostname that actually serves the request.
        ///
        /// For a full list of resource service values, see
        /// <https://cloud.google.com/iam/help/conditions/resource-services>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service: std::string::String,

        /// The stable identifier (name) of a resource on the `service`. A resource
        /// can be logically identified as `//{resource.service}/{resource.name}`.
        /// Unlike the resource URI, the resource name doesn't contain any protocol
        /// and version information.
        ///
        /// For a list of full resource name formats, see
        /// <https://cloud.google.com/iam/help/troubleshooter/full-resource-names>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The type of the resource, in the format `{service}/{kind}`.
        ///
        /// For a full list of resource type values, see
        /// <https://cloud.google.com/iam/help/conditions/resource-types>
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,
    }

    impl Resource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::condition_context::Resource::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [name][crate::model::condition_context::Resource::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::condition_context::Resource::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Resource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionContext.Resource"
        }
    }

    /// This message defines attributes for a node that handles a network request.
    /// The node can be either a service or an application that sends, forwards,
    /// or receives the request. Service peers should fill in
    /// `principal` and `labels` as appropriate.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Peer {
        /// The IPv4 or IPv6 address of the peer.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ip: std::string::String,

        /// The network port of the peer.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub port: i64,
    }

    impl Peer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip][crate::model::condition_context::Peer::ip].
        pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip = v.into();
            self
        }

        /// Sets the value of [port][crate::model::condition_context::Peer::port].
        pub fn set_port<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }
    }

    impl wkt::message::Message for Peer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionContext.Peer"
        }
    }

    /// This message defines attributes for an HTTP request. If the actual
    /// request is not an HTTP request, the runtime system should try to map
    /// the actual request to an equivalent HTTP request.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Request {
        /// Optional. The timestamp when the destination service receives the first
        /// byte of the request.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub receive_time: std::option::Option<wkt::Timestamp>,
    }

    impl Request {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [receive_time][crate::model::condition_context::Request::receive_time].
        pub fn set_receive_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.receive_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Request {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionContext.Request"
        }
    }

    /// A tag that applies to a resource during policy evaluation. Tags can be
    /// either directly bound to a resource or inherited from its ancestor.
    /// `EffectiveTag` contains the `name` and `namespaced_name` of the tag value
    /// and tag key, with additional fields of `inherited` to indicate the
    /// inheritance status of the effective tag.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EffectiveTag {
        /// Output only. Resource name for TagValue in the format `tagValues/456`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tag_value: std::string::String,

        /// Output only. The namespaced name of the TagValue. Can be in the form
        /// `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or
        /// `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or
        /// `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespaced_tag_value: std::string::String,

        /// Output only. The name of the TagKey, in the format `tagKeys/{id}`, such
        /// as `tagKeys/123`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tag_key: std::string::String,

        /// Output only. The namespaced name of the TagKey. Can be in the form
        /// `{organization_id}/{tag_key_short_name}` or
        /// `{project_id}/{tag_key_short_name}` or
        /// `{project_number}/{tag_key_short_name}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub namespaced_tag_key: std::string::String,

        /// The parent name of the tag key.
        /// Must be in the format `organizations/{organization_id}` or
        /// `projects/{project_number}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub tag_key_parent_name: std::string::String,

        /// Output only. Indicates the inheritance status of a tag value
        /// attached to the given resource. If the tag value is inherited from one of
        /// the resource's ancestors, inherited will be true. If false, then the tag
        /// value is directly attached to the resource, inherited will be false.
        pub inherited: bool,
    }

    impl EffectiveTag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag_value][crate::model::condition_context::EffectiveTag::tag_value].
        pub fn set_tag_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tag_value = v.into();
            self
        }

        /// Sets the value of [namespaced_tag_value][crate::model::condition_context::EffectiveTag::namespaced_tag_value].
        pub fn set_namespaced_tag_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespaced_tag_value = v.into();
            self
        }

        /// Sets the value of [tag_key][crate::model::condition_context::EffectiveTag::tag_key].
        pub fn set_tag_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tag_key = v.into();
            self
        }

        /// Sets the value of [namespaced_tag_key][crate::model::condition_context::EffectiveTag::namespaced_tag_key].
        pub fn set_namespaced_tag_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.namespaced_tag_key = v.into();
            self
        }

        /// Sets the value of [tag_key_parent_name][crate::model::condition_context::EffectiveTag::tag_key_parent_name].
        pub fn set_tag_key_parent_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tag_key_parent_name = v.into();
            self
        }

        /// Sets the value of [inherited][crate::model::condition_context::EffectiveTag::inherited].
        pub fn set_inherited<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.inherited = v.into();
            self
        }
    }

    impl wkt::message::Message for EffectiveTag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionContext.EffectiveTag"
        }
    }
}

/// Details about how the relevant IAM allow policies affect the final access
/// state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllowPolicyExplanation {
    /// Indicates whether the principal has the specified permission for the
    /// specified resource, based on evaluating all applicable IAM allow policies.
    pub allow_access_state: crate::model::AllowAccessState,

    /// List of IAM allow policies that were evaluated to check the principal's
    /// permissions, with annotations to indicate how each policy contributed to
    /// the final result.
    ///
    /// The list of policies includes the policy for the resource itself, as well
    /// as allow policies that are inherited from higher levels of the resource
    /// hierarchy, including the organization, the folder, and the project.
    ///
    /// To learn more about the resource hierarchy, see
    /// <https://cloud.google.com/iam/help/resource-hierarchy>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explained_policies: std::vec::Vec<crate::model::ExplainedAllowPolicy>,

    /// The relevance of the allow policy type to the overall access state.
    pub relevance: crate::model::HeuristicRelevance,
}

impl AllowPolicyExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_access_state][crate::model::AllowPolicyExplanation::allow_access_state].
    pub fn set_allow_access_state<T: std::convert::Into<crate::model::AllowAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_access_state = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::AllowPolicyExplanation::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [explained_policies][crate::model::AllowPolicyExplanation::explained_policies].
    pub fn set_explained_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExplainedAllowPolicy>,
    {
        use std::iter::Iterator;
        self.explained_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllowPolicyExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.AllowPolicyExplanation"
    }
}

/// Details about how a specific IAM allow policy contributed to the final access
/// state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainedAllowPolicy {
    /// Required. Indicates whether _this policy_ provides the specified permission
    /// to the specified principal for the specified resource.
    ///
    /// This field does _not_ indicate whether the principal actually has the
    /// permission for the resource. There might be another policy that overrides
    /// this policy. To determine whether the principal actually has the
    /// permission, use the `overall_access_state` field in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub allow_access_state: crate::model::AllowAccessState,

    /// The full resource name that identifies the resource. For example,
    /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    ///
    /// For examples of full resource names for Google Cloud services, see
    /// <https://cloud.google.com/iam/help/troubleshooter/full-resource-names>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource_name: std::string::String,

    /// Details about how each role binding in the policy affects the principal's
    /// ability, or inability, to use the permission for the resource. The order of
    /// the role bindings matches the role binding order in the policy.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub binding_explanations: std::vec::Vec<crate::model::AllowBindingExplanation>,

    /// The relevance of this policy to the overall access state in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub relevance: crate::model::HeuristicRelevance,

    /// The IAM allow policy attached to the resource.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<iam_v1::model::Policy>,
}

impl ExplainedAllowPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_access_state][crate::model::ExplainedAllowPolicy::allow_access_state].
    pub fn set_allow_access_state<T: std::convert::Into<crate::model::AllowAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_access_state = v.into();
        self
    }

    /// Sets the value of [full_resource_name][crate::model::ExplainedAllowPolicy::full_resource_name].
    pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.full_resource_name = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::ExplainedAllowPolicy::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::ExplainedAllowPolicy::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<iam_v1::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [binding_explanations][crate::model::ExplainedAllowPolicy::binding_explanations].
    pub fn set_binding_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AllowBindingExplanation>,
    {
        use std::iter::Iterator;
        self.binding_explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainedAllowPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ExplainedAllowPolicy"
    }
}

/// Details about how a role binding in an allow policy affects a principal's
/// ability to use a permission.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllowBindingExplanation {
    /// Required. Indicates whether _this role binding_ gives the specified
    /// permission to the specified principal on the specified resource.
    ///
    /// This field does _not_ indicate whether the principal actually has the
    /// permission on the resource. There might be another role binding that
    /// overrides this role binding. To determine whether the principal actually
    /// has the permission, use the `overall_access_state` field in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub allow_access_state: crate::model::AllowAccessState,

    /// The role that this role binding grants. For example,
    /// `roles/compute.admin`.
    ///
    /// For a complete list of predefined IAM roles, as well as the permissions in
    /// each role, see <https://cloud.google.com/iam/help/roles/reference>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// Indicates whether the role granted by this role binding contains the
    /// specified permission.
    pub role_permission: crate::model::RolePermissionInclusionState,

    /// The relevance of the permission's existence, or nonexistence, in the role
    /// to the overall determination for the entire policy.
    pub role_permission_relevance: crate::model::HeuristicRelevance,

    /// The combined result of all memberships. Indicates if the principal is
    /// included in any role binding, either directly or indirectly.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub combined_membership:
        std::option::Option<crate::model::allow_binding_explanation::AnnotatedAllowMembership>,

    /// Indicates whether each role binding includes the principal specified in the
    /// request, either directly or indirectly. Each key identifies a principal in
    /// the role binding, and each value indicates whether the principal in the
    /// role binding includes the principal in the request.
    ///
    /// For example, suppose that a role binding includes the following principals:
    ///
    /// * `user:alice@example.com`
    /// * `group:product-eng@example.com`
    ///
    /// You want to troubleshoot access for `user:bob@example.com`. This user is a
    /// member of the group `group:product-eng@example.com`.
    ///
    /// For the first principal in the role binding, the key is
    /// `user:alice@example.com`, and the `membership` field in the value is set to
    /// `NOT_INCLUDED`.
    ///
    /// For the second principal in the role binding, the key is
    /// `group:product-eng@example.com`, and the `membership` field in the value is
    /// set to `INCLUDED`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub memberships: std::collections::HashMap<
        std::string::String,
        crate::model::allow_binding_explanation::AnnotatedAllowMembership,
    >,

    /// The relevance of this role binding to the overall determination for the
    /// entire policy.
    pub relevance: crate::model::HeuristicRelevance,

    /// A condition expression that specifies when the role binding grants access.
    ///
    /// To learn about IAM Conditions, see
    /// <https://cloud.google.com/iam/help/conditions/overview>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<gtype::model::Expr>,

    /// Condition evaluation state for this role binding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition_explanation: std::option::Option<crate::model::ConditionExplanation>,
}

impl AllowBindingExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_access_state][crate::model::AllowBindingExplanation::allow_access_state].
    pub fn set_allow_access_state<T: std::convert::Into<crate::model::AllowAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_access_state = v.into();
        self
    }

    /// Sets the value of [role][crate::model::AllowBindingExplanation::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [role_permission][crate::model::AllowBindingExplanation::role_permission].
    pub fn set_role_permission<
        T: std::convert::Into<crate::model::RolePermissionInclusionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.role_permission = v.into();
        self
    }

    /// Sets the value of [role_permission_relevance][crate::model::AllowBindingExplanation::role_permission_relevance].
    pub fn set_role_permission_relevance<
        T: std::convert::Into<crate::model::HeuristicRelevance>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.role_permission_relevance = v.into();
        self
    }

    /// Sets the value of [combined_membership][crate::model::AllowBindingExplanation::combined_membership].
    pub fn set_combined_membership<
        T: std::convert::Into<
            std::option::Option<crate::model::allow_binding_explanation::AnnotatedAllowMembership>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combined_membership = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::AllowBindingExplanation::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::AllowBindingExplanation::condition].
    pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [condition_explanation][crate::model::AllowBindingExplanation::condition_explanation].
    pub fn set_condition_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ConditionExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_explanation = v.into();
        self
    }

    /// Sets the value of [memberships][crate::model::AllowBindingExplanation::memberships].
    pub fn set_memberships<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::allow_binding_explanation::AnnotatedAllowMembership>,
    {
        use std::iter::Iterator;
        self.memberships = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AllowBindingExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.AllowBindingExplanation"
    }
}

/// Defines additional types related to AllowBindingExplanation
pub mod allow_binding_explanation {
    #[allow(unused_imports)]
    use super::*;

    /// Details about whether the role binding includes the principal.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnnotatedAllowMembership {
        /// Indicates whether the role binding includes the principal.
        pub membership: crate::model::MembershipMatchingState,

        /// The relevance of the principal's status to the overall determination for
        /// the role binding.
        pub relevance: crate::model::HeuristicRelevance,
    }

    impl AnnotatedAllowMembership {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [membership][crate::model::allow_binding_explanation::AnnotatedAllowMembership::membership].
        pub fn set_membership<T: std::convert::Into<crate::model::MembershipMatchingState>>(
            mut self,
            v: T,
        ) -> Self {
            self.membership = v.into();
            self
        }

        /// Sets the value of [relevance][crate::model::allow_binding_explanation::AnnotatedAllowMembership::relevance].
        pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
            mut self,
            v: T,
        ) -> Self {
            self.relevance = v.into();
            self
        }
    }

    impl wkt::message::Message for AnnotatedAllowMembership {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.AllowBindingExplanation.AnnotatedAllowMembership"
        }
    }
}

/// Details about how the relevant IAM deny policies affect the final access
/// state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DenyPolicyExplanation {
    /// Indicates whether the principal is denied the specified permission for
    /// the specified resource, based on evaluating all applicable IAM deny
    /// policies.
    pub deny_access_state: crate::model::DenyAccessState,

    /// List of resources with IAM deny policies that were evaluated to check the
    /// principal's denied permissions, with annotations to indicate how each
    /// policy contributed to the final result.
    ///
    /// The list of resources includes the policy for the resource itself, as well
    /// as policies that are inherited from higher levels of the resource
    /// hierarchy, including the organization, the folder, and the project. The
    /// order of the resources starts from the resource and climbs up the resource
    /// hierarchy.
    ///
    /// To learn more about the resource hierarchy, see
    /// <https://cloud.google.com/iam/help/resource-hierarchy>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explained_resources: std::vec::Vec<crate::model::ExplainedDenyResource>,

    /// The relevance of the deny policy result to the overall access state.
    pub relevance: crate::model::HeuristicRelevance,

    /// Indicates whether the permission to troubleshoot is supported in deny
    /// policies.
    pub permission_deniable: bool,
}

impl DenyPolicyExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deny_access_state][crate::model::DenyPolicyExplanation::deny_access_state].
    pub fn set_deny_access_state<T: std::convert::Into<crate::model::DenyAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deny_access_state = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::DenyPolicyExplanation::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [permission_deniable][crate::model::DenyPolicyExplanation::permission_deniable].
    pub fn set_permission_deniable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.permission_deniable = v.into();
        self
    }

    /// Sets the value of [explained_resources][crate::model::DenyPolicyExplanation::explained_resources].
    pub fn set_explained_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExplainedDenyResource>,
    {
        use std::iter::Iterator;
        self.explained_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DenyPolicyExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.DenyPolicyExplanation"
    }
}

/// Details about how a specific resource contributed to the deny policy
/// evaluation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainedDenyResource {
    /// Required. Indicates whether any policies attached to _this resource_ deny
    /// the specific permission to the specified principal for the specified
    /// resource.
    ///
    /// This field does _not_ indicate whether the principal actually has the
    /// permission for the resource. There might be another policy that overrides
    /// this policy. To determine whether the principal actually has the
    /// permission, use the `overall_access_state` field in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub deny_access_state: crate::model::DenyAccessState,

    /// The full resource name that identifies the resource. For example,
    /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    ///
    /// For examples of full resource names for Google Cloud services, see
    /// <https://cloud.google.com/iam/help/troubleshooter/full-resource-names>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub full_resource_name: std::string::String,

    /// List of IAM deny policies that were evaluated to check the principal's
    /// denied permissions, with annotations to indicate how each policy
    /// contributed to the final result.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub explained_policies: std::vec::Vec<crate::model::ExplainedDenyPolicy>,

    /// The relevance of this policy to the overall access state in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub relevance: crate::model::HeuristicRelevance,
}

impl ExplainedDenyResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deny_access_state][crate::model::ExplainedDenyResource::deny_access_state].
    pub fn set_deny_access_state<T: std::convert::Into<crate::model::DenyAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deny_access_state = v.into();
        self
    }

    /// Sets the value of [full_resource_name][crate::model::ExplainedDenyResource::full_resource_name].
    pub fn set_full_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.full_resource_name = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::ExplainedDenyResource::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [explained_policies][crate::model::ExplainedDenyResource::explained_policies].
    pub fn set_explained_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExplainedDenyPolicy>,
    {
        use std::iter::Iterator;
        self.explained_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainedDenyResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ExplainedDenyResource"
    }
}

/// Details about how a specific IAM deny policy [Policy][google.iam.v2.Policy]
/// contributed to the access check.
///
/// [google.iam.v2.Policy]: iam_v2::model::Policy
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplainedDenyPolicy {
    /// Required. Indicates whether _this policy_ denies the specified permission
    /// to the specified principal for the specified resource.
    ///
    /// This field does _not_ indicate whether the principal actually has the
    /// permission for the resource. There might be another policy that overrides
    /// this policy. To determine whether the principal actually has the
    /// permission, use the `overall_access_state` field in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub deny_access_state: crate::model::DenyAccessState,

    /// The IAM deny policy attached to the resource.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<iam_v2::model::Policy>,

    /// Details about how each rule in the policy affects the principal's inability
    /// to use the permission for the resource. The order of the deny rule matches
    /// the order of the rules in the deny policy.
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rule_explanations: std::vec::Vec<crate::model::DenyRuleExplanation>,

    /// The relevance of this policy to the overall access state in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// If the sender of the request does not have access to the policy, this field
    /// is omitted.
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub relevance: crate::model::HeuristicRelevance,
}

impl ExplainedDenyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deny_access_state][crate::model::ExplainedDenyPolicy::deny_access_state].
    pub fn set_deny_access_state<T: std::convert::Into<crate::model::DenyAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deny_access_state = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::ExplainedDenyPolicy::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<iam_v2::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::ExplainedDenyPolicy::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [rule_explanations][crate::model::ExplainedDenyPolicy::rule_explanations].
    pub fn set_rule_explanations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DenyRuleExplanation>,
    {
        use std::iter::Iterator;
        self.rule_explanations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExplainedDenyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ExplainedDenyPolicy"
    }
}

/// Details about how a deny rule in a deny policy affects a principal's ability
/// to use a permission.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DenyRuleExplanation {
    /// Required. Indicates whether _this rule_ denies the specified permission to
    /// the specified principal for the specified resource.
    ///
    /// This field does _not_ indicate whether the principal is actually denied on
    /// the permission for the resource. There might be another rule that overrides
    /// this rule. To determine whether the principal actually has the permission,
    /// use the `overall_access_state` field in the
    /// [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse].
    ///
    /// [google.cloud.policytroubleshooter.iam.v3.TroubleshootIamPolicyResponse]: crate::model::TroubleshootIamPolicyResponse
    pub deny_access_state: crate::model::DenyAccessState,

    /// Indicates whether the permission in the request is listed as a denied
    /// permission in the deny rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub combined_denied_permission:
        std::option::Option<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,

    /// Lists all denied permissions in the deny rule and indicates whether each
    /// permission matches the permission in the request.
    ///
    /// Each key identifies a denied permission in the rule, and each value
    /// indicates whether the denied permission matches the permission in the
    /// request.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub denied_permissions: std::collections::HashMap<
        std::string::String,
        crate::model::deny_rule_explanation::AnnotatedPermissionMatching,
    >,

    /// Indicates whether the permission in the request is listed as an exception
    /// permission in the deny rule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub combined_exception_permission:
        std::option::Option<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,

    /// Lists all exception permissions in the deny rule and indicates whether each
    /// permission matches the permission in the request.
    ///
    /// Each key identifies a exception permission in the rule, and each value
    /// indicates whether the exception permission matches the permission in the
    /// request.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub exception_permissions: std::collections::HashMap<
        std::string::String,
        crate::model::deny_rule_explanation::AnnotatedPermissionMatching,
    >,

    /// Indicates whether the principal is listed as a denied principal in the
    /// deny rule, either directly or through membership in a principal set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub combined_denied_principal:
        std::option::Option<crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>,

    /// Lists all denied principals in the deny rule and indicates whether each
    /// principal matches the principal in the request, either directly or through
    /// membership in a principal set.
    ///
    /// Each key identifies a denied principal in the rule, and each value
    /// indicates whether the denied principal matches the principal in the
    /// request.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub denied_principals: std::collections::HashMap<
        std::string::String,
        crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
    >,

    /// Indicates whether the principal is listed as an exception principal in the
    /// deny rule, either directly or through membership in a principal set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub combined_exception_principal:
        std::option::Option<crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>,

    /// Lists all exception principals in the deny rule and indicates whether each
    /// principal matches the principal in the request, either directly or through
    /// membership in a principal set.
    ///
    /// Each key identifies a exception principal in the rule, and each value
    /// indicates whether the exception principal matches the principal in the
    /// request.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub exception_principals: std::collections::HashMap<
        std::string::String,
        crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
    >,

    /// The relevance of this role binding to the overall determination for the
    /// entire policy.
    pub relevance: crate::model::HeuristicRelevance,

    /// A condition expression that specifies when the deny rule denies the
    /// principal access.
    ///
    /// To learn about IAM Conditions, see
    /// <https://cloud.google.com/iam/help/conditions/overview>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<gtype::model::Expr>,

    /// Condition evaluation state for this role binding.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition_explanation: std::option::Option<crate::model::ConditionExplanation>,
}

impl DenyRuleExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deny_access_state][crate::model::DenyRuleExplanation::deny_access_state].
    pub fn set_deny_access_state<T: std::convert::Into<crate::model::DenyAccessState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deny_access_state = v.into();
        self
    }

    /// Sets the value of [combined_denied_permission][crate::model::DenyRuleExplanation::combined_denied_permission].
    pub fn set_combined_denied_permission<
        T: std::convert::Into<
            std::option::Option<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combined_denied_permission = v.into();
        self
    }

    /// Sets the value of [combined_exception_permission][crate::model::DenyRuleExplanation::combined_exception_permission].
    pub fn set_combined_exception_permission<
        T: std::convert::Into<
            std::option::Option<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combined_exception_permission = v.into();
        self
    }

    /// Sets the value of [combined_denied_principal][crate::model::DenyRuleExplanation::combined_denied_principal].
    pub fn set_combined_denied_principal<
        T: std::convert::Into<
            std::option::Option<
                crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combined_denied_principal = v.into();
        self
    }

    /// Sets the value of [combined_exception_principal][crate::model::DenyRuleExplanation::combined_exception_principal].
    pub fn set_combined_exception_principal<
        T: std::convert::Into<
            std::option::Option<
                crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.combined_exception_principal = v.into();
        self
    }

    /// Sets the value of [relevance][crate::model::DenyRuleExplanation::relevance].
    pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
        mut self,
        v: T,
    ) -> Self {
        self.relevance = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::DenyRuleExplanation::condition].
    pub fn set_condition<T: std::convert::Into<std::option::Option<gtype::model::Expr>>>(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [condition_explanation][crate::model::DenyRuleExplanation::condition_explanation].
    pub fn set_condition_explanation<
        T: std::convert::Into<std::option::Option<crate::model::ConditionExplanation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.condition_explanation = v.into();
        self
    }

    /// Sets the value of [denied_permissions][crate::model::DenyRuleExplanation::denied_permissions].
    pub fn set_denied_permissions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,
    {
        use std::iter::Iterator;
        self.denied_permissions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [exception_permissions][crate::model::DenyRuleExplanation::exception_permissions].
    pub fn set_exception_permissions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::deny_rule_explanation::AnnotatedPermissionMatching>,
    {
        use std::iter::Iterator;
        self.exception_permissions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [denied_principals][crate::model::DenyRuleExplanation::denied_principals].
    pub fn set_denied_principals<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>,
    {
        use std::iter::Iterator;
        self.denied_principals = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [exception_principals][crate::model::DenyRuleExplanation::exception_principals].
    pub fn set_exception_principals<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>,
    {
        use std::iter::Iterator;
        self.exception_principals = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DenyRuleExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.DenyRuleExplanation"
    }
}

/// Defines additional types related to DenyRuleExplanation
pub mod deny_rule_explanation {
    #[allow(unused_imports)]
    use super::*;

    /// Details about whether the permission in the request is denied by the
    /// deny rule.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnnotatedPermissionMatching {
        /// Indicates whether the permission in the request is denied by the deny
        /// rule.
        pub permission_matching_state: crate::model::PermissionPatternMatchingState,

        /// The relevance of the permission status to the overall determination for
        /// the rule.
        pub relevance: crate::model::HeuristicRelevance,
    }

    impl AnnotatedPermissionMatching {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [permission_matching_state][crate::model::deny_rule_explanation::AnnotatedPermissionMatching::permission_matching_state].
        pub fn set_permission_matching_state<
            T: std::convert::Into<crate::model::PermissionPatternMatchingState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.permission_matching_state = v.into();
            self
        }

        /// Sets the value of [relevance][crate::model::deny_rule_explanation::AnnotatedPermissionMatching::relevance].
        pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
            mut self,
            v: T,
        ) -> Self {
            self.relevance = v.into();
            self
        }
    }

    impl wkt::message::Message for AnnotatedPermissionMatching {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.DenyRuleExplanation.AnnotatedPermissionMatching"
        }
    }

    /// Details about whether the principal in the request is listed as a denied
    /// principal in the deny rule, either directly or through membership in a
    /// principal set.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnnotatedDenyPrincipalMatching {
        /// Indicates whether the principal is listed as a denied principal in the
        /// deny rule, either directly or through membership in a principal set.
        pub membership: crate::model::MembershipMatchingState,

        /// The relevance of the principal's status to the overall determination for
        /// the role binding.
        pub relevance: crate::model::HeuristicRelevance,
    }

    impl AnnotatedDenyPrincipalMatching {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [membership][crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching::membership].
        pub fn set_membership<T: std::convert::Into<crate::model::MembershipMatchingState>>(
            mut self,
            v: T,
        ) -> Self {
            self.membership = v.into();
            self
        }

        /// Sets the value of [relevance][crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching::relevance].
        pub fn set_relevance<T: std::convert::Into<crate::model::HeuristicRelevance>>(
            mut self,
            v: T,
        ) -> Self {
            self.relevance = v.into();
            self
        }
    }

    impl wkt::message::Message for AnnotatedDenyPrincipalMatching {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.DenyRuleExplanation.AnnotatedDenyPrincipalMatching"
        }
    }
}

/// Explanation for how a condition affects a principal's access
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConditionExplanation {
    /// Value of the condition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<wkt::Value>,

    /// Any errors that prevented complete evaluation of the condition expression.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<rpc::model::Status>,

    /// The value of each statement of the condition expression. The value can be
    /// `true`, `false`, or `null`. The value is `null` if the statement can't be
    /// evaluated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub evaluation_states: std::vec::Vec<crate::model::condition_explanation::EvaluationState>,
}

impl ConditionExplanation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::ConditionExplanation::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<wkt::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ConditionExplanation::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [evaluation_states][crate::model::ConditionExplanation::evaluation_states].
    pub fn set_evaluation_states<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition_explanation::EvaluationState>,
    {
        use std::iter::Iterator;
        self.evaluation_states = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConditionExplanation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionExplanation"
    }
}

/// Defines additional types related to ConditionExplanation
pub mod condition_explanation {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluated state of a condition expression.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EvaluationState {
        /// Start position of an expression in the condition, by character.
        pub start: i32,

        /// End position of an expression in the condition, by character,
        /// end included, for example: the end position of the first part of
        /// `a==b || c==d` would be 4.
        pub end: i32,

        /// Value of this expression.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value: std::option::Option<wkt::Value>,

        /// Any errors that prevented complete evaluation of the condition
        /// expression.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub errors: std::vec::Vec<rpc::model::Status>,
    }

    impl EvaluationState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start][crate::model::condition_explanation::EvaluationState::start].
        pub fn set_start<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.start = v.into();
            self
        }

        /// Sets the value of [end][crate::model::condition_explanation::EvaluationState::end].
        pub fn set_end<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.end = v.into();
            self
        }

        /// Sets the value of [value][crate::model::condition_explanation::EvaluationState::value].
        pub fn set_value<T: std::convert::Into<std::option::Option<wkt::Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [errors][crate::model::condition_explanation::EvaluationState::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<rpc::model::Status>,
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EvaluationState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.policytroubleshooter.iam.v3.ConditionExplanation.EvaluationState"
        }
    }
}

/// Whether IAM allow policies gives the principal the permission.
#[derive(Clone, Debug, PartialEq)]
pub struct AllowAccessState(wkt::enumerations::Enumeration);

/// Useful constants to work with [AllowAccessState](AllowAccessState)
pub mod allow_access_state {
    use super::AllowAccessState;

    /// Not specified.
    pub const ALLOW_ACCESS_STATE_UNSPECIFIED: AllowAccessState =
        AllowAccessState::known("ALLOW_ACCESS_STATE_UNSPECIFIED", 0);

    /// The allow policy gives the principal the permission.
    pub const ALLOW_ACCESS_STATE_GRANTED: AllowAccessState =
        AllowAccessState::known("ALLOW_ACCESS_STATE_GRANTED", 1);

    /// The allow policy doesn't give the principal the permission.
    pub const ALLOW_ACCESS_STATE_NOT_GRANTED: AllowAccessState =
        AllowAccessState::known("ALLOW_ACCESS_STATE_NOT_GRANTED", 2);

    /// The allow policy gives the principal the permission if a condition
    /// expression evaluate to `true`. However, the sender of the request didn't
    /// provide enough context for Policy Troubleshooter to evaluate the condition
    /// expression.
    pub const ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL: AllowAccessState =
        AllowAccessState::known("ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL", 3);

    /// The sender of the request doesn't have access to all of the allow policies
    /// that Policy Troubleshooter needs to evaluate the principal's access.
    pub const ALLOW_ACCESS_STATE_UNKNOWN_INFO: AllowAccessState =
        AllowAccessState::known("ALLOW_ACCESS_STATE_UNKNOWN_INFO", 4);
}

impl AllowAccessState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for AllowAccessState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for AllowAccessState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(AllowAccessState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(AllowAccessState::from(val)),
            Enumeration::UnknownNum { str } => Ok(AllowAccessState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for AllowAccessState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "ALLOW_ACCESS_STATE_UNSPECIFIED" => allow_access_state::ALLOW_ACCESS_STATE_UNSPECIFIED,
            "ALLOW_ACCESS_STATE_GRANTED" => allow_access_state::ALLOW_ACCESS_STATE_GRANTED,
            "ALLOW_ACCESS_STATE_NOT_GRANTED" => allow_access_state::ALLOW_ACCESS_STATE_NOT_GRANTED,
            "ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL" => {
                allow_access_state::ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL
            }
            "ALLOW_ACCESS_STATE_UNKNOWN_INFO" => {
                allow_access_state::ALLOW_ACCESS_STATE_UNKNOWN_INFO
            }
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for AllowAccessState {
    fn from(value: i32) -> Self {
        match value {
            0 => allow_access_state::ALLOW_ACCESS_STATE_UNSPECIFIED,
            1 => allow_access_state::ALLOW_ACCESS_STATE_GRANTED,
            2 => allow_access_state::ALLOW_ACCESS_STATE_NOT_GRANTED,
            3 => allow_access_state::ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL,
            4 => allow_access_state::ALLOW_ACCESS_STATE_UNKNOWN_INFO,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for AllowAccessState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Whether IAM deny policies deny the principal the permission.
#[derive(Clone, Debug, PartialEq)]
pub struct DenyAccessState(wkt::enumerations::Enumeration);

/// Useful constants to work with [DenyAccessState](DenyAccessState)
pub mod deny_access_state {
    use super::DenyAccessState;

    /// Not specified.
    pub const DENY_ACCESS_STATE_UNSPECIFIED: DenyAccessState =
        DenyAccessState::known("DENY_ACCESS_STATE_UNSPECIFIED", 0);

    /// The deny policy denies the principal the permission.
    pub const DENY_ACCESS_STATE_DENIED: DenyAccessState =
        DenyAccessState::known("DENY_ACCESS_STATE_DENIED", 1);

    /// The deny policy doesn't deny the principal the permission.
    pub const DENY_ACCESS_STATE_NOT_DENIED: DenyAccessState =
        DenyAccessState::known("DENY_ACCESS_STATE_NOT_DENIED", 2);

    /// The deny policy denies the principal the permission if a condition
    /// expression evaluates to `true`. However, the sender of the request didn't
    /// provide enough context for Policy Troubleshooter to evaluate the condition
    /// expression.
    pub const DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL: DenyAccessState =
        DenyAccessState::known("DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL", 3);

    /// The sender of the request does not have access to all of the deny policies
    /// that Policy Troubleshooter needs to evaluate the principal's access.
    pub const DENY_ACCESS_STATE_UNKNOWN_INFO: DenyAccessState =
        DenyAccessState::known("DENY_ACCESS_STATE_UNKNOWN_INFO", 4);
}

impl DenyAccessState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for DenyAccessState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for DenyAccessState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(DenyAccessState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(DenyAccessState::from(val)),
            Enumeration::UnknownNum { str } => Ok(DenyAccessState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for DenyAccessState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "DENY_ACCESS_STATE_UNSPECIFIED" => deny_access_state::DENY_ACCESS_STATE_UNSPECIFIED,
            "DENY_ACCESS_STATE_DENIED" => deny_access_state::DENY_ACCESS_STATE_DENIED,
            "DENY_ACCESS_STATE_NOT_DENIED" => deny_access_state::DENY_ACCESS_STATE_NOT_DENIED,
            "DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL" => {
                deny_access_state::DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL
            }
            "DENY_ACCESS_STATE_UNKNOWN_INFO" => deny_access_state::DENY_ACCESS_STATE_UNKNOWN_INFO,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for DenyAccessState {
    fn from(value: i32) -> Self {
        match value {
            0 => deny_access_state::DENY_ACCESS_STATE_UNSPECIFIED,
            1 => deny_access_state::DENY_ACCESS_STATE_DENIED,
            2 => deny_access_state::DENY_ACCESS_STATE_NOT_DENIED,
            3 => deny_access_state::DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL,
            4 => deny_access_state::DENY_ACCESS_STATE_UNKNOWN_INFO,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for DenyAccessState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Whether a role includes a specific permission.
#[derive(Clone, Debug, PartialEq)]
pub struct RolePermissionInclusionState(wkt::enumerations::Enumeration);

/// Useful constants to work with [RolePermissionInclusionState](RolePermissionInclusionState)
pub mod role_permission_inclusion_state {
    use super::RolePermissionInclusionState;

    /// Not specified.
    pub const ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED: RolePermissionInclusionState =
        RolePermissionInclusionState::known("ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED", 0);

    /// The permission is included in the role.
    pub const ROLE_PERMISSION_INCLUDED: RolePermissionInclusionState =
        RolePermissionInclusionState::known("ROLE_PERMISSION_INCLUDED", 1);

    /// The permission is not included in the role.
    pub const ROLE_PERMISSION_NOT_INCLUDED: RolePermissionInclusionState =
        RolePermissionInclusionState::known("ROLE_PERMISSION_NOT_INCLUDED", 2);

    /// The sender of the request is not allowed to access the role definition.
    pub const ROLE_PERMISSION_UNKNOWN_INFO: RolePermissionInclusionState =
        RolePermissionInclusionState::known("ROLE_PERMISSION_UNKNOWN_INFO", 3);
}

impl RolePermissionInclusionState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for RolePermissionInclusionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for RolePermissionInclusionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(RolePermissionInclusionState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(RolePermissionInclusionState::from(val)),
            Enumeration::UnknownNum { str } => Ok(RolePermissionInclusionState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for RolePermissionInclusionState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED" => {
                role_permission_inclusion_state::ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED
            }
            "ROLE_PERMISSION_INCLUDED" => role_permission_inclusion_state::ROLE_PERMISSION_INCLUDED,
            "ROLE_PERMISSION_NOT_INCLUDED" => {
                role_permission_inclusion_state::ROLE_PERMISSION_NOT_INCLUDED
            }
            "ROLE_PERMISSION_UNKNOWN_INFO" => {
                role_permission_inclusion_state::ROLE_PERMISSION_UNKNOWN_INFO
            }
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for RolePermissionInclusionState {
    fn from(value: i32) -> Self {
        match value {
            0 => role_permission_inclusion_state::ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED,
            1 => role_permission_inclusion_state::ROLE_PERMISSION_INCLUDED,
            2 => role_permission_inclusion_state::ROLE_PERMISSION_NOT_INCLUDED,
            3 => role_permission_inclusion_state::ROLE_PERMISSION_UNKNOWN_INFO,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for RolePermissionInclusionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Whether the permission in the request matches the permission in the policy.
#[derive(Clone, Debug, PartialEq)]
pub struct PermissionPatternMatchingState(wkt::enumerations::Enumeration);

/// Useful constants to work with [PermissionPatternMatchingState](PermissionPatternMatchingState)
pub mod permission_pattern_matching_state {
    use super::PermissionPatternMatchingState;

    /// Not specified.
    pub const PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED: PermissionPatternMatchingState =
        PermissionPatternMatchingState::known("PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED", 0);

    /// The permission in the request matches the permission in the policy.
    pub const PERMISSION_PATTERN_MATCHED: PermissionPatternMatchingState =
        PermissionPatternMatchingState::known("PERMISSION_PATTERN_MATCHED", 1);

    /// The permission in the request matches the permission in the policy.
    pub const PERMISSION_PATTERN_NOT_MATCHED: PermissionPatternMatchingState =
        PermissionPatternMatchingState::known("PERMISSION_PATTERN_NOT_MATCHED", 2);
}

impl PermissionPatternMatchingState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for PermissionPatternMatchingState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for PermissionPatternMatchingState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(PermissionPatternMatchingState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => {
                Ok(PermissionPatternMatchingState::from(val))
            }
            Enumeration::UnknownNum { str } => Ok(PermissionPatternMatchingState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for PermissionPatternMatchingState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED" => {
                permission_pattern_matching_state::PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED
            }
            "PERMISSION_PATTERN_MATCHED" => {
                permission_pattern_matching_state::PERMISSION_PATTERN_MATCHED
            }
            "PERMISSION_PATTERN_NOT_MATCHED" => {
                permission_pattern_matching_state::PERMISSION_PATTERN_NOT_MATCHED
            }
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for PermissionPatternMatchingState {
    fn from(value: i32) -> Self {
        match value {
            0 => permission_pattern_matching_state::PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED,
            1 => permission_pattern_matching_state::PERMISSION_PATTERN_MATCHED,
            2 => permission_pattern_matching_state::PERMISSION_PATTERN_NOT_MATCHED,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for PermissionPatternMatchingState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Whether the principal in the request matches the principal in the policy.
#[derive(Clone, Debug, PartialEq)]
pub struct MembershipMatchingState(wkt::enumerations::Enumeration);

/// Useful constants to work with [MembershipMatchingState](MembershipMatchingState)
pub mod membership_matching_state {
    use super::MembershipMatchingState;

    /// Not specified.
    pub const MEMBERSHIP_MATCHING_STATE_UNSPECIFIED: MembershipMatchingState =
        MembershipMatchingState::known("MEMBERSHIP_MATCHING_STATE_UNSPECIFIED", 0);

    /// The principal in the request matches the principal in the policy. The
    /// principal can be included directly or indirectly:
    ///
    /// * A principal is included directly if that principal is listed in the
    ///   role binding.
    /// * A principal is included indirectly if that principal is in a Google
    ///   group, Google Workspace account, or Cloud Identity domain that is listed
    ///   in the policy.
    pub const MEMBERSHIP_MATCHED: MembershipMatchingState =
        MembershipMatchingState::known("MEMBERSHIP_MATCHED", 1);

    /// The principal in the request doesn't match the principal in the policy.
    pub const MEMBERSHIP_NOT_MATCHED: MembershipMatchingState =
        MembershipMatchingState::known("MEMBERSHIP_NOT_MATCHED", 2);

    /// The principal in the policy is a group or domain, and the sender of the
    /// request doesn't have permission to view whether the principal in the
    /// request is a member of the group or domain.
    pub const MEMBERSHIP_UNKNOWN_INFO: MembershipMatchingState =
        MembershipMatchingState::known("MEMBERSHIP_UNKNOWN_INFO", 3);

    /// The principal is an unsupported type.
    pub const MEMBERSHIP_UNKNOWN_UNSUPPORTED: MembershipMatchingState =
        MembershipMatchingState::known("MEMBERSHIP_UNKNOWN_UNSUPPORTED", 4);
}

impl MembershipMatchingState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for MembershipMatchingState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for MembershipMatchingState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(MembershipMatchingState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(MembershipMatchingState::from(val)),
            Enumeration::UnknownNum { str } => Ok(MembershipMatchingState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for MembershipMatchingState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "MEMBERSHIP_MATCHING_STATE_UNSPECIFIED" => {
                membership_matching_state::MEMBERSHIP_MATCHING_STATE_UNSPECIFIED
            }
            "MEMBERSHIP_MATCHED" => membership_matching_state::MEMBERSHIP_MATCHED,
            "MEMBERSHIP_NOT_MATCHED" => membership_matching_state::MEMBERSHIP_NOT_MATCHED,
            "MEMBERSHIP_UNKNOWN_INFO" => membership_matching_state::MEMBERSHIP_UNKNOWN_INFO,
            "MEMBERSHIP_UNKNOWN_UNSUPPORTED" => {
                membership_matching_state::MEMBERSHIP_UNKNOWN_UNSUPPORTED
            }
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for MembershipMatchingState {
    fn from(value: i32) -> Self {
        match value {
            0 => membership_matching_state::MEMBERSHIP_MATCHING_STATE_UNSPECIFIED,
            1 => membership_matching_state::MEMBERSHIP_MATCHED,
            2 => membership_matching_state::MEMBERSHIP_NOT_MATCHED,
            3 => membership_matching_state::MEMBERSHIP_UNKNOWN_INFO,
            4 => membership_matching_state::MEMBERSHIP_UNKNOWN_UNSUPPORTED,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for MembershipMatchingState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The extent to which a single data point contributes to an overall
/// determination.
#[derive(Clone, Debug, PartialEq)]
pub struct HeuristicRelevance(wkt::enumerations::Enumeration);

/// Useful constants to work with [HeuristicRelevance](HeuristicRelevance)
pub mod heuristic_relevance {
    use super::HeuristicRelevance;

    /// Not specified.
    pub const HEURISTIC_RELEVANCE_UNSPECIFIED: HeuristicRelevance =
        HeuristicRelevance::known("HEURISTIC_RELEVANCE_UNSPECIFIED", 0);

    /// The data point has a limited effect on the result. Changing the data point
    /// is unlikely to affect the overall determination.
    pub const HEURISTIC_RELEVANCE_NORMAL: HeuristicRelevance =
        HeuristicRelevance::known("HEURISTIC_RELEVANCE_NORMAL", 1);

    /// The data point has a strong effect on the result. Changing the data point
    /// is likely to affect the overall determination.
    pub const HEURISTIC_RELEVANCE_HIGH: HeuristicRelevance =
        HeuristicRelevance::known("HEURISTIC_RELEVANCE_HIGH", 2);
}

impl HeuristicRelevance {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for HeuristicRelevance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for HeuristicRelevance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(HeuristicRelevance::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(HeuristicRelevance::from(val)),
            Enumeration::UnknownNum { str } => Ok(HeuristicRelevance::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for HeuristicRelevance {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "HEURISTIC_RELEVANCE_UNSPECIFIED" => {
                heuristic_relevance::HEURISTIC_RELEVANCE_UNSPECIFIED
            }
            "HEURISTIC_RELEVANCE_NORMAL" => heuristic_relevance::HEURISTIC_RELEVANCE_NORMAL,
            "HEURISTIC_RELEVANCE_HIGH" => heuristic_relevance::HEURISTIC_RELEVANCE_HIGH,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for HeuristicRelevance {
    fn from(value: i32) -> Self {
        match value {
            0 => heuristic_relevance::HEURISTIC_RELEVANCE_UNSPECIFIED,
            1 => heuristic_relevance::HEURISTIC_RELEVANCE_NORMAL,
            2 => heuristic_relevance::HEURISTIC_RELEVANCE_HIGH,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for HeuristicRelevance {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
