// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TroubleshootIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_tuple,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TroubleshootIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessTuple" => Ok(__FieldTag::__access_tuple),
                            "access_tuple" => Ok(__FieldTag::__access_tuple),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TroubleshootIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TroubleshootIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_tuple => {
                            if !fields.insert(__FieldTag::__access_tuple) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_tuple",
                                ));
                            }
                            result.access_tuple =
                                map.next_value::<std::option::Option<crate::model::AccessTuple>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TroubleshootIamPolicyResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __overall_access_state,
            __access_tuple,
            __allow_policy_explanation,
            __deny_policy_explanation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TroubleshootIamPolicyResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "overallAccessState" => Ok(__FieldTag::__overall_access_state),
                            "overall_access_state" => Ok(__FieldTag::__overall_access_state),
                            "accessTuple" => Ok(__FieldTag::__access_tuple),
                            "access_tuple" => Ok(__FieldTag::__access_tuple),
                            "allowPolicyExplanation" => Ok(__FieldTag::__allow_policy_explanation),
                            "allow_policy_explanation" => {
                                Ok(__FieldTag::__allow_policy_explanation)
                            }
                            "denyPolicyExplanation" => Ok(__FieldTag::__deny_policy_explanation),
                            "deny_policy_explanation" => Ok(__FieldTag::__deny_policy_explanation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TroubleshootIamPolicyResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TroubleshootIamPolicyResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__overall_access_state => {
                            if !fields.insert(__FieldTag::__overall_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overall_access_state",
                                ));
                            }
                            result.overall_access_state = map.next_value::<std::option::Option<crate::model::troubleshoot_iam_policy_response::OverallAccessState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__access_tuple => {
                            if !fields.insert(__FieldTag::__access_tuple) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_tuple",
                                ));
                            }
                            result.access_tuple =
                                map.next_value::<std::option::Option<crate::model::AccessTuple>>()?;
                        }
                        __FieldTag::__allow_policy_explanation => {
                            if !fields.insert(__FieldTag::__allow_policy_explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_policy_explanation",
                                ));
                            }
                            result.allow_policy_explanation = map.next_value::<std::option::Option<crate::model::AllowPolicyExplanation>>()?
                                ;
                        }
                        __FieldTag::__deny_policy_explanation => {
                            if !fields.insert(__FieldTag::__deny_policy_explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_policy_explanation",
                                ));
                            }
                            result.deny_policy_explanation = map.next_value::<std::option::Option<crate::model::DenyPolicyExplanation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AccessTuple {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal,
            __full_resource_name,
            __permission,
            __permission_fqdn,
            __condition_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessTuple")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principal" => Ok(__FieldTag::__principal),
                            "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                            "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                            "permission" => Ok(__FieldTag::__permission),
                            "permissionFqdn" => Ok(__FieldTag::__permission_fqdn),
                            "permission_fqdn" => Ok(__FieldTag::__permission_fqdn),
                            "conditionContext" => Ok(__FieldTag::__condition_context),
                            "condition_context" => Ok(__FieldTag::__condition_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AccessTuple;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessTuple")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal => {
                            if !fields.insert(__FieldTag::__principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal",
                                ));
                            }
                            result.principal = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource_name => {
                            if !fields.insert(__FieldTag::__full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource_name",
                                ));
                            }
                            result.full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permission => {
                            if !fields.insert(__FieldTag::__permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission",
                                ));
                            }
                            result.permission = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permission_fqdn => {
                            if !fields.insert(__FieldTag::__permission_fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission_fqdn",
                                ));
                            }
                            result.permission_fqdn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition_context => {
                            if !fields.insert(__FieldTag::__condition_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition_context",
                                ));
                            }
                            result.condition_context = map
                                .next_value::<std::option::Option<crate::model::ConditionContext>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConditionContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __destination,
            __request,
            __effective_tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConditionContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "destination" => Ok(__FieldTag::__destination),
                            "request" => Ok(__FieldTag::__request),
                            "effectiveTags" => Ok(__FieldTag::__effective_tags),
                            "effective_tags" => Ok(__FieldTag::__effective_tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConditionContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConditionContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map.next_value::<std::option::Option<crate::model::condition_context::Resource>>()?
                                ;
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::condition_context::Peer>>()?
                                ;
                        }
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<crate::model::condition_context::Request>>()?
                                ;
                        }
                        __FieldTag::__effective_tags => {
                            if !fields.insert(__FieldTag::__effective_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_tags",
                                ));
                            }
                            result.effective_tags = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::condition_context::EffectiveTag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::condition_context::Resource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __name,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Resource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::condition_context::Resource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Resource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::condition_context::Peer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip,
            __port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Peer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ip" => Ok(__FieldTag::__ip),
                            "port" => Ok(__FieldTag::__port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::condition_context::Peer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Peer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip => {
                            if !fields.insert(__FieldTag::__ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip",
                                ));
                            }
                            result.ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::condition_context::Request {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __receive_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Request")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "receiveTime" => Ok(__FieldTag::__receive_time),
                            "receive_time" => Ok(__FieldTag::__receive_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::condition_context::Request;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Request")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__receive_time => {
                            if !fields.insert(__FieldTag::__receive_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for receive_time",
                                ));
                            }
                            result.receive_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::condition_context::EffectiveTag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tag_value,
            __namespaced_tag_value,
            __tag_key,
            __namespaced_tag_key,
            __tag_key_parent_name,
            __inherited,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EffectiveTag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tagValue" => Ok(__FieldTag::__tag_value),
                            "tag_value" => Ok(__FieldTag::__tag_value),
                            "namespacedTagValue" => Ok(__FieldTag::__namespaced_tag_value),
                            "namespaced_tag_value" => Ok(__FieldTag::__namespaced_tag_value),
                            "tagKey" => Ok(__FieldTag::__tag_key),
                            "tag_key" => Ok(__FieldTag::__tag_key),
                            "namespacedTagKey" => Ok(__FieldTag::__namespaced_tag_key),
                            "namespaced_tag_key" => Ok(__FieldTag::__namespaced_tag_key),
                            "tagKeyParentName" => Ok(__FieldTag::__tag_key_parent_name),
                            "tag_key_parent_name" => Ok(__FieldTag::__tag_key_parent_name),
                            "inherited" => Ok(__FieldTag::__inherited),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::condition_context::EffectiveTag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EffectiveTag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tag_value => {
                            if !fields.insert(__FieldTag::__tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_value",
                                ));
                            }
                            result.tag_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespaced_tag_value => {
                            if !fields.insert(__FieldTag::__namespaced_tag_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaced_tag_value",
                                ));
                            }
                            result.namespaced_tag_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_key => {
                            if !fields.insert(__FieldTag::__tag_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key",
                                ));
                            }
                            result.tag_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespaced_tag_key => {
                            if !fields.insert(__FieldTag::__namespaced_tag_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaced_tag_key",
                                ));
                            }
                            result.namespaced_tag_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_key_parent_name => {
                            if !fields.insert(__FieldTag::__tag_key_parent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_key_parent_name",
                                ));
                            }
                            result.tag_key_parent_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inherited => {
                            if !fields.insert(__FieldTag::__inherited) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inherited",
                                ));
                            }
                            result.inherited = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AllowPolicyExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_access_state,
            __explained_policies,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowPolicyExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAccessState" => Ok(__FieldTag::__allow_access_state),
                            "allow_access_state" => Ok(__FieldTag::__allow_access_state),
                            "explainedPolicies" => Ok(__FieldTag::__explained_policies),
                            "explained_policies" => Ok(__FieldTag::__explained_policies),
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AllowPolicyExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowPolicyExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_access_state => {
                            if !fields.insert(__FieldTag::__allow_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_access_state",
                                ));
                            }
                            result.allow_access_state = map
                                .next_value::<std::option::Option<crate::model::AllowAccessState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__explained_policies => {
                            if !fields.insert(__FieldTag::__explained_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explained_policies",
                                ));
                            }
                            result.explained_policies = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExplainedAllowPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainedAllowPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_access_state,
            __full_resource_name,
            __binding_explanations,
            __relevance,
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainedAllowPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAccessState" => Ok(__FieldTag::__allow_access_state),
                            "allow_access_state" => Ok(__FieldTag::__allow_access_state),
                            "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                            "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                            "bindingExplanations" => Ok(__FieldTag::__binding_explanations),
                            "binding_explanations" => Ok(__FieldTag::__binding_explanations),
                            "relevance" => Ok(__FieldTag::__relevance),
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainedAllowPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainedAllowPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_access_state => {
                            if !fields.insert(__FieldTag::__allow_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_access_state",
                                ));
                            }
                            result.allow_access_state = map
                                .next_value::<std::option::Option<crate::model::AllowAccessState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource_name => {
                            if !fields.insert(__FieldTag::__full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource_name",
                                ));
                            }
                            result.full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binding_explanations => {
                            if !fields.insert(__FieldTag::__binding_explanations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binding_explanations",
                                ));
                            }
                            result.binding_explanations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AllowBindingExplanation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<iam_v1::model::Policy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AllowBindingExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_access_state,
            __role,
            __role_permission,
            __role_permission_relevance,
            __combined_membership,
            __memberships,
            __relevance,
            __condition,
            __condition_explanation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowBindingExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowAccessState" => Ok(__FieldTag::__allow_access_state),
                            "allow_access_state" => Ok(__FieldTag::__allow_access_state),
                            "role" => Ok(__FieldTag::__role),
                            "rolePermission" => Ok(__FieldTag::__role_permission),
                            "role_permission" => Ok(__FieldTag::__role_permission),
                            "rolePermissionRelevance" => {
                                Ok(__FieldTag::__role_permission_relevance)
                            }
                            "role_permission_relevance" => {
                                Ok(__FieldTag::__role_permission_relevance)
                            }
                            "combinedMembership" => Ok(__FieldTag::__combined_membership),
                            "combined_membership" => Ok(__FieldTag::__combined_membership),
                            "memberships" => Ok(__FieldTag::__memberships),
                            "relevance" => Ok(__FieldTag::__relevance),
                            "condition" => Ok(__FieldTag::__condition),
                            "conditionExplanation" => Ok(__FieldTag::__condition_explanation),
                            "condition_explanation" => Ok(__FieldTag::__condition_explanation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AllowBindingExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowBindingExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_access_state => {
                            if !fields.insert(__FieldTag::__allow_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_access_state",
                                ));
                            }
                            result.allow_access_state = map
                                .next_value::<std::option::Option<crate::model::AllowAccessState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role_permission => {
                            if !fields.insert(__FieldTag::__role_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_permission",
                                ));
                            }
                            result.role_permission = map.next_value::<std::option::Option<crate::model::RolePermissionInclusionState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__role_permission_relevance => {
                            if !fields.insert(__FieldTag::__role_permission_relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role_permission_relevance",
                                ));
                            }
                            result.role_permission_relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__combined_membership => {
                            if !fields.insert(__FieldTag::__combined_membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combined_membership",
                                ));
                            }
                            result.combined_membership = map.next_value::<std::option::Option<
                                crate::model::allow_binding_explanation::AnnotatedAllowMembership,
                            >>()?;
                        }
                        __FieldTag::__memberships => {
                            if !fields.insert(__FieldTag::__memberships) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memberships",
                                ));
                            }
                            result.memberships = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::allow_binding_explanation::AnnotatedAllowMembership>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::__condition_explanation => {
                            if !fields.insert(__FieldTag::__condition_explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition_explanation",
                                ));
                            }
                            result.condition_explanation = map.next_value::<std::option::Option<crate::model::ConditionExplanation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::allow_binding_explanation::AnnotatedAllowMembership
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __membership,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatedAllowMembership")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "membership" => Ok(__FieldTag::__membership),
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::allow_binding_explanation::AnnotatedAllowMembership;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatedAllowMembership")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map.next_value::<std::option::Option<crate::model::MembershipMatchingState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DenyPolicyExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deny_access_state,
            __explained_resources,
            __relevance,
            __permission_deniable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DenyPolicyExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "denyAccessState" => Ok(__FieldTag::__deny_access_state),
                            "deny_access_state" => Ok(__FieldTag::__deny_access_state),
                            "explainedResources" => Ok(__FieldTag::__explained_resources),
                            "explained_resources" => Ok(__FieldTag::__explained_resources),
                            "relevance" => Ok(__FieldTag::__relevance),
                            "permissionDeniable" => Ok(__FieldTag::__permission_deniable),
                            "permission_deniable" => Ok(__FieldTag::__permission_deniable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DenyPolicyExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DenyPolicyExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deny_access_state => {
                            if !fields.insert(__FieldTag::__deny_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_access_state",
                                ));
                            }
                            result.deny_access_state = map
                                .next_value::<std::option::Option<crate::model::DenyAccessState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__explained_resources => {
                            if !fields.insert(__FieldTag::__explained_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explained_resources",
                                ));
                            }
                            result.explained_resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExplainedDenyResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permission_deniable => {
                            if !fields.insert(__FieldTag::__permission_deniable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission_deniable",
                                ));
                            }
                            result.permission_deniable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainedDenyResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deny_access_state,
            __full_resource_name,
            __explained_policies,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainedDenyResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "denyAccessState" => Ok(__FieldTag::__deny_access_state),
                            "deny_access_state" => Ok(__FieldTag::__deny_access_state),
                            "fullResourceName" => Ok(__FieldTag::__full_resource_name),
                            "full_resource_name" => Ok(__FieldTag::__full_resource_name),
                            "explainedPolicies" => Ok(__FieldTag::__explained_policies),
                            "explained_policies" => Ok(__FieldTag::__explained_policies),
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainedDenyResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainedDenyResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deny_access_state => {
                            if !fields.insert(__FieldTag::__deny_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_access_state",
                                ));
                            }
                            result.deny_access_state = map
                                .next_value::<std::option::Option<crate::model::DenyAccessState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_resource_name => {
                            if !fields.insert(__FieldTag::__full_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_resource_name",
                                ));
                            }
                            result.full_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__explained_policies => {
                            if !fields.insert(__FieldTag::__explained_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explained_policies",
                                ));
                            }
                            result.explained_policies = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExplainedDenyPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ExplainedDenyPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deny_access_state,
            __policy,
            __rule_explanations,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplainedDenyPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "denyAccessState" => Ok(__FieldTag::__deny_access_state),
                            "deny_access_state" => Ok(__FieldTag::__deny_access_state),
                            "policy" => Ok(__FieldTag::__policy),
                            "ruleExplanations" => Ok(__FieldTag::__rule_explanations),
                            "rule_explanations" => Ok(__FieldTag::__rule_explanations),
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ExplainedDenyPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplainedDenyPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deny_access_state => {
                            if !fields.insert(__FieldTag::__deny_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_access_state",
                                ));
                            }
                            result.deny_access_state = map
                                .next_value::<std::option::Option<crate::model::DenyAccessState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<iam_v2::model::Policy>>()?;
                        }
                        __FieldTag::__rule_explanations => {
                            if !fields.insert(__FieldTag::__rule_explanations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_explanations",
                                ));
                            }
                            result.rule_explanations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DenyRuleExplanation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DenyRuleExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deny_access_state,
            __combined_denied_permission,
            __denied_permissions,
            __combined_exception_permission,
            __exception_permissions,
            __combined_denied_principal,
            __denied_principals,
            __combined_exception_principal,
            __exception_principals,
            __relevance,
            __condition,
            __condition_explanation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DenyRuleExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "denyAccessState" => Ok(__FieldTag::__deny_access_state),
                            "deny_access_state" => Ok(__FieldTag::__deny_access_state),
                            "combinedDeniedPermission" => {
                                Ok(__FieldTag::__combined_denied_permission)
                            }
                            "combined_denied_permission" => {
                                Ok(__FieldTag::__combined_denied_permission)
                            }
                            "deniedPermissions" => Ok(__FieldTag::__denied_permissions),
                            "denied_permissions" => Ok(__FieldTag::__denied_permissions),
                            "combinedExceptionPermission" => {
                                Ok(__FieldTag::__combined_exception_permission)
                            }
                            "combined_exception_permission" => {
                                Ok(__FieldTag::__combined_exception_permission)
                            }
                            "exceptionPermissions" => Ok(__FieldTag::__exception_permissions),
                            "exception_permissions" => Ok(__FieldTag::__exception_permissions),
                            "combinedDeniedPrincipal" => {
                                Ok(__FieldTag::__combined_denied_principal)
                            }
                            "combined_denied_principal" => {
                                Ok(__FieldTag::__combined_denied_principal)
                            }
                            "deniedPrincipals" => Ok(__FieldTag::__denied_principals),
                            "denied_principals" => Ok(__FieldTag::__denied_principals),
                            "combinedExceptionPrincipal" => {
                                Ok(__FieldTag::__combined_exception_principal)
                            }
                            "combined_exception_principal" => {
                                Ok(__FieldTag::__combined_exception_principal)
                            }
                            "exceptionPrincipals" => Ok(__FieldTag::__exception_principals),
                            "exception_principals" => Ok(__FieldTag::__exception_principals),
                            "relevance" => Ok(__FieldTag::__relevance),
                            "condition" => Ok(__FieldTag::__condition),
                            "conditionExplanation" => Ok(__FieldTag::__condition_explanation),
                            "condition_explanation" => Ok(__FieldTag::__condition_explanation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DenyRuleExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DenyRuleExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deny_access_state => {
                            if !fields.insert(__FieldTag::__deny_access_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_access_state",
                                ));
                            }
                            result.deny_access_state = map
                                .next_value::<std::option::Option<crate::model::DenyAccessState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__combined_denied_permission => {
                            if !fields.insert(__FieldTag::__combined_denied_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combined_denied_permission",
                                ));
                            }
                            result.combined_denied_permission = map
                                .next_value::<std::option::Option<
                                crate::model::deny_rule_explanation::AnnotatedPermissionMatching,
                            >>(
                            )?;
                        }
                        __FieldTag::__denied_permissions => {
                            if !fields.insert(__FieldTag::__denied_permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denied_permissions",
                                ));
                            }
                            result.denied_permissions = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::deny_rule_explanation::AnnotatedPermissionMatching>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__combined_exception_permission => {
                            if !fields.insert(__FieldTag::__combined_exception_permission) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combined_exception_permission",
                                ));
                            }
                            result.combined_exception_permission = map
                                .next_value::<std::option::Option<
                                crate::model::deny_rule_explanation::AnnotatedPermissionMatching,
                            >>(
                            )?;
                        }
                        __FieldTag::__exception_permissions => {
                            if !fields.insert(__FieldTag::__exception_permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exception_permissions",
                                ));
                            }
                            result.exception_permissions = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::deny_rule_explanation::AnnotatedPermissionMatching>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__combined_denied_principal => {
                            if !fields.insert(__FieldTag::__combined_denied_principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combined_denied_principal",
                                ));
                            }
                            result.combined_denied_principal = map
                                .next_value::<std::option::Option<
                                crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
                            >>(
                            )?;
                        }
                        __FieldTag::__denied_principals => {
                            if !fields.insert(__FieldTag::__denied_principals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denied_principals",
                                ));
                            }
                            result.denied_principals = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__combined_exception_principal => {
                            if !fields.insert(__FieldTag::__combined_exception_principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for combined_exception_principal",
                                ));
                            }
                            result.combined_exception_principal = map
                                .next_value::<std::option::Option<
                                crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching,
                            >>(
                            )?;
                        }
                        __FieldTag::__exception_principals => {
                            if !fields.insert(__FieldTag::__exception_principals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exception_principals",
                                ));
                            }
                            result.exception_principals = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::deny_rule_explanation::AnnotatedDenyPrincipalMatching>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::__condition_explanation => {
                            if !fields.insert(__FieldTag::__condition_explanation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition_explanation",
                                ));
                            }
                            result.condition_explanation = map.next_value::<std::option::Option<crate::model::ConditionExplanation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::deny_rule_explanation::AnnotatedPermissionMatching
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __permission_matching_state,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatedPermissionMatching")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "permissionMatchingState" => {
                                Ok(__FieldTag::__permission_matching_state)
                            }
                            "permission_matching_state" => {
                                Ok(__FieldTag::__permission_matching_state)
                            }
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::deny_rule_explanation::AnnotatedPermissionMatching;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatedPermissionMatching")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__permission_matching_state => {
                            if !fields.insert(__FieldTag::__permission_matching_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permission_matching_state",
                                ));
                            }
                            result.permission_matching_state =
                                map.next_value::<std::option::Option<
                                    crate::model::PermissionPatternMatchingState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::deny_rule_explanation::AnnotatedDenyPrincipalMatching
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __membership,
            __relevance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatedDenyPrincipalMatching")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "membership" => Ok(__FieldTag::__membership),
                            "relevance" => Ok(__FieldTag::__relevance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::deny_rule_explanation::AnnotatedDenyPrincipalMatching;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatedDenyPrincipalMatching")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map.next_value::<std::option::Option<crate::model::MembershipMatchingState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__relevance => {
                            if !fields.insert(__FieldTag::__relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance",
                                ));
                            }
                            result.relevance = map.next_value::<std::option::Option<crate::model::HeuristicRelevance>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConditionExplanation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __errors,
            __evaluation_states,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConditionExplanation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "errors" => Ok(__FieldTag::__errors),
                            "evaluationStates" => Ok(__FieldTag::__evaluation_states),
                            "evaluation_states" => Ok(__FieldTag::__evaluation_states),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConditionExplanation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConditionExplanation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__evaluation_states => {
                            if !fields.insert(__FieldTag::__evaluation_states) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_states",
                                ));
                            }
                            result.evaluation_states = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::condition_explanation::EvaluationState,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::condition_explanation::EvaluationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start,
            __end,
            __value,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "start" => Ok(__FieldTag::__start),
                            "end" => Ok(__FieldTag::__end),
                            "value" => Ok(__FieldTag::__value),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::condition_explanation::EvaluationState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start => {
                            if !fields.insert(__FieldTag::__start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end => {
                            if !fields.insert(__FieldTag::__end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.end = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
