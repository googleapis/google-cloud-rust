// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::SummarizeMaintenancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SummarizeMaintenancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.maintenances.is_empty() {
            state.serialize_entry("maintenances", &self.maintenances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaintenanceSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.maintenance_name.is_empty() {
            state.serialize_entry("maintenanceName", &self.maintenance_name)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if self.maintenance_scheduled_start_time.is_some() {
            state.serialize_entry(
                "maintenanceScheduledStartTime",
                &self.maintenance_scheduled_start_time,
            )?;
        }
        if self.maintenance_scheduled_end_time.is_some() {
            state.serialize_entry(
                "maintenanceScheduledEndTime",
                &self.maintenance_scheduled_end_time,
            )?;
        }
        if self.maintenance_start_time.is_some() {
            state.serialize_entry("maintenanceStartTime", &self.maintenance_start_time)?;
        }
        if self.maintenance_end_time.is_some() {
            state.serialize_entry("maintenanceEndTime", &self.maintenance_end_time)?;
        }
        if !wkt::internal::is_default(&self.user_controllable) {
            state.serialize_entry("userControllable", &self.user_controllable)?;
        }
        if !self.controls.is_empty() {
            state.serialize_entry("controls", &self.controls)?;
        }
        if !self.stats.is_empty() {
            state.serialize_entry("stats", &self.stats)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::maintenance_summary::Stats {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group_by.is_empty() {
            state.serialize_entry("groupBy", &self.group_by)?;
        }
        if !self.aggregates.is_empty() {
            state.serialize_entry("aggregates", &self.aggregates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::maintenance_summary::Aggregate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceMaintenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.maintenance.is_some() {
            state.serialize_entry("maintenance", &self.maintenance)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.maintenance_start_time.is_some() {
            state.serialize_entry("maintenanceStartTime", &self.maintenance_start_time)?;
        }
        if self.maintenance_end_time.is_some() {
            state.serialize_entry("maintenanceEndTime", &self.maintenance_end_time)?;
        }
        if self.maintenance_cancel_time.is_some() {
            state.serialize_entry("maintenanceCancelTime", &self.maintenance_cancel_time)?;
        }
        if self.maintenance_scheduled_start_time.is_some() {
            state.serialize_entry(
                "maintenanceScheduledStartTime",
                &self.maintenance_scheduled_start_time,
            )?;
        }
        if self.maintenance_scheduled_end_time.is_some() {
            state.serialize_entry(
                "maintenanceScheduledEndTime",
                &self.maintenance_scheduled_end_time,
            )?;
        }
        if !wkt::internal::is_default(&self.user_controllable) {
            state.serialize_entry("userControllable", &self.user_controllable)?;
        }
        if !self.controls.is_empty() {
            state.serialize_entry("controls", &self.controls)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::resource_maintenance::Resource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::resource_maintenance::Maintenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.maintenance_name.is_empty() {
            state.serialize_entry("maintenanceName", &self.maintenance_name)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaintenanceControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.control) {
            state.serialize_entry("control", &self.control)?;
        }
        if !wkt::internal::is_default(&self.is_custom) {
            state.serialize_entry("isCustom", &self.is_custom)?;
        }
        if !self.documentation.is_empty() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListResourceMaintenancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListResourceMaintenancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_maintenances.is_empty() {
            state.serialize_entry("resourceMaintenances", &self.resource_maintenances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetResourceMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
