// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __data_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.optimization.v1.InputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<crate::model::DataFormat>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __data_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.optimization.v1.OutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<crate::model::DataFormat>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AsyncModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_message,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AsyncModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::async_model_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OptimizeToursRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __timeout,
            __model,
            __solving_mode,
            __search_mode,
            __injected_first_solution_routes,
            __injected_solution_constraint,
            __refresh_details_routes,
            __interpret_injected_solutions_using_labels,
            __consider_road_traffic,
            __populate_polylines,
            __populate_transition_polylines,
            __allow_large_deadline_despite_interruption_risk,
            __use_geodesic_distances,
            __geodesic_meters_per_second,
            __max_validation_errors,
            __label,
            __populate_travel_step_polylines,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OptimizeToursRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "model" => Ok(__FieldTag::__model),
                            "solvingMode" => Ok(__FieldTag::__solving_mode),
                            "solving_mode" => Ok(__FieldTag::__solving_mode),
                            "searchMode" => Ok(__FieldTag::__search_mode),
                            "search_mode" => Ok(__FieldTag::__search_mode),
                            "injectedFirstSolutionRoutes" => {
                                Ok(__FieldTag::__injected_first_solution_routes)
                            }
                            "injected_first_solution_routes" => {
                                Ok(__FieldTag::__injected_first_solution_routes)
                            }
                            "injectedSolutionConstraint" => {
                                Ok(__FieldTag::__injected_solution_constraint)
                            }
                            "injected_solution_constraint" => {
                                Ok(__FieldTag::__injected_solution_constraint)
                            }
                            "refreshDetailsRoutes" => Ok(__FieldTag::__refresh_details_routes),
                            "refresh_details_routes" => Ok(__FieldTag::__refresh_details_routes),
                            "interpretInjectedSolutionsUsingLabels" => {
                                Ok(__FieldTag::__interpret_injected_solutions_using_labels)
                            }
                            "interpret_injected_solutions_using_labels" => {
                                Ok(__FieldTag::__interpret_injected_solutions_using_labels)
                            }
                            "considerRoadTraffic" => Ok(__FieldTag::__consider_road_traffic),
                            "consider_road_traffic" => Ok(__FieldTag::__consider_road_traffic),
                            "populatePolylines" => Ok(__FieldTag::__populate_polylines),
                            "populate_polylines" => Ok(__FieldTag::__populate_polylines),
                            "populateTransitionPolylines" => {
                                Ok(__FieldTag::__populate_transition_polylines)
                            }
                            "populate_transition_polylines" => {
                                Ok(__FieldTag::__populate_transition_polylines)
                            }
                            "allowLargeDeadlineDespiteInterruptionRisk" => {
                                Ok(__FieldTag::__allow_large_deadline_despite_interruption_risk)
                            }
                            "allow_large_deadline_despite_interruption_risk" => {
                                Ok(__FieldTag::__allow_large_deadline_despite_interruption_risk)
                            }
                            "useGeodesicDistances" => Ok(__FieldTag::__use_geodesic_distances),
                            "use_geodesic_distances" => Ok(__FieldTag::__use_geodesic_distances),
                            "geodesicMetersPerSecond" => {
                                Ok(__FieldTag::__geodesic_meters_per_second)
                            }
                            "geodesic_meters_per_second" => {
                                Ok(__FieldTag::__geodesic_meters_per_second)
                            }
                            "maxValidationErrors" => Ok(__FieldTag::__max_validation_errors),
                            "max_validation_errors" => Ok(__FieldTag::__max_validation_errors),
                            "label" => Ok(__FieldTag::__label),
                            "populateTravelStepPolylines" => {
                                Ok(__FieldTag::__populate_travel_step_polylines)
                            }
                            "populate_travel_step_polylines" => {
                                Ok(__FieldTag::__populate_travel_step_polylines)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OptimizeToursRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OptimizeToursRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<crate::model::ShipmentModel>>()?;
                        }
                        __FieldTag::__solving_mode => {
                            if !fields.insert(__FieldTag::__solving_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for solving_mode",
                                ));
                            }
                            result.solving_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::optimize_tours_request::SolvingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__search_mode => {
                            if !fields.insert(__FieldTag::__search_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_mode",
                                ));
                            }
                            result.search_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::optimize_tours_request::SearchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__injected_first_solution_routes => {
                            if !fields.insert(__FieldTag::__injected_first_solution_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for injected_first_solution_routes",
                                ));
                            }
                            result.injected_first_solution_routes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ShipmentRoute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__injected_solution_constraint => {
                            if !fields.insert(__FieldTag::__injected_solution_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for injected_solution_constraint",
                                ));
                            }
                            result.injected_solution_constraint = map.next_value::<std::option::Option<crate::model::InjectedSolutionConstraint>>()?
                                ;
                        }
                        __FieldTag::__refresh_details_routes => {
                            if !fields.insert(__FieldTag::__refresh_details_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_details_routes",
                                ));
                            }
                            result.refresh_details_routes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ShipmentRoute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__interpret_injected_solutions_using_labels => {
                            if !fields
                                .insert(__FieldTag::__interpret_injected_solutions_using_labels)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interpret_injected_solutions_using_labels",
                                ));
                            }
                            result.interpret_injected_solutions_using_labels = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consider_road_traffic => {
                            if !fields.insert(__FieldTag::__consider_road_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consider_road_traffic",
                                ));
                            }
                            result.consider_road_traffic = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__populate_polylines => {
                            if !fields.insert(__FieldTag::__populate_polylines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for populate_polylines",
                                ));
                            }
                            result.populate_polylines = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__populate_transition_polylines => {
                            if !fields.insert(__FieldTag::__populate_transition_polylines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for populate_transition_polylines",
                                ));
                            }
                            result.populate_transition_polylines = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_large_deadline_despite_interruption_risk => {
                            if !fields.insert(
                                __FieldTag::__allow_large_deadline_despite_interruption_risk,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_large_deadline_despite_interruption_risk",
                                ));
                            }
                            result.allow_large_deadline_despite_interruption_risk = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_geodesic_distances => {
                            if !fields.insert(__FieldTag::__use_geodesic_distances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_geodesic_distances",
                                ));
                            }
                            result.use_geodesic_distances = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__geodesic_meters_per_second => {
                            if !fields.insert(__FieldTag::__geodesic_meters_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geodesic_meters_per_second",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.geodesic_meters_per_second = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_validation_errors => {
                            if !fields.insert(__FieldTag::__max_validation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_validation_errors",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_validation_errors = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__populate_travel_step_polylines => {
                            if !fields.insert(__FieldTag::__populate_travel_step_polylines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for populate_travel_step_polylines",
                                ));
                            }
                            result.populate_travel_step_polylines = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OptimizeToursResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routes,
            __request_label,
            __skipped_shipments,
            __validation_errors,
            __metrics,
            __total_cost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OptimizeToursResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routes" => Ok(__FieldTag::__routes),
                            "requestLabel" => Ok(__FieldTag::__request_label),
                            "request_label" => Ok(__FieldTag::__request_label),
                            "skippedShipments" => Ok(__FieldTag::__skipped_shipments),
                            "skipped_shipments" => Ok(__FieldTag::__skipped_shipments),
                            "validationErrors" => Ok(__FieldTag::__validation_errors),
                            "validation_errors" => Ok(__FieldTag::__validation_errors),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "totalCost" => Ok(__FieldTag::__total_cost),
                            "total_cost" => Ok(__FieldTag::__total_cost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OptimizeToursResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OptimizeToursResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routes => {
                            if !fields.insert(__FieldTag::__routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routes",
                                ));
                            }
                            result.routes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ShipmentRoute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__request_label => {
                            if !fields.insert(__FieldTag::__request_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_label",
                                ));
                            }
                            result.request_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skipped_shipments => {
                            if !fields.insert(__FieldTag::__skipped_shipments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skipped_shipments",
                                ));
                            }
                            result.skipped_shipments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SkippedShipment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_errors => {
                            if !fields.insert(__FieldTag::__validation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_errors",
                                ));
                            }
                            result.validation_errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OptimizeToursValidationError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map.next_value::<std::option::Option<
                                crate::model::optimize_tours_response::Metrics,
                            >>()?;
                        }
                        __FieldTag::__total_cost => {
                            if !fields.insert(__FieldTag::__total_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::optimize_tours_response::Metrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregated_route_metrics,
            __skipped_mandatory_shipment_count,
            __used_vehicle_count,
            __earliest_vehicle_start_time,
            __latest_vehicle_end_time,
            __costs,
            __total_cost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregatedRouteMetrics" => Ok(__FieldTag::__aggregated_route_metrics),
                            "aggregated_route_metrics" => {
                                Ok(__FieldTag::__aggregated_route_metrics)
                            }
                            "skippedMandatoryShipmentCount" => {
                                Ok(__FieldTag::__skipped_mandatory_shipment_count)
                            }
                            "skipped_mandatory_shipment_count" => {
                                Ok(__FieldTag::__skipped_mandatory_shipment_count)
                            }
                            "usedVehicleCount" => Ok(__FieldTag::__used_vehicle_count),
                            "used_vehicle_count" => Ok(__FieldTag::__used_vehicle_count),
                            "earliestVehicleStartTime" => {
                                Ok(__FieldTag::__earliest_vehicle_start_time)
                            }
                            "earliest_vehicle_start_time" => {
                                Ok(__FieldTag::__earliest_vehicle_start_time)
                            }
                            "latestVehicleEndTime" => Ok(__FieldTag::__latest_vehicle_end_time),
                            "latest_vehicle_end_time" => Ok(__FieldTag::__latest_vehicle_end_time),
                            "costs" => Ok(__FieldTag::__costs),
                            "totalCost" => Ok(__FieldTag::__total_cost),
                            "total_cost" => Ok(__FieldTag::__total_cost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::optimize_tours_response::Metrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregated_route_metrics => {
                            if !fields.insert(__FieldTag::__aggregated_route_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregated_route_metrics",
                                ));
                            }
                            result.aggregated_route_metrics = map
                                .next_value::<std::option::Option<crate::model::AggregatedMetrics>>(
                                )?;
                        }
                        __FieldTag::__skipped_mandatory_shipment_count => {
                            if !fields.insert(__FieldTag::__skipped_mandatory_shipment_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skipped_mandatory_shipment_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.skipped_mandatory_shipment_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__used_vehicle_count => {
                            if !fields.insert(__FieldTag::__used_vehicle_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_vehicle_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.used_vehicle_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__earliest_vehicle_start_time => {
                            if !fields.insert(__FieldTag::__earliest_vehicle_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for earliest_vehicle_start_time",
                                ));
                            }
                            result.earliest_vehicle_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_vehicle_end_time => {
                            if !fields.insert(__FieldTag::__latest_vehicle_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_vehicle_end_time",
                                ));
                            }
                            result.latest_vehicle_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__costs => {
                            if !fields.insert(__FieldTag::__costs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for costs",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.costs = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_cost => {
                            if !fields.insert(__FieldTag::__total_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchOptimizeToursRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __model_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchOptimizeToursRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "modelConfigs" => Ok(__FieldTag::__model_configs),
                            "model_configs" => Ok(__FieldTag::__model_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchOptimizeToursRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchOptimizeToursRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_configs => {
                            if !fields.insert(__FieldTag::__model_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_configs",
                                ));
                            }
                            result.model_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::batch_optimize_tours_request::AsyncModelConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::batch_optimize_tours_request::AsyncModelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __input_config,
            __output_config,
            __enable_checkpoints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncModelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "enableCheckpoints" => Ok(__FieldTag::__enable_checkpoints),
                            "enable_checkpoints" => Ok(__FieldTag::__enable_checkpoints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::batch_optimize_tours_request::AsyncModelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncModelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__enable_checkpoints => {
                            if !fields.insert(__FieldTag::__enable_checkpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_checkpoints",
                                ));
                            }
                            result.enable_checkpoints = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BatchOptimizeToursResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchOptimizeToursResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BatchOptimizeToursResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchOptimizeToursResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShipmentModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shipments,
            __vehicles,
            __max_active_vehicles,
            __global_start_time,
            __global_end_time,
            __global_duration_cost_per_hour,
            __duration_distance_matrices,
            __duration_distance_matrix_src_tags,
            __duration_distance_matrix_dst_tags,
            __transition_attributes,
            __shipment_type_incompatibilities,
            __shipment_type_requirements,
            __precedence_rules,
            __break_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShipmentModel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shipments" => Ok(__FieldTag::__shipments),
                            "vehicles" => Ok(__FieldTag::__vehicles),
                            "maxActiveVehicles" => Ok(__FieldTag::__max_active_vehicles),
                            "max_active_vehicles" => Ok(__FieldTag::__max_active_vehicles),
                            "globalStartTime" => Ok(__FieldTag::__global_start_time),
                            "global_start_time" => Ok(__FieldTag::__global_start_time),
                            "globalEndTime" => Ok(__FieldTag::__global_end_time),
                            "global_end_time" => Ok(__FieldTag::__global_end_time),
                            "globalDurationCostPerHour" => {
                                Ok(__FieldTag::__global_duration_cost_per_hour)
                            }
                            "global_duration_cost_per_hour" => {
                                Ok(__FieldTag::__global_duration_cost_per_hour)
                            }
                            "durationDistanceMatrices" => {
                                Ok(__FieldTag::__duration_distance_matrices)
                            }
                            "duration_distance_matrices" => {
                                Ok(__FieldTag::__duration_distance_matrices)
                            }
                            "durationDistanceMatrixSrcTags" => {
                                Ok(__FieldTag::__duration_distance_matrix_src_tags)
                            }
                            "duration_distance_matrix_src_tags" => {
                                Ok(__FieldTag::__duration_distance_matrix_src_tags)
                            }
                            "durationDistanceMatrixDstTags" => {
                                Ok(__FieldTag::__duration_distance_matrix_dst_tags)
                            }
                            "duration_distance_matrix_dst_tags" => {
                                Ok(__FieldTag::__duration_distance_matrix_dst_tags)
                            }
                            "transitionAttributes" => Ok(__FieldTag::__transition_attributes),
                            "transition_attributes" => Ok(__FieldTag::__transition_attributes),
                            "shipmentTypeIncompatibilities" => {
                                Ok(__FieldTag::__shipment_type_incompatibilities)
                            }
                            "shipment_type_incompatibilities" => {
                                Ok(__FieldTag::__shipment_type_incompatibilities)
                            }
                            "shipmentTypeRequirements" => {
                                Ok(__FieldTag::__shipment_type_requirements)
                            }
                            "shipment_type_requirements" => {
                                Ok(__FieldTag::__shipment_type_requirements)
                            }
                            "precedenceRules" => Ok(__FieldTag::__precedence_rules),
                            "precedence_rules" => Ok(__FieldTag::__precedence_rules),
                            "breakRules" => Ok(__FieldTag::__break_rules),
                            "break_rules" => Ok(__FieldTag::__break_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShipmentModel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShipmentModel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shipments => {
                            if !fields.insert(__FieldTag::__shipments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipments",
                                ));
                            }
                            result.shipments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Shipment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vehicles => {
                            if !fields.insert(__FieldTag::__vehicles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicles",
                                ));
                            }
                            result.vehicles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Vehicle>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_active_vehicles => {
                            if !fields.insert(__FieldTag::__max_active_vehicles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_active_vehicles",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_active_vehicles = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__global_start_time => {
                            if !fields.insert(__FieldTag::__global_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_start_time",
                                ));
                            }
                            result.global_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__global_end_time => {
                            if !fields.insert(__FieldTag::__global_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_end_time",
                                ));
                            }
                            result.global_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__global_duration_cost_per_hour => {
                            if !fields.insert(__FieldTag::__global_duration_cost_per_hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_duration_cost_per_hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.global_duration_cost_per_hour =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__duration_distance_matrices => {
                            if !fields.insert(__FieldTag::__duration_distance_matrices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration_distance_matrices",
                                ));
                            }
                            result.duration_distance_matrices = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::shipment_model::DurationDistanceMatrix,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__duration_distance_matrix_src_tags => {
                            if !fields.insert(__FieldTag::__duration_distance_matrix_src_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration_distance_matrix_src_tags",
                                ));
                            }
                            result.duration_distance_matrix_src_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__duration_distance_matrix_dst_tags => {
                            if !fields.insert(__FieldTag::__duration_distance_matrix_dst_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration_distance_matrix_dst_tags",
                                ));
                            }
                            result.duration_distance_matrix_dst_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transition_attributes => {
                            if !fields.insert(__FieldTag::__transition_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_attributes",
                                ));
                            }
                            result.transition_attributes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransitionAttributes>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shipment_type_incompatibilities => {
                            if !fields.insert(__FieldTag::__shipment_type_incompatibilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipment_type_incompatibilities",
                                ));
                            }
                            result.shipment_type_incompatibilities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ShipmentTypeIncompatibility>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shipment_type_requirements => {
                            if !fields.insert(__FieldTag::__shipment_type_requirements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipment_type_requirements",
                                ));
                            }
                            result.shipment_type_requirements = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ShipmentTypeRequirement>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__precedence_rules => {
                            if !fields.insert(__FieldTag::__precedence_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precedence_rules",
                                ));
                            }
                            result.precedence_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_model::PrecedenceRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__break_rules => {
                            if !fields.insert(__FieldTag::__break_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_rules",
                                ));
                            }
                            result.break_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_model::BreakRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::DurationDistanceMatrix {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rows,
            __vehicle_start_tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DurationDistanceMatrix")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rows" => Ok(__FieldTag::__rows),
                            "vehicleStartTag" => Ok(__FieldTag::__vehicle_start_tag),
                            "vehicle_start_tag" => Ok(__FieldTag::__vehicle_start_tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::DurationDistanceMatrix;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DurationDistanceMatrix")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::shipment_model::duration_distance_matrix::Row,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vehicle_start_tag => {
                            if !fields.insert(__FieldTag::__vehicle_start_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_start_tag",
                                ));
                            }
                            result.vehicle_start_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::duration_distance_matrix::Row {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __durations,
            __meters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Row")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "durations" => Ok(__FieldTag::__durations),
                            "meters" => Ok(__FieldTag::__meters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::duration_distance_matrix::Row;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Row")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__durations => {
                            if !fields.insert(__FieldTag::__durations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for durations",
                                ));
                            }
                            result.durations = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__meters => {
                            if !fields.insert(__FieldTag::__meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for meters",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.meters = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::PrecedenceRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __first_index,
            __first_is_delivery,
            __second_index,
            __second_is_delivery,
            __offset_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrecedenceRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firstIndex" => Ok(__FieldTag::__first_index),
                            "first_index" => Ok(__FieldTag::__first_index),
                            "firstIsDelivery" => Ok(__FieldTag::__first_is_delivery),
                            "first_is_delivery" => Ok(__FieldTag::__first_is_delivery),
                            "secondIndex" => Ok(__FieldTag::__second_index),
                            "second_index" => Ok(__FieldTag::__second_index),
                            "secondIsDelivery" => Ok(__FieldTag::__second_is_delivery),
                            "second_is_delivery" => Ok(__FieldTag::__second_is_delivery),
                            "offsetDuration" => Ok(__FieldTag::__offset_duration),
                            "offset_duration" => Ok(__FieldTag::__offset_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::PrecedenceRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrecedenceRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__first_index => {
                            if !fields.insert(__FieldTag::__first_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.first_index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__first_is_delivery => {
                            if !fields.insert(__FieldTag::__first_is_delivery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_is_delivery",
                                ));
                            }
                            result.first_is_delivery = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__second_index => {
                            if !fields.insert(__FieldTag::__second_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for second_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.second_index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__second_is_delivery => {
                            if !fields.insert(__FieldTag::__second_is_delivery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for second_is_delivery",
                                ));
                            }
                            result.second_is_delivery = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offset_duration => {
                            if !fields.insert(__FieldTag::__offset_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset_duration",
                                ));
                            }
                            result.offset_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::BreakRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __break_requests,
            __frequency_constraints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BreakRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "breakRequests" => Ok(__FieldTag::__break_requests),
                            "break_requests" => Ok(__FieldTag::__break_requests),
                            "frequencyConstraints" => Ok(__FieldTag::__frequency_constraints),
                            "frequency_constraints" => Ok(__FieldTag::__frequency_constraints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::BreakRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BreakRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__break_requests => {
                            if !fields.insert(__FieldTag::__break_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_requests",
                                ));
                            }
                            result.break_requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::shipment_model::break_rule::BreakRequest,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frequency_constraints => {
                            if !fields.insert(__FieldTag::__frequency_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency_constraints",
                                ));
                            }
                            result.frequency_constraints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::shipment_model::break_rule::FrequencyConstraint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::break_rule::BreakRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __earliest_start_time,
            __latest_start_time,
            __min_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BreakRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "earliestStartTime" => Ok(__FieldTag::__earliest_start_time),
                            "earliest_start_time" => Ok(__FieldTag::__earliest_start_time),
                            "latestStartTime" => Ok(__FieldTag::__latest_start_time),
                            "latest_start_time" => Ok(__FieldTag::__latest_start_time),
                            "minDuration" => Ok(__FieldTag::__min_duration),
                            "min_duration" => Ok(__FieldTag::__min_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::break_rule::BreakRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BreakRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__earliest_start_time => {
                            if !fields.insert(__FieldTag::__earliest_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for earliest_start_time",
                                ));
                            }
                            result.earliest_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_start_time => {
                            if !fields.insert(__FieldTag::__latest_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_start_time",
                                ));
                            }
                            result.latest_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__min_duration => {
                            if !fields.insert(__FieldTag::__min_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_duration",
                                ));
                            }
                            result.min_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_model::break_rule::FrequencyConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_break_duration,
            __max_inter_break_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrequencyConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minBreakDuration" => Ok(__FieldTag::__min_break_duration),
                            "min_break_duration" => Ok(__FieldTag::__min_break_duration),
                            "maxInterBreakDuration" => Ok(__FieldTag::__max_inter_break_duration),
                            "max_inter_break_duration" => {
                                Ok(__FieldTag::__max_inter_break_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_model::break_rule::FrequencyConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrequencyConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_break_duration => {
                            if !fields.insert(__FieldTag::__min_break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_break_duration",
                                ));
                            }
                            result.min_break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_inter_break_duration => {
                            if !fields.insert(__FieldTag::__max_inter_break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_inter_break_duration",
                                ));
                            }
                            result.max_inter_break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Shipment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pickups,
            __deliveries,
            __load_demands,
            __penalty_cost,
            __allowed_vehicle_indices,
            __costs_per_vehicle,
            __costs_per_vehicle_indices,
            __pickup_to_delivery_relative_detour_limit,
            __pickup_to_delivery_absolute_detour_limit,
            __pickup_to_delivery_time_limit,
            __shipment_type,
            __label,
            __ignore,
            __demands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Shipment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pickups" => Ok(__FieldTag::__pickups),
                            "deliveries" => Ok(__FieldTag::__deliveries),
                            "loadDemands" => Ok(__FieldTag::__load_demands),
                            "load_demands" => Ok(__FieldTag::__load_demands),
                            "penaltyCost" => Ok(__FieldTag::__penalty_cost),
                            "penalty_cost" => Ok(__FieldTag::__penalty_cost),
                            "allowedVehicleIndices" => Ok(__FieldTag::__allowed_vehicle_indices),
                            "allowed_vehicle_indices" => Ok(__FieldTag::__allowed_vehicle_indices),
                            "costsPerVehicle" => Ok(__FieldTag::__costs_per_vehicle),
                            "costs_per_vehicle" => Ok(__FieldTag::__costs_per_vehicle),
                            "costsPerVehicleIndices" => Ok(__FieldTag::__costs_per_vehicle_indices),
                            "costs_per_vehicle_indices" => {
                                Ok(__FieldTag::__costs_per_vehicle_indices)
                            }
                            "pickupToDeliveryRelativeDetourLimit" => {
                                Ok(__FieldTag::__pickup_to_delivery_relative_detour_limit)
                            }
                            "pickup_to_delivery_relative_detour_limit" => {
                                Ok(__FieldTag::__pickup_to_delivery_relative_detour_limit)
                            }
                            "pickupToDeliveryAbsoluteDetourLimit" => {
                                Ok(__FieldTag::__pickup_to_delivery_absolute_detour_limit)
                            }
                            "pickup_to_delivery_absolute_detour_limit" => {
                                Ok(__FieldTag::__pickup_to_delivery_absolute_detour_limit)
                            }
                            "pickupToDeliveryTimeLimit" => {
                                Ok(__FieldTag::__pickup_to_delivery_time_limit)
                            }
                            "pickup_to_delivery_time_limit" => {
                                Ok(__FieldTag::__pickup_to_delivery_time_limit)
                            }
                            "shipmentType" => Ok(__FieldTag::__shipment_type),
                            "shipment_type" => Ok(__FieldTag::__shipment_type),
                            "label" => Ok(__FieldTag::__label),
                            "ignore" => Ok(__FieldTag::__ignore),
                            "demands" => Ok(__FieldTag::__demands),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Shipment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Shipment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pickups => {
                            if !fields.insert(__FieldTag::__pickups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pickups",
                                ));
                            }
                            result.pickups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment::VisitRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deliveries => {
                            if !fields.insert(__FieldTag::__deliveries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deliveries",
                                ));
                            }
                            result.deliveries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment::VisitRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__load_demands => {
                            if !fields.insert(__FieldTag::__load_demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_demands",
                                ));
                            }
                            result.load_demands = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::shipment::Load,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__penalty_cost => {
                            if !fields.insert(__FieldTag::__penalty_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for penalty_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.penalty_cost = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__allowed_vehicle_indices => {
                            if !fields.insert(__FieldTag::__allowed_vehicle_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_vehicle_indices",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.allowed_vehicle_indices =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__costs_per_vehicle => {
                            if !fields.insert(__FieldTag::__costs_per_vehicle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for costs_per_vehicle",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.costs_per_vehicle =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__costs_per_vehicle_indices => {
                            if !fields.insert(__FieldTag::__costs_per_vehicle_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for costs_per_vehicle_indices",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.costs_per_vehicle_indices =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pickup_to_delivery_relative_detour_limit => {
                            if !fields
                                .insert(__FieldTag::__pickup_to_delivery_relative_detour_limit)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pickup_to_delivery_relative_detour_limit",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pickup_to_delivery_relative_detour_limit =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__pickup_to_delivery_absolute_detour_limit => {
                            if !fields
                                .insert(__FieldTag::__pickup_to_delivery_absolute_detour_limit)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pickup_to_delivery_absolute_detour_limit",
                                ));
                            }
                            result.pickup_to_delivery_absolute_detour_limit =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__pickup_to_delivery_time_limit => {
                            if !fields.insert(__FieldTag::__pickup_to_delivery_time_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pickup_to_delivery_time_limit",
                                ));
                            }
                            result.pickup_to_delivery_time_limit =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__shipment_type => {
                            if !fields.insert(__FieldTag::__shipment_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipment_type",
                                ));
                            }
                            result.shipment_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore => {
                            if !fields.insert(__FieldTag::__ignore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore",
                                ));
                            }
                            result.ignore = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__demands => {
                            if !fields.insert(__FieldTag::__demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for demands",
                                ));
                            }
                            result.demands =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment::VisitRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __arrival_location,
            __arrival_waypoint,
            __departure_location,
            __departure_waypoint,
            __tags,
            __time_windows,
            __duration,
            __cost,
            __load_demands,
            __visit_types,
            __label,
            __demands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VisitRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "arrivalLocation" => Ok(__FieldTag::__arrival_location),
                            "arrival_location" => Ok(__FieldTag::__arrival_location),
                            "arrivalWaypoint" => Ok(__FieldTag::__arrival_waypoint),
                            "arrival_waypoint" => Ok(__FieldTag::__arrival_waypoint),
                            "departureLocation" => Ok(__FieldTag::__departure_location),
                            "departure_location" => Ok(__FieldTag::__departure_location),
                            "departureWaypoint" => Ok(__FieldTag::__departure_waypoint),
                            "departure_waypoint" => Ok(__FieldTag::__departure_waypoint),
                            "tags" => Ok(__FieldTag::__tags),
                            "timeWindows" => Ok(__FieldTag::__time_windows),
                            "time_windows" => Ok(__FieldTag::__time_windows),
                            "duration" => Ok(__FieldTag::__duration),
                            "cost" => Ok(__FieldTag::__cost),
                            "loadDemands" => Ok(__FieldTag::__load_demands),
                            "load_demands" => Ok(__FieldTag::__load_demands),
                            "visitTypes" => Ok(__FieldTag::__visit_types),
                            "visit_types" => Ok(__FieldTag::__visit_types),
                            "label" => Ok(__FieldTag::__label),
                            "demands" => Ok(__FieldTag::__demands),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment::VisitRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VisitRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__arrival_location => {
                            if !fields.insert(__FieldTag::__arrival_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arrival_location",
                                ));
                            }
                            result.arrival_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__arrival_waypoint => {
                            if !fields.insert(__FieldTag::__arrival_waypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arrival_waypoint",
                                ));
                            }
                            result.arrival_waypoint =
                                map.next_value::<std::option::Option<crate::model::Waypoint>>()?;
                        }
                        __FieldTag::__departure_location => {
                            if !fields.insert(__FieldTag::__departure_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for departure_location",
                                ));
                            }
                            result.departure_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__departure_waypoint => {
                            if !fields.insert(__FieldTag::__departure_waypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for departure_waypoint",
                                ));
                            }
                            result.departure_waypoint =
                                map.next_value::<std::option::Option<crate::model::Waypoint>>()?;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_windows => {
                            if !fields.insert(__FieldTag::__time_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_windows",
                                ));
                            }
                            result.time_windows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeWindow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__load_demands => {
                            if !fields.insert(__FieldTag::__load_demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_demands",
                                ));
                            }
                            result.load_demands = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::shipment::Load,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visit_types => {
                            if !fields.insert(__FieldTag::__visit_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visit_types",
                                ));
                            }
                            result.visit_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__demands => {
                            if !fields.insert(__FieldTag::__demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for demands",
                                ));
                            }
                            result.demands =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment::Load {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __amount,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Load")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "amount" => Ok(__FieldTag::__amount),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment::Load;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Load")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__amount => {
                            if !fields.insert(__FieldTag::__amount) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for amount",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.amount = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShipmentTypeIncompatibility {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __types,
            __incompatibility_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShipmentTypeIncompatibility")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "types" => Ok(__FieldTag::__types),
                            "incompatibilityMode" => Ok(__FieldTag::__incompatibility_mode),
                            "incompatibility_mode" => Ok(__FieldTag::__incompatibility_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShipmentTypeIncompatibility;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShipmentTypeIncompatibility")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__types => {
                            if !fields.insert(__FieldTag::__types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for types",
                                ));
                            }
                            result.types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__incompatibility_mode => {
                            if !fields.insert(__FieldTag::__incompatibility_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incompatibility_mode",
                                ));
                            }
                            result.incompatibility_mode = map.next_value::<std::option::Option<crate::model::shipment_type_incompatibility::IncompatibilityMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShipmentTypeRequirement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __required_shipment_type_alternatives,
            __dependent_shipment_types,
            __requirement_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShipmentTypeRequirement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requiredShipmentTypeAlternatives" => {
                                Ok(__FieldTag::__required_shipment_type_alternatives)
                            }
                            "required_shipment_type_alternatives" => {
                                Ok(__FieldTag::__required_shipment_type_alternatives)
                            }
                            "dependentShipmentTypes" => Ok(__FieldTag::__dependent_shipment_types),
                            "dependent_shipment_types" => {
                                Ok(__FieldTag::__dependent_shipment_types)
                            }
                            "requirementMode" => Ok(__FieldTag::__requirement_mode),
                            "requirement_mode" => Ok(__FieldTag::__requirement_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShipmentTypeRequirement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShipmentTypeRequirement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__required_shipment_type_alternatives => {
                            if !fields.insert(__FieldTag::__required_shipment_type_alternatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required_shipment_type_alternatives",
                                ));
                            }
                            result.required_shipment_type_alternatives = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dependent_shipment_types => {
                            if !fields.insert(__FieldTag::__dependent_shipment_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dependent_shipment_types",
                                ));
                            }
                            result.dependent_shipment_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__requirement_mode => {
                            if !fields.insert(__FieldTag::__requirement_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requirement_mode",
                                ));
                            }
                            result.requirement_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::shipment_type_requirement::RequirementMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RouteModifiers {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __avoid_tolls,
            __avoid_highways,
            __avoid_ferries,
            __avoid_indoor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RouteModifiers")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "avoidTolls" => Ok(__FieldTag::__avoid_tolls),
                            "avoid_tolls" => Ok(__FieldTag::__avoid_tolls),
                            "avoidHighways" => Ok(__FieldTag::__avoid_highways),
                            "avoid_highways" => Ok(__FieldTag::__avoid_highways),
                            "avoidFerries" => Ok(__FieldTag::__avoid_ferries),
                            "avoid_ferries" => Ok(__FieldTag::__avoid_ferries),
                            "avoidIndoor" => Ok(__FieldTag::__avoid_indoor),
                            "avoid_indoor" => Ok(__FieldTag::__avoid_indoor),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RouteModifiers;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RouteModifiers")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__avoid_tolls => {
                            if !fields.insert(__FieldTag::__avoid_tolls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avoid_tolls",
                                ));
                            }
                            result.avoid_tolls = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avoid_highways => {
                            if !fields.insert(__FieldTag::__avoid_highways) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avoid_highways",
                                ));
                            }
                            result.avoid_highways = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avoid_ferries => {
                            if !fields.insert(__FieldTag::__avoid_ferries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avoid_ferries",
                                ));
                            }
                            result.avoid_ferries = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avoid_indoor => {
                            if !fields.insert(__FieldTag::__avoid_indoor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avoid_indoor",
                                ));
                            }
                            result.avoid_indoor = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Vehicle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __travel_mode,
            __route_modifiers,
            __start_location,
            __start_waypoint,
            __end_location,
            __end_waypoint,
            __start_tags,
            __end_tags,
            __start_time_windows,
            __end_time_windows,
            __travel_duration_multiple,
            __unloading_policy,
            __load_limits,
            __cost_per_hour,
            __cost_per_traveled_hour,
            __cost_per_kilometer,
            __fixed_cost,
            __used_if_route_is_empty,
            __route_duration_limit,
            __travel_duration_limit,
            __route_distance_limit,
            __extra_visit_duration_for_visit_type,
            __break_rule,
            __label,
            __ignore,
            __break_rule_indices,
            __capacities,
            __start_load_intervals,
            __end_load_intervals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vehicle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "travelMode" => Ok(__FieldTag::__travel_mode),
                            "travel_mode" => Ok(__FieldTag::__travel_mode),
                            "routeModifiers" => Ok(__FieldTag::__route_modifiers),
                            "route_modifiers" => Ok(__FieldTag::__route_modifiers),
                            "startLocation" => Ok(__FieldTag::__start_location),
                            "start_location" => Ok(__FieldTag::__start_location),
                            "startWaypoint" => Ok(__FieldTag::__start_waypoint),
                            "start_waypoint" => Ok(__FieldTag::__start_waypoint),
                            "endLocation" => Ok(__FieldTag::__end_location),
                            "end_location" => Ok(__FieldTag::__end_location),
                            "endWaypoint" => Ok(__FieldTag::__end_waypoint),
                            "end_waypoint" => Ok(__FieldTag::__end_waypoint),
                            "startTags" => Ok(__FieldTag::__start_tags),
                            "start_tags" => Ok(__FieldTag::__start_tags),
                            "endTags" => Ok(__FieldTag::__end_tags),
                            "end_tags" => Ok(__FieldTag::__end_tags),
                            "startTimeWindows" => Ok(__FieldTag::__start_time_windows),
                            "start_time_windows" => Ok(__FieldTag::__start_time_windows),
                            "endTimeWindows" => Ok(__FieldTag::__end_time_windows),
                            "end_time_windows" => Ok(__FieldTag::__end_time_windows),
                            "travelDurationMultiple" => Ok(__FieldTag::__travel_duration_multiple),
                            "travel_duration_multiple" => {
                                Ok(__FieldTag::__travel_duration_multiple)
                            }
                            "unloadingPolicy" => Ok(__FieldTag::__unloading_policy),
                            "unloading_policy" => Ok(__FieldTag::__unloading_policy),
                            "loadLimits" => Ok(__FieldTag::__load_limits),
                            "load_limits" => Ok(__FieldTag::__load_limits),
                            "costPerHour" => Ok(__FieldTag::__cost_per_hour),
                            "cost_per_hour" => Ok(__FieldTag::__cost_per_hour),
                            "costPerTraveledHour" => Ok(__FieldTag::__cost_per_traveled_hour),
                            "cost_per_traveled_hour" => Ok(__FieldTag::__cost_per_traveled_hour),
                            "costPerKilometer" => Ok(__FieldTag::__cost_per_kilometer),
                            "cost_per_kilometer" => Ok(__FieldTag::__cost_per_kilometer),
                            "fixedCost" => Ok(__FieldTag::__fixed_cost),
                            "fixed_cost" => Ok(__FieldTag::__fixed_cost),
                            "usedIfRouteIsEmpty" => Ok(__FieldTag::__used_if_route_is_empty),
                            "used_if_route_is_empty" => Ok(__FieldTag::__used_if_route_is_empty),
                            "routeDurationLimit" => Ok(__FieldTag::__route_duration_limit),
                            "route_duration_limit" => Ok(__FieldTag::__route_duration_limit),
                            "travelDurationLimit" => Ok(__FieldTag::__travel_duration_limit),
                            "travel_duration_limit" => Ok(__FieldTag::__travel_duration_limit),
                            "routeDistanceLimit" => Ok(__FieldTag::__route_distance_limit),
                            "route_distance_limit" => Ok(__FieldTag::__route_distance_limit),
                            "extraVisitDurationForVisitType" => {
                                Ok(__FieldTag::__extra_visit_duration_for_visit_type)
                            }
                            "extra_visit_duration_for_visit_type" => {
                                Ok(__FieldTag::__extra_visit_duration_for_visit_type)
                            }
                            "breakRule" => Ok(__FieldTag::__break_rule),
                            "break_rule" => Ok(__FieldTag::__break_rule),
                            "label" => Ok(__FieldTag::__label),
                            "ignore" => Ok(__FieldTag::__ignore),
                            "breakRuleIndices" => Ok(__FieldTag::__break_rule_indices),
                            "break_rule_indices" => Ok(__FieldTag::__break_rule_indices),
                            "capacities" => Ok(__FieldTag::__capacities),
                            "startLoadIntervals" => Ok(__FieldTag::__start_load_intervals),
                            "start_load_intervals" => Ok(__FieldTag::__start_load_intervals),
                            "endLoadIntervals" => Ok(__FieldTag::__end_load_intervals),
                            "end_load_intervals" => Ok(__FieldTag::__end_load_intervals),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Vehicle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vehicle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__travel_mode => {
                            if !fields.insert(__FieldTag::__travel_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_mode",
                                ));
                            }
                            result.travel_mode = map.next_value::<std::option::Option<crate::model::vehicle::TravelMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__route_modifiers => {
                            if !fields.insert(__FieldTag::__route_modifiers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_modifiers",
                                ));
                            }
                            result.route_modifiers = map
                                .next_value::<std::option::Option<crate::model::RouteModifiers>>(
                                )?;
                        }
                        __FieldTag::__start_location => {
                            if !fields.insert(__FieldTag::__start_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_location",
                                ));
                            }
                            result.start_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__start_waypoint => {
                            if !fields.insert(__FieldTag::__start_waypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_waypoint",
                                ));
                            }
                            result.start_waypoint =
                                map.next_value::<std::option::Option<crate::model::Waypoint>>()?;
                        }
                        __FieldTag::__end_location => {
                            if !fields.insert(__FieldTag::__end_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_location",
                                ));
                            }
                            result.end_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__end_waypoint => {
                            if !fields.insert(__FieldTag::__end_waypoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_waypoint",
                                ));
                            }
                            result.end_waypoint =
                                map.next_value::<std::option::Option<crate::model::Waypoint>>()?;
                        }
                        __FieldTag::__start_tags => {
                            if !fields.insert(__FieldTag::__start_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_tags",
                                ));
                            }
                            result.start_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__end_tags => {
                            if !fields.insert(__FieldTag::__end_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_tags",
                                ));
                            }
                            result.end_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_time_windows => {
                            if !fields.insert(__FieldTag::__start_time_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time_windows",
                                ));
                            }
                            result.start_time_windows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeWindow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__end_time_windows => {
                            if !fields.insert(__FieldTag::__end_time_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time_windows",
                                ));
                            }
                            result.end_time_windows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TimeWindow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__travel_duration_multiple => {
                            if !fields.insert(__FieldTag::__travel_duration_multiple) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_duration_multiple",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.travel_duration_multiple = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__unloading_policy => {
                            if !fields.insert(__FieldTag::__unloading_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unloading_policy",
                                ));
                            }
                            result.unloading_policy = map.next_value::<std::option::Option<crate::model::vehicle::UnloadingPolicy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__load_limits => {
                            if !fields.insert(__FieldTag::__load_limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_limits",
                                ));
                            }
                            result.load_limits = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::vehicle::LoadLimit,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cost_per_hour => {
                            if !fields.insert(__FieldTag::__cost_per_hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_hour =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost_per_traveled_hour => {
                            if !fields.insert(__FieldTag::__cost_per_traveled_hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_traveled_hour",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_traveled_hour =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost_per_kilometer => {
                            if !fields.insert(__FieldTag::__cost_per_kilometer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_kilometer",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_kilometer =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__fixed_cost => {
                            if !fields.insert(__FieldTag::__fixed_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.fixed_cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__used_if_route_is_empty => {
                            if !fields.insert(__FieldTag::__used_if_route_is_empty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for used_if_route_is_empty",
                                ));
                            }
                            result.used_if_route_is_empty = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route_duration_limit => {
                            if !fields.insert(__FieldTag::__route_duration_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_duration_limit",
                                ));
                            }
                            result.route_duration_limit = map.next_value::<std::option::Option<crate::model::vehicle::DurationLimit>>()?
                                ;
                        }
                        __FieldTag::__travel_duration_limit => {
                            if !fields.insert(__FieldTag::__travel_duration_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_duration_limit",
                                ));
                            }
                            result.travel_duration_limit = map.next_value::<std::option::Option<crate::model::vehicle::DurationLimit>>()?
                                ;
                        }
                        __FieldTag::__route_distance_limit => {
                            if !fields.insert(__FieldTag::__route_distance_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_distance_limit",
                                ));
                            }
                            result.route_distance_limit = map
                                .next_value::<std::option::Option<crate::model::DistanceLimit>>()?;
                        }
                        __FieldTag::__extra_visit_duration_for_visit_type => {
                            if !fields.insert(__FieldTag::__extra_visit_duration_for_visit_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extra_visit_duration_for_visit_type",
                                ));
                            }
                            result.extra_visit_duration_for_visit_type = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Duration>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__break_rule => {
                            if !fields.insert(__FieldTag::__break_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_rule",
                                ));
                            }
                            result.break_rule =
                                map.next_value::<std::option::Option<crate::model::BreakRule>>()?;
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore => {
                            if !fields.insert(__FieldTag::__ignore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore",
                                ));
                            }
                            result.ignore = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__break_rule_indices => {
                            if !fields.insert(__FieldTag::__break_rule_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_rule_indices",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.break_rule_indices =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__capacities => {
                            if !fields.insert(__FieldTag::__capacities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for capacities",
                                ));
                            }
                            result.capacities =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_load_intervals => {
                            if !fields.insert(__FieldTag::__start_load_intervals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_load_intervals",
                                ));
                            }
                            result.start_load_intervals = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantityInterval>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_load_intervals => {
                            if !fields.insert(__FieldTag::__end_load_intervals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_load_intervals",
                                ));
                            }
                            result.end_load_intervals = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantityInterval>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vehicle::LoadLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_load,
            __soft_max_load,
            __cost_per_unit_above_soft_max,
            __start_load_interval,
            __end_load_interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxLoad" => Ok(__FieldTag::__max_load),
                            "max_load" => Ok(__FieldTag::__max_load),
                            "softMaxLoad" => Ok(__FieldTag::__soft_max_load),
                            "soft_max_load" => Ok(__FieldTag::__soft_max_load),
                            "costPerUnitAboveSoftMax" => {
                                Ok(__FieldTag::__cost_per_unit_above_soft_max)
                            }
                            "cost_per_unit_above_soft_max" => {
                                Ok(__FieldTag::__cost_per_unit_above_soft_max)
                            }
                            "startLoadInterval" => Ok(__FieldTag::__start_load_interval),
                            "start_load_interval" => Ok(__FieldTag::__start_load_interval),
                            "endLoadInterval" => Ok(__FieldTag::__end_load_interval),
                            "end_load_interval" => Ok(__FieldTag::__end_load_interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vehicle::LoadLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_load => {
                            if !fields.insert(__FieldTag::__max_load) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_load",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_load = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__soft_max_load => {
                            if !fields.insert(__FieldTag::__soft_max_load) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_max_load",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.soft_max_load =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost_per_unit_above_soft_max => {
                            if !fields.insert(__FieldTag::__cost_per_unit_above_soft_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_unit_above_soft_max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_unit_above_soft_max =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_load_interval => {
                            if !fields.insert(__FieldTag::__start_load_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_load_interval",
                                ));
                            }
                            result.start_load_interval =
                                map.next_value::<std::option::Option<
                                    crate::model::vehicle::load_limit::Interval,
                                >>()?;
                        }
                        __FieldTag::__end_load_interval => {
                            if !fields.insert(__FieldTag::__end_load_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_load_interval",
                                ));
                            }
                            result.end_load_interval =
                                map.next_value::<std::option::Option<
                                    crate::model::vehicle::load_limit::Interval,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vehicle::load_limit::Interval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Interval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vehicle::load_limit::Interval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Interval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::vehicle::DurationLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_duration,
            __soft_max_duration,
            __cost_per_hour_after_soft_max,
            __quadratic_soft_max_duration,
            __cost_per_square_hour_after_quadratic_soft_max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DurationLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxDuration" => Ok(__FieldTag::__max_duration),
                            "max_duration" => Ok(__FieldTag::__max_duration),
                            "softMaxDuration" => Ok(__FieldTag::__soft_max_duration),
                            "soft_max_duration" => Ok(__FieldTag::__soft_max_duration),
                            "costPerHourAfterSoftMax" => {
                                Ok(__FieldTag::__cost_per_hour_after_soft_max)
                            }
                            "cost_per_hour_after_soft_max" => {
                                Ok(__FieldTag::__cost_per_hour_after_soft_max)
                            }
                            "quadraticSoftMaxDuration" => {
                                Ok(__FieldTag::__quadratic_soft_max_duration)
                            }
                            "quadratic_soft_max_duration" => {
                                Ok(__FieldTag::__quadratic_soft_max_duration)
                            }
                            "costPerSquareHourAfterQuadraticSoftMax" => {
                                Ok(__FieldTag::__cost_per_square_hour_after_quadratic_soft_max)
                            }
                            "cost_per_square_hour_after_quadratic_soft_max" => {
                                Ok(__FieldTag::__cost_per_square_hour_after_quadratic_soft_max)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::vehicle::DurationLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DurationLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_duration => {
                            if !fields.insert(__FieldTag::__max_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_duration",
                                ));
                            }
                            result.max_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__soft_max_duration => {
                            if !fields.insert(__FieldTag::__soft_max_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_max_duration",
                                ));
                            }
                            result.soft_max_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cost_per_hour_after_soft_max => {
                            if !fields.insert(__FieldTag::__cost_per_hour_after_soft_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_hour_after_soft_max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_hour_after_soft_max = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__quadratic_soft_max_duration => {
                            if !fields.insert(__FieldTag::__quadratic_soft_max_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quadratic_soft_max_duration",
                                ));
                            }
                            result.quadratic_soft_max_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cost_per_square_hour_after_quadratic_soft_max => {
                            if !fields
                                .insert(__FieldTag::__cost_per_square_hour_after_quadratic_soft_max)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_square_hour_after_quadratic_soft_max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_square_hour_after_quadratic_soft_max =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __soft_start_time,
            __soft_end_time,
            __cost_per_hour_before_soft_start_time,
            __cost_per_hour_after_soft_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "softStartTime" => Ok(__FieldTag::__soft_start_time),
                            "soft_start_time" => Ok(__FieldTag::__soft_start_time),
                            "softEndTime" => Ok(__FieldTag::__soft_end_time),
                            "soft_end_time" => Ok(__FieldTag::__soft_end_time),
                            "costPerHourBeforeSoftStartTime" => {
                                Ok(__FieldTag::__cost_per_hour_before_soft_start_time)
                            }
                            "cost_per_hour_before_soft_start_time" => {
                                Ok(__FieldTag::__cost_per_hour_before_soft_start_time)
                            }
                            "costPerHourAfterSoftEndTime" => {
                                Ok(__FieldTag::__cost_per_hour_after_soft_end_time)
                            }
                            "cost_per_hour_after_soft_end_time" => {
                                Ok(__FieldTag::__cost_per_hour_after_soft_end_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__soft_start_time => {
                            if !fields.insert(__FieldTag::__soft_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_start_time",
                                ));
                            }
                            result.soft_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__soft_end_time => {
                            if !fields.insert(__FieldTag::__soft_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_end_time",
                                ));
                            }
                            result.soft_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cost_per_hour_before_soft_start_time => {
                            if !fields.insert(__FieldTag::__cost_per_hour_before_soft_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_hour_before_soft_start_time",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_hour_before_soft_start_time =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cost_per_hour_after_soft_end_time => {
                            if !fields.insert(__FieldTag::__cost_per_hour_after_soft_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_hour_after_soft_end_time",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_hour_after_soft_end_time =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CapacityQuantity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CapacityQuantity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CapacityQuantity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CapacityQuantity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CapacityQuantityInterval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __min_value,
            __max_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CapacityQuantityInterval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "minValue" => Ok(__FieldTag::__min_value),
                            "min_value" => Ok(__FieldTag::__min_value),
                            "maxValue" => Ok(__FieldTag::__max_value),
                            "max_value" => Ok(__FieldTag::__max_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CapacityQuantityInterval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CapacityQuantityInterval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_value => {
                            if !fields.insert(__FieldTag::__min_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__max_value => {
                            if !fields.insert(__FieldTag::__max_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DistanceLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_meters,
            __soft_max_meters,
            __cost_per_kilometer_below_soft_max,
            __cost_per_kilometer_above_soft_max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DistanceLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxMeters" => Ok(__FieldTag::__max_meters),
                            "max_meters" => Ok(__FieldTag::__max_meters),
                            "softMaxMeters" => Ok(__FieldTag::__soft_max_meters),
                            "soft_max_meters" => Ok(__FieldTag::__soft_max_meters),
                            "costPerKilometerBelowSoftMax" => {
                                Ok(__FieldTag::__cost_per_kilometer_below_soft_max)
                            }
                            "cost_per_kilometer_below_soft_max" => {
                                Ok(__FieldTag::__cost_per_kilometer_below_soft_max)
                            }
                            "costPerKilometerAboveSoftMax" => {
                                Ok(__FieldTag::__cost_per_kilometer_above_soft_max)
                            }
                            "cost_per_kilometer_above_soft_max" => {
                                Ok(__FieldTag::__cost_per_kilometer_above_soft_max)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DistanceLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DistanceLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_meters => {
                            if !fields.insert(__FieldTag::__max_meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_meters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_meters = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__soft_max_meters => {
                            if !fields.insert(__FieldTag::__soft_max_meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for soft_max_meters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.soft_max_meters = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cost_per_kilometer_below_soft_max => {
                            if !fields.insert(__FieldTag::__cost_per_kilometer_below_soft_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_kilometer_below_soft_max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_kilometer_below_soft_max =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__cost_per_kilometer_above_soft_max => {
                            if !fields.insert(__FieldTag::__cost_per_kilometer_above_soft_max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_kilometer_above_soft_max",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_kilometer_above_soft_max =
                                map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TransitionAttributes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __src_tag,
            __excluded_src_tag,
            __dst_tag,
            __excluded_dst_tag,
            __cost,
            __cost_per_kilometer,
            __distance_limit,
            __delay,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransitionAttributes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "srcTag" => Ok(__FieldTag::__src_tag),
                            "src_tag" => Ok(__FieldTag::__src_tag),
                            "excludedSrcTag" => Ok(__FieldTag::__excluded_src_tag),
                            "excluded_src_tag" => Ok(__FieldTag::__excluded_src_tag),
                            "dstTag" => Ok(__FieldTag::__dst_tag),
                            "dst_tag" => Ok(__FieldTag::__dst_tag),
                            "excludedDstTag" => Ok(__FieldTag::__excluded_dst_tag),
                            "excluded_dst_tag" => Ok(__FieldTag::__excluded_dst_tag),
                            "cost" => Ok(__FieldTag::__cost),
                            "costPerKilometer" => Ok(__FieldTag::__cost_per_kilometer),
                            "cost_per_kilometer" => Ok(__FieldTag::__cost_per_kilometer),
                            "distanceLimit" => Ok(__FieldTag::__distance_limit),
                            "distance_limit" => Ok(__FieldTag::__distance_limit),
                            "delay" => Ok(__FieldTag::__delay),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TransitionAttributes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransitionAttributes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__src_tag => {
                            if !fields.insert(__FieldTag::__src_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for src_tag",
                                ));
                            }
                            result.src_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excluded_src_tag => {
                            if !fields.insert(__FieldTag::__excluded_src_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_src_tag",
                                ));
                            }
                            result.excluded_src_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dst_tag => {
                            if !fields.insert(__FieldTag::__dst_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dst_tag",
                                ));
                            }
                            result.dst_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excluded_dst_tag => {
                            if !fields.insert(__FieldTag::__excluded_dst_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_dst_tag",
                                ));
                            }
                            result.excluded_dst_tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost_per_kilometer => {
                            if !fields.insert(__FieldTag::__cost_per_kilometer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_per_kilometer",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost_per_kilometer =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__distance_limit => {
                            if !fields.insert(__FieldTag::__distance_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_limit",
                                ));
                            }
                            result.distance_limit = map
                                .next_value::<std::option::Option<crate::model::DistanceLimit>>()?;
                        }
                        __FieldTag::__delay => {
                            if !fields.insert(__FieldTag::__delay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delay",
                                ));
                            }
                            result.delay =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Waypoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __place_id,
            __side_of_road,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Waypoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "placeId" => Ok(__FieldTag::__place_id),
                            "place_id" => Ok(__FieldTag::__place_id),
                            "sideOfRoad" => Ok(__FieldTag::__side_of_road),
                            "side_of_road" => Ok(__FieldTag::__side_of_road),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Waypoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Waypoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            if result.location_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location_type`, a oneof with full ID .google.cloud.optimization.v1.Waypoint.location, latest field was location",
                                ));
                            }
                            result.location_type = std::option::Option::Some(
                                crate::model::waypoint::LocationType::Location(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Location>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__place_id => {
                            if !fields.insert(__FieldTag::__place_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_id",
                                ));
                            }
                            if result.location_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location_type`, a oneof with full ID .google.cloud.optimization.v1.Waypoint.place_id, latest field was placeId",
                                ));
                            }
                            result.location_type = std::option::Option::Some(
                                crate::model::waypoint::LocationType::PlaceId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__side_of_road => {
                            if !fields.insert(__FieldTag::__side_of_road) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for side_of_road",
                                ));
                            }
                            result.side_of_road = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Location {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lat_lng,
            __heading,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Location")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latLng" => Ok(__FieldTag::__lat_lng),
                            "lat_lng" => Ok(__FieldTag::__lat_lng),
                            "heading" => Ok(__FieldTag::__heading),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Location;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Location")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lat_lng => {
                            if !fields.insert(__FieldTag::__lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lat_lng",
                                ));
                            }
                            result.lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__heading => {
                            if !fields.insert(__FieldTag::__heading) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for heading",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.heading = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BreakRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __break_requests,
            __frequency_constraints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BreakRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "breakRequests" => Ok(__FieldTag::__break_requests),
                            "break_requests" => Ok(__FieldTag::__break_requests),
                            "frequencyConstraints" => Ok(__FieldTag::__frequency_constraints),
                            "frequency_constraints" => Ok(__FieldTag::__frequency_constraints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BreakRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BreakRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__break_requests => {
                            if !fields.insert(__FieldTag::__break_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_requests",
                                ));
                            }
                            result.break_requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::break_rule::BreakRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frequency_constraints => {
                            if !fields.insert(__FieldTag::__frequency_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency_constraints",
                                ));
                            }
                            result.frequency_constraints = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::break_rule::FrequencyConstraint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::break_rule::BreakRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __earliest_start_time,
            __latest_start_time,
            __min_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BreakRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "earliestStartTime" => Ok(__FieldTag::__earliest_start_time),
                            "earliest_start_time" => Ok(__FieldTag::__earliest_start_time),
                            "latestStartTime" => Ok(__FieldTag::__latest_start_time),
                            "latest_start_time" => Ok(__FieldTag::__latest_start_time),
                            "minDuration" => Ok(__FieldTag::__min_duration),
                            "min_duration" => Ok(__FieldTag::__min_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::break_rule::BreakRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BreakRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__earliest_start_time => {
                            if !fields.insert(__FieldTag::__earliest_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for earliest_start_time",
                                ));
                            }
                            result.earliest_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_start_time => {
                            if !fields.insert(__FieldTag::__latest_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_start_time",
                                ));
                            }
                            result.latest_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__min_duration => {
                            if !fields.insert(__FieldTag::__min_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_duration",
                                ));
                            }
                            result.min_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::break_rule::FrequencyConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_break_duration,
            __max_inter_break_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrequencyConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minBreakDuration" => Ok(__FieldTag::__min_break_duration),
                            "min_break_duration" => Ok(__FieldTag::__min_break_duration),
                            "maxInterBreakDuration" => Ok(__FieldTag::__max_inter_break_duration),
                            "max_inter_break_duration" => {
                                Ok(__FieldTag::__max_inter_break_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::break_rule::FrequencyConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrequencyConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_break_duration => {
                            if !fields.insert(__FieldTag::__min_break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_break_duration",
                                ));
                            }
                            result.min_break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_inter_break_duration => {
                            if !fields.insert(__FieldTag::__max_inter_break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_inter_break_duration",
                                ));
                            }
                            result.max_inter_break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShipmentRoute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vehicle_index,
            __vehicle_label,
            __vehicle_start_time,
            __vehicle_end_time,
            __visits,
            __transitions,
            __has_traffic_infeasibilities,
            __route_polyline,
            __breaks,
            __metrics,
            __route_costs,
            __route_total_cost,
            __end_loads,
            __travel_steps,
            __vehicle_detour,
            __delay_before_vehicle_end,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShipmentRoute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vehicleIndex" => Ok(__FieldTag::__vehicle_index),
                            "vehicle_index" => Ok(__FieldTag::__vehicle_index),
                            "vehicleLabel" => Ok(__FieldTag::__vehicle_label),
                            "vehicle_label" => Ok(__FieldTag::__vehicle_label),
                            "vehicleStartTime" => Ok(__FieldTag::__vehicle_start_time),
                            "vehicle_start_time" => Ok(__FieldTag::__vehicle_start_time),
                            "vehicleEndTime" => Ok(__FieldTag::__vehicle_end_time),
                            "vehicle_end_time" => Ok(__FieldTag::__vehicle_end_time),
                            "visits" => Ok(__FieldTag::__visits),
                            "transitions" => Ok(__FieldTag::__transitions),
                            "hasTrafficInfeasibilities" => {
                                Ok(__FieldTag::__has_traffic_infeasibilities)
                            }
                            "has_traffic_infeasibilities" => {
                                Ok(__FieldTag::__has_traffic_infeasibilities)
                            }
                            "routePolyline" => Ok(__FieldTag::__route_polyline),
                            "route_polyline" => Ok(__FieldTag::__route_polyline),
                            "breaks" => Ok(__FieldTag::__breaks),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "routeCosts" => Ok(__FieldTag::__route_costs),
                            "route_costs" => Ok(__FieldTag::__route_costs),
                            "routeTotalCost" => Ok(__FieldTag::__route_total_cost),
                            "route_total_cost" => Ok(__FieldTag::__route_total_cost),
                            "endLoads" => Ok(__FieldTag::__end_loads),
                            "end_loads" => Ok(__FieldTag::__end_loads),
                            "travelSteps" => Ok(__FieldTag::__travel_steps),
                            "travel_steps" => Ok(__FieldTag::__travel_steps),
                            "vehicleDetour" => Ok(__FieldTag::__vehicle_detour),
                            "vehicle_detour" => Ok(__FieldTag::__vehicle_detour),
                            "delayBeforeVehicleEnd" => Ok(__FieldTag::__delay_before_vehicle_end),
                            "delay_before_vehicle_end" => {
                                Ok(__FieldTag::__delay_before_vehicle_end)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShipmentRoute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShipmentRoute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vehicle_index => {
                            if !fields.insert(__FieldTag::__vehicle_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vehicle_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vehicle_label => {
                            if !fields.insert(__FieldTag::__vehicle_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_label",
                                ));
                            }
                            result.vehicle_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vehicle_start_time => {
                            if !fields.insert(__FieldTag::__vehicle_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_start_time",
                                ));
                            }
                            result.vehicle_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__vehicle_end_time => {
                            if !fields.insert(__FieldTag::__vehicle_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_end_time",
                                ));
                            }
                            result.vehicle_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__visits => {
                            if !fields.insert(__FieldTag::__visits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visits",
                                ));
                            }
                            result.visits = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_route::Visit>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transitions => {
                            if !fields.insert(__FieldTag::__transitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transitions",
                                ));
                            }
                            result.transitions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_route::Transition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_traffic_infeasibilities => {
                            if !fields.insert(__FieldTag::__has_traffic_infeasibilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_traffic_infeasibilities",
                                ));
                            }
                            result.has_traffic_infeasibilities = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route_polyline => {
                            if !fields.insert(__FieldTag::__route_polyline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_polyline",
                                ));
                            }
                            result.route_polyline = map.next_value::<std::option::Option<
                                crate::model::shipment_route::EncodedPolyline,
                            >>()?;
                        }
                        __FieldTag::__breaks => {
                            if !fields.insert(__FieldTag::__breaks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for breaks",
                                ));
                            }
                            result.breaks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_route::Break>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map
                                .next_value::<std::option::Option<crate::model::AggregatedMetrics>>(
                                )?;
                        }
                        __FieldTag::__route_costs => {
                            if !fields.insert(__FieldTag::__route_costs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_costs",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.route_costs = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__route_total_cost => {
                            if !fields.insert(__FieldTag::__route_total_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_total_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.route_total_cost =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__end_loads => {
                            if !fields.insert(__FieldTag::__end_loads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_loads",
                                ));
                            }
                            result.end_loads =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__travel_steps => {
                            if !fields.insert(__FieldTag::__travel_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_steps",
                                ));
                            }
                            result.travel_steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::shipment_route::TravelStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vehicle_detour => {
                            if !fields.insert(__FieldTag::__vehicle_detour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_detour",
                                ));
                            }
                            result.vehicle_detour =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__delay_before_vehicle_end => {
                            if !fields.insert(__FieldTag::__delay_before_vehicle_end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delay_before_vehicle_end",
                                ));
                            }
                            result.delay_before_vehicle_end = map.next_value::<std::option::Option<crate::model::shipment_route::Delay>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::Delay {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Delay")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::Delay;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Delay")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::Visit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __shipment_index,
            __is_pickup,
            __visit_request_index,
            __start_time,
            __load_demands,
            __detour,
            __shipment_label,
            __visit_label,
            __arrival_loads,
            __delay_before_start,
            __demands,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Visit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shipmentIndex" => Ok(__FieldTag::__shipment_index),
                            "shipment_index" => Ok(__FieldTag::__shipment_index),
                            "isPickup" => Ok(__FieldTag::__is_pickup),
                            "is_pickup" => Ok(__FieldTag::__is_pickup),
                            "visitRequestIndex" => Ok(__FieldTag::__visit_request_index),
                            "visit_request_index" => Ok(__FieldTag::__visit_request_index),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "loadDemands" => Ok(__FieldTag::__load_demands),
                            "load_demands" => Ok(__FieldTag::__load_demands),
                            "detour" => Ok(__FieldTag::__detour),
                            "shipmentLabel" => Ok(__FieldTag::__shipment_label),
                            "shipment_label" => Ok(__FieldTag::__shipment_label),
                            "visitLabel" => Ok(__FieldTag::__visit_label),
                            "visit_label" => Ok(__FieldTag::__visit_label),
                            "arrivalLoads" => Ok(__FieldTag::__arrival_loads),
                            "arrival_loads" => Ok(__FieldTag::__arrival_loads),
                            "delayBeforeStart" => Ok(__FieldTag::__delay_before_start),
                            "delay_before_start" => Ok(__FieldTag::__delay_before_start),
                            "demands" => Ok(__FieldTag::__demands),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::Visit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Visit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__shipment_index => {
                            if !fields.insert(__FieldTag::__shipment_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipment_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shipment_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_pickup => {
                            if !fields.insert(__FieldTag::__is_pickup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_pickup",
                                ));
                            }
                            result.is_pickup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visit_request_index => {
                            if !fields.insert(__FieldTag::__visit_request_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visit_request_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.visit_request_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__load_demands => {
                            if !fields.insert(__FieldTag::__load_demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_demands",
                                ));
                            }
                            result.load_demands = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::shipment::Load,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detour => {
                            if !fields.insert(__FieldTag::__detour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detour",
                                ));
                            }
                            result.detour =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__shipment_label => {
                            if !fields.insert(__FieldTag::__shipment_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shipment_label",
                                ));
                            }
                            result.shipment_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visit_label => {
                            if !fields.insert(__FieldTag::__visit_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visit_label",
                                ));
                            }
                            result.visit_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__arrival_loads => {
                            if !fields.insert(__FieldTag::__arrival_loads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arrival_loads",
                                ));
                            }
                            result.arrival_loads =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delay_before_start => {
                            if !fields.insert(__FieldTag::__delay_before_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delay_before_start",
                                ));
                            }
                            result.delay_before_start = map.next_value::<std::option::Option<crate::model::shipment_route::Delay>>()?
                                ;
                        }
                        __FieldTag::__demands => {
                            if !fields.insert(__FieldTag::__demands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for demands",
                                ));
                            }
                            result.demands =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::Transition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __travel_duration,
            __travel_distance_meters,
            __traffic_info_unavailable,
            __delay_duration,
            __break_duration,
            __wait_duration,
            __total_duration,
            __start_time,
            __route_polyline,
            __vehicle_loads,
            __loads,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Transition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "travelDuration" => Ok(__FieldTag::__travel_duration),
                            "travel_duration" => Ok(__FieldTag::__travel_duration),
                            "travelDistanceMeters" => Ok(__FieldTag::__travel_distance_meters),
                            "travel_distance_meters" => Ok(__FieldTag::__travel_distance_meters),
                            "trafficInfoUnavailable" => Ok(__FieldTag::__traffic_info_unavailable),
                            "traffic_info_unavailable" => {
                                Ok(__FieldTag::__traffic_info_unavailable)
                            }
                            "delayDuration" => Ok(__FieldTag::__delay_duration),
                            "delay_duration" => Ok(__FieldTag::__delay_duration),
                            "breakDuration" => Ok(__FieldTag::__break_duration),
                            "break_duration" => Ok(__FieldTag::__break_duration),
                            "waitDuration" => Ok(__FieldTag::__wait_duration),
                            "wait_duration" => Ok(__FieldTag::__wait_duration),
                            "totalDuration" => Ok(__FieldTag::__total_duration),
                            "total_duration" => Ok(__FieldTag::__total_duration),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "routePolyline" => Ok(__FieldTag::__route_polyline),
                            "route_polyline" => Ok(__FieldTag::__route_polyline),
                            "vehicleLoads" => Ok(__FieldTag::__vehicle_loads),
                            "vehicle_loads" => Ok(__FieldTag::__vehicle_loads),
                            "loads" => Ok(__FieldTag::__loads),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::Transition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Transition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__travel_duration => {
                            if !fields.insert(__FieldTag::__travel_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_duration",
                                ));
                            }
                            result.travel_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__travel_distance_meters => {
                            if !fields.insert(__FieldTag::__travel_distance_meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_distance_meters",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.travel_distance_meters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__traffic_info_unavailable => {
                            if !fields.insert(__FieldTag::__traffic_info_unavailable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traffic_info_unavailable",
                                ));
                            }
                            result.traffic_info_unavailable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delay_duration => {
                            if !fields.insert(__FieldTag::__delay_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delay_duration",
                                ));
                            }
                            result.delay_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__break_duration => {
                            if !fields.insert(__FieldTag::__break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_duration",
                                ));
                            }
                            result.break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__wait_duration => {
                            if !fields.insert(__FieldTag::__wait_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_duration",
                                ));
                            }
                            result.wait_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__total_duration => {
                            if !fields.insert(__FieldTag::__total_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_duration",
                                ));
                            }
                            result.total_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__route_polyline => {
                            if !fields.insert(__FieldTag::__route_polyline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_polyline",
                                ));
                            }
                            result.route_polyline = map.next_value::<std::option::Option<
                                crate::model::shipment_route::EncodedPolyline,
                            >>()?;
                        }
                        __FieldTag::__vehicle_loads => {
                            if !fields.insert(__FieldTag::__vehicle_loads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_loads",
                                ));
                            }
                            result.vehicle_loads = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::shipment_route::VehicleLoad,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__loads => {
                            if !fields.insert(__FieldTag::__loads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for loads",
                                ));
                            }
                            result.loads =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CapacityQuantity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::VehicleLoad {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __amount,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VehicleLoad")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "amount" => Ok(__FieldTag::__amount),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::VehicleLoad;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VehicleLoad")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__amount => {
                            if !fields.insert(__FieldTag::__amount) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for amount",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.amount = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::EncodedPolyline {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __points,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncodedPolyline")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "points" => Ok(__FieldTag::__points),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::EncodedPolyline;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncodedPolyline")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__points => {
                            if !fields.insert(__FieldTag::__points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for points",
                                ));
                            }
                            result.points = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::Break {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Break")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::Break;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Break")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::shipment_route::TravelStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __duration,
            __distance_meters,
            __traffic_info_unavailable,
            __route_polyline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TravelStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "duration" => Ok(__FieldTag::__duration),
                            "distanceMeters" => Ok(__FieldTag::__distance_meters),
                            "distance_meters" => Ok(__FieldTag::__distance_meters),
                            "trafficInfoUnavailable" => Ok(__FieldTag::__traffic_info_unavailable),
                            "traffic_info_unavailable" => {
                                Ok(__FieldTag::__traffic_info_unavailable)
                            }
                            "routePolyline" => Ok(__FieldTag::__route_polyline),
                            "route_polyline" => Ok(__FieldTag::__route_polyline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::shipment_route::TravelStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TravelStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__distance_meters => {
                            if !fields.insert(__FieldTag::__distance_meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_meters",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.distance_meters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__traffic_info_unavailable => {
                            if !fields.insert(__FieldTag::__traffic_info_unavailable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traffic_info_unavailable",
                                ));
                            }
                            result.traffic_info_unavailable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__route_polyline => {
                            if !fields.insert(__FieldTag::__route_polyline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_polyline",
                                ));
                            }
                            result.route_polyline = map.next_value::<std::option::Option<
                                crate::model::shipment_route::EncodedPolyline,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SkippedShipment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __label,
            __reasons,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SkippedShipment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "label" => Ok(__FieldTag::__label),
                            "reasons" => Ok(__FieldTag::__reasons),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SkippedShipment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SkippedShipment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reasons => {
                            if !fields.insert(__FieldTag::__reasons) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reasons",
                                ));
                            }
                            result.reasons = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::skipped_shipment::Reason>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::skipped_shipment::Reason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __example_vehicle_index,
            __example_exceeded_capacity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Reason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "exampleVehicleIndex" => Ok(__FieldTag::__example_vehicle_index),
                            "example_vehicle_index" => Ok(__FieldTag::__example_vehicle_index),
                            "exampleExceededCapacityType" => {
                                Ok(__FieldTag::__example_exceeded_capacity_type)
                            }
                            "example_exceeded_capacity_type" => {
                                Ok(__FieldTag::__example_exceeded_capacity_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::skipped_shipment::Reason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Reason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code =
                                map.next_value::<std::option::Option<
                                    crate::model::skipped_shipment::reason::Code,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__example_vehicle_index => {
                            if !fields.insert(__FieldTag::__example_vehicle_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example_vehicle_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.example_vehicle_index = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__example_exceeded_capacity_type => {
                            if !fields.insert(__FieldTag::__example_exceeded_capacity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example_exceeded_capacity_type",
                                ));
                            }
                            result.example_exceeded_capacity_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AggregatedMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __performed_shipment_count,
            __travel_duration,
            __wait_duration,
            __delay_duration,
            __break_duration,
            __visit_duration,
            __total_duration,
            __travel_distance_meters,
            __max_loads,
            __costs,
            __total_cost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregatedMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "performedShipmentCount" => Ok(__FieldTag::__performed_shipment_count),
                            "performed_shipment_count" => {
                                Ok(__FieldTag::__performed_shipment_count)
                            }
                            "travelDuration" => Ok(__FieldTag::__travel_duration),
                            "travel_duration" => Ok(__FieldTag::__travel_duration),
                            "waitDuration" => Ok(__FieldTag::__wait_duration),
                            "wait_duration" => Ok(__FieldTag::__wait_duration),
                            "delayDuration" => Ok(__FieldTag::__delay_duration),
                            "delay_duration" => Ok(__FieldTag::__delay_duration),
                            "breakDuration" => Ok(__FieldTag::__break_duration),
                            "break_duration" => Ok(__FieldTag::__break_duration),
                            "visitDuration" => Ok(__FieldTag::__visit_duration),
                            "visit_duration" => Ok(__FieldTag::__visit_duration),
                            "totalDuration" => Ok(__FieldTag::__total_duration),
                            "total_duration" => Ok(__FieldTag::__total_duration),
                            "travelDistanceMeters" => Ok(__FieldTag::__travel_distance_meters),
                            "travel_distance_meters" => Ok(__FieldTag::__travel_distance_meters),
                            "maxLoads" => Ok(__FieldTag::__max_loads),
                            "max_loads" => Ok(__FieldTag::__max_loads),
                            "costs" => Ok(__FieldTag::__costs),
                            "totalCost" => Ok(__FieldTag::__total_cost),
                            "total_cost" => Ok(__FieldTag::__total_cost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AggregatedMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregatedMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__performed_shipment_count => {
                            if !fields.insert(__FieldTag::__performed_shipment_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performed_shipment_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.performed_shipment_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__travel_duration => {
                            if !fields.insert(__FieldTag::__travel_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_duration",
                                ));
                            }
                            result.travel_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__wait_duration => {
                            if !fields.insert(__FieldTag::__wait_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for wait_duration",
                                ));
                            }
                            result.wait_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__delay_duration => {
                            if !fields.insert(__FieldTag::__delay_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delay_duration",
                                ));
                            }
                            result.delay_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__break_duration => {
                            if !fields.insert(__FieldTag::__break_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for break_duration",
                                ));
                            }
                            result.break_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__visit_duration => {
                            if !fields.insert(__FieldTag::__visit_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visit_duration",
                                ));
                            }
                            result.visit_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__total_duration => {
                            if !fields.insert(__FieldTag::__total_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_duration",
                                ));
                            }
                            result.total_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__travel_distance_meters => {
                            if !fields.insert(__FieldTag::__travel_distance_meters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_distance_meters",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.travel_distance_meters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_loads => {
                            if !fields.insert(__FieldTag::__max_loads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_loads",
                                ));
                            }
                            result.max_loads = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::shipment_route::VehicleLoad,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__costs => {
                            if !fields.insert(__FieldTag::__costs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for costs",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, f64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::F64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.costs = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_cost => {
                            if !fields.insert(__FieldTag::__total_cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_cost",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InjectedSolutionConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __routes,
            __skipped_shipments,
            __constraint_relaxations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InjectedSolutionConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "routes" => Ok(__FieldTag::__routes),
                            "skippedShipments" => Ok(__FieldTag::__skipped_shipments),
                            "skipped_shipments" => Ok(__FieldTag::__skipped_shipments),
                            "constraintRelaxations" => Ok(__FieldTag::__constraint_relaxations),
                            "constraint_relaxations" => Ok(__FieldTag::__constraint_relaxations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InjectedSolutionConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InjectedSolutionConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__routes => {
                            if !fields.insert(__FieldTag::__routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for routes",
                                ));
                            }
                            result.routes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ShipmentRoute>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__skipped_shipments => {
                            if !fields.insert(__FieldTag::__skipped_shipments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skipped_shipments",
                                ));
                            }
                            result.skipped_shipments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SkippedShipment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__constraint_relaxations => {
                            if !fields.insert(__FieldTag::__constraint_relaxations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint_relaxations",
                                ));
                            }
                            result.constraint_relaxations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::injected_solution_constraint::ConstraintRelaxation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::injected_solution_constraint::ConstraintRelaxation
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __relaxations,
            __vehicle_indices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConstraintRelaxation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relaxations" => Ok(__FieldTag::__relaxations),
                            "vehicleIndices" => Ok(__FieldTag::__vehicle_indices),
                            "vehicle_indices" => Ok(__FieldTag::__vehicle_indices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::injected_solution_constraint::ConstraintRelaxation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConstraintRelaxation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__relaxations => {
                            if !fields.insert(__FieldTag::__relaxations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relaxations",
                                ));
                            }
                            result.relaxations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::injected_solution_constraint::constraint_relaxation::Relaxation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vehicle_indices => {
                            if !fields.insert(__FieldTag::__vehicle_indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vehicle_indices",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.vehicle_indices =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::injected_solution_constraint::constraint_relaxation::Relaxation
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __level,
            __threshold_time,
            __threshold_visit_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Relaxation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "level" => Ok(__FieldTag::__level),
                            "thresholdTime" => Ok(__FieldTag::__threshold_time),
                            "threshold_time" => Ok(__FieldTag::__threshold_time),
                            "thresholdVisitCount" => Ok(__FieldTag::__threshold_visit_count),
                            "threshold_visit_count" => Ok(__FieldTag::__threshold_visit_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::injected_solution_constraint::constraint_relaxation::Relaxation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Relaxation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__level => {
                            if !fields.insert(__FieldTag::__level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for level",
                                ));
                            }
                            result.level = map.next_value::<std::option::Option<crate::model::injected_solution_constraint::constraint_relaxation::relaxation::Level>>()?.unwrap_or_default();
                        }
                        __FieldTag::__threshold_time => {
                            if !fields.insert(__FieldTag::__threshold_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold_time",
                                ));
                            }
                            result.threshold_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__threshold_visit_count => {
                            if !fields.insert(__FieldTag::__threshold_visit_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threshold_visit_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threshold_visit_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OptimizeToursValidationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __display_name,
            __fields,
            __error_message,
            __offending_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OptimizeToursValidationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "fields" => Ok(__FieldTag::__fields),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "offendingValues" => Ok(__FieldTag::__offending_values),
                            "offending_values" => Ok(__FieldTag::__offending_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OptimizeToursValidationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OptimizeToursValidationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<crate::model::optimize_tours_validation_error::FieldReference>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offending_values => {
                            if !fields.insert(__FieldTag::__offending_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offending_values",
                                ));
                            }
                            result.offending_values = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::optimize_tours_validation_error::FieldReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __index,
            __key,
            __sub_field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FieldReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "index" => Ok(__FieldTag::__index),
                            "key" => Ok(__FieldTag::__key),
                            "subField" => Ok(__FieldTag::__sub_field),
                            "sub_field" => Ok(__FieldTag::__sub_field),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::optimize_tours_validation_error::FieldReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FieldReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.index_or_key.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `index_or_key`, a oneof with full ID .google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference.index, latest field was index",
                                ));
                            }
                            result.index_or_key = std::option::Option::Some(
                                crate::model::optimize_tours_validation_error::field_reference::IndexOrKey::Index(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            if result.index_or_key.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `index_or_key`, a oneof with full ID .google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference.key, latest field was key",
                                ));
                            }
                            result.index_or_key = std::option::Option::Some(
                                crate::model::optimize_tours_validation_error::field_reference::IndexOrKey::Key(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sub_field => {
                            if !fields.insert(__FieldTag::__sub_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sub_field",
                                ));
                            }
                            result.sub_field = map.next_value::<std::option::Option<
                                std::boxed::Box<
                                    crate::model::optimize_tours_validation_error::FieldReference,
                                >,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
