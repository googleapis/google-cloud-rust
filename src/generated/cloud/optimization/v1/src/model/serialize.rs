// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AsyncModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OptimizeToursRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if self.model.is_some() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.solving_mode) {
            state.serialize_entry("solvingMode", &self.solving_mode)?;
        }
        if !wkt::internal::is_default(&self.search_mode) {
            state.serialize_entry("searchMode", &self.search_mode)?;
        }
        if !self.injected_first_solution_routes.is_empty() {
            state.serialize_entry("injectedFirstSolutionRoutes", &self.injected_first_solution_routes)?;
        }
        if self.injected_solution_constraint.is_some() {
            state.serialize_entry("injectedSolutionConstraint", &self.injected_solution_constraint)?;
        }
        if !self.refresh_details_routes.is_empty() {
            state.serialize_entry("refreshDetailsRoutes", &self.refresh_details_routes)?;
        }
        if !wkt::internal::is_default(&self.interpret_injected_solutions_using_labels) {
            state.serialize_entry("interpretInjectedSolutionsUsingLabels", &self.interpret_injected_solutions_using_labels)?;
        }
        if !wkt::internal::is_default(&self.consider_road_traffic) {
            state.serialize_entry("considerRoadTraffic", &self.consider_road_traffic)?;
        }
        if !wkt::internal::is_default(&self.populate_polylines) {
            state.serialize_entry("populatePolylines", &self.populate_polylines)?;
        }
        if !wkt::internal::is_default(&self.populate_transition_polylines) {
            state.serialize_entry("populateTransitionPolylines", &self.populate_transition_polylines)?;
        }
        if !wkt::internal::is_default(&self.allow_large_deadline_despite_interruption_risk) {
            state.serialize_entry("allowLargeDeadlineDespiteInterruptionRisk", &self.allow_large_deadline_despite_interruption_risk)?;
        }
        if !wkt::internal::is_default(&self.use_geodesic_distances) {
            state.serialize_entry("useGeodesicDistances", &self.use_geodesic_distances)?;
        }
        if self.geodesic_meters_per_second.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("geodesicMetersPerSecond", &__With(&self.geodesic_meters_per_second))?;
        }
        if self.max_validation_errors.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxValidationErrors", &__With(&self.max_validation_errors))?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !wkt::internal::is_default(&self.populate_travel_step_polylines) {
            state.serialize_entry("populateTravelStepPolylines", &self.populate_travel_step_polylines)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OptimizeToursResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.routes.is_empty() {
            state.serialize_entry("routes", &self.routes)?;
        }
        if !self.request_label.is_empty() {
            state.serialize_entry("requestLabel", &self.request_label)?;
        }
        if !self.skipped_shipments.is_empty() {
            state.serialize_entry("skippedShipments", &self.skipped_shipments)?;
        }
        if !self.validation_errors.is_empty() {
            state.serialize_entry("validationErrors", &self.validation_errors)?;
        }
        if self.metrics.is_some() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !wkt::internal::is_default(&self.total_cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCost", &__With(&self.total_cost))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::optimize_tours_response::Metrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aggregated_route_metrics.is_some() {
            state.serialize_entry("aggregatedRouteMetrics", &self.aggregated_route_metrics)?;
        }
        if !wkt::internal::is_default(&self.skipped_mandatory_shipment_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("skippedMandatoryShipmentCount", &__With(&self.skipped_mandatory_shipment_count))?;
        }
        if !wkt::internal::is_default(&self.used_vehicle_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("usedVehicleCount", &__With(&self.used_vehicle_count))?;
        }
        if self.earliest_vehicle_start_time.is_some() {
            state.serialize_entry("earliestVehicleStartTime", &self.earliest_vehicle_start_time)?;
        }
        if self.latest_vehicle_end_time.is_some() {
            state.serialize_entry("latestVehicleEndTime", &self.latest_vehicle_end_time)?;
        }
        if !self.costs.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String,f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costs", &__With(&self.costs))?;
        }
        if !wkt::internal::is_default(&self.total_cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCost", &__With(&self.total_cost))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BatchOptimizeToursRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.model_configs.is_empty() {
            state.serialize_entry("modelConfigs", &self.model_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::batch_optimize_tours_request::AsyncModelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !wkt::internal::is_default(&self.enable_checkpoints) {
            state.serialize_entry("enableCheckpoints", &self.enable_checkpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BatchOptimizeToursResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShipmentModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.shipments.is_empty() {
            state.serialize_entry("shipments", &self.shipments)?;
        }
        if !self.vehicles.is_empty() {
            state.serialize_entry("vehicles", &self.vehicles)?;
        }
        if self.max_active_vehicles.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxActiveVehicles", &__With(&self.max_active_vehicles))?;
        }
        if self.global_start_time.is_some() {
            state.serialize_entry("globalStartTime", &self.global_start_time)?;
        }
        if self.global_end_time.is_some() {
            state.serialize_entry("globalEndTime", &self.global_end_time)?;
        }
        if !wkt::internal::is_default(&self.global_duration_cost_per_hour) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("globalDurationCostPerHour", &__With(&self.global_duration_cost_per_hour))?;
        }
        if !self.duration_distance_matrices.is_empty() {
            state.serialize_entry("durationDistanceMatrices", &self.duration_distance_matrices)?;
        }
        if !self.duration_distance_matrix_src_tags.is_empty() {
            state.serialize_entry("durationDistanceMatrixSrcTags", &self.duration_distance_matrix_src_tags)?;
        }
        if !self.duration_distance_matrix_dst_tags.is_empty() {
            state.serialize_entry("durationDistanceMatrixDstTags", &self.duration_distance_matrix_dst_tags)?;
        }
        if !self.transition_attributes.is_empty() {
            state.serialize_entry("transitionAttributes", &self.transition_attributes)?;
        }
        if !self.shipment_type_incompatibilities.is_empty() {
            state.serialize_entry("shipmentTypeIncompatibilities", &self.shipment_type_incompatibilities)?;
        }
        if !self.shipment_type_requirements.is_empty() {
            state.serialize_entry("shipmentTypeRequirements", &self.shipment_type_requirements)?;
        }
        if !self.precedence_rules.is_empty() {
            state.serialize_entry("precedenceRules", &self.precedence_rules)?;
        }
        if !self.break_rules.is_empty() {
            state.serialize_entry("breakRules", &self.break_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::DurationDistanceMatrix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if !self.vehicle_start_tag.is_empty() {
            state.serialize_entry("vehicleStartTag", &self.vehicle_start_tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::duration_distance_matrix::Row {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.durations.is_empty() {
            state.serialize_entry("durations", &self.durations)?;
        }
        if !self.meters.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("meters", &__With(&self.meters))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::PrecedenceRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.first_index.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("firstIndex", &__With(&self.first_index))?;
        }
        if !wkt::internal::is_default(&self.first_is_delivery) {
            state.serialize_entry("firstIsDelivery", &self.first_is_delivery)?;
        }
        if self.second_index.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("secondIndex", &__With(&self.second_index))?;
        }
        if !wkt::internal::is_default(&self.second_is_delivery) {
            state.serialize_entry("secondIsDelivery", &self.second_is_delivery)?;
        }
        if self.offset_duration.is_some() {
            state.serialize_entry("offsetDuration", &self.offset_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::BreakRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.break_requests.is_empty() {
            state.serialize_entry("breakRequests", &self.break_requests)?;
        }
        if !self.frequency_constraints.is_empty() {
            state.serialize_entry("frequencyConstraints", &self.frequency_constraints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::break_rule::BreakRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.earliest_start_time.is_some() {
            state.serialize_entry("earliestStartTime", &self.earliest_start_time)?;
        }
        if self.latest_start_time.is_some() {
            state.serialize_entry("latestStartTime", &self.latest_start_time)?;
        }
        if self.min_duration.is_some() {
            state.serialize_entry("minDuration", &self.min_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_model::break_rule::FrequencyConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_break_duration.is_some() {
            state.serialize_entry("minBreakDuration", &self.min_break_duration)?;
        }
        if self.max_inter_break_duration.is_some() {
            state.serialize_entry("maxInterBreakDuration", &self.max_inter_break_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Shipment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pickups.is_empty() {
            state.serialize_entry("pickups", &self.pickups)?;
        }
        if !self.deliveries.is_empty() {
            state.serialize_entry("deliveries", &self.deliveries)?;
        }
        if !self.load_demands.is_empty() {
            state.serialize_entry("loadDemands", &self.load_demands)?;
        }
        if self.penalty_cost.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("penaltyCost", &__With(&self.penalty_cost))?;
        }
        if !self.allowed_vehicle_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("allowedVehicleIndices", &__With(&self.allowed_vehicle_indices))?;
        }
        if !self.costs_per_vehicle.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costsPerVehicle", &__With(&self.costs_per_vehicle))?;
        }
        if !self.costs_per_vehicle_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costsPerVehicleIndices", &__With(&self.costs_per_vehicle_indices))?;
        }
        if self.pickup_to_delivery_relative_detour_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pickupToDeliveryRelativeDetourLimit", &__With(&self.pickup_to_delivery_relative_detour_limit))?;
        }
        if self.pickup_to_delivery_absolute_detour_limit.is_some() {
            state.serialize_entry("pickupToDeliveryAbsoluteDetourLimit", &self.pickup_to_delivery_absolute_detour_limit)?;
        }
        if self.pickup_to_delivery_time_limit.is_some() {
            state.serialize_entry("pickupToDeliveryTimeLimit", &self.pickup_to_delivery_time_limit)?;
        }
        if !self.shipment_type.is_empty() {
            state.serialize_entry("shipmentType", &self.shipment_type)?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !wkt::internal::is_default(&self.ignore) {
            state.serialize_entry("ignore", &self.ignore)?;
        }
        if !self.demands.is_empty() {
            state.serialize_entry("demands", &self.demands)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment::VisitRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.arrival_location.is_some() {
            state.serialize_entry("arrivalLocation", &self.arrival_location)?;
        }
        if self.arrival_waypoint.is_some() {
            state.serialize_entry("arrivalWaypoint", &self.arrival_waypoint)?;
        }
        if self.departure_location.is_some() {
            state.serialize_entry("departureLocation", &self.departure_location)?;
        }
        if self.departure_waypoint.is_some() {
            state.serialize_entry("departureWaypoint", &self.departure_waypoint)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.time_windows.is_empty() {
            state.serialize_entry("timeWindows", &self.time_windows)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !wkt::internal::is_default(&self.cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cost", &__With(&self.cost))?;
        }
        if !self.load_demands.is_empty() {
            state.serialize_entry("loadDemands", &self.load_demands)?;
        }
        if !self.visit_types.is_empty() {
            state.serialize_entry("visitTypes", &self.visit_types)?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self.demands.is_empty() {
            state.serialize_entry("demands", &self.demands)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment::Load {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.amount) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("amount", &__With(&self.amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}


#[doc(hidden)]
impl serde::ser::Serialize for super::ShipmentTypeIncompatibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !wkt::internal::is_default(&self.incompatibility_mode) {
            state.serialize_entry("incompatibilityMode", &self.incompatibility_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShipmentTypeRequirement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.required_shipment_type_alternatives.is_empty() {
            state.serialize_entry("requiredShipmentTypeAlternatives", &self.required_shipment_type_alternatives)?;
        }
        if !self.dependent_shipment_types.is_empty() {
            state.serialize_entry("dependentShipmentTypes", &self.dependent_shipment_types)?;
        }
        if !wkt::internal::is_default(&self.requirement_mode) {
            state.serialize_entry("requirementMode", &self.requirement_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RouteModifiers {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.avoid_tolls) {
            state.serialize_entry("avoidTolls", &self.avoid_tolls)?;
        }
        if !wkt::internal::is_default(&self.avoid_highways) {
            state.serialize_entry("avoidHighways", &self.avoid_highways)?;
        }
        if !wkt::internal::is_default(&self.avoid_ferries) {
            state.serialize_entry("avoidFerries", &self.avoid_ferries)?;
        }
        if !wkt::internal::is_default(&self.avoid_indoor) {
            state.serialize_entry("avoidIndoor", &self.avoid_indoor)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Vehicle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.travel_mode) {
            state.serialize_entry("travelMode", &self.travel_mode)?;
        }
        if self.route_modifiers.is_some() {
            state.serialize_entry("routeModifiers", &self.route_modifiers)?;
        }
        if self.start_location.is_some() {
            state.serialize_entry("startLocation", &self.start_location)?;
        }
        if self.start_waypoint.is_some() {
            state.serialize_entry("startWaypoint", &self.start_waypoint)?;
        }
        if self.end_location.is_some() {
            state.serialize_entry("endLocation", &self.end_location)?;
        }
        if self.end_waypoint.is_some() {
            state.serialize_entry("endWaypoint", &self.end_waypoint)?;
        }
        if !self.start_tags.is_empty() {
            state.serialize_entry("startTags", &self.start_tags)?;
        }
        if !self.end_tags.is_empty() {
            state.serialize_entry("endTags", &self.end_tags)?;
        }
        if !self.start_time_windows.is_empty() {
            state.serialize_entry("startTimeWindows", &self.start_time_windows)?;
        }
        if !self.end_time_windows.is_empty() {
            state.serialize_entry("endTimeWindows", &self.end_time_windows)?;
        }
        if self.travel_duration_multiple.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("travelDurationMultiple", &__With(&self.travel_duration_multiple))?;
        }
        if !wkt::internal::is_default(&self.unloading_policy) {
            state.serialize_entry("unloadingPolicy", &self.unloading_policy)?;
        }
        if !self.load_limits.is_empty() {
            state.serialize_entry("loadLimits", &self.load_limits)?;
        }
        if !wkt::internal::is_default(&self.cost_per_hour) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerHour", &__With(&self.cost_per_hour))?;
        }
        if !wkt::internal::is_default(&self.cost_per_traveled_hour) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerTraveledHour", &__With(&self.cost_per_traveled_hour))?;
        }
        if !wkt::internal::is_default(&self.cost_per_kilometer) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerKilometer", &__With(&self.cost_per_kilometer))?;
        }
        if !wkt::internal::is_default(&self.fixed_cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fixedCost", &__With(&self.fixed_cost))?;
        }
        if !wkt::internal::is_default(&self.used_if_route_is_empty) {
            state.serialize_entry("usedIfRouteIsEmpty", &self.used_if_route_is_empty)?;
        }
        if self.route_duration_limit.is_some() {
            state.serialize_entry("routeDurationLimit", &self.route_duration_limit)?;
        }
        if self.travel_duration_limit.is_some() {
            state.serialize_entry("travelDurationLimit", &self.travel_duration_limit)?;
        }
        if self.route_distance_limit.is_some() {
            state.serialize_entry("routeDistanceLimit", &self.route_distance_limit)?;
        }
        if !self.extra_visit_duration_for_visit_type.is_empty() {
            state.serialize_entry("extraVisitDurationForVisitType", &self.extra_visit_duration_for_visit_type)?;
        }
        if self.break_rule.is_some() {
            state.serialize_entry("breakRule", &self.break_rule)?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !wkt::internal::is_default(&self.ignore) {
            state.serialize_entry("ignore", &self.ignore)?;
        }
        if !self.break_rule_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("breakRuleIndices", &__With(&self.break_rule_indices))?;
        }
        if !self.capacities.is_empty() {
            state.serialize_entry("capacities", &self.capacities)?;
        }
        if !self.start_load_intervals.is_empty() {
            state.serialize_entry("startLoadIntervals", &self.start_load_intervals)?;
        }
        if !self.end_load_intervals.is_empty() {
            state.serialize_entry("endLoadIntervals", &self.end_load_intervals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::vehicle::LoadLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_load.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxLoad", &__With(&self.max_load))?;
        }
        if !wkt::internal::is_default(&self.soft_max_load) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("softMaxLoad", &__With(&self.soft_max_load))?;
        }
        if !wkt::internal::is_default(&self.cost_per_unit_above_soft_max) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerUnitAboveSoftMax", &__With(&self.cost_per_unit_above_soft_max))?;
        }
        if self.start_load_interval.is_some() {
            state.serialize_entry("startLoadInterval", &self.start_load_interval)?;
        }
        if self.end_load_interval.is_some() {
            state.serialize_entry("endLoadInterval", &self.end_load_interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::vehicle::load_limit::Interval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if self.max.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::vehicle::DurationLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_duration.is_some() {
            state.serialize_entry("maxDuration", &self.max_duration)?;
        }
        if self.soft_max_duration.is_some() {
            state.serialize_entry("softMaxDuration", &self.soft_max_duration)?;
        }
        if self.cost_per_hour_after_soft_max.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerHourAfterSoftMax", &__With(&self.cost_per_hour_after_soft_max))?;
        }
        if self.quadratic_soft_max_duration.is_some() {
            state.serialize_entry("quadraticSoftMaxDuration", &self.quadratic_soft_max_duration)?;
        }
        if self.cost_per_square_hour_after_quadratic_soft_max.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerSquareHourAfterQuadraticSoftMax", &__With(&self.cost_per_square_hour_after_quadratic_soft_max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}



#[doc(hidden)]
impl serde::ser::Serialize for super::TimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.soft_start_time.is_some() {
            state.serialize_entry("softStartTime", &self.soft_start_time)?;
        }
        if self.soft_end_time.is_some() {
            state.serialize_entry("softEndTime", &self.soft_end_time)?;
        }
        if self.cost_per_hour_before_soft_start_time.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerHourBeforeSoftStartTime", &__With(&self.cost_per_hour_before_soft_start_time))?;
        }
        if self.cost_per_hour_after_soft_end_time.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerHourAfterSoftEndTime", &__With(&self.cost_per_hour_after_soft_end_time))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CapacityQuantity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CapacityQuantityInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.min_value.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minValue", &__With(&self.min_value))?;
        }
        if self.max_value.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxValue", &__With(&self.max_value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DistanceLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_meters.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxMeters", &__With(&self.max_meters))?;
        }
        if self.soft_max_meters.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("softMaxMeters", &__With(&self.soft_max_meters))?;
        }
        if self.cost_per_kilometer_below_soft_max.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerKilometerBelowSoftMax", &__With(&self.cost_per_kilometer_below_soft_max))?;
        }
        if self.cost_per_kilometer_above_soft_max.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerKilometerAboveSoftMax", &__With(&self.cost_per_kilometer_above_soft_max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::TransitionAttributes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.src_tag.is_empty() {
            state.serialize_entry("srcTag", &self.src_tag)?;
        }
        if !self.excluded_src_tag.is_empty() {
            state.serialize_entry("excludedSrcTag", &self.excluded_src_tag)?;
        }
        if !self.dst_tag.is_empty() {
            state.serialize_entry("dstTag", &self.dst_tag)?;
        }
        if !self.excluded_dst_tag.is_empty() {
            state.serialize_entry("excludedDstTag", &self.excluded_dst_tag)?;
        }
        if !wkt::internal::is_default(&self.cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cost", &__With(&self.cost))?;
        }
        if !wkt::internal::is_default(&self.cost_per_kilometer) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costPerKilometer", &__With(&self.cost_per_kilometer))?;
        }
        if self.distance_limit.is_some() {
            state.serialize_entry("distanceLimit", &self.distance_limit)?;
        }
        if self.delay.is_some() {
            state.serialize_entry("delay", &self.delay)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Waypoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.location() {
            state.serialize_entry("location", value)?;
        }
        if let Some(value) = self.place_id() {
            state.serialize_entry("placeId", value)?;
        }
        if !wkt::internal::is_default(&self.side_of_road) {
            state.serialize_entry("sideOfRoad", &self.side_of_road)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Location {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lat_lng.is_some() {
            state.serialize_entry("latLng", &self.lat_lng)?;
        }
        if self.heading.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("heading", &__With(&self.heading))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BreakRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.break_requests.is_empty() {
            state.serialize_entry("breakRequests", &self.break_requests)?;
        }
        if !self.frequency_constraints.is_empty() {
            state.serialize_entry("frequencyConstraints", &self.frequency_constraints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::break_rule::BreakRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.earliest_start_time.is_some() {
            state.serialize_entry("earliestStartTime", &self.earliest_start_time)?;
        }
        if self.latest_start_time.is_some() {
            state.serialize_entry("latestStartTime", &self.latest_start_time)?;
        }
        if self.min_duration.is_some() {
            state.serialize_entry("minDuration", &self.min_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::break_rule::FrequencyConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_break_duration.is_some() {
            state.serialize_entry("minBreakDuration", &self.min_break_duration)?;
        }
        if self.max_inter_break_duration.is_some() {
            state.serialize_entry("maxInterBreakDuration", &self.max_inter_break_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShipmentRoute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.vehicle_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vehicleIndex", &__With(&self.vehicle_index))?;
        }
        if !self.vehicle_label.is_empty() {
            state.serialize_entry("vehicleLabel", &self.vehicle_label)?;
        }
        if self.vehicle_start_time.is_some() {
            state.serialize_entry("vehicleStartTime", &self.vehicle_start_time)?;
        }
        if self.vehicle_end_time.is_some() {
            state.serialize_entry("vehicleEndTime", &self.vehicle_end_time)?;
        }
        if !self.visits.is_empty() {
            state.serialize_entry("visits", &self.visits)?;
        }
        if !self.transitions.is_empty() {
            state.serialize_entry("transitions", &self.transitions)?;
        }
        if !wkt::internal::is_default(&self.has_traffic_infeasibilities) {
            state.serialize_entry("hasTrafficInfeasibilities", &self.has_traffic_infeasibilities)?;
        }
        if self.route_polyline.is_some() {
            state.serialize_entry("routePolyline", &self.route_polyline)?;
        }
        if !self.breaks.is_empty() {
            state.serialize_entry("breaks", &self.breaks)?;
        }
        if self.metrics.is_some() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self.route_costs.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String,f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("routeCosts", &__With(&self.route_costs))?;
        }
        if !wkt::internal::is_default(&self.route_total_cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("routeTotalCost", &__With(&self.route_total_cost))?;
        }
        if !self.end_loads.is_empty() {
            state.serialize_entry("endLoads", &self.end_loads)?;
        }
        if !self.travel_steps.is_empty() {
            state.serialize_entry("travelSteps", &self.travel_steps)?;
        }
        if self.vehicle_detour.is_some() {
            state.serialize_entry("vehicleDetour", &self.vehicle_detour)?;
        }
        if self.delay_before_vehicle_end.is_some() {
            state.serialize_entry("delayBeforeVehicleEnd", &self.delay_before_vehicle_end)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::Delay {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::Visit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.shipment_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shipmentIndex", &__With(&self.shipment_index))?;
        }
        if !wkt::internal::is_default(&self.is_pickup) {
            state.serialize_entry("isPickup", &self.is_pickup)?;
        }
        if !wkt::internal::is_default(&self.visit_request_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("visitRequestIndex", &__With(&self.visit_request_index))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.load_demands.is_empty() {
            state.serialize_entry("loadDemands", &self.load_demands)?;
        }
        if self.detour.is_some() {
            state.serialize_entry("detour", &self.detour)?;
        }
        if !self.shipment_label.is_empty() {
            state.serialize_entry("shipmentLabel", &self.shipment_label)?;
        }
        if !self.visit_label.is_empty() {
            state.serialize_entry("visitLabel", &self.visit_label)?;
        }
        if !self.arrival_loads.is_empty() {
            state.serialize_entry("arrivalLoads", &self.arrival_loads)?;
        }
        if self.delay_before_start.is_some() {
            state.serialize_entry("delayBeforeStart", &self.delay_before_start)?;
        }
        if !self.demands.is_empty() {
            state.serialize_entry("demands", &self.demands)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::Transition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.travel_duration.is_some() {
            state.serialize_entry("travelDuration", &self.travel_duration)?;
        }
        if !wkt::internal::is_default(&self.travel_distance_meters) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("travelDistanceMeters", &__With(&self.travel_distance_meters))?;
        }
        if !wkt::internal::is_default(&self.traffic_info_unavailable) {
            state.serialize_entry("trafficInfoUnavailable", &self.traffic_info_unavailable)?;
        }
        if self.delay_duration.is_some() {
            state.serialize_entry("delayDuration", &self.delay_duration)?;
        }
        if self.break_duration.is_some() {
            state.serialize_entry("breakDuration", &self.break_duration)?;
        }
        if self.wait_duration.is_some() {
            state.serialize_entry("waitDuration", &self.wait_duration)?;
        }
        if self.total_duration.is_some() {
            state.serialize_entry("totalDuration", &self.total_duration)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.route_polyline.is_some() {
            state.serialize_entry("routePolyline", &self.route_polyline)?;
        }
        if !self.vehicle_loads.is_empty() {
            state.serialize_entry("vehicleLoads", &self.vehicle_loads)?;
        }
        if !self.loads.is_empty() {
            state.serialize_entry("loads", &self.loads)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::VehicleLoad {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.amount) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("amount", &__With(&self.amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::EncodedPolyline {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.points.is_empty() {
            state.serialize_entry("points", &self.points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::Break {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::shipment_route::TravelStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !wkt::internal::is_default(&self.distance_meters) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("distanceMeters", &__With(&self.distance_meters))?;
        }
        if !wkt::internal::is_default(&self.traffic_info_unavailable) {
            state.serialize_entry("trafficInfoUnavailable", &self.traffic_info_unavailable)?;
        }
        if self.route_polyline.is_some() {
            state.serialize_entry("routePolyline", &self.route_polyline)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}


#[doc(hidden)]
impl serde::ser::Serialize for super::SkippedShipment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self.reasons.is_empty() {
            state.serialize_entry("reasons", &self.reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::skipped_shipment::Reason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if self.example_vehicle_index.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exampleVehicleIndex", &__With(&self.example_vehicle_index))?;
        }
        if !self.example_exceeded_capacity_type.is_empty() {
            state.serialize_entry("exampleExceededCapacityType", &self.example_exceeded_capacity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AggregatedMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.performed_shipment_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("performedShipmentCount", &__With(&self.performed_shipment_count))?;
        }
        if self.travel_duration.is_some() {
            state.serialize_entry("travelDuration", &self.travel_duration)?;
        }
        if self.wait_duration.is_some() {
            state.serialize_entry("waitDuration", &self.wait_duration)?;
        }
        if self.delay_duration.is_some() {
            state.serialize_entry("delayDuration", &self.delay_duration)?;
        }
        if self.break_duration.is_some() {
            state.serialize_entry("breakDuration", &self.break_duration)?;
        }
        if self.visit_duration.is_some() {
            state.serialize_entry("visitDuration", &self.visit_duration)?;
        }
        if self.total_duration.is_some() {
            state.serialize_entry("totalDuration", &self.total_duration)?;
        }
        if !wkt::internal::is_default(&self.travel_distance_meters) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("travelDistanceMeters", &__With(&self.travel_distance_meters))?;
        }
        if !self.max_loads.is_empty() {
            state.serialize_entry("maxLoads", &self.max_loads)?;
        }
        if !self.costs.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String,f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("costs", &__With(&self.costs))?;
        }
        if !wkt::internal::is_default(&self.total_cost) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCost", &__With(&self.total_cost))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::InjectedSolutionConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.routes.is_empty() {
            state.serialize_entry("routes", &self.routes)?;
        }
        if !self.skipped_shipments.is_empty() {
            state.serialize_entry("skippedShipments", &self.skipped_shipments)?;
        }
        if !self.constraint_relaxations.is_empty() {
            state.serialize_entry("constraintRelaxations", &self.constraint_relaxations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::injected_solution_constraint::ConstraintRelaxation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.relaxations.is_empty() {
            state.serialize_entry("relaxations", &self.relaxations)?;
        }
        if !self.vehicle_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::vec::Vec<wkt::internal::I32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vehicleIndices", &__With(&self.vehicle_indices))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::injected_solution_constraint::constraint_relaxation::Relaxation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.level) {
            state.serialize_entry("level", &self.level)?;
        }
        if self.threshold_time.is_some() {
            state.serialize_entry("thresholdTime", &self.threshold_time)?;
        }
        if !wkt::internal::is_default(&self.threshold_visit_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("thresholdVisitCount", &__With(&self.threshold_visit_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OptimizeToursValidationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("code", &__With(&self.code))?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self.offending_values.is_empty() {
            state.serialize_entry("offendingValues", &self.offending_values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::optimize_tours_validation_error::FieldReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.index() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(value))?;
        }
        if let Some(value) = self.key() {
            state.serialize_entry("key", value)?;
        }
        if self.sub_field.is_some() {
            state.serialize_entry("subField", &self.sub_field)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
