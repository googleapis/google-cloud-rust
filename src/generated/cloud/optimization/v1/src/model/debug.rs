// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::InputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputConfig");
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputConfig");
        debug_struct.field("data_format", &self.data_format);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsSource");
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDestination");
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AsyncModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncModelMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OptimizeToursRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OptimizeToursRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("model", &self.model);
        debug_struct.field("solving_mode", &self.solving_mode);
        debug_struct.field("search_mode", &self.search_mode);
        debug_struct.field(
            "injected_first_solution_routes",
            &self.injected_first_solution_routes,
        );
        debug_struct.field(
            "injected_solution_constraint",
            &self.injected_solution_constraint,
        );
        debug_struct.field("refresh_details_routes", &self.refresh_details_routes);
        debug_struct.field(
            "interpret_injected_solutions_using_labels",
            &self.interpret_injected_solutions_using_labels,
        );
        debug_struct.field("consider_road_traffic", &self.consider_road_traffic);
        debug_struct.field("populate_polylines", &self.populate_polylines);
        debug_struct.field(
            "populate_transition_polylines",
            &self.populate_transition_polylines,
        );
        debug_struct.field(
            "allow_large_deadline_despite_interruption_risk",
            &self.allow_large_deadline_despite_interruption_risk,
        );
        debug_struct.field("use_geodesic_distances", &self.use_geodesic_distances);
        debug_struct.field(
            "geodesic_meters_per_second",
            &self.geodesic_meters_per_second,
        );
        debug_struct.field("max_validation_errors", &self.max_validation_errors);
        debug_struct.field("label", &self.label);
        debug_struct.field(
            "populate_travel_step_polylines",
            &self.populate_travel_step_polylines,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OptimizeToursResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OptimizeToursResponse");
        debug_struct.field("routes", &self.routes);
        debug_struct.field("request_label", &self.request_label);
        debug_struct.field("skipped_shipments", &self.skipped_shipments);
        debug_struct.field("validation_errors", &self.validation_errors);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("total_cost", &self.total_cost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::optimize_tours_response::Metrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metrics");
        debug_struct.field("aggregated_route_metrics", &self.aggregated_route_metrics);
        debug_struct.field(
            "skipped_mandatory_shipment_count",
            &self.skipped_mandatory_shipment_count,
        );
        debug_struct.field("used_vehicle_count", &self.used_vehicle_count);
        debug_struct.field(
            "earliest_vehicle_start_time",
            &self.earliest_vehicle_start_time,
        );
        debug_struct.field("latest_vehicle_end_time", &self.latest_vehicle_end_time);
        debug_struct.field("costs", &self.costs);
        debug_struct.field("total_cost", &self.total_cost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchOptimizeToursRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchOptimizeToursRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("model_configs", &self.model_configs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::batch_optimize_tours_request::AsyncModelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncModelConfig");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("enable_checkpoints", &self.enable_checkpoints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchOptimizeToursResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchOptimizeToursResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShipmentModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShipmentModel");
        debug_struct.field("shipments", &self.shipments);
        debug_struct.field("vehicles", &self.vehicles);
        debug_struct.field("max_active_vehicles", &self.max_active_vehicles);
        debug_struct.field("global_start_time", &self.global_start_time);
        debug_struct.field("global_end_time", &self.global_end_time);
        debug_struct.field(
            "global_duration_cost_per_hour",
            &self.global_duration_cost_per_hour,
        );
        debug_struct.field(
            "duration_distance_matrices",
            &self.duration_distance_matrices,
        );
        debug_struct.field(
            "duration_distance_matrix_src_tags",
            &self.duration_distance_matrix_src_tags,
        );
        debug_struct.field(
            "duration_distance_matrix_dst_tags",
            &self.duration_distance_matrix_dst_tags,
        );
        debug_struct.field("transition_attributes", &self.transition_attributes);
        debug_struct.field(
            "shipment_type_incompatibilities",
            &self.shipment_type_incompatibilities,
        );
        debug_struct.field(
            "shipment_type_requirements",
            &self.shipment_type_requirements,
        );
        debug_struct.field("precedence_rules", &self.precedence_rules);
        debug_struct.field("break_rules", &self.break_rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::DurationDistanceMatrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DurationDistanceMatrix");
        debug_struct.field("rows", &self.rows);
        debug_struct.field("vehicle_start_tag", &self.vehicle_start_tag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::duration_distance_matrix::Row {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Row");
        debug_struct.field("durations", &self.durations);
        debug_struct.field("meters", &self.meters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::PrecedenceRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrecedenceRule");
        debug_struct.field("first_index", &self.first_index);
        debug_struct.field("first_is_delivery", &self.first_is_delivery);
        debug_struct.field("second_index", &self.second_index);
        debug_struct.field("second_is_delivery", &self.second_is_delivery);
        debug_struct.field("offset_duration", &self.offset_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::BreakRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BreakRule");
        debug_struct.field("break_requests", &self.break_requests);
        debug_struct.field("frequency_constraints", &self.frequency_constraints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::break_rule::BreakRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BreakRequest");
        debug_struct.field("earliest_start_time", &self.earliest_start_time);
        debug_struct.field("latest_start_time", &self.latest_start_time);
        debug_struct.field("min_duration", &self.min_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_model::break_rule::FrequencyConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrequencyConstraint");
        debug_struct.field("min_break_duration", &self.min_break_duration);
        debug_struct.field("max_inter_break_duration", &self.max_inter_break_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Shipment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Shipment");
        debug_struct.field("pickups", &self.pickups);
        debug_struct.field("deliveries", &self.deliveries);
        debug_struct.field("load_demands", &self.load_demands);
        debug_struct.field("penalty_cost", &self.penalty_cost);
        debug_struct.field("allowed_vehicle_indices", &self.allowed_vehicle_indices);
        debug_struct.field("costs_per_vehicle", &self.costs_per_vehicle);
        debug_struct.field("costs_per_vehicle_indices", &self.costs_per_vehicle_indices);
        debug_struct.field(
            "pickup_to_delivery_relative_detour_limit",
            &self.pickup_to_delivery_relative_detour_limit,
        );
        debug_struct.field(
            "pickup_to_delivery_absolute_detour_limit",
            &self.pickup_to_delivery_absolute_detour_limit,
        );
        debug_struct.field(
            "pickup_to_delivery_time_limit",
            &self.pickup_to_delivery_time_limit,
        );
        debug_struct.field("shipment_type", &self.shipment_type);
        debug_struct.field("label", &self.label);
        debug_struct.field("ignore", &self.ignore);
        debug_struct.field("demands", &self.demands);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment::VisitRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VisitRequest");
        debug_struct.field("arrival_location", &self.arrival_location);
        debug_struct.field("arrival_waypoint", &self.arrival_waypoint);
        debug_struct.field("departure_location", &self.departure_location);
        debug_struct.field("departure_waypoint", &self.departure_waypoint);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("time_windows", &self.time_windows);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("cost", &self.cost);
        debug_struct.field("load_demands", &self.load_demands);
        debug_struct.field("visit_types", &self.visit_types);
        debug_struct.field("label", &self.label);
        debug_struct.field("demands", &self.demands);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment::Load {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Load");
        debug_struct.field("amount", &self.amount);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShipmentTypeIncompatibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShipmentTypeIncompatibility");
        debug_struct.field("types", &self.types);
        debug_struct.field("incompatibility_mode", &self.incompatibility_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShipmentTypeRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShipmentTypeRequirement");
        debug_struct.field(
            "required_shipment_type_alternatives",
            &self.required_shipment_type_alternatives,
        );
        debug_struct.field("dependent_shipment_types", &self.dependent_shipment_types);
        debug_struct.field("requirement_mode", &self.requirement_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RouteModifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RouteModifiers");
        debug_struct.field("avoid_tolls", &self.avoid_tolls);
        debug_struct.field("avoid_highways", &self.avoid_highways);
        debug_struct.field("avoid_ferries", &self.avoid_ferries);
        debug_struct.field("avoid_indoor", &self.avoid_indoor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Vehicle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vehicle");
        debug_struct.field("travel_mode", &self.travel_mode);
        debug_struct.field("route_modifiers", &self.route_modifiers);
        debug_struct.field("start_location", &self.start_location);
        debug_struct.field("start_waypoint", &self.start_waypoint);
        debug_struct.field("end_location", &self.end_location);
        debug_struct.field("end_waypoint", &self.end_waypoint);
        debug_struct.field("start_tags", &self.start_tags);
        debug_struct.field("end_tags", &self.end_tags);
        debug_struct.field("start_time_windows", &self.start_time_windows);
        debug_struct.field("end_time_windows", &self.end_time_windows);
        debug_struct.field("travel_duration_multiple", &self.travel_duration_multiple);
        debug_struct.field("unloading_policy", &self.unloading_policy);
        debug_struct.field("load_limits", &self.load_limits);
        debug_struct.field("cost_per_hour", &self.cost_per_hour);
        debug_struct.field("cost_per_traveled_hour", &self.cost_per_traveled_hour);
        debug_struct.field("cost_per_kilometer", &self.cost_per_kilometer);
        debug_struct.field("fixed_cost", &self.fixed_cost);
        debug_struct.field("used_if_route_is_empty", &self.used_if_route_is_empty);
        debug_struct.field("route_duration_limit", &self.route_duration_limit);
        debug_struct.field("travel_duration_limit", &self.travel_duration_limit);
        debug_struct.field("route_distance_limit", &self.route_distance_limit);
        debug_struct.field(
            "extra_visit_duration_for_visit_type",
            &self.extra_visit_duration_for_visit_type,
        );
        debug_struct.field("break_rule", &self.break_rule);
        debug_struct.field("label", &self.label);
        debug_struct.field("ignore", &self.ignore);
        debug_struct.field("break_rule_indices", &self.break_rule_indices);
        debug_struct.field("capacities", &self.capacities);
        debug_struct.field("start_load_intervals", &self.start_load_intervals);
        debug_struct.field("end_load_intervals", &self.end_load_intervals);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vehicle::LoadLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadLimit");
        debug_struct.field("max_load", &self.max_load);
        debug_struct.field("soft_max_load", &self.soft_max_load);
        debug_struct.field(
            "cost_per_unit_above_soft_max",
            &self.cost_per_unit_above_soft_max,
        );
        debug_struct.field("start_load_interval", &self.start_load_interval);
        debug_struct.field("end_load_interval", &self.end_load_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vehicle::load_limit::Interval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Interval");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vehicle::DurationLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DurationLimit");
        debug_struct.field("max_duration", &self.max_duration);
        debug_struct.field("soft_max_duration", &self.soft_max_duration);
        debug_struct.field(
            "cost_per_hour_after_soft_max",
            &self.cost_per_hour_after_soft_max,
        );
        debug_struct.field(
            "quadratic_soft_max_duration",
            &self.quadratic_soft_max_duration,
        );
        debug_struct.field(
            "cost_per_square_hour_after_quadratic_soft_max",
            &self.cost_per_square_hour_after_quadratic_soft_max,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("soft_start_time", &self.soft_start_time);
        debug_struct.field("soft_end_time", &self.soft_end_time);
        debug_struct.field(
            "cost_per_hour_before_soft_start_time",
            &self.cost_per_hour_before_soft_start_time,
        );
        debug_struct.field(
            "cost_per_hour_after_soft_end_time",
            &self.cost_per_hour_after_soft_end_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CapacityQuantity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CapacityQuantity");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CapacityQuantityInterval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CapacityQuantityInterval");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("min_value", &self.min_value);
        debug_struct.field("max_value", &self.max_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DistanceLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DistanceLimit");
        debug_struct.field("max_meters", &self.max_meters);
        debug_struct.field("soft_max_meters", &self.soft_max_meters);
        debug_struct.field(
            "cost_per_kilometer_below_soft_max",
            &self.cost_per_kilometer_below_soft_max,
        );
        debug_struct.field(
            "cost_per_kilometer_above_soft_max",
            &self.cost_per_kilometer_above_soft_max,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TransitionAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TransitionAttributes");
        debug_struct.field("src_tag", &self.src_tag);
        debug_struct.field("excluded_src_tag", &self.excluded_src_tag);
        debug_struct.field("dst_tag", &self.dst_tag);
        debug_struct.field("excluded_dst_tag", &self.excluded_dst_tag);
        debug_struct.field("cost", &self.cost);
        debug_struct.field("cost_per_kilometer", &self.cost_per_kilometer);
        debug_struct.field("distance_limit", &self.distance_limit);
        debug_struct.field("delay", &self.delay);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Waypoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Waypoint");
        debug_struct.field("side_of_road", &self.side_of_road);
        debug_struct.field("location_type", &self.location_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Location");
        debug_struct.field("lat_lng", &self.lat_lng);
        debug_struct.field("heading", &self.heading);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BreakRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BreakRule");
        debug_struct.field("break_requests", &self.break_requests);
        debug_struct.field("frequency_constraints", &self.frequency_constraints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::break_rule::BreakRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BreakRequest");
        debug_struct.field("earliest_start_time", &self.earliest_start_time);
        debug_struct.field("latest_start_time", &self.latest_start_time);
        debug_struct.field("min_duration", &self.min_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::break_rule::FrequencyConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrequencyConstraint");
        debug_struct.field("min_break_duration", &self.min_break_duration);
        debug_struct.field("max_inter_break_duration", &self.max_inter_break_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShipmentRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShipmentRoute");
        debug_struct.field("vehicle_index", &self.vehicle_index);
        debug_struct.field("vehicle_label", &self.vehicle_label);
        debug_struct.field("vehicle_start_time", &self.vehicle_start_time);
        debug_struct.field("vehicle_end_time", &self.vehicle_end_time);
        debug_struct.field("visits", &self.visits);
        debug_struct.field("transitions", &self.transitions);
        debug_struct.field(
            "has_traffic_infeasibilities",
            &self.has_traffic_infeasibilities,
        );
        debug_struct.field("route_polyline", &self.route_polyline);
        debug_struct.field("breaks", &self.breaks);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("route_costs", &self.route_costs);
        debug_struct.field("route_total_cost", &self.route_total_cost);
        debug_struct.field("end_loads", &self.end_loads);
        debug_struct.field("travel_steps", &self.travel_steps);
        debug_struct.field("vehicle_detour", &self.vehicle_detour);
        debug_struct.field("delay_before_vehicle_end", &self.delay_before_vehicle_end);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::Delay {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Delay");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("duration", &self.duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::Visit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Visit");
        debug_struct.field("shipment_index", &self.shipment_index);
        debug_struct.field("is_pickup", &self.is_pickup);
        debug_struct.field("visit_request_index", &self.visit_request_index);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("load_demands", &self.load_demands);
        debug_struct.field("detour", &self.detour);
        debug_struct.field("shipment_label", &self.shipment_label);
        debug_struct.field("visit_label", &self.visit_label);
        debug_struct.field("arrival_loads", &self.arrival_loads);
        debug_struct.field("delay_before_start", &self.delay_before_start);
        debug_struct.field("demands", &self.demands);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::Transition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Transition");
        debug_struct.field("travel_duration", &self.travel_duration);
        debug_struct.field("travel_distance_meters", &self.travel_distance_meters);
        debug_struct.field("traffic_info_unavailable", &self.traffic_info_unavailable);
        debug_struct.field("delay_duration", &self.delay_duration);
        debug_struct.field("break_duration", &self.break_duration);
        debug_struct.field("wait_duration", &self.wait_duration);
        debug_struct.field("total_duration", &self.total_duration);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("route_polyline", &self.route_polyline);
        debug_struct.field("vehicle_loads", &self.vehicle_loads);
        debug_struct.field("loads", &self.loads);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::VehicleLoad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VehicleLoad");
        debug_struct.field("amount", &self.amount);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::EncodedPolyline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncodedPolyline");
        debug_struct.field("points", &self.points);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::Break {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Break");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("duration", &self.duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::shipment_route::TravelStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TravelStep");
        debug_struct.field("duration", &self.duration);
        debug_struct.field("distance_meters", &self.distance_meters);
        debug_struct.field("traffic_info_unavailable", &self.traffic_info_unavailable);
        debug_struct.field("route_polyline", &self.route_polyline);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SkippedShipment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SkippedShipment");
        debug_struct.field("index", &self.index);
        debug_struct.field("label", &self.label);
        debug_struct.field("reasons", &self.reasons);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::skipped_shipment::Reason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Reason");
        debug_struct.field("code", &self.code);
        debug_struct.field("example_vehicle_index", &self.example_vehicle_index);
        debug_struct.field(
            "example_exceeded_capacity_type",
            &self.example_exceeded_capacity_type,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AggregatedMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AggregatedMetrics");
        debug_struct.field("performed_shipment_count", &self.performed_shipment_count);
        debug_struct.field("travel_duration", &self.travel_duration);
        debug_struct.field("wait_duration", &self.wait_duration);
        debug_struct.field("delay_duration", &self.delay_duration);
        debug_struct.field("break_duration", &self.break_duration);
        debug_struct.field("visit_duration", &self.visit_duration);
        debug_struct.field("total_duration", &self.total_duration);
        debug_struct.field("travel_distance_meters", &self.travel_distance_meters);
        debug_struct.field("max_loads", &self.max_loads);
        debug_struct.field("costs", &self.costs);
        debug_struct.field("total_cost", &self.total_cost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InjectedSolutionConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InjectedSolutionConstraint");
        debug_struct.field("routes", &self.routes);
        debug_struct.field("skipped_shipments", &self.skipped_shipments);
        debug_struct.field("constraint_relaxations", &self.constraint_relaxations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::injected_solution_constraint::ConstraintRelaxation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConstraintRelaxation");
        debug_struct.field("relaxations", &self.relaxations);
        debug_struct.field("vehicle_indices", &self.vehicle_indices);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::injected_solution_constraint::constraint_relaxation::Relaxation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Relaxation");
        debug_struct.field("level", &self.level);
        debug_struct.field("threshold_time", &self.threshold_time);
        debug_struct.field("threshold_visit_count", &self.threshold_visit_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OptimizeToursValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OptimizeToursValidationError");
        debug_struct.field("code", &self.code);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("fields", &self.fields);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("offending_values", &self.offending_values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::optimize_tours_validation_error::FieldReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FieldReference");
        debug_struct.field("name", &self.name);
        debug_struct.field("sub_field", &self.sub_field);
        debug_struct.field("index_or_key", &self.index_or_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
