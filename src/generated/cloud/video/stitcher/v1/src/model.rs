// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Information related to the details for one ad tag. This resource is only
/// available for live sessions that do not implement Google Ad Manager ad
/// insertion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LiveAdTagDetail {
    /// The resource name in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}/liveAdTagDetails/{id}`.
    pub name: std::string::String,

    /// A list of ad requests.
    pub ad_requests: std::vec::Vec<crate::model::AdRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveAdTagDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveAdTagDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_requests][crate::model::LiveAdTagDetail::ad_requests].
    pub fn set_ad_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdRequest>,
    {
        use std::iter::Iterator;
        self.ad_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LiveAdTagDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveAdTagDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LiveAdTagDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ad_requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LiveAdTagDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "adRequests" => Ok(__FieldTag::__ad_requests),
                            "ad_requests" => Ok(__FieldTag::__ad_requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LiveAdTagDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LiveAdTagDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_requests => {
                            if !fields.insert(__FieldTag::__ad_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_requests",
                                ));
                            }
                            result.ad_requests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AdRequest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LiveAdTagDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ad_requests.is_empty() {
            state.serialize_entry("adRequests", &self.ad_requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information related to the details for one ad tag. This resource is only
/// available for VOD sessions that do not implement Google Ad Manager ad
/// insertion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodAdTagDetail {
    /// The name of the ad tag detail for the specified VOD session, in the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodAdTagDetails/{id}`.
    pub name: std::string::String,

    /// A list of ad requests for one ad tag.
    pub ad_requests: std::vec::Vec<crate::model::AdRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodAdTagDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodAdTagDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_requests][crate::model::VodAdTagDetail::ad_requests].
    pub fn set_ad_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdRequest>,
    {
        use std::iter::Iterator;
        self.ad_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodAdTagDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodAdTagDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodAdTagDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ad_requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodAdTagDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "adRequests" => Ok(__FieldTag::__ad_requests),
                            "ad_requests" => Ok(__FieldTag::__ad_requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodAdTagDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodAdTagDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_requests => {
                            if !fields.insert(__FieldTag::__ad_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_requests",
                                ));
                            }
                            result.ad_requests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AdRequest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodAdTagDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ad_requests.is_empty() {
            state.serialize_entry("adRequests", &self.ad_requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details of an ad request to an ad server.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdRequest {
    /// The ad tag URI processed with integrated macros.
    pub uri: std::string::String,

    /// The request metadata used to make the ad request.
    pub request_metadata: std::option::Option<crate::model::RequestMetadata>,

    /// The response metadata received from the ad request.
    pub response_metadata: std::option::Option<crate::model::ResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::AdRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [request_metadata][crate::model::AdRequest::request_metadata].
    pub fn set_request_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_metadata][crate::model::AdRequest::request_metadata].
    pub fn set_or_clear_request_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_metadata][crate::model::AdRequest::response_metadata].
    pub fn set_response_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.response_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response_metadata][crate::model::AdRequest::response_metadata].
    pub fn set_or_clear_response_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.response_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AdRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __request_metadata,
            __response_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "requestMetadata" => Ok(__FieldTag::__request_metadata),
                            "request_metadata" => Ok(__FieldTag::__request_metadata),
                            "responseMetadata" => Ok(__FieldTag::__response_metadata),
                            "response_metadata" => Ok(__FieldTag::__response_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_metadata => {
                            if !fields.insert(__FieldTag::__request_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_metadata",
                                ));
                            }
                            result.request_metadata = map
                                .next_value::<std::option::Option<crate::model::RequestMetadata>>(
                                )?;
                        }
                        __FieldTag::__response_metadata => {
                            if !fields.insert(__FieldTag::__response_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_metadata",
                                ));
                            }
                            result.response_metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.request_metadata.is_some() {
            state.serialize_entry("requestMetadata", &self.request_metadata)?;
        }
        if self.response_metadata.is_some() {
            state.serialize_entry("responseMetadata", &self.response_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for an ad request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RequestMetadata {
    /// The HTTP headers of the ad request.
    pub headers: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::RequestMetadata::headers].
    pub fn set_headers<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [headers][crate::model::RequestMetadata::headers].
    pub fn set_or_clear_headers<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RequestMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.RequestMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RequestMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __headers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RequestMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "headers" => Ok(__FieldTag::__headers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RequestMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RequestMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RequestMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.headers.is_some() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for the response of an ad request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResponseMetadata {
    /// Error message received when making the ad request.
    pub error: std::string::String,

    /// Headers from the response.
    pub headers: std::option::Option<wkt::Struct>,

    /// Status code for the response.
    pub status_code: std::string::String,

    /// Size in bytes of the response.
    pub size_bytes: i32,

    /// Total time elapsed for the response.
    pub duration: std::option::Option<wkt::Duration>,

    /// The body of the response.
    pub body: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResponseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::ResponseMetadata::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::ResponseMetadata::headers].
    pub fn set_headers<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [headers][crate::model::ResponseMetadata::headers].
    pub fn set_or_clear_headers<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_code][crate::model::ResponseMetadata::status_code].
    pub fn set_status_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_code = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::ResponseMetadata::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::ResponseMetadata::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::ResponseMetadata::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [body][crate::model::ResponseMetadata::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for ResponseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ResponseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResponseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __headers,
            __status_code,
            __size_bytes,
            __duration,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "headers" => Ok(__FieldTag::__headers),
                            "statusCode" => Ok(__FieldTag::__status_code),
                            "status_code" => Ok(__FieldTag::__status_code),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            "duration" => Ok(__FieldTag::__duration),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResponseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__status_code => {
                            if !fields.insert(__FieldTag::__status_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_code",
                                ));
                            }
                            result.status_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            result.body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResponseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error.is_empty() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.headers.is_some() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.status_code.is_empty() {
            state.serialize_entry("statusCode", &self.status_code)?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self.body.is_empty() {
            state.serialize_entry("body", &self.body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for a CDN key. Used by the Video Stitcher
/// to sign URIs for fetching video manifests and signing
/// media segments for playback.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CdnKey {
    /// The resource name of the CDN key, in the form of
    /// `projects/{project}/locations/{location}/cdnKeys/{id}`.
    /// The name is ignored when creating a CDN key.
    pub name: std::string::String,

    /// The hostname this key applies to.
    pub hostname: std::string::String,

    /// Configuration associated with the CDN key.
    pub cdn_key_config: std::option::Option<crate::model::cdn_key::CdnKeyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CdnKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CdnKey::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config].
    ///
    /// Note that all the setters affecting `cdn_key_config` are mutually
    /// exclusive.
    pub fn set_cdn_key_config<
        T: std::convert::Into<std::option::Option<crate::model::cdn_key::CdnKeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config = v.into();
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `GoogleCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::GoogleCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `GoogleCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_google_cdn_key<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleCdnKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::GoogleCdnKey(v.into()));
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `AkamaiCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn akamai_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AkamaiCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::AkamaiCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `AkamaiCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_akamai_cdn_key<
        T: std::convert::Into<std::boxed::Box<crate::model::AkamaiCdnKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::AkamaiCdnKey(v.into()));
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `MediaCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn media_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MediaCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::MediaCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `MediaCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_media_cdn_key<T: std::convert::Into<std::boxed::Box<crate::model::MediaCdnKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::MediaCdnKey(v.into()));
        self
    }
}

impl wkt::message::Message for CdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CdnKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CdnKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_cdn_key,
            __akamai_cdn_key,
            __media_cdn_key,
            __name,
            __hostname,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CdnKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleCdnKey" => Ok(__FieldTag::__google_cdn_key),
                            "google_cdn_key" => Ok(__FieldTag::__google_cdn_key),
                            "akamaiCdnKey" => Ok(__FieldTag::__akamai_cdn_key),
                            "akamai_cdn_key" => Ok(__FieldTag::__akamai_cdn_key),
                            "mediaCdnKey" => Ok(__FieldTag::__media_cdn_key),
                            "media_cdn_key" => Ok(__FieldTag::__media_cdn_key),
                            "name" => Ok(__FieldTag::__name),
                            "hostname" => Ok(__FieldTag::__hostname),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CdnKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CdnKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_cdn_key => {
                            if !fields.insert(__FieldTag::__google_cdn_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_cdn_key",
                                ));
                            }
                            if result.cdn_key_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdn_key_config`, a oneof with full ID .google.cloud.video.stitcher.v1.CdnKey.google_cdn_key, latest field was googleCdnKey",
                                ));
                            }
                            result.cdn_key_config = std::option::Option::Some(
                                crate::model::cdn_key::CdnKeyConfig::GoogleCdnKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GoogleCdnKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__akamai_cdn_key => {
                            if !fields.insert(__FieldTag::__akamai_cdn_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for akamai_cdn_key",
                                ));
                            }
                            if result.cdn_key_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdn_key_config`, a oneof with full ID .google.cloud.video.stitcher.v1.CdnKey.akamai_cdn_key, latest field was akamaiCdnKey",
                                ));
                            }
                            result.cdn_key_config = std::option::Option::Some(
                                crate::model::cdn_key::CdnKeyConfig::AkamaiCdnKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AkamaiCdnKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__media_cdn_key => {
                            if !fields.insert(__FieldTag::__media_cdn_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for media_cdn_key",
                                ));
                            }
                            if result.cdn_key_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cdn_key_config`, a oneof with full ID .google.cloud.video.stitcher.v1.CdnKey.media_cdn_key, latest field was mediaCdnKey",
                                ));
                            }
                            result.cdn_key_config = std::option::Option::Some(
                                crate::model::cdn_key::CdnKeyConfig::MediaCdnKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MediaCdnKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CdnKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.google_cdn_key() {
            state.serialize_entry("googleCdnKey", value)?;
        }
        if let Some(value) = self.akamai_cdn_key() {
            state.serialize_entry("akamaiCdnKey", value)?;
        }
        if let Some(value) = self.media_cdn_key() {
            state.serialize_entry("mediaCdnKey", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CdnKey].
pub mod cdn_key {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration associated with the CDN key.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CdnKeyConfig {
        /// The configuration for a Google Cloud CDN key.
        GoogleCdnKey(std::boxed::Box<crate::model::GoogleCdnKey>),
        /// The configuration for an Akamai CDN key.
        AkamaiCdnKey(std::boxed::Box<crate::model::AkamaiCdnKey>),
        /// The configuration for a Media CDN key.
        MediaCdnKey(std::boxed::Box<crate::model::MediaCdnKey>),
    }
}

/// Configuration for a Google Cloud CDN key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleCdnKey {
    /// Input only. Secret for this Google Cloud CDN key.
    pub private_key: ::bytes::Bytes,

    /// The public name of the Google Cloud CDN key.
    pub key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::GoogleCdnKey::private_key].
    pub fn set_private_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_name][crate::model::GoogleCdnKey::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }
}

impl wkt::message::Message for GoogleCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GoogleCdnKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleCdnKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_key,
            __key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleCdnKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleCdnKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleCdnKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.private_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_name",
                                ));
                            }
                            result.key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleCdnKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("privateKey", &__With(&self.private_key))?;
        }
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for an Akamai CDN key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AkamaiCdnKey {
    /// Input only. Token key for the Akamai CDN edge configuration.
    pub token_key: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AkamaiCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token_key][crate::model::AkamaiCdnKey::token_key].
    pub fn set_token_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.token_key = v.into();
        self
    }
}

impl wkt::message::Message for AkamaiCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AkamaiCdnKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AkamaiCdnKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AkamaiCdnKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tokenKey" => Ok(__FieldTag::__token_key),
                            "token_key" => Ok(__FieldTag::__token_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AkamaiCdnKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AkamaiCdnKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token_key => {
                            if !fields.insert(__FieldTag::__token_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.token_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AkamaiCdnKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token_key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tokenKey", &__With(&self.token_key))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for a Media CDN key.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MediaCdnKey {
    /// Input only. 64-byte ed25519 private key for this Media CDN key.
    pub private_key: ::bytes::Bytes,

    /// The keyset name of the Media CDN key.
    pub key_name: std::string::String,

    /// Optional. If set, the URL will be signed using the Media CDN token.
    /// Otherwise, the URL would be signed using the standard Media CDN signature.
    pub token_config: std::option::Option<crate::model::media_cdn_key::TokenConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MediaCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::MediaCdnKey::private_key].
    pub fn set_private_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_name][crate::model::MediaCdnKey::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }

    /// Sets the value of [token_config][crate::model::MediaCdnKey::token_config].
    pub fn set_token_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::media_cdn_key::TokenConfig>,
    {
        self.token_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [token_config][crate::model::MediaCdnKey::token_config].
    pub fn set_or_clear_token_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::media_cdn_key::TokenConfig>,
    {
        self.token_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MediaCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.MediaCdnKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MediaCdnKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_key,
            __key_name,
            __token_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MediaCdnKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            "tokenConfig" => Ok(__FieldTag::__token_config),
                            "token_config" => Ok(__FieldTag::__token_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MediaCdnKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MediaCdnKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.private_key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_name",
                                ));
                            }
                            result.key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__token_config => {
                            if !fields.insert(__FieldTag::__token_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_config",
                                ));
                            }
                            result.token_config = map.next_value::<std::option::Option<crate::model::media_cdn_key::TokenConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MediaCdnKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("privateKey", &__With(&self.private_key))?;
        }
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if self.token_config.is_some() {
            state.serialize_entry("tokenConfig", &self.token_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MediaCdnKey].
pub mod media_cdn_key {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for a Media CDN token.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TokenConfig {
        /// Optional. The query parameter in which to find the token.
        ///
        /// The name must be 1-64 characters long and match
        /// the regular expression `[a-zA-Z]([a-zA-Z0-9_-])*` which means the
        /// first character must be a letter, and all following characters
        /// must be a dash, underscore, letter or digit.
        ///
        /// Defaults to `edge-cache-token`.
        pub query_parameter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TokenConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_parameter][crate::model::media_cdn_key::TokenConfig::query_parameter].
        pub fn set_query_parameter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.query_parameter = v.into();
            self
        }
    }

    impl wkt::message::Message for TokenConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.MediaCdnKey.TokenConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TokenConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_parameter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TokenConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryParameter" => Ok(__FieldTag::__query_parameter),
                                "query_parameter" => Ok(__FieldTag::__query_parameter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TokenConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TokenConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_parameter => {
                                if !fields.insert(__FieldTag::__query_parameter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_parameter",
                                    ));
                                }
                                result.query_parameter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TokenConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_parameter.is_empty() {
                state.serialize_entry("queryParameter", &self.query_parameter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Metadata for companion ads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompanionAds {
    /// Indicates how many of the companions should be displayed with the ad.
    pub display_requirement: crate::model::companion_ads::DisplayRequirement,

    /// List of companion ads.
    pub companions: std::vec::Vec<crate::model::Companion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompanionAds {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_requirement][crate::model::CompanionAds::display_requirement].
    pub fn set_display_requirement<
        T: std::convert::Into<crate::model::companion_ads::DisplayRequirement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.display_requirement = v.into();
        self
    }

    /// Sets the value of [companions][crate::model::CompanionAds::companions].
    pub fn set_companions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Companion>,
    {
        use std::iter::Iterator;
        self.companions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CompanionAds {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CompanionAds"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompanionAds {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_requirement,
            __companions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompanionAds")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayRequirement" => Ok(__FieldTag::__display_requirement),
                            "display_requirement" => Ok(__FieldTag::__display_requirement),
                            "companions" => Ok(__FieldTag::__companions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompanionAds;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompanionAds")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_requirement => {
                            if !fields.insert(__FieldTag::__display_requirement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_requirement",
                                ));
                            }
                            result.display_requirement = map
                                .next_value::<std::option::Option<
                                    crate::model::companion_ads::DisplayRequirement,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__companions => {
                            if !fields.insert(__FieldTag::__companions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for companions",
                                ));
                            }
                            result.companions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Companion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompanionAds {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.display_requirement) {
            state.serialize_entry("displayRequirement", &self.display_requirement)?;
        }
        if !self.companions.is_empty() {
            state.serialize_entry("companions", &self.companions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CompanionAds].
pub mod companion_ads {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates how many of the companions should be displayed with the ad.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DisplayRequirement {
        /// Required companions are not specified. The default is ALL.
        Unspecified,
        /// All companions are required to be displayed.
        All,
        /// At least one of companions needs to be displayed.
        Any,
        /// All companions are optional for display.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DisplayRequirement::value] or
        /// [DisplayRequirement::name].
        UnknownValue(display_requirement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod display_requirement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DisplayRequirement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::Any => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISPLAY_REQUIREMENT_UNSPECIFIED"),
                Self::All => std::option::Option::Some("ALL"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DisplayRequirement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DisplayRequirement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DisplayRequirement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::Any,
                3 => Self::None,
                _ => Self::UnknownValue(display_requirement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DisplayRequirement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISPLAY_REQUIREMENT_UNSPECIFIED" => Self::Unspecified,
                "ALL" => Self::All,
                "ANY" => Self::Any,
                "NONE" => Self::None,
                _ => Self::UnknownValue(display_requirement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DisplayRequirement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::Any => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DisplayRequirement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DisplayRequirement>::new(
                ".google.cloud.video.stitcher.v1.CompanionAds.DisplayRequirement",
            ))
        }
    }
}

/// Metadata for a companion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Companion {
    /// The API necessary to communicate with the creative if available.
    pub api_framework: std::string::String,

    /// The pixel height of the placement slot for the intended creative.
    pub height_px: i32,

    /// The pixel width of the placement slot for the intended creative.
    pub width_px: i32,

    /// The pixel height of the creative.
    pub asset_height_px: i32,

    /// The maximum pixel height of the creative in its expanded state.
    pub expanded_height_px: i32,

    /// The pixel width of the creative.
    pub asset_width_px: i32,

    /// The maximum pixel width of the creative in its expanded state.
    pub expanded_width_px: i32,

    /// The ID used to identify the desired placement on a publisher's page.
    /// Values to be used should be discussed between publishers and
    /// advertisers.
    pub ad_slot_id: std::string::String,

    /// The list of tracking events for the companion.
    pub events: std::vec::Vec<crate::model::Event>,

    /// Ad resource associated with the companion ad.
    pub ad_resource: std::option::Option<crate::model::companion::AdResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Companion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_framework][crate::model::Companion::api_framework].
    pub fn set_api_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_framework = v.into();
        self
    }

    /// Sets the value of [height_px][crate::model::Companion::height_px].
    pub fn set_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height_px = v.into();
        self
    }

    /// Sets the value of [width_px][crate::model::Companion::width_px].
    pub fn set_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width_px = v.into();
        self
    }

    /// Sets the value of [asset_height_px][crate::model::Companion::asset_height_px].
    pub fn set_asset_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.asset_height_px = v.into();
        self
    }

    /// Sets the value of [expanded_height_px][crate::model::Companion::expanded_height_px].
    pub fn set_expanded_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expanded_height_px = v.into();
        self
    }

    /// Sets the value of [asset_width_px][crate::model::Companion::asset_width_px].
    pub fn set_asset_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.asset_width_px = v.into();
        self
    }

    /// Sets the value of [expanded_width_px][crate::model::Companion::expanded_width_px].
    pub fn set_expanded_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expanded_width_px = v.into();
        self
    }

    /// Sets the value of [ad_slot_id][crate::model::Companion::ad_slot_id].
    pub fn set_ad_slot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_slot_id = v.into();
        self
    }

    /// Sets the value of [events][crate::model::Companion::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource].
    ///
    /// Note that all the setters affecting `ad_resource` are mutually
    /// exclusive.
    pub fn set_ad_resource<
        T: std::convert::Into<std::option::Option<crate::model::companion::AdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = v.into();
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `IframeAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn iframe_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IframeAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::IframeAdResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `IframeAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_iframe_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::IframeAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::IframeAdResource(v.into()),
        );
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `StaticAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::StaticAdResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `StaticAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_static_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::StaticAdResource(v.into()),
        );
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `HtmlAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn html_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HtmlAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::HtmlAdResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `HtmlAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_html_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::HtmlAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::HtmlAdResource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Companion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Companion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Companion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __iframe_ad_resource,
            __static_ad_resource,
            __html_ad_resource,
            __api_framework,
            __height_px,
            __width_px,
            __asset_height_px,
            __expanded_height_px,
            __asset_width_px,
            __expanded_width_px,
            __ad_slot_id,
            __events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Companion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "iframeAdResource" => Ok(__FieldTag::__iframe_ad_resource),
                            "iframe_ad_resource" => Ok(__FieldTag::__iframe_ad_resource),
                            "staticAdResource" => Ok(__FieldTag::__static_ad_resource),
                            "static_ad_resource" => Ok(__FieldTag::__static_ad_resource),
                            "htmlAdResource" => Ok(__FieldTag::__html_ad_resource),
                            "html_ad_resource" => Ok(__FieldTag::__html_ad_resource),
                            "apiFramework" => Ok(__FieldTag::__api_framework),
                            "api_framework" => Ok(__FieldTag::__api_framework),
                            "heightPx" => Ok(__FieldTag::__height_px),
                            "height_px" => Ok(__FieldTag::__height_px),
                            "widthPx" => Ok(__FieldTag::__width_px),
                            "width_px" => Ok(__FieldTag::__width_px),
                            "assetHeightPx" => Ok(__FieldTag::__asset_height_px),
                            "asset_height_px" => Ok(__FieldTag::__asset_height_px),
                            "expandedHeightPx" => Ok(__FieldTag::__expanded_height_px),
                            "expanded_height_px" => Ok(__FieldTag::__expanded_height_px),
                            "assetWidthPx" => Ok(__FieldTag::__asset_width_px),
                            "asset_width_px" => Ok(__FieldTag::__asset_width_px),
                            "expandedWidthPx" => Ok(__FieldTag::__expanded_width_px),
                            "expanded_width_px" => Ok(__FieldTag::__expanded_width_px),
                            "adSlotId" => Ok(__FieldTag::__ad_slot_id),
                            "ad_slot_id" => Ok(__FieldTag::__ad_slot_id),
                            "events" => Ok(__FieldTag::__events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Companion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Companion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__iframe_ad_resource => {
                            if !fields.insert(__FieldTag::__iframe_ad_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iframe_ad_resource",
                                ));
                            }
                            if result.ad_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `ad_resource`, a oneof with full ID .google.cloud.video.stitcher.v1.Companion.iframe_ad_resource, latest field was iframeAdResource",
                                ));
                            }
                            result.ad_resource = std::option::Option::Some(
                                crate::model::companion::AdResource::IframeAdResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IframeAdResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__static_ad_resource => {
                            if !fields.insert(__FieldTag::__static_ad_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ad_resource",
                                ));
                            }
                            if result.ad_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `ad_resource`, a oneof with full ID .google.cloud.video.stitcher.v1.Companion.static_ad_resource, latest field was staticAdResource",
                                ));
                            }
                            result.ad_resource = std::option::Option::Some(
                                crate::model::companion::AdResource::StaticAdResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StaticAdResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__html_ad_resource => {
                            if !fields.insert(__FieldTag::__html_ad_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for html_ad_resource",
                                ));
                            }
                            if result.ad_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `ad_resource`, a oneof with full ID .google.cloud.video.stitcher.v1.Companion.html_ad_resource, latest field was htmlAdResource",
                                ));
                            }
                            result.ad_resource = std::option::Option::Some(
                                crate::model::companion::AdResource::HtmlAdResource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HtmlAdResource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__api_framework => {
                            if !fields.insert(__FieldTag::__api_framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_framework",
                                ));
                            }
                            result.api_framework = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__height_px => {
                            if !fields.insert(__FieldTag::__height_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height_px = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__width_px => {
                            if !fields.insert(__FieldTag::__width_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width_px = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__asset_height_px => {
                            if !fields.insert(__FieldTag::__asset_height_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_height_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.asset_height_px =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expanded_height_px => {
                            if !fields.insert(__FieldTag::__expanded_height_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expanded_height_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expanded_height_px =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__asset_width_px => {
                            if !fields.insert(__FieldTag::__asset_width_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_width_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.asset_width_px =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expanded_width_px => {
                            if !fields.insert(__FieldTag::__expanded_width_px) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expanded_width_px",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.expanded_width_px =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__ad_slot_id => {
                            if !fields.insert(__FieldTag::__ad_slot_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_slot_id",
                                ));
                            }
                            result.ad_slot_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Companion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.iframe_ad_resource() {
            state.serialize_entry("iframeAdResource", value)?;
        }
        if let Some(value) = self.static_ad_resource() {
            state.serialize_entry("staticAdResource", value)?;
        }
        if let Some(value) = self.html_ad_resource() {
            state.serialize_entry("htmlAdResource", value)?;
        }
        if !self.api_framework.is_empty() {
            state.serialize_entry("apiFramework", &self.api_framework)?;
        }
        if !wkt::internal::is_default(&self.height_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("heightPx", &__With(&self.height_px))?;
        }
        if !wkt::internal::is_default(&self.width_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("widthPx", &__With(&self.width_px))?;
        }
        if !wkt::internal::is_default(&self.asset_height_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("assetHeightPx", &__With(&self.asset_height_px))?;
        }
        if !wkt::internal::is_default(&self.expanded_height_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expandedHeightPx", &__With(&self.expanded_height_px))?;
        }
        if !wkt::internal::is_default(&self.asset_width_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("assetWidthPx", &__With(&self.asset_width_px))?;
        }
        if !wkt::internal::is_default(&self.expanded_width_px) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("expandedWidthPx", &__With(&self.expanded_width_px))?;
        }
        if !self.ad_slot_id.is_empty() {
            state.serialize_entry("adSlotId", &self.ad_slot_id)?;
        }
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Companion].
pub mod companion {
    #[allow(unused_imports)]
    use super::*;

    /// Ad resource associated with the companion ad.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AdResource {
        /// The IFrame ad resource associated with the companion ad.
        IframeAdResource(std::boxed::Box<crate::model::IframeAdResource>),
        /// The static ad resource associated with the companion ad.
        StaticAdResource(std::boxed::Box<crate::model::StaticAdResource>),
        /// The HTML ad resource associated with the companion ad.
        HtmlAdResource(std::boxed::Box<crate::model::HtmlAdResource>),
    }
}

/// Metadata for an HTML ad resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HtmlAdResource {
    /// The HTML to display for the ad resource.
    pub html_source: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HtmlAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [html_source][crate::model::HtmlAdResource::html_source].
    pub fn set_html_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.html_source = v.into();
        self
    }
}

impl wkt::message::Message for HtmlAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.HtmlAdResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HtmlAdResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __html_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HtmlAdResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "htmlSource" => Ok(__FieldTag::__html_source),
                            "html_source" => Ok(__FieldTag::__html_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HtmlAdResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HtmlAdResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__html_source => {
                            if !fields.insert(__FieldTag::__html_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for html_source",
                                ));
                            }
                            result.html_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HtmlAdResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.html_source.is_empty() {
            state.serialize_entry("htmlSource", &self.html_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for an IFrame ad resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IframeAdResource {
    /// URI source for an IFrame to display for the ad resource.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IframeAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::IframeAdResource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for IframeAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.IframeAdResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IframeAdResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IframeAdResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IframeAdResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IframeAdResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IframeAdResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a static ad resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticAdResource {
    /// URI to the static file for the ad resource.
    pub uri: std::string::String,

    /// Describes the MIME type of the ad resource.
    pub creative_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::StaticAdResource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [creative_type][crate::model::StaticAdResource::creative_type].
    pub fn set_creative_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creative_type = v.into();
        self
    }
}

impl wkt::message::Message for StaticAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.StaticAdResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticAdResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __creative_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticAdResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "creativeType" => Ok(__FieldTag::__creative_type),
                            "creative_type" => Ok(__FieldTag::__creative_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticAdResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticAdResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__creative_type => {
                            if !fields.insert(__FieldTag::__creative_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creative_type",
                                ));
                            }
                            result.creative_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticAdResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.creative_type.is_empty() {
            state.serialize_entry("creativeType", &self.creative_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes an event and a trigger URI.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Describes the event that occurred.
    pub r#type: crate::model::event::EventType,

    /// The URI to trigger for this event.
    pub uri: std::string::String,

    /// The ID of the event.
    pub id: std::string::String,

    /// The offset in seconds if the event type is `PROGRESS`.
    pub offset: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::EventType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Event::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Event::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::Event::offset].
    pub fn set_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [offset][crate::model::Event::offset].
    pub fn set_or_clear_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.offset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Event"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __uri,
            __id,
            __offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Event")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "uri" => Ok(__FieldTag::__uri),
                            "id" => Ok(__FieldTag::__id),
                            "offset" => Ok(__FieldTag::__offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Event;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Event")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::event::EventType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offset => {
                            if !fields.insert(__FieldTag::__offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset",
                                ));
                            }
                            result.offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.offset.is_some() {
            state.serialize_entry("offset", &self.offset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the event that occurred.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// The event type is unspecified.
        Unspecified,
        /// First frame of creative ad viewed.
        CreativeView,
        /// Creative ad started.
        Start,
        /// Start of an ad break.
        BreakStart,
        /// End of an ad break.
        BreakEnd,
        /// Impression.
        Impression,
        /// First quartile progress.
        FirstQuartile,
        /// Midpoint progress.
        Midpoint,
        /// Third quartile progress.
        ThirdQuartile,
        /// Ad progress completed.
        Complete,
        /// Specific progress event with an offset.
        Progress,
        /// Player muted.
        Mute,
        /// Player unmuted.
        Unmute,
        /// Player paused.
        Pause,
        /// Click event.
        Click,
        /// Click-through event.
        ClickThrough,
        /// Player rewinding.
        Rewind,
        /// Player resumed.
        Resume,
        /// Error event.
        Error,
        /// Ad expanded to a larger size.
        Expand,
        /// Ad collapsed to a smaller size.
        Collapse,
        /// Non-linear ad closed.
        Close,
        /// Linear ad closed.
        CloseLinear,
        /// Ad skipped.
        Skip,
        /// Accept invitation event.
        AcceptInvitation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CreativeView => std::option::Option::Some(1),
                Self::Start => std::option::Option::Some(2),
                Self::BreakStart => std::option::Option::Some(3),
                Self::BreakEnd => std::option::Option::Some(4),
                Self::Impression => std::option::Option::Some(5),
                Self::FirstQuartile => std::option::Option::Some(6),
                Self::Midpoint => std::option::Option::Some(7),
                Self::ThirdQuartile => std::option::Option::Some(8),
                Self::Complete => std::option::Option::Some(9),
                Self::Progress => std::option::Option::Some(10),
                Self::Mute => std::option::Option::Some(11),
                Self::Unmute => std::option::Option::Some(12),
                Self::Pause => std::option::Option::Some(13),
                Self::Click => std::option::Option::Some(14),
                Self::ClickThrough => std::option::Option::Some(15),
                Self::Rewind => std::option::Option::Some(16),
                Self::Resume => std::option::Option::Some(17),
                Self::Error => std::option::Option::Some(18),
                Self::Expand => std::option::Option::Some(21),
                Self::Collapse => std::option::Option::Some(22),
                Self::Close => std::option::Option::Some(24),
                Self::CloseLinear => std::option::Option::Some(25),
                Self::Skip => std::option::Option::Some(26),
                Self::AcceptInvitation => std::option::Option::Some(27),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::CreativeView => std::option::Option::Some("CREATIVE_VIEW"),
                Self::Start => std::option::Option::Some("START"),
                Self::BreakStart => std::option::Option::Some("BREAK_START"),
                Self::BreakEnd => std::option::Option::Some("BREAK_END"),
                Self::Impression => std::option::Option::Some("IMPRESSION"),
                Self::FirstQuartile => std::option::Option::Some("FIRST_QUARTILE"),
                Self::Midpoint => std::option::Option::Some("MIDPOINT"),
                Self::ThirdQuartile => std::option::Option::Some("THIRD_QUARTILE"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::Progress => std::option::Option::Some("PROGRESS"),
                Self::Mute => std::option::Option::Some("MUTE"),
                Self::Unmute => std::option::Option::Some("UNMUTE"),
                Self::Pause => std::option::Option::Some("PAUSE"),
                Self::Click => std::option::Option::Some("CLICK"),
                Self::ClickThrough => std::option::Option::Some("CLICK_THROUGH"),
                Self::Rewind => std::option::Option::Some("REWIND"),
                Self::Resume => std::option::Option::Some("RESUME"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Expand => std::option::Option::Some("EXPAND"),
                Self::Collapse => std::option::Option::Some("COLLAPSE"),
                Self::Close => std::option::Option::Some("CLOSE"),
                Self::CloseLinear => std::option::Option::Some("CLOSE_LINEAR"),
                Self::Skip => std::option::Option::Some("SKIP"),
                Self::AcceptInvitation => std::option::Option::Some("ACCEPT_INVITATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CreativeView,
                2 => Self::Start,
                3 => Self::BreakStart,
                4 => Self::BreakEnd,
                5 => Self::Impression,
                6 => Self::FirstQuartile,
                7 => Self::Midpoint,
                8 => Self::ThirdQuartile,
                9 => Self::Complete,
                10 => Self::Progress,
                11 => Self::Mute,
                12 => Self::Unmute,
                13 => Self::Pause,
                14 => Self::Click,
                15 => Self::ClickThrough,
                16 => Self::Rewind,
                17 => Self::Resume,
                18 => Self::Error,
                21 => Self::Expand,
                22 => Self::Collapse,
                24 => Self::Close,
                25 => Self::CloseLinear,
                26 => Self::Skip,
                27 => Self::AcceptInvitation,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATIVE_VIEW" => Self::CreativeView,
                "START" => Self::Start,
                "BREAK_START" => Self::BreakStart,
                "BREAK_END" => Self::BreakEnd,
                "IMPRESSION" => Self::Impression,
                "FIRST_QUARTILE" => Self::FirstQuartile,
                "MIDPOINT" => Self::Midpoint,
                "THIRD_QUARTILE" => Self::ThirdQuartile,
                "COMPLETE" => Self::Complete,
                "PROGRESS" => Self::Progress,
                "MUTE" => Self::Mute,
                "UNMUTE" => Self::Unmute,
                "PAUSE" => Self::Pause,
                "CLICK" => Self::Click,
                "CLICK_THROUGH" => Self::ClickThrough,
                "REWIND" => Self::Rewind,
                "RESUME" => Self::Resume,
                "ERROR" => Self::Error,
                "EXPAND" => Self::Expand,
                "COLLAPSE" => Self::Collapse,
                "CLOSE" => Self::Close,
                "CLOSE_LINEAR" => Self::CloseLinear,
                "SKIP" => Self::Skip,
                "ACCEPT_INVITATION" => Self::AcceptInvitation,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CreativeView => serializer.serialize_i32(1),
                Self::Start => serializer.serialize_i32(2),
                Self::BreakStart => serializer.serialize_i32(3),
                Self::BreakEnd => serializer.serialize_i32(4),
                Self::Impression => serializer.serialize_i32(5),
                Self::FirstQuartile => serializer.serialize_i32(6),
                Self::Midpoint => serializer.serialize_i32(7),
                Self::ThirdQuartile => serializer.serialize_i32(8),
                Self::Complete => serializer.serialize_i32(9),
                Self::Progress => serializer.serialize_i32(10),
                Self::Mute => serializer.serialize_i32(11),
                Self::Unmute => serializer.serialize_i32(12),
                Self::Pause => serializer.serialize_i32(13),
                Self::Click => serializer.serialize_i32(14),
                Self::ClickThrough => serializer.serialize_i32(15),
                Self::Rewind => serializer.serialize_i32(16),
                Self::Resume => serializer.serialize_i32(17),
                Self::Error => serializer.serialize_i32(18),
                Self::Expand => serializer.serialize_i32(21),
                Self::Collapse => serializer.serialize_i32(22),
                Self::Close => serializer.serialize_i32(24),
                Self::CloseLinear => serializer.serialize_i32(25),
                Self::Skip => serializer.serialize_i32(26),
                Self::AcceptInvitation => serializer.serialize_i32(27),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.video.stitcher.v1.Event.EventType",
            ))
        }
    }
}

/// Indicates a time in which a list of events should be triggered
/// during media playback.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProgressEvent {
    /// The time when the following tracking events occurs. The time is in
    /// seconds relative to the start of the VOD asset.
    pub time_offset: std::option::Option<wkt::Duration>,

    /// The list of progress tracking events for the ad break. These can be of
    /// the following IAB types: `BREAK_START`, `BREAK_END`, `IMPRESSION`,
    /// `CREATIVE_VIEW`, `START`, `FIRST_QUARTILE`, `MIDPOINT`, `THIRD_QUARTILE`,
    /// `COMPLETE`, `PROGRESS`.
    pub events: std::vec::Vec<crate::model::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProgressEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_offset][crate::model::ProgressEvent::time_offset].
    pub fn set_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_offset][crate::model::ProgressEvent::time_offset].
    pub fn set_or_clear_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [events][crate::model::ProgressEvent::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProgressEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ProgressEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProgressEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_offset,
            __events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProgressEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeOffset" => Ok(__FieldTag::__time_offset),
                            "time_offset" => Ok(__FieldTag::__time_offset),
                            "events" => Ok(__FieldTag::__events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProgressEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProgressEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_offset => {
                            if !fields.insert(__FieldTag::__time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_offset",
                                ));
                            }
                            result.time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProgressEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.time_offset.is_some() {
            state.serialize_entry("timeOffset", &self.time_offset)?;
        }
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options on how fetches should be made.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchOptions {
    /// Custom headers to pass into fetch request.
    /// Headers must have a maximum of 3 key value pairs.
    /// Each key value pair must have a maximum of 256 characters per key and 256
    /// characters per value.
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::FetchOptions::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for FetchOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.FetchOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __headers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "headers" => Ok(__FieldTag::__headers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for used to register live configs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LiveConfig {
    /// Output only. The resource name of the live config, in the form of
    /// `projects/{project}/locations/{location}/liveConfigs/{id}`.
    pub name: std::string::String,

    /// Required. Source URI for the live stream manifest.
    pub source_uri: std::string::String,

    /// The default ad tag associated with this live stream config.
    pub ad_tag_uri: std::string::String,

    /// Additional metadata used to register a live stream with Google Ad Manager
    /// (GAM)
    pub gam_live_config: std::option::Option<crate::model::GamLiveConfig>,

    /// Output only. State of the live config.
    pub state: crate::model::live_config::State,

    /// Required. Determines how the ads are tracked.
    pub ad_tracking: crate::model::AdTracking,

    /// This must refer to a slate in the same
    /// project. If Google Ad Manager (GAM) is used for ads, this string sets the
    /// value of `slateCreativeId` in
    /// <https://developers.google.com/ad-manager/api/reference/v202211/LiveStreamEventService.LiveStreamEvent#slateCreativeId>
    pub default_slate: std::string::String,

    /// Defines the stitcher behavior in case an ad does not align exactly with
    /// the ad break boundaries. If not specified, the default is `CUT_CURRENT`.
    pub stitching_policy: crate::model::live_config::StitchingPolicy,

    /// The configuration for prefetching ads.
    pub prefetch_config: std::option::Option<crate::model::PrefetchConfig>,

    /// Options for fetching source manifests and segments.
    pub source_fetch_options: std::option::Option<crate::model::FetchOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::LiveConfig::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::LiveConfig::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [gam_live_config][crate::model::LiveConfig::gam_live_config].
    pub fn set_gam_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GamLiveConfig>,
    {
        self.gam_live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_live_config][crate::model::LiveConfig::gam_live_config].
    pub fn set_or_clear_gam_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GamLiveConfig>,
    {
        self.gam_live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::LiveConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::live_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::LiveConfig::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }

    /// Sets the value of [default_slate][crate::model::LiveConfig::default_slate].
    pub fn set_default_slate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_slate = v.into();
        self
    }

    /// Sets the value of [stitching_policy][crate::model::LiveConfig::stitching_policy].
    pub fn set_stitching_policy<
        T: std::convert::Into<crate::model::live_config::StitchingPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stitching_policy = v.into();
        self
    }

    /// Sets the value of [prefetch_config][crate::model::LiveConfig::prefetch_config].
    pub fn set_prefetch_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrefetchConfig>,
    {
        self.prefetch_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [prefetch_config][crate::model::LiveConfig::prefetch_config].
    pub fn set_or_clear_prefetch_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrefetchConfig>,
    {
        self.prefetch_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_fetch_options][crate::model::LiveConfig::source_fetch_options].
    pub fn set_source_fetch_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_fetch_options][crate::model::LiveConfig::source_fetch_options].
    pub fn set_or_clear_source_fetch_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LiveConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_uri,
            __ad_tag_uri,
            __gam_live_config,
            __state,
            __ad_tracking,
            __default_slate,
            __stitching_policy,
            __prefetch_config,
            __source_fetch_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LiveConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceUri" => Ok(__FieldTag::__source_uri),
                            "source_uri" => Ok(__FieldTag::__source_uri),
                            "adTagUri" => Ok(__FieldTag::__ad_tag_uri),
                            "ad_tag_uri" => Ok(__FieldTag::__ad_tag_uri),
                            "gamLiveConfig" => Ok(__FieldTag::__gam_live_config),
                            "gam_live_config" => Ok(__FieldTag::__gam_live_config),
                            "state" => Ok(__FieldTag::__state),
                            "adTracking" => Ok(__FieldTag::__ad_tracking),
                            "ad_tracking" => Ok(__FieldTag::__ad_tracking),
                            "defaultSlate" => Ok(__FieldTag::__default_slate),
                            "default_slate" => Ok(__FieldTag::__default_slate),
                            "stitchingPolicy" => Ok(__FieldTag::__stitching_policy),
                            "stitching_policy" => Ok(__FieldTag::__stitching_policy),
                            "prefetchConfig" => Ok(__FieldTag::__prefetch_config),
                            "prefetch_config" => Ok(__FieldTag::__prefetch_config),
                            "sourceFetchOptions" => Ok(__FieldTag::__source_fetch_options),
                            "source_fetch_options" => Ok(__FieldTag::__source_fetch_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LiveConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LiveConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_uri => {
                            if !fields.insert(__FieldTag::__source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri",
                                ));
                            }
                            result.source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tag_uri => {
                            if !fields.insert(__FieldTag::__ad_tag_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tag_uri",
                                ));
                            }
                            result.ad_tag_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gam_live_config => {
                            if !fields.insert(__FieldTag::__gam_live_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gam_live_config",
                                ));
                            }
                            result.gam_live_config = map
                                .next_value::<std::option::Option<crate::model::GamLiveConfig>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::live_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ad_tracking => {
                            if !fields.insert(__FieldTag::__ad_tracking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tracking",
                                ));
                            }
                            result.ad_tracking = map
                                .next_value::<std::option::Option<crate::model::AdTracking>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_slate => {
                            if !fields.insert(__FieldTag::__default_slate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_slate",
                                ));
                            }
                            result.default_slate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stitching_policy => {
                            if !fields.insert(__FieldTag::__stitching_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stitching_policy",
                                ));
                            }
                            result.stitching_policy = map.next_value::<std::option::Option<crate::model::live_config::StitchingPolicy>>()?.unwrap_or_default();
                        }
                        __FieldTag::__prefetch_config => {
                            if !fields.insert(__FieldTag::__prefetch_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prefetch_config",
                                ));
                            }
                            result.prefetch_config = map
                                .next_value::<std::option::Option<crate::model::PrefetchConfig>>(
                                )?;
                        }
                        __FieldTag::__source_fetch_options => {
                            if !fields.insert(__FieldTag::__source_fetch_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_fetch_options",
                                ));
                            }
                            result.source_fetch_options = map
                                .next_value::<std::option::Option<crate::model::FetchOptions>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LiveConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_uri.is_empty() {
            state.serialize_entry("sourceUri", &self.source_uri)?;
        }
        if !self.ad_tag_uri.is_empty() {
            state.serialize_entry("adTagUri", &self.ad_tag_uri)?;
        }
        if self.gam_live_config.is_some() {
            state.serialize_entry("gamLiveConfig", &self.gam_live_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.ad_tracking) {
            state.serialize_entry("adTracking", &self.ad_tracking)?;
        }
        if !self.default_slate.is_empty() {
            state.serialize_entry("defaultSlate", &self.default_slate)?;
        }
        if !wkt::internal::is_default(&self.stitching_policy) {
            state.serialize_entry("stitchingPolicy", &self.stitching_policy)?;
        }
        if self.prefetch_config.is_some() {
            state.serialize_entry("prefetchConfig", &self.prefetch_config)?;
        }
        if self.source_fetch_options.is_some() {
            state.serialize_entry("sourceFetchOptions", &self.source_fetch_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LiveConfig].
pub mod live_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the live config.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// Live config is being created.
        Creating,
        /// Live config is ready for use.
        Ready,
        /// Live config is queued up for deletion.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.stitcher.v1.LiveConfig.State",
            ))
        }
    }

    /// Defines the ad stitching behavior in case the ad duration does not align
    /// exactly with the ad break boundaries. If not specified, the default is
    /// `CUT_CURRENT`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StitchingPolicy {
        /// Stitching policy is not specified.
        Unspecified,
        /// Cuts an ad short and returns to content in the middle of the ad.
        CutCurrent,
        /// Finishes stitching the current ad before returning to content.
        CompleteAd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StitchingPolicy::value] or
        /// [StitchingPolicy::name].
        UnknownValue(stitching_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stitching_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StitchingPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CutCurrent => std::option::Option::Some(1),
                Self::CompleteAd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STITCHING_POLICY_UNSPECIFIED"),
                Self::CutCurrent => std::option::Option::Some("CUT_CURRENT"),
                Self::CompleteAd => std::option::Option::Some("COMPLETE_AD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StitchingPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StitchingPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StitchingPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CutCurrent,
                2 => Self::CompleteAd,
                _ => Self::UnknownValue(stitching_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StitchingPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STITCHING_POLICY_UNSPECIFIED" => Self::Unspecified,
                "CUT_CURRENT" => Self::CutCurrent,
                "COMPLETE_AD" => Self::CompleteAd,
                _ => Self::UnknownValue(stitching_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StitchingPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CutCurrent => serializer.serialize_i32(1),
                Self::CompleteAd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StitchingPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StitchingPolicy>::new(
                ".google.cloud.video.stitcher.v1.LiveConfig.StitchingPolicy",
            ))
        }
    }
}

/// The configuration for prefetch ads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrefetchConfig {
    /// Required. Indicates whether the option to prefetch ad requests is enabled.
    pub enabled: bool,

    /// The duration in seconds of the part of the break to be prefetched.
    /// This field is only relevant if prefetch is enabled.
    /// You should set this duration to as long as possible to increase the
    /// benefits of prefetching, but not longer than the shortest ad break
    /// expected. For example, for a live event with 30s and 60s ad breaks, the
    /// initial duration should be set to 30s.
    pub initial_ad_request_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrefetchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PrefetchConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [initial_ad_request_duration][crate::model::PrefetchConfig::initial_ad_request_duration].
    pub fn set_initial_ad_request_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_ad_request_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_ad_request_duration][crate::model::PrefetchConfig::initial_ad_request_duration].
    pub fn set_or_clear_initial_ad_request_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_ad_request_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrefetchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.PrefetchConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrefetchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __initial_ad_request_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrefetchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "initialAdRequestDuration" => {
                                Ok(__FieldTag::__initial_ad_request_duration)
                            }
                            "initial_ad_request_duration" => {
                                Ok(__FieldTag::__initial_ad_request_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrefetchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrefetchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_ad_request_duration => {
                            if !fields.insert(__FieldTag::__initial_ad_request_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_ad_request_duration",
                                ));
                            }
                            result.initial_ad_request_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrefetchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.initial_ad_request_duration.is_some() {
            state.serialize_entry(
                "initialAdRequestDuration",
                &self.initial_ad_request_duration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata used to register a live stream with Google Ad Manager (GAM)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GamLiveConfig {
    /// Required. Ad Manager network code to associate with the live config.
    pub network_code: std::string::String,

    /// Output only. The asset key identifier generated for the live config.
    pub asset_key: std::string::String,

    /// Output only. The custom asset key identifier generated for the live config.
    pub custom_asset_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GamLiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_code][crate::model::GamLiveConfig::network_code].
    pub fn set_network_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_code = v.into();
        self
    }

    /// Sets the value of [asset_key][crate::model::GamLiveConfig::asset_key].
    pub fn set_asset_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_key = v.into();
        self
    }

    /// Sets the value of [custom_asset_key][crate::model::GamLiveConfig::custom_asset_key].
    pub fn set_custom_asset_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_asset_key = v.into();
        self
    }
}

impl wkt::message::Message for GamLiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GamLiveConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GamLiveConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_code,
            __asset_key,
            __custom_asset_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GamLiveConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkCode" => Ok(__FieldTag::__network_code),
                            "network_code" => Ok(__FieldTag::__network_code),
                            "assetKey" => Ok(__FieldTag::__asset_key),
                            "asset_key" => Ok(__FieldTag::__asset_key),
                            "customAssetKey" => Ok(__FieldTag::__custom_asset_key),
                            "custom_asset_key" => Ok(__FieldTag::__custom_asset_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GamLiveConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GamLiveConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_code => {
                            if !fields.insert(__FieldTag::__network_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_code",
                                ));
                            }
                            result.network_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset_key => {
                            if !fields.insert(__FieldTag::__asset_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_key",
                                ));
                            }
                            result.asset_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_asset_key => {
                            if !fields.insert(__FieldTag::__custom_asset_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_asset_key",
                                ));
                            }
                            result.custom_asset_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GamLiveConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_code.is_empty() {
            state.serialize_entry("networkCode", &self.network_code)?;
        }
        if !self.asset_key.is_empty() {
            state.serialize_entry("assetKey", &self.asset_key)?;
        }
        if !self.custom_asset_key.is_empty() {
            state.serialize_entry("customAssetKey", &self.custom_asset_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a VOD session. The session expires 4 hours after its creation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodSession {
    /// Output only. The name of the VOD session, in the form of
    /// `projects/{project_number}/locations/{location}/vodSessions/{id}`.
    pub name: std::string::String,

    /// Output only. Metadata of what was stitched into the content.
    pub interstitials: std::option::Option<crate::model::Interstitials>,

    /// Output only. The playback URI of the stitched content.
    pub play_uri: std::string::String,

    /// URI of the media to stitch. For most use cases, you should create a
    /// [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
    /// rather than setting this field directly.
    ///
    /// [google.cloud.video.stitcher.v1.VodConfig]: crate::model::VodConfig
    pub source_uri: std::string::String,

    /// Ad tag URI. For most use cases, you should create a
    /// [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
    /// rather than setting this field directly.
    ///
    /// [google.cloud.video.stitcher.v1.VodConfig]: crate::model::VodConfig
    pub ad_tag_uri: std::string::String,

    /// Key value pairs for ad tag macro replacement, only available for VOD
    /// sessions that do not implement Google Ad manager ad insertion. If the
    /// specified ad tag URI has macros, this field provides the mapping to the
    /// value that will replace the macro in the ad tag URI.
    ///
    /// Macros are designated by square brackets, for example:
    ///
    /// Ad tag URI: `"<https://doubleclick.google.com/ad/1?geo_id=>[geoId]"`
    ///
    /// Ad tag macro map: `{"geoId": "123"}`
    ///
    /// Fully qualified ad tag:
    /// ``https://doubleclick.google.com/ad/1?geo_id=123``
    pub ad_tag_macro_map: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional options that affect the output of the manifest.
    pub manifest_options: std::option::Option<crate::model::ManifestOptions>,

    /// Output only. The generated ID of the VodSession's source media.
    pub asset_id: std::string::String,

    /// Required. Determines how the ad should be tracked.
    pub ad_tracking: crate::model::AdTracking,

    /// This field should be set with appropriate values if GAM is being used for
    /// ads.
    pub gam_settings: std::option::Option<crate::model::vod_session::GamSettings>,

    /// The resource name of the VOD config for this session, in the form of
    /// `projects/{project}/locations/{location}/vodConfigs/{id}`.
    pub vod_config: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interstitials][crate::model::VodSession::interstitials].
    pub fn set_interstitials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Interstitials>,
    {
        self.interstitials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interstitials][crate::model::VodSession::interstitials].
    pub fn set_or_clear_interstitials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Interstitials>,
    {
        self.interstitials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [play_uri][crate::model::VodSession::play_uri].
    pub fn set_play_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.play_uri = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::VodSession::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::VodSession::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_macro_map][crate::model::VodSession::ad_tag_macro_map].
    pub fn set_ad_tag_macro_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ad_tag_macro_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [manifest_options][crate::model::VodSession::manifest_options].
    pub fn set_manifest_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [manifest_options][crate::model::VodSession::manifest_options].
    pub fn set_or_clear_manifest_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_id][crate::model::VodSession::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::VodSession::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }

    /// Sets the value of [gam_settings][crate::model::VodSession::gam_settings].
    pub fn set_gam_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vod_session::GamSettings>,
    {
        self.gam_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_settings][crate::model::VodSession::gam_settings].
    pub fn set_or_clear_gam_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vod_session::GamSettings>,
    {
        self.gam_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vod_config][crate::model::VodSession::vod_config].
    pub fn set_vod_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vod_config = v.into();
        self
    }
}

impl wkt::message::Message for VodSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSession"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodSession {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __interstitials,
            __play_uri,
            __source_uri,
            __ad_tag_uri,
            __ad_tag_macro_map,
            __manifest_options,
            __asset_id,
            __ad_tracking,
            __gam_settings,
            __vod_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodSession")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "interstitials" => Ok(__FieldTag::__interstitials),
                            "playUri" => Ok(__FieldTag::__play_uri),
                            "play_uri" => Ok(__FieldTag::__play_uri),
                            "sourceUri" => Ok(__FieldTag::__source_uri),
                            "source_uri" => Ok(__FieldTag::__source_uri),
                            "adTagUri" => Ok(__FieldTag::__ad_tag_uri),
                            "ad_tag_uri" => Ok(__FieldTag::__ad_tag_uri),
                            "adTagMacroMap" => Ok(__FieldTag::__ad_tag_macro_map),
                            "ad_tag_macro_map" => Ok(__FieldTag::__ad_tag_macro_map),
                            "manifestOptions" => Ok(__FieldTag::__manifest_options),
                            "manifest_options" => Ok(__FieldTag::__manifest_options),
                            "assetId" => Ok(__FieldTag::__asset_id),
                            "asset_id" => Ok(__FieldTag::__asset_id),
                            "adTracking" => Ok(__FieldTag::__ad_tracking),
                            "ad_tracking" => Ok(__FieldTag::__ad_tracking),
                            "gamSettings" => Ok(__FieldTag::__gam_settings),
                            "gam_settings" => Ok(__FieldTag::__gam_settings),
                            "vodConfig" => Ok(__FieldTag::__vod_config),
                            "vod_config" => Ok(__FieldTag::__vod_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodSession;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodSession")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interstitials => {
                            if !fields.insert(__FieldTag::__interstitials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interstitials",
                                ));
                            }
                            result.interstitials = map
                                .next_value::<std::option::Option<crate::model::Interstitials>>()?;
                        }
                        __FieldTag::__play_uri => {
                            if !fields.insert(__FieldTag::__play_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for play_uri",
                                ));
                            }
                            result.play_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_uri => {
                            if !fields.insert(__FieldTag::__source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri",
                                ));
                            }
                            result.source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tag_uri => {
                            if !fields.insert(__FieldTag::__ad_tag_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tag_uri",
                                ));
                            }
                            result.ad_tag_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tag_macro_map => {
                            if !fields.insert(__FieldTag::__ad_tag_macro_map) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tag_macro_map",
                                ));
                            }
                            result.ad_tag_macro_map = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manifest_options => {
                            if !fields.insert(__FieldTag::__manifest_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest_options",
                                ));
                            }
                            result.manifest_options = map
                                .next_value::<std::option::Option<crate::model::ManifestOptions>>(
                                )?;
                        }
                        __FieldTag::__asset_id => {
                            if !fields.insert(__FieldTag::__asset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_id",
                                ));
                            }
                            result.asset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tracking => {
                            if !fields.insert(__FieldTag::__ad_tracking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tracking",
                                ));
                            }
                            result.ad_tracking = map
                                .next_value::<std::option::Option<crate::model::AdTracking>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gam_settings => {
                            if !fields.insert(__FieldTag::__gam_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gam_settings",
                                ));
                            }
                            result.gam_settings = map.next_value::<std::option::Option<crate::model::vod_session::GamSettings>>()?
                                ;
                        }
                        __FieldTag::__vod_config => {
                            if !fields.insert(__FieldTag::__vod_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_config",
                                ));
                            }
                            result.vod_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodSession {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.interstitials.is_some() {
            state.serialize_entry("interstitials", &self.interstitials)?;
        }
        if !self.play_uri.is_empty() {
            state.serialize_entry("playUri", &self.play_uri)?;
        }
        if !self.source_uri.is_empty() {
            state.serialize_entry("sourceUri", &self.source_uri)?;
        }
        if !self.ad_tag_uri.is_empty() {
            state.serialize_entry("adTagUri", &self.ad_tag_uri)?;
        }
        if !self.ad_tag_macro_map.is_empty() {
            state.serialize_entry("adTagMacroMap", &self.ad_tag_macro_map)?;
        }
        if self.manifest_options.is_some() {
            state.serialize_entry("manifestOptions", &self.manifest_options)?;
        }
        if !self.asset_id.is_empty() {
            state.serialize_entry("assetId", &self.asset_id)?;
        }
        if !wkt::internal::is_default(&self.ad_tracking) {
            state.serialize_entry("adTracking", &self.ad_tracking)?;
        }
        if self.gam_settings.is_some() {
            state.serialize_entry("gamSettings", &self.gam_settings)?;
        }
        if !self.vod_config.is_empty() {
            state.serialize_entry("vodConfig", &self.vod_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VodSession].
pub mod vod_session {
    #[allow(unused_imports)]
    use super::*;

    /// Defines fields related to Google Ad Manager (GAM). This should be set if
    /// GAM is being used for ads.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GamSettings {
        /// Required. Ad Manager network code.
        pub network_code: std::string::String,

        /// Required. The stream ID generated by Ad Manager.
        pub stream_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_code][crate::model::vod_session::GamSettings::network_code].
        pub fn set_network_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_code = v.into();
            self
        }

        /// Sets the value of [stream_id][crate::model::vod_session::GamSettings::stream_id].
        pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GamSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.VodSession.GamSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GamSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_code,
                __stream_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GamSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkCode" => Ok(__FieldTag::__network_code),
                                "network_code" => Ok(__FieldTag::__network_code),
                                "streamId" => Ok(__FieldTag::__stream_id),
                                "stream_id" => Ok(__FieldTag::__stream_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GamSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GamSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_code => {
                                if !fields.insert(__FieldTag::__network_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_code",
                                    ));
                                }
                                result.network_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__stream_id => {
                                if !fields.insert(__FieldTag::__stream_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stream_id",
                                    ));
                                }
                                result.stream_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GamSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_code.is_empty() {
                state.serialize_entry("networkCode", &self.network_code)?;
            }
            if !self.stream_id.is_empty() {
                state.serialize_entry("streamId", &self.stream_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Describes what was stitched into a VOD session's manifest.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Interstitials {
    /// List of ad breaks ordered by time.
    pub ad_breaks: std::vec::Vec<crate::model::VodSessionAdBreak>,

    /// Information related to the content of the VOD session.
    pub session_content: std::option::Option<crate::model::VodSessionContent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Interstitials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ad_breaks][crate::model::Interstitials::ad_breaks].
    pub fn set_ad_breaks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodSessionAdBreak>,
    {
        use std::iter::Iterator;
        self.ad_breaks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [session_content][crate::model::Interstitials::session_content].
    pub fn set_session_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodSessionContent>,
    {
        self.session_content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_content][crate::model::Interstitials::session_content].
    pub fn set_or_clear_session_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodSessionContent>,
    {
        self.session_content = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Interstitials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Interstitials"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Interstitials {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ad_breaks,
            __session_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Interstitials")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adBreaks" => Ok(__FieldTag::__ad_breaks),
                            "ad_breaks" => Ok(__FieldTag::__ad_breaks),
                            "sessionContent" => Ok(__FieldTag::__session_content),
                            "session_content" => Ok(__FieldTag::__session_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Interstitials;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Interstitials")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ad_breaks => {
                            if !fields.insert(__FieldTag::__ad_breaks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_breaks",
                                ));
                            }
                            result.ad_breaks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VodSessionAdBreak>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_content => {
                            if !fields.insert(__FieldTag::__session_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_content",
                                ));
                            }
                            result.session_content = map
                                .next_value::<std::option::Option<crate::model::VodSessionContent>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Interstitials {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ad_breaks.is_empty() {
            state.serialize_entry("adBreaks", &self.ad_breaks)?;
        }
        if self.session_content.is_some() {
            state.serialize_entry("sessionContent", &self.session_content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for an inserted ad in a VOD session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodSessionAd {
    /// Duration in seconds of the ad.
    pub duration: std::option::Option<wkt::Duration>,

    /// Metadata of companion ads associated with the ad.
    pub companion_ads: std::option::Option<crate::model::CompanionAds>,

    /// The list of progress tracking events for the ad break. These can be of
    /// the following IAB types: `MUTE`, `UNMUTE`, `PAUSE`, `CLICK`,
    /// `CLICK_THROUGH`, `REWIND`, `RESUME`, `ERROR`, `FULLSCREEN`,
    /// `EXIT_FULLSCREEN`, `EXPAND`, `COLLAPSE`, `ACCEPT_INVITATION_LINEAR`,
    /// `CLOSE_LINEAR`, `SKIP`.
    pub activity_events: std::vec::Vec<crate::model::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionAd {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [duration][crate::model::VodSessionAd::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::VodSessionAd::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [companion_ads][crate::model::VodSessionAd::companion_ads].
    pub fn set_companion_ads<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompanionAds>,
    {
        self.companion_ads = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [companion_ads][crate::model::VodSessionAd::companion_ads].
    pub fn set_or_clear_companion_ads<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompanionAds>,
    {
        self.companion_ads = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activity_events][crate::model::VodSessionAd::activity_events].
    pub fn set_activity_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.activity_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodSessionAd {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionAd"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodSessionAd {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __duration,
            __companion_ads,
            __activity_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodSessionAd")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "duration" => Ok(__FieldTag::__duration),
                            "companionAds" => Ok(__FieldTag::__companion_ads),
                            "companion_ads" => Ok(__FieldTag::__companion_ads),
                            "activityEvents" => Ok(__FieldTag::__activity_events),
                            "activity_events" => Ok(__FieldTag::__activity_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodSessionAd;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodSessionAd")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__companion_ads => {
                            if !fields.insert(__FieldTag::__companion_ads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for companion_ads",
                                ));
                            }
                            result.companion_ads = map
                                .next_value::<std::option::Option<crate::model::CompanionAds>>()?;
                        }
                        __FieldTag::__activity_events => {
                            if !fields.insert(__FieldTag::__activity_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activity_events",
                                ));
                            }
                            result.activity_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodSessionAd {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.companion_ads.is_some() {
            state.serialize_entry("companionAds", &self.companion_ads)?;
        }
        if !self.activity_events.is_empty() {
            state.serialize_entry("activityEvents", &self.activity_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for the entire stitched content in a VOD session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodSessionContent {
    /// The total duration in seconds of the content including the ads stitched
    /// in.
    pub duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [duration][crate::model::VodSessionContent::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::VodSessionContent::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodSessionContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionContent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodSessionContent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodSessionContent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodSessionContent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodSessionContent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodSessionContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for an inserted ad break.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodSessionAdBreak {
    /// List of events that are expected to be triggered, ordered by time.
    pub progress_events: std::vec::Vec<crate::model::ProgressEvent>,

    /// Ordered list of ads stitched into the ad break.
    pub ads: std::vec::Vec<crate::model::VodSessionAd>,

    /// Ad break end time in seconds relative to the start of the VOD asset.
    pub end_time_offset: std::option::Option<wkt::Duration>,

    /// Ad break start time in seconds relative to the start of the VOD asset.
    pub start_time_offset: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionAdBreak {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_events][crate::model::VodSessionAdBreak::progress_events].
    pub fn set_progress_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProgressEvent>,
    {
        use std::iter::Iterator;
        self.progress_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ads][crate::model::VodSessionAdBreak::ads].
    pub fn set_ads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodSessionAd>,
    {
        use std::iter::Iterator;
        self.ads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_time_offset][crate::model::VodSessionAdBreak::end_time_offset].
    pub fn set_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time_offset][crate::model::VodSessionAdBreak::end_time_offset].
    pub fn set_or_clear_end_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time_offset][crate::model::VodSessionAdBreak::start_time_offset].
    pub fn set_start_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time_offset][crate::model::VodSessionAdBreak::start_time_offset].
    pub fn set_or_clear_start_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_time_offset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodSessionAdBreak {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionAdBreak"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodSessionAdBreak {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __progress_events,
            __ads,
            __end_time_offset,
            __start_time_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodSessionAdBreak")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "progressEvents" => Ok(__FieldTag::__progress_events),
                            "progress_events" => Ok(__FieldTag::__progress_events),
                            "ads" => Ok(__FieldTag::__ads),
                            "endTimeOffset" => Ok(__FieldTag::__end_time_offset),
                            "end_time_offset" => Ok(__FieldTag::__end_time_offset),
                            "startTimeOffset" => Ok(__FieldTag::__start_time_offset),
                            "start_time_offset" => Ok(__FieldTag::__start_time_offset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodSessionAdBreak;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodSessionAdBreak")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__progress_events => {
                            if !fields.insert(__FieldTag::__progress_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_events",
                                ));
                            }
                            result.progress_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ProgressEvent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ads => {
                            if !fields.insert(__FieldTag::__ads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ads",
                                ));
                            }
                            result.ads = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VodSessionAd>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__end_time_offset => {
                            if !fields.insert(__FieldTag::__end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time_offset",
                                ));
                            }
                            result.end_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__start_time_offset => {
                            if !fields.insert(__FieldTag::__start_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time_offset",
                                ));
                            }
                            result.start_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodSessionAdBreak {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.progress_events.is_empty() {
            state.serialize_entry("progressEvents", &self.progress_events)?;
        }
        if !self.ads.is_empty() {
            state.serialize_entry("ads", &self.ads)?;
        }
        if self.end_time_offset.is_some() {
            state.serialize_entry("endTimeOffset", &self.end_time_offset)?;
        }
        if self.start_time_offset.is_some() {
            state.serialize_entry("startTimeOffset", &self.start_time_offset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a live session. The session expires 5 minutes after the client
/// stops fetching the session's playlists.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LiveSession {
    /// Output only. The name of the live session, in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{id}`.
    pub name: std::string::String,

    /// Output only. The URI to play the live session's ad-stitched stream.
    pub play_uri: std::string::String,

    /// Key value pairs for ad tag macro replacement, only available for live
    /// sessions that do not implement Google Ad manager ad insertion. If the
    /// specified ad tag URI has macros, this field provides the mapping to the
    /// value that will replace the macro in the ad tag URI.
    ///
    /// Macros are designated by square brackets, for example:
    ///
    /// Ad tag URI: "<https://doubleclick.google.com/ad/1?geo_id=>[geoId]"
    ///
    /// Ad tag macros: `{"geoId": "123"}`
    ///
    /// Fully qualified ad tag:
    /// ``https://doubleclick.google.com/ad/1?geo_id=123``
    pub ad_tag_macros: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional options that affect the output of the manifest.
    pub manifest_options: std::option::Option<crate::model::ManifestOptions>,

    /// This field should be set with appropriate values if GAM is being used for
    /// ads.
    pub gam_settings: std::option::Option<crate::model::live_session::GamSettings>,

    /// Required. The resource name of the live config for this session, in the
    /// form of `projects/{project}/locations/{location}/liveConfigs/{id}`.
    pub live_config: std::string::String,

    /// Determines how the ad should be tracked. This overrides the value set in
    /// the live config for this session.
    pub ad_tracking: crate::model::AdTracking,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [play_uri][crate::model::LiveSession::play_uri].
    pub fn set_play_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.play_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_macros][crate::model::LiveSession::ad_tag_macros].
    pub fn set_ad_tag_macros<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ad_tag_macros = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [manifest_options][crate::model::LiveSession::manifest_options].
    pub fn set_manifest_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [manifest_options][crate::model::LiveSession::manifest_options].
    pub fn set_or_clear_manifest_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gam_settings][crate::model::LiveSession::gam_settings].
    pub fn set_gam_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::live_session::GamSettings>,
    {
        self.gam_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_settings][crate::model::LiveSession::gam_settings].
    pub fn set_or_clear_gam_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::live_session::GamSettings>,
    {
        self.gam_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [live_config][crate::model::LiveSession::live_config].
    pub fn set_live_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.live_config = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::LiveSession::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }
}

impl wkt::message::Message for LiveSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveSession"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LiveSession {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __play_uri,
            __ad_tag_macros,
            __manifest_options,
            __gam_settings,
            __live_config,
            __ad_tracking,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LiveSession")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "playUri" => Ok(__FieldTag::__play_uri),
                            "play_uri" => Ok(__FieldTag::__play_uri),
                            "adTagMacros" => Ok(__FieldTag::__ad_tag_macros),
                            "ad_tag_macros" => Ok(__FieldTag::__ad_tag_macros),
                            "manifestOptions" => Ok(__FieldTag::__manifest_options),
                            "manifest_options" => Ok(__FieldTag::__manifest_options),
                            "gamSettings" => Ok(__FieldTag::__gam_settings),
                            "gam_settings" => Ok(__FieldTag::__gam_settings),
                            "liveConfig" => Ok(__FieldTag::__live_config),
                            "live_config" => Ok(__FieldTag::__live_config),
                            "adTracking" => Ok(__FieldTag::__ad_tracking),
                            "ad_tracking" => Ok(__FieldTag::__ad_tracking),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LiveSession;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LiveSession")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__play_uri => {
                            if !fields.insert(__FieldTag::__play_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for play_uri",
                                ));
                            }
                            result.play_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tag_macros => {
                            if !fields.insert(__FieldTag::__ad_tag_macros) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tag_macros",
                                ));
                            }
                            result.ad_tag_macros = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manifest_options => {
                            if !fields.insert(__FieldTag::__manifest_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifest_options",
                                ));
                            }
                            result.manifest_options = map
                                .next_value::<std::option::Option<crate::model::ManifestOptions>>(
                                )?;
                        }
                        __FieldTag::__gam_settings => {
                            if !fields.insert(__FieldTag::__gam_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gam_settings",
                                ));
                            }
                            result.gam_settings = map.next_value::<std::option::Option<crate::model::live_session::GamSettings>>()?
                                ;
                        }
                        __FieldTag::__live_config => {
                            if !fields.insert(__FieldTag::__live_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_config",
                                ));
                            }
                            result.live_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tracking => {
                            if !fields.insert(__FieldTag::__ad_tracking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tracking",
                                ));
                            }
                            result.ad_tracking = map
                                .next_value::<std::option::Option<crate::model::AdTracking>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LiveSession {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.play_uri.is_empty() {
            state.serialize_entry("playUri", &self.play_uri)?;
        }
        if !self.ad_tag_macros.is_empty() {
            state.serialize_entry("adTagMacros", &self.ad_tag_macros)?;
        }
        if self.manifest_options.is_some() {
            state.serialize_entry("manifestOptions", &self.manifest_options)?;
        }
        if self.gam_settings.is_some() {
            state.serialize_entry("gamSettings", &self.gam_settings)?;
        }
        if !self.live_config.is_empty() {
            state.serialize_entry("liveConfig", &self.live_config)?;
        }
        if !wkt::internal::is_default(&self.ad_tracking) {
            state.serialize_entry("adTracking", &self.ad_tracking)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LiveSession].
pub mod live_session {
    #[allow(unused_imports)]
    use super::*;

    /// Defines fields related to Google Ad Manager (GAM).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GamSettings {
        /// Required. The stream ID generated by Ad Manager. This must be set if GAM
        /// is being used for ads and the session uses client-side ad tracking.
        pub stream_id: std::string::String,

        /// [Targeting
        /// parameters](https://support.google.com/admanager/answer/7320899) to send
        /// to Ad Manager to generate a stream ID. This should only be set if the
        /// session uses server-side ad tracking.
        pub targeting_parameters:
            std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stream_id][crate::model::live_session::GamSettings::stream_id].
        pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_id = v.into();
            self
        }

        /// Sets the value of [targeting_parameters][crate::model::live_session::GamSettings::targeting_parameters].
        pub fn set_targeting_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.targeting_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for GamSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.LiveSession.GamSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GamSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __stream_id,
                __targeting_parameters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GamSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "streamId" => Ok(__FieldTag::__stream_id),
                                "stream_id" => Ok(__FieldTag::__stream_id),
                                "targetingParameters" => Ok(__FieldTag::__targeting_parameters),
                                "targeting_parameters" => Ok(__FieldTag::__targeting_parameters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GamSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GamSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__stream_id => {
                                if !fields.insert(__FieldTag::__stream_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stream_id",
                                    ));
                                }
                                result.stream_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__targeting_parameters => {
                                if !fields.insert(__FieldTag::__targeting_parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for targeting_parameters",
                                    ));
                                }
                                result.targeting_parameters = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GamSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.stream_id.is_empty() {
                state.serialize_entry("streamId", &self.stream_id)?;
            }
            if !self.targeting_parameters.is_empty() {
                state.serialize_entry("targetingParameters", &self.targeting_parameters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Options for manifest generation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManifestOptions {
    /// If specified, the output manifest will only return renditions matching the
    /// specified filters.
    pub include_renditions: std::vec::Vec<crate::model::RenditionFilter>,

    /// If specified, the output manifest will orders the video and muxed
    /// renditions by bitrate according to the ordering policy.
    pub bitrate_order: crate::model::manifest_options::OrderPolicy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManifestOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_renditions][crate::model::ManifestOptions::include_renditions].
    pub fn set_include_renditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RenditionFilter>,
    {
        use std::iter::Iterator;
        self.include_renditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bitrate_order][crate::model::ManifestOptions::bitrate_order].
    pub fn set_bitrate_order<T: std::convert::Into<crate::model::manifest_options::OrderPolicy>>(
        mut self,
        v: T,
    ) -> Self {
        self.bitrate_order = v.into();
        self
    }
}

impl wkt::message::Message for ManifestOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ManifestOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManifestOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_renditions,
            __bitrate_order,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManifestOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeRenditions" => Ok(__FieldTag::__include_renditions),
                            "include_renditions" => Ok(__FieldTag::__include_renditions),
                            "bitrateOrder" => Ok(__FieldTag::__bitrate_order),
                            "bitrate_order" => Ok(__FieldTag::__bitrate_order),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManifestOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManifestOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_renditions => {
                            if !fields.insert(__FieldTag::__include_renditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_renditions",
                                ));
                            }
                            result.include_renditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RenditionFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bitrate_order => {
                            if !fields.insert(__FieldTag::__bitrate_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitrate_order",
                                ));
                            }
                            result.bitrate_order =
                                map.next_value::<std::option::Option<
                                    crate::model::manifest_options::OrderPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManifestOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.include_renditions.is_empty() {
            state.serialize_entry("includeRenditions", &self.include_renditions)?;
        }
        if !wkt::internal::is_default(&self.bitrate_order) {
            state.serialize_entry("bitrateOrder", &self.bitrate_order)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ManifestOptions].
pub mod manifest_options {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the ordering policy during manifest generation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OrderPolicy {
        /// Ordering policy is not specified.
        Unspecified,
        /// Order by ascending.
        Ascending,
        /// Order by descending.
        Descending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OrderPolicy::value] or
        /// [OrderPolicy::name].
        UnknownValue(order_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod order_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OrderPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ascending => std::option::Option::Some(1),
                Self::Descending => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ORDER_POLICY_UNSPECIFIED"),
                Self::Ascending => std::option::Option::Some("ASCENDING"),
                Self::Descending => std::option::Option::Some("DESCENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OrderPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OrderPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OrderPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ascending,
                2 => Self::Descending,
                _ => Self::UnknownValue(order_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OrderPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ORDER_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ASCENDING" => Self::Ascending,
                "DESCENDING" => Self::Descending,
                _ => Self::UnknownValue(order_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OrderPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ascending => serializer.serialize_i32(1),
                Self::Descending => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OrderPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OrderPolicy>::new(
                ".google.cloud.video.stitcher.v1.ManifestOptions.OrderPolicy",
            ))
        }
    }
}

/// Filters for a video or muxed redition.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RenditionFilter {
    /// Bitrate in bits per second for the rendition. If set, only renditions with
    /// the exact bitrate will match.
    pub bitrate_bps: i32,

    /// Codecs for the rendition. If set, only renditions with the exact value
    /// will match.
    pub codecs: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenditionFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bitrate_bps][crate::model::RenditionFilter::bitrate_bps].
    pub fn set_bitrate_bps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bitrate_bps = v.into();
        self
    }

    /// Sets the value of [codecs][crate::model::RenditionFilter::codecs].
    pub fn set_codecs<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codecs = v.into();
        self
    }
}

impl wkt::message::Message for RenditionFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.RenditionFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RenditionFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bitrate_bps,
            __codecs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RenditionFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bitrateBps" => Ok(__FieldTag::__bitrate_bps),
                            "bitrate_bps" => Ok(__FieldTag::__bitrate_bps),
                            "codecs" => Ok(__FieldTag::__codecs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RenditionFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RenditionFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bitrate_bps => {
                            if !fields.insert(__FieldTag::__bitrate_bps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitrate_bps",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bitrate_bps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__codecs => {
                            if !fields.insert(__FieldTag::__codecs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codecs",
                                ));
                            }
                            result.codecs = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RenditionFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.bitrate_bps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bitrateBps", &__With(&self.bitrate_bps))?;
        }
        if !self.codecs.is_empty() {
            state.serialize_entry("codecs", &self.codecs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Slate object
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Slate {
    /// Output only. The name of the slate, in the form of
    /// `projects/{project_number}/locations/{location}/slates/{id}`.
    pub name: std::string::String,

    /// The URI to fetch the source content for the slate. This URI must return an
    /// MP4 video with at least one audio track.
    pub uri: std::string::String,

    /// gam_slate has all the GAM-related attributes of slates.
    pub gam_slate: std::option::Option<crate::model::slate::GamSlate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Slate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Slate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Slate::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [gam_slate][crate::model::Slate::gam_slate].
    pub fn set_gam_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slate::GamSlate>,
    {
        self.gam_slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_slate][crate::model::Slate::gam_slate].
    pub fn set_or_clear_gam_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slate::GamSlate>,
    {
        self.gam_slate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Slate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Slate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Slate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uri,
            __gam_slate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Slate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uri" => Ok(__FieldTag::__uri),
                            "gamSlate" => Ok(__FieldTag::__gam_slate),
                            "gam_slate" => Ok(__FieldTag::__gam_slate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Slate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Slate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gam_slate => {
                            if !fields.insert(__FieldTag::__gam_slate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gam_slate",
                                ));
                            }
                            result.gam_slate = map
                                .next_value::<std::option::Option<crate::model::slate::GamSlate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Slate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.gam_slate.is_some() {
            state.serialize_entry("gamSlate", &self.gam_slate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Slate].
pub mod slate {
    #[allow(unused_imports)]
    use super::*;

    /// GamSlate object has Google Ad Manager (GAM) related properties for the
    /// slate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GamSlate {
        /// Required. Ad Manager network code to associate with the live config.
        pub network_code: std::string::String,

        /// Output only. The identifier generated for the slate by GAM.
        pub gam_slate_id: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSlate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_code][crate::model::slate::GamSlate::network_code].
        pub fn set_network_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_code = v.into();
            self
        }

        /// Sets the value of [gam_slate_id][crate::model::slate::GamSlate::gam_slate_id].
        pub fn set_gam_slate_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.gam_slate_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GamSlate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.Slate.GamSlate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GamSlate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_code,
                __gam_slate_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GamSlate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkCode" => Ok(__FieldTag::__network_code),
                                "network_code" => Ok(__FieldTag::__network_code),
                                "gamSlateId" => Ok(__FieldTag::__gam_slate_id),
                                "gam_slate_id" => Ok(__FieldTag::__gam_slate_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GamSlate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GamSlate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_code => {
                                if !fields.insert(__FieldTag::__network_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_code",
                                    ));
                                }
                                result.network_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gam_slate_id => {
                                if !fields.insert(__FieldTag::__gam_slate_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gam_slate_id",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.gam_slate_id =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GamSlate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_code.is_empty() {
                state.serialize_entry("networkCode", &self.network_code)?;
            }
            if !wkt::internal::is_default(&self.gam_slate_id) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("gamSlateId", &__With(&self.gam_slate_id))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Information related to the interstitial of a VOD session. This resource is
/// only available for VOD sessions that do not implement Google Ad Manager ad
/// insertion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodStitchDetail {
    /// The name of the stitch detail in the specified VOD session, in the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodStitchDetails/{id}`.
    pub name: std::string::String,

    /// A list of ad processing details for the fetched ad playlist.
    pub ad_stitch_details: std::vec::Vec<crate::model::AdStitchDetail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodStitchDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodStitchDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_stitch_details][crate::model::VodStitchDetail::ad_stitch_details].
    pub fn set_ad_stitch_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdStitchDetail>,
    {
        use std::iter::Iterator;
        self.ad_stitch_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodStitchDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodStitchDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodStitchDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ad_stitch_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodStitchDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "adStitchDetails" => Ok(__FieldTag::__ad_stitch_details),
                            "ad_stitch_details" => Ok(__FieldTag::__ad_stitch_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodStitchDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodStitchDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_stitch_details => {
                            if !fields.insert(__FieldTag::__ad_stitch_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_stitch_details",
                                ));
                            }
                            result.ad_stitch_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdStitchDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodStitchDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ad_stitch_details.is_empty() {
            state.serialize_entry("adStitchDetails", &self.ad_stitch_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a stitched ad.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdStitchDetail {
    /// Required. The ad break ID of the processed ad.
    pub ad_break_id: std::string::String,

    /// Required. The ad ID of the processed ad.
    pub ad_id: std::string::String,

    /// Required. The time offset of the processed ad.
    pub ad_time_offset: std::option::Option<wkt::Duration>,

    /// Optional. Indicates the reason why the ad has been skipped.
    pub skip_reason: std::string::String,

    /// Optional. The metadata of the chosen media file for the ad.
    pub media: std::collections::HashMap<std::string::String, wkt::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdStitchDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ad_break_id][crate::model::AdStitchDetail::ad_break_id].
    pub fn set_ad_break_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_break_id = v.into();
        self
    }

    /// Sets the value of [ad_id][crate::model::AdStitchDetail::ad_id].
    pub fn set_ad_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_id = v.into();
        self
    }

    /// Sets the value of [ad_time_offset][crate::model::AdStitchDetail::ad_time_offset].
    pub fn set_ad_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ad_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ad_time_offset][crate::model::AdStitchDetail::ad_time_offset].
    pub fn set_or_clear_ad_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ad_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_reason][crate::model::AdStitchDetail::skip_reason].
    pub fn set_skip_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_reason = v.into();
        self
    }

    /// Sets the value of [media][crate::model::AdStitchDetail::media].
    pub fn set_media<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.media = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AdStitchDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AdStitchDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdStitchDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ad_break_id,
            __ad_id,
            __ad_time_offset,
            __skip_reason,
            __media,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdStitchDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adBreakId" => Ok(__FieldTag::__ad_break_id),
                            "ad_break_id" => Ok(__FieldTag::__ad_break_id),
                            "adId" => Ok(__FieldTag::__ad_id),
                            "ad_id" => Ok(__FieldTag::__ad_id),
                            "adTimeOffset" => Ok(__FieldTag::__ad_time_offset),
                            "ad_time_offset" => Ok(__FieldTag::__ad_time_offset),
                            "skipReason" => Ok(__FieldTag::__skip_reason),
                            "skip_reason" => Ok(__FieldTag::__skip_reason),
                            "media" => Ok(__FieldTag::__media),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdStitchDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdStitchDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ad_break_id => {
                            if !fields.insert(__FieldTag::__ad_break_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_break_id",
                                ));
                            }
                            result.ad_break_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_id => {
                            if !fields.insert(__FieldTag::__ad_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_id",
                                ));
                            }
                            result.ad_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_time_offset => {
                            if !fields.insert(__FieldTag::__ad_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_time_offset",
                                ));
                            }
                            result.ad_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__skip_reason => {
                            if !fields.insert(__FieldTag::__skip_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_reason",
                                ));
                            }
                            result.skip_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__media => {
                            if !fields.insert(__FieldTag::__media) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for media",
                                ));
                            }
                            result.media = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdStitchDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ad_break_id.is_empty() {
            state.serialize_entry("adBreakId", &self.ad_break_id)?;
        }
        if !self.ad_id.is_empty() {
            state.serialize_entry("adId", &self.ad_id)?;
        }
        if self.ad_time_offset.is_some() {
            state.serialize_entry("adTimeOffset", &self.ad_time_offset)?;
        }
        if !self.skip_reason.is_empty() {
            state.serialize_entry("skipReason", &self.skip_reason)?;
        }
        if !self.media.is_empty() {
            state.serialize_entry("media", &self.media)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createCdnKey.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCdnKeyRequest {
    /// Required. The project in which the CDN key should be created, in the form
    /// of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The CDN key resource to create.
    pub cdn_key: std::option::Option<crate::model::CdnKey>,

    /// Required. The ID to use for the CDN key, which will become the final
    /// component of the CDN key's resource name.
    ///
    /// This value should conform to RFC-1034, which restricts to
    /// lower-case letters, numbers, and hyphen, with the first character a
    /// letter, the last a letter or a number, and a 63 character maximum.
    pub cdn_key_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCdnKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cdn_key][crate::model::CreateCdnKeyRequest::cdn_key].
    pub fn set_cdn_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdn_key][crate::model::CreateCdnKeyRequest::cdn_key].
    pub fn set_or_clear_cdn_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cdn_key_id][crate::model::CreateCdnKeyRequest::cdn_key_id].
    pub fn set_cdn_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cdn_key_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateCdnKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCdnKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cdn_key,
            __cdn_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCdnKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cdnKey" => Ok(__FieldTag::__cdn_key),
                            "cdn_key" => Ok(__FieldTag::__cdn_key),
                            "cdnKeyId" => Ok(__FieldTag::__cdn_key_id),
                            "cdn_key_id" => Ok(__FieldTag::__cdn_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCdnKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCdnKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cdn_key => {
                            if !fields.insert(__FieldTag::__cdn_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cdn_key",
                                ));
                            }
                            result.cdn_key =
                                map.next_value::<std::option::Option<crate::model::CdnKey>>()?;
                        }
                        __FieldTag::__cdn_key_id => {
                            if !fields.insert(__FieldTag::__cdn_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cdn_key_id",
                                ));
                            }
                            result.cdn_key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCdnKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.cdn_key.is_some() {
            state.serialize_entry("cdnKey", &self.cdn_key)?;
        }
        if !self.cdn_key_id.is_empty() {
            state.serialize_entry("cdnKeyId", &self.cdn_key_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listCdnKeys.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCdnKeysRequest {
    /// Required. The project that contains the list of CDN keys, in the form of
    /// `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCdnKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCdnKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCdnKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCdnKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCdnKeysRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCdnKeysRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCdnKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListCdnKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCdnKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCdnKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCdnKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCdnKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCdnKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcher.ListCdnKeys.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCdnKeysResponse {
    /// List of CDN keys.
    pub cdn_keys: std::vec::Vec<crate::model::CdnKey>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCdnKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cdn_keys][crate::model::ListCdnKeysResponse::cdn_keys].
    pub fn set_cdn_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CdnKey>,
    {
        use std::iter::Iterator;
        self.cdn_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCdnKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCdnKeysResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCdnKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListCdnKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCdnKeysResponse {
    type PageItem = crate::model::CdnKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cdn_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCdnKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cdn_keys,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCdnKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cdnKeys" => Ok(__FieldTag::__cdn_keys),
                            "cdn_keys" => Ok(__FieldTag::__cdn_keys),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCdnKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCdnKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cdn_keys => {
                            if !fields.insert(__FieldTag::__cdn_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cdn_keys",
                                ));
                            }
                            result.cdn_keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CdnKey>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCdnKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cdn_keys.is_empty() {
            state.serialize_entry("cdnKeys", &self.cdn_keys)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getCdnKey.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCdnKeyRequest {
    /// Required. The name of the CDN key to be retrieved, in the form of
    /// `projects/{project}/locations/{location}/cdnKeys/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCdnKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetCdnKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCdnKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCdnKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCdnKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCdnKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCdnKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.deleteCdnKey.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCdnKeyRequest {
    /// Required. The name of the CDN key to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/cdnKeys/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCdnKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteCdnKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCdnKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCdnKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCdnKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCdnKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCdnKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.updateCdnKey.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCdnKeyRequest {
    /// Required. The CDN key resource which replaces the resource on the server.
    pub cdn_key: std::option::Option<crate::model::CdnKey>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cdn_key][crate::model::UpdateCdnKeyRequest::cdn_key].
    pub fn set_cdn_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdn_key][crate::model::UpdateCdnKeyRequest::cdn_key].
    pub fn set_or_clear_cdn_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCdnKeyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCdnKeyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateCdnKeyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCdnKeyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cdn_key,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCdnKeyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cdnKey" => Ok(__FieldTag::__cdn_key),
                            "cdn_key" => Ok(__FieldTag::__cdn_key),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCdnKeyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCdnKeyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cdn_key => {
                            if !fields.insert(__FieldTag::__cdn_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cdn_key",
                                ));
                            }
                            result.cdn_key =
                                map.next_value::<std::option::Option<crate::model::CdnKey>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCdnKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cdn_key.is_some() {
            state.serialize_entry("cdnKey", &self.cdn_key)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createVodSession
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVodSessionRequest {
    /// Required. The project and location in which the VOD session should be
    /// created, in the form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. Parameters for creating a session.
    pub vod_session: std::option::Option<crate::model::VodSession>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVodSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVodSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vod_session][crate::model::CreateVodSessionRequest::vod_session].
    pub fn set_vod_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodSession>,
    {
        self.vod_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_session][crate::model::CreateVodSessionRequest::vod_session].
    pub fn set_or_clear_vod_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodSession>,
    {
        self.vod_session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVodSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateVodSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVodSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vod_session,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVodSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vodSession" => Ok(__FieldTag::__vod_session),
                            "vod_session" => Ok(__FieldTag::__vod_session),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVodSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVodSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vod_session => {
                            if !fields.insert(__FieldTag::__vod_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_session",
                                ));
                            }
                            result.vod_session =
                                map.next_value::<std::option::Option<crate::model::VodSession>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVodSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.vod_session.is_some() {
            state.serialize_entry("vodSession", &self.vod_session)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getVodSession
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVodSessionRequest {
    /// Required. The name of the VOD session to be retrieved, in the form of
    /// `projects/{project_number}/locations/{location}/vodSessions/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVodSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVodSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVodSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVodSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVodSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listVodStitchDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodStitchDetailsRequest {
    /// Required. The VOD session where the stitch details belong to, in the form
    /// of `projects/{project}/locations/{location}/vodSessions/{id}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodStitchDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodStitchDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodStitchDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodStitchDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodStitchDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodStitchDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodStitchDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodStitchDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodStitchDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodStitchDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodStitchDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcherService.listVodStitchDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodStitchDetailsResponse {
    /// A List of stitch Details.
    pub vod_stitch_details: std::vec::Vec<crate::model::VodStitchDetail>,

    /// The pagination token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodStitchDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_stitch_details][crate::model::ListVodStitchDetailsResponse::vod_stitch_details].
    pub fn set_vod_stitch_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodStitchDetail>,
    {
        use std::iter::Iterator;
        self.vod_stitch_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodStitchDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodStitchDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodStitchDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodStitchDetailsResponse {
    type PageItem = crate::model::VodStitchDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_stitch_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodStitchDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vod_stitch_details,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodStitchDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vodStitchDetails" => Ok(__FieldTag::__vod_stitch_details),
                            "vod_stitch_details" => Ok(__FieldTag::__vod_stitch_details),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodStitchDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodStitchDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vod_stitch_details => {
                            if !fields.insert(__FieldTag::__vod_stitch_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_stitch_details",
                                ));
                            }
                            result.vod_stitch_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VodStitchDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodStitchDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vod_stitch_details.is_empty() {
            state.serialize_entry("vodStitchDetails", &self.vod_stitch_details)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getVodStitchDetail.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVodStitchDetailRequest {
    /// Required. The name of the stitch detail in the specified VOD session, in
    /// the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodStitchDetails/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodStitchDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodStitchDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodStitchDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodStitchDetailRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVodStitchDetailRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVodStitchDetailRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVodStitchDetailRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVodStitchDetailRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVodStitchDetailRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listVodAdTagDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodAdTagDetailsRequest {
    /// Required. The VOD session which the ad tag details belong to, in the form
    /// of `projects/{project}/locations/{location}/vodSessions/{vod_session_id}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodAdTagDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodAdTagDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodAdTagDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodAdTagDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodAdTagDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodAdTagDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodAdTagDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodAdTagDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodAdTagDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodAdTagDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodAdTagDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcherService.listVodAdTagDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodAdTagDetailsResponse {
    /// A List of ad tag details.
    pub vod_ad_tag_details: std::vec::Vec<crate::model::VodAdTagDetail>,

    /// The pagination token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodAdTagDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_ad_tag_details][crate::model::ListVodAdTagDetailsResponse::vod_ad_tag_details].
    pub fn set_vod_ad_tag_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodAdTagDetail>,
    {
        use std::iter::Iterator;
        self.vod_ad_tag_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodAdTagDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodAdTagDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodAdTagDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodAdTagDetailsResponse {
    type PageItem = crate::model::VodAdTagDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_ad_tag_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodAdTagDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vod_ad_tag_details,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodAdTagDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vodAdTagDetails" => Ok(__FieldTag::__vod_ad_tag_details),
                            "vod_ad_tag_details" => Ok(__FieldTag::__vod_ad_tag_details),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodAdTagDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodAdTagDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vod_ad_tag_details => {
                            if !fields.insert(__FieldTag::__vod_ad_tag_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_ad_tag_details",
                                ));
                            }
                            result.vod_ad_tag_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VodAdTagDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodAdTagDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vod_ad_tag_details.is_empty() {
            state.serialize_entry("vodAdTagDetails", &self.vod_ad_tag_details)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getVodAdTagDetail
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVodAdTagDetailRequest {
    /// Required. The name of the ad tag detail for the specified VOD session, in
    /// the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodAdTagDetails/{vod_ad_tag_detail}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodAdTagDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodAdTagDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodAdTagDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodAdTagDetailRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVodAdTagDetailRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVodAdTagDetailRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVodAdTagDetailRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVodAdTagDetailRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVodAdTagDetailRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listLiveAdTagDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLiveAdTagDetailsRequest {
    /// Required. The resource parent in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The pagination token returned from a previous List request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveAdTagDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLiveAdTagDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLiveAdTagDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLiveAdTagDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveAdTagDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveAdTagDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLiveAdTagDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLiveAdTagDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLiveAdTagDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLiveAdTagDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLiveAdTagDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcherService.listLiveAdTagDetails.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLiveAdTagDetailsResponse {
    /// A list of live session ad tag details.
    pub live_ad_tag_details: std::vec::Vec<crate::model::LiveAdTagDetail>,

    /// The pagination token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveAdTagDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_ad_tag_details][crate::model::ListLiveAdTagDetailsResponse::live_ad_tag_details].
    pub fn set_live_ad_tag_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LiveAdTagDetail>,
    {
        use std::iter::Iterator;
        self.live_ad_tag_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLiveAdTagDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveAdTagDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveAdTagDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLiveAdTagDetailsResponse {
    type PageItem = crate::model::LiveAdTagDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.live_ad_tag_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLiveAdTagDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __live_ad_tag_details,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLiveAdTagDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "liveAdTagDetails" => Ok(__FieldTag::__live_ad_tag_details),
                            "live_ad_tag_details" => Ok(__FieldTag::__live_ad_tag_details),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLiveAdTagDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLiveAdTagDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__live_ad_tag_details => {
                            if !fields.insert(__FieldTag::__live_ad_tag_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_ad_tag_details",
                                ));
                            }
                            result.live_ad_tag_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LiveAdTagDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLiveAdTagDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.live_ad_tag_details.is_empty() {
            state.serialize_entry("liveAdTagDetails", &self.live_ad_tag_details)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getLiveAdTagDetail
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLiveAdTagDetailRequest {
    /// Required. The resource name in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}/liveAdTagDetails/{live_ad_tag_detail}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveAdTagDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveAdTagDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveAdTagDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveAdTagDetailRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLiveAdTagDetailRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLiveAdTagDetailRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLiveAdTagDetailRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLiveAdTagDetailRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLiveAdTagDetailRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createSlate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSlateRequest {
    /// Required. The project in which the slate should be created, in the form of
    /// `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The unique identifier for the slate.
    /// This value should conform to RFC-1034, which restricts to
    /// lower-case letters, numbers, and hyphen, with the first character a
    /// letter, the last a letter or a number, and a 63 character maximum.
    pub slate_id: std::string::String,

    /// Required. The slate to create.
    pub slate: std::option::Option<crate::model::Slate>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSlateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [slate_id][crate::model::CreateSlateRequest::slate_id].
    pub fn set_slate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slate_id = v.into();
        self
    }

    /// Sets the value of [slate][crate::model::CreateSlateRequest::slate].
    pub fn set_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slate][crate::model::CreateSlateRequest::slate].
    pub fn set_or_clear_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSlateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateSlateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSlateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __slate_id,
            __slate,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSlateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "slateId" => Ok(__FieldTag::__slate_id),
                            "slate_id" => Ok(__FieldTag::__slate_id),
                            "slate" => Ok(__FieldTag::__slate),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSlateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSlateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slate_id => {
                            if !fields.insert(__FieldTag::__slate_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slate_id",
                                ));
                            }
                            result.slate_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__slate => {
                            if !fields.insert(__FieldTag::__slate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slate",
                                ));
                            }
                            result.slate =
                                map.next_value::<std::option::Option<crate::model::Slate>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSlateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.slate_id.is_empty() {
            state.serialize_entry("slateId", &self.slate_id)?;
        }
        if self.slate.is_some() {
            state.serialize_entry("slate", &self.slate)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getSlate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSlateRequest {
    /// Required. The name of the slate to be retrieved, of the slate, in the form
    /// of `projects/{project_number}/locations/{location}/slates/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSlateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetSlateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSlateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSlateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSlateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSlateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSlateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listSlates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSlatesRequest {
    /// Required. The project to list slates, in the form of
    /// `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSlatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSlatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSlatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSlatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSlatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSlatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSlatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListSlatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSlatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSlatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSlatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSlatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSlatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcherService.listSlates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSlatesResponse {
    /// The list of slates
    pub slates: std::vec::Vec<crate::model::Slate>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSlatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [slates][crate::model::ListSlatesResponse::slates].
    pub fn set_slates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Slate>,
    {
        use std::iter::Iterator;
        self.slates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSlatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSlatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSlatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListSlatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSlatesResponse {
    type PageItem = crate::model::Slate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.slates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSlatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __slates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSlatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "slates" => Ok(__FieldTag::__slates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSlatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSlatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__slates => {
                            if !fields.insert(__FieldTag::__slates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slates",
                                ));
                            }
                            result.slates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Slate>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSlatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.slates.is_empty() {
            state.serialize_entry("slates", &self.slates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.updateSlate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSlateRequest {
    /// Required. The resource with updated fields.
    pub slate: std::option::Option<crate::model::Slate>,

    /// Required. The update mask which specifies fields which should be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [slate][crate::model::UpdateSlateRequest::slate].
    pub fn set_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slate][crate::model::UpdateSlateRequest::slate].
    pub fn set_or_clear_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSlateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSlateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateSlateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSlateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __slate,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSlateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "slate" => Ok(__FieldTag::__slate),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSlateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSlateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__slate => {
                            if !fields.insert(__FieldTag::__slate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slate",
                                ));
                            }
                            result.slate =
                                map.next_value::<std::option::Option<crate::model::Slate>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSlateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.slate.is_some() {
            state.serialize_entry("slate", &self.slate)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.deleteSlate.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSlateRequest {
    /// Required. The name of the slate to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/slates/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSlateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteSlateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSlateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSlateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSlateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSlateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSlateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createLiveSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLiveSessionRequest {
    /// Required. The project and location in which the live session should be
    /// created, in the form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. Parameters for creating a live session.
    pub live_session: std::option::Option<crate::model::LiveSession>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLiveSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLiveSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [live_session][crate::model::CreateLiveSessionRequest::live_session].
    pub fn set_live_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveSession>,
    {
        self.live_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_session][crate::model::CreateLiveSessionRequest::live_session].
    pub fn set_or_clear_live_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveSession>,
    {
        self.live_session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLiveSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateLiveSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLiveSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __live_session,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLiveSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "liveSession" => Ok(__FieldTag::__live_session),
                            "live_session" => Ok(__FieldTag::__live_session),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLiveSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLiveSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__live_session => {
                            if !fields.insert(__FieldTag::__live_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_session",
                                ));
                            }
                            result.live_session =
                                map.next_value::<std::option::Option<crate::model::LiveSession>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLiveSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.live_session.is_some() {
            state.serialize_entry("liveSession", &self.live_session)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getSession.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLiveSessionRequest {
    /// Required. The name of the live session, in the form of
    /// `projects/{project_number}/locations/{location}/liveSessions/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLiveSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLiveSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLiveSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLiveSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLiveSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createLiveConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLiveConfigRequest {
    /// Required. The project in which the live config should be created, in
    /// the form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The unique identifier ID to use for the live config.
    pub live_config_id: std::string::String,

    /// Required. The live config resource to create.
    pub live_config: std::option::Option<crate::model::LiveConfig>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLiveConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [live_config_id][crate::model::CreateLiveConfigRequest::live_config_id].
    pub fn set_live_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.live_config_id = v.into();
        self
    }

    /// Sets the value of [live_config][crate::model::CreateLiveConfigRequest::live_config].
    pub fn set_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_config][crate::model::CreateLiveConfigRequest::live_config].
    pub fn set_or_clear_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateLiveConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateLiveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLiveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __live_config_id,
            __live_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLiveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "liveConfigId" => Ok(__FieldTag::__live_config_id),
                            "live_config_id" => Ok(__FieldTag::__live_config_id),
                            "liveConfig" => Ok(__FieldTag::__live_config),
                            "live_config" => Ok(__FieldTag::__live_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLiveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLiveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__live_config_id => {
                            if !fields.insert(__FieldTag::__live_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_config_id",
                                ));
                            }
                            result.live_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__live_config => {
                            if !fields.insert(__FieldTag::__live_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_config",
                                ));
                            }
                            result.live_config =
                                map.next_value::<std::option::Option<crate::model::LiveConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLiveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.live_config_id.is_empty() {
            state.serialize_entry("liveConfigId", &self.live_config_id)?;
        }
        if self.live_config.is_some() {
            state.serialize_entry("liveConfig", &self.live_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listLiveConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLiveConfigsRequest {
    /// Required. The project that contains the list of live configs, in the
    /// form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    /// Optional. The filter to apply to list results (see
    /// [Filtering](https://google.aip.dev/160)).
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results following
    /// [Cloud API
    /// syntax](https://cloud.google.com/apis/design/design_patterns#sorting_order).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLiveConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLiveConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLiveConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLiveConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLiveConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLiveConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLiveConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLiveConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLiveConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLiveConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcher.ListLiveConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLiveConfigsResponse {
    /// List of live configs.
    pub live_configs: std::vec::Vec<crate::model::LiveConfig>,

    /// The pagination token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_configs][crate::model::ListLiveConfigsResponse::live_configs].
    pub fn set_live_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LiveConfig>,
    {
        use std::iter::Iterator;
        self.live_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLiveConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLiveConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLiveConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLiveConfigsResponse {
    type PageItem = crate::model::LiveConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.live_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLiveConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __live_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLiveConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "liveConfigs" => Ok(__FieldTag::__live_configs),
                            "live_configs" => Ok(__FieldTag::__live_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLiveConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLiveConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__live_configs => {
                            if !fields.insert(__FieldTag::__live_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_configs",
                                ));
                            }
                            result.live_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LiveConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLiveConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.live_configs.is_empty() {
            state.serialize_entry("liveConfigs", &self.live_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getLiveConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLiveConfigRequest {
    /// Required. The name of the live config to be retrieved, in the form
    /// of
    /// `projects/{project_number}/locations/{location}/liveConfigs/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLiveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLiveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLiveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLiveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLiveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.deleteLiveConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLiveConfigRequest {
    /// Required. The name of the live config to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/liveConfigs/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteLiveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLiveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLiveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLiveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLiveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLiveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.updateLiveConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLiveConfigRequest {
    /// Required. The LiveConfig resource which replaces the resource on the
    /// server.
    pub live_config: std::option::Option<crate::model::LiveConfig>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_config][crate::model::UpdateLiveConfigRequest::live_config].
    pub fn set_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_config][crate::model::UpdateLiveConfigRequest::live_config].
    pub fn set_or_clear_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateLiveConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLiveConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateLiveConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLiveConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __live_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLiveConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "liveConfig" => Ok(__FieldTag::__live_config),
                            "live_config" => Ok(__FieldTag::__live_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLiveConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLiveConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__live_config => {
                            if !fields.insert(__FieldTag::__live_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_config",
                                ));
                            }
                            result.live_config =
                                map.next_value::<std::option::Option<crate::model::LiveConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLiveConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.live_config.is_some() {
            state.serialize_entry("liveConfig", &self.live_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.createVodConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVodConfigRequest {
    /// Required. The project in which the VOD config should be created, in
    /// the form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The unique identifier ID to use for the VOD config.
    pub vod_config_id: std::string::String,

    /// Required. The VOD config resource to create.
    pub vod_config: std::option::Option<crate::model::VodConfig>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVodConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vod_config_id][crate::model::CreateVodConfigRequest::vod_config_id].
    pub fn set_vod_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vod_config_id = v.into();
        self
    }

    /// Sets the value of [vod_config][crate::model::CreateVodConfigRequest::vod_config].
    pub fn set_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_config][crate::model::CreateVodConfigRequest::vod_config].
    pub fn set_or_clear_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVodConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateVodConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVodConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vod_config_id,
            __vod_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVodConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vodConfigId" => Ok(__FieldTag::__vod_config_id),
                            "vod_config_id" => Ok(__FieldTag::__vod_config_id),
                            "vodConfig" => Ok(__FieldTag::__vod_config),
                            "vod_config" => Ok(__FieldTag::__vod_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVodConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVodConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vod_config_id => {
                            if !fields.insert(__FieldTag::__vod_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_config_id",
                                ));
                            }
                            result.vod_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vod_config => {
                            if !fields.insert(__FieldTag::__vod_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_config",
                                ));
                            }
                            result.vod_config =
                                map.next_value::<std::option::Option<crate::model::VodConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVodConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.vod_config_id.is_empty() {
            state.serialize_entry("vodConfigId", &self.vod_config_id)?;
        }
        if self.vod_config.is_some() {
            state.serialize_entry("vodConfig", &self.vod_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.listVodConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodConfigsRequest {
    /// Required. The project that contains the list of VOD configs, in the
    /// form of `projects/{project_number}/locations/{location}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    pub page_token: std::string::String,

    /// Optional. The filter to apply to list results (see
    /// [Filtering](https://google.aip.dev/160)).
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results following
    /// [Cloud API
    /// syntax](https://cloud.google.com/apis/design/design_patterns#sorting_order).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVodConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVodConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVodConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for VideoStitcher.ListVodConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVodConfigsResponse {
    /// List of VOD configs.
    pub vod_configs: std::vec::Vec<crate::model::VodConfig>,

    /// The pagination token.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_configs][crate::model::ListVodConfigsResponse::vod_configs].
    pub fn set_vod_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodConfig>,
    {
        use std::iter::Iterator;
        self.vod_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVodConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVodConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodConfigsResponse {
    type PageItem = crate::model::VodConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVodConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vod_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVodConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vodConfigs" => Ok(__FieldTag::__vod_configs),
                            "vod_configs" => Ok(__FieldTag::__vod_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVodConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVodConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vod_configs => {
                            if !fields.insert(__FieldTag::__vod_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_configs",
                                ));
                            }
                            result.vod_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VodConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVodConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vod_configs.is_empty() {
            state.serialize_entry("vodConfigs", &self.vod_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.getVodConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVodConfigRequest {
    /// Required. The name of the VOD config to be retrieved, in the form
    /// of `projects/{project_number}/locations/{location}/vodConfigs/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVodConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVodConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVodConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVodConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVodConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.deleteVodConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVodConfigRequest {
    /// Required. The name of the VOD config to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/vodConfigs/{id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVodConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteVodConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVodConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVodConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVodConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVodConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVodConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for VideoStitcherService.updateVodConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVodConfigRequest {
    /// Required. The VOD config resource which replaces the resource on the
    /// server.
    pub vod_config: std::option::Option<crate::model::VodConfig>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_config][crate::model::UpdateVodConfigRequest::vod_config].
    pub fn set_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_config][crate::model::UpdateVodConfigRequest::vod_config].
    pub fn set_or_clear_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVodConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVodConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateVodConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVodConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vod_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVodConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vodConfig" => Ok(__FieldTag::__vod_config),
                            "vod_config" => Ok(__FieldTag::__vod_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVodConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVodConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vod_config => {
                            if !fields.insert(__FieldTag::__vod_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vod_config",
                                ));
                            }
                            result.vod_config =
                                map.next_value::<std::option::Option<crate::model::VodConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateVodConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.vod_config.is_some() {
            state.serialize_entry("vodConfig", &self.vod_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    pub verb: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata used to register VOD configs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VodConfig {
    /// Output only. The resource name of the VOD config, in the form of
    /// `projects/{project}/locations/{location}/vodConfigs/{id}`.
    pub name: std::string::String,

    /// Required. Source URI for the VOD stream manifest.
    pub source_uri: std::string::String,

    /// Required. The default ad tag associated with this VOD config.
    pub ad_tag_uri: std::string::String,

    /// Optional. Google Ad Manager (GAM) metadata.
    pub gam_vod_config: std::option::Option<crate::model::GamVodConfig>,

    /// Output only. State of the VOD config.
    pub state: crate::model::vod_config::State,

    /// Options for fetching source manifests and segments.
    pub source_fetch_options: std::option::Option<crate::model::FetchOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::VodConfig::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::VodConfig::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [gam_vod_config][crate::model::VodConfig::gam_vod_config].
    pub fn set_gam_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GamVodConfig>,
    {
        self.gam_vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_vod_config][crate::model::VodConfig::gam_vod_config].
    pub fn set_or_clear_gam_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GamVodConfig>,
    {
        self.gam_vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::VodConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::vod_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [source_fetch_options][crate::model::VodConfig::source_fetch_options].
    pub fn set_source_fetch_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_fetch_options][crate::model::VodConfig::source_fetch_options].
    pub fn set_or_clear_source_fetch_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VodConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_uri,
            __ad_tag_uri,
            __gam_vod_config,
            __state,
            __source_fetch_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VodConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceUri" => Ok(__FieldTag::__source_uri),
                            "source_uri" => Ok(__FieldTag::__source_uri),
                            "adTagUri" => Ok(__FieldTag::__ad_tag_uri),
                            "ad_tag_uri" => Ok(__FieldTag::__ad_tag_uri),
                            "gamVodConfig" => Ok(__FieldTag::__gam_vod_config),
                            "gam_vod_config" => Ok(__FieldTag::__gam_vod_config),
                            "state" => Ok(__FieldTag::__state),
                            "sourceFetchOptions" => Ok(__FieldTag::__source_fetch_options),
                            "source_fetch_options" => Ok(__FieldTag::__source_fetch_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VodConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VodConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_uri => {
                            if !fields.insert(__FieldTag::__source_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_uri",
                                ));
                            }
                            result.source_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ad_tag_uri => {
                            if !fields.insert(__FieldTag::__ad_tag_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_tag_uri",
                                ));
                            }
                            result.ad_tag_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gam_vod_config => {
                            if !fields.insert(__FieldTag::__gam_vod_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gam_vod_config",
                                ));
                            }
                            result.gam_vod_config = map
                                .next_value::<std::option::Option<crate::model::GamVodConfig>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::vod_config::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_fetch_options => {
                            if !fields.insert(__FieldTag::__source_fetch_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_fetch_options",
                                ));
                            }
                            result.source_fetch_options = map
                                .next_value::<std::option::Option<crate::model::FetchOptions>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VodConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_uri.is_empty() {
            state.serialize_entry("sourceUri", &self.source_uri)?;
        }
        if !self.ad_tag_uri.is_empty() {
            state.serialize_entry("adTagUri", &self.ad_tag_uri)?;
        }
        if self.gam_vod_config.is_some() {
            state.serialize_entry("gamVodConfig", &self.gam_vod_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.source_fetch_options.is_some() {
            state.serialize_entry("sourceFetchOptions", &self.source_fetch_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VodConfig].
pub mod vod_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the VOD config.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// VOD config is being created.
        Creating,
        /// VOD config is ready for use.
        Ready,
        /// VOD config is queued up for deletion.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.stitcher.v1.VodConfig.State",
            ))
        }
    }
}

/// Metadata used for GAM ad decisioning.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GamVodConfig {
    /// Required. Ad Manager network code to associate with the VOD config.
    pub network_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GamVodConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_code][crate::model::GamVodConfig::network_code].
    pub fn set_network_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_code = v.into();
        self
    }
}

impl wkt::message::Message for GamVodConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GamVodConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GamVodConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GamVodConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkCode" => Ok(__FieldTag::__network_code),
                            "network_code" => Ok(__FieldTag::__network_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GamVodConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GamVodConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_code => {
                            if !fields.insert(__FieldTag::__network_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_code",
                                ));
                            }
                            result.network_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GamVodConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_code.is_empty() {
            state.serialize_entry("networkCode", &self.network_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Determines the ad tracking policy.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AdTracking {
    /// The ad tracking policy is not specified.
    Unspecified,
    /// Client-side ad tracking is specified. The client player is expected to
    /// trigger playback and activity events itself.
    Client,
    /// The Video Stitcher API will trigger playback events on behalf of
    /// the client player.
    Server,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AdTracking::value] or
    /// [AdTracking::name].
    UnknownValue(ad_tracking::UnknownValue),
}

#[doc(hidden)]
pub mod ad_tracking {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AdTracking {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Client => std::option::Option::Some(1),
            Self::Server => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AD_TRACKING_UNSPECIFIED"),
            Self::Client => std::option::Option::Some("CLIENT"),
            Self::Server => std::option::Option::Some("SERVER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AdTracking {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AdTracking {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AdTracking {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Client,
            2 => Self::Server,
            _ => Self::UnknownValue(ad_tracking::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AdTracking {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AD_TRACKING_UNSPECIFIED" => Self::Unspecified,
            "CLIENT" => Self::Client,
            "SERVER" => Self::Server,
            _ => Self::UnknownValue(ad_tracking::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AdTracking {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Client => serializer.serialize_i32(1),
            Self::Server => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AdTracking {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AdTracking>::new(
            ".google.cloud.video.stitcher.v1.AdTracking",
        ))
    }
}
