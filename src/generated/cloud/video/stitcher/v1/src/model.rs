// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Information related to the details for one ad tag. This resource is only
/// available for live sessions that do not implement Google Ad Manager ad
/// insertion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LiveAdTagDetail {
    /// The resource name in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}/liveAdTagDetails/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of ad requests.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ad_requests: std::vec::Vec<crate::model::AdRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveAdTagDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveAdTagDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_requests][crate::model::LiveAdTagDetail::ad_requests].
    pub fn set_ad_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdRequest>,
    {
        use std::iter::Iterator;
        self.ad_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LiveAdTagDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveAdTagDetail"
    }
}

/// Information related to the details for one ad tag. This resource is only
/// available for VOD sessions that do not implement Google Ad Manager ad
/// insertion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodAdTagDetail {
    /// The name of the ad tag detail for the specified VOD session, in the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodAdTagDetails/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of ad requests for one ad tag.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ad_requests: std::vec::Vec<crate::model::AdRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodAdTagDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodAdTagDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_requests][crate::model::VodAdTagDetail::ad_requests].
    pub fn set_ad_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdRequest>,
    {
        use std::iter::Iterator;
        self.ad_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodAdTagDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodAdTagDetail"
    }
}

/// Details of an ad request to an ad server.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdRequest {
    /// The ad tag URI processed with integrated macros.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The request metadata used to make the ad request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_metadata: std::option::Option<crate::model::RequestMetadata>,

    /// The response metadata received from the ad request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_metadata: std::option::Option<crate::model::ResponseMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::AdRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [request_metadata][crate::model::AdRequest::request_metadata].
    pub fn set_request_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_metadata][crate::model::AdRequest::request_metadata].
    pub fn set_or_clear_request_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_metadata][crate::model::AdRequest::response_metadata].
    pub fn set_response_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.response_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response_metadata][crate::model::AdRequest::response_metadata].
    pub fn set_or_clear_response_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.response_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AdRequest"
    }
}

/// Metadata for an ad request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RequestMetadata {
    /// The HTTP headers of the ad request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub headers: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::RequestMetadata::headers].
    pub fn set_headers<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [headers][crate::model::RequestMetadata::headers].
    pub fn set_or_clear_headers<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RequestMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.RequestMetadata"
    }
}

/// Metadata for the response of an ad request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResponseMetadata {
    /// Error message received when making the ad request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error: std::string::String,

    /// Headers from the response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub headers: std::option::Option<wkt::Struct>,

    /// Status code for the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_code: std::string::String,

    /// Size in bytes of the response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub size_bytes: i32,

    /// Total time elapsed for the response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// The body of the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub body: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResponseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::ResponseMetadata::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::ResponseMetadata::headers].
    pub fn set_headers<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [headers][crate::model::ResponseMetadata::headers].
    pub fn set_or_clear_headers<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.headers = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_code][crate::model::ResponseMetadata::status_code].
    pub fn set_status_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_code = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::ResponseMetadata::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::ResponseMetadata::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::ResponseMetadata::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [body][crate::model::ResponseMetadata::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for ResponseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ResponseMetadata"
    }
}

/// Configuration for a CDN key. Used by the Video Stitcher
/// to sign URIs for fetching video manifests and signing
/// media segments for playback.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CdnKey {
    /// The resource name of the CDN key, in the form of
    /// `projects/{project}/locations/{location}/cdnKeys/{id}`.
    /// The name is ignored when creating a CDN key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The hostname this key applies to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Configuration associated with the CDN key.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub cdn_key_config: std::option::Option<crate::model::cdn_key::CdnKeyConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CdnKey::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [hostname][crate::model::CdnKey::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config].
    ///
    /// Note that all the setters affecting `cdn_key_config` are mutually
    /// exclusive.
    pub fn set_cdn_key_config<
        T: std::convert::Into<std::option::Option<crate::model::cdn_key::CdnKeyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config = v.into();
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `GoogleCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::GoogleCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `GoogleCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_google_cdn_key<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleCdnKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::GoogleCdnKey(v.into()));
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `AkamaiCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn akamai_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AkamaiCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::AkamaiCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `AkamaiCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_akamai_cdn_key<
        T: std::convert::Into<std::boxed::Box<crate::model::AkamaiCdnKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::AkamaiCdnKey(v.into()));
        self
    }

    /// The value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// if it holds a `MediaCdnKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn media_cdn_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MediaCdnKey>> {
        #[allow(unreachable_patterns)]
        self.cdn_key_config.as_ref().and_then(|v| match v {
            crate::model::cdn_key::CdnKeyConfig::MediaCdnKey(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cdn_key_config][crate::model::CdnKey::cdn_key_config]
    /// to hold a `MediaCdnKey`.
    ///
    /// Note that all the setters affecting `cdn_key_config` are
    /// mutually exclusive.
    pub fn set_media_cdn_key<T: std::convert::Into<std::boxed::Box<crate::model::MediaCdnKey>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cdn_key_config =
            std::option::Option::Some(crate::model::cdn_key::CdnKeyConfig::MediaCdnKey(v.into()));
        self
    }
}

impl wkt::message::Message for CdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CdnKey"
    }
}

/// Defines additional types related to [CdnKey].
pub mod cdn_key {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration associated with the CDN key.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CdnKeyConfig {
        /// The configuration for a Google Cloud CDN key.
        GoogleCdnKey(std::boxed::Box<crate::model::GoogleCdnKey>),
        /// The configuration for an Akamai CDN key.
        AkamaiCdnKey(std::boxed::Box<crate::model::AkamaiCdnKey>),
        /// The configuration for a Media CDN key.
        MediaCdnKey(std::boxed::Box<crate::model::MediaCdnKey>),
    }
}

/// Configuration for a Google Cloud CDN key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GoogleCdnKey {
    /// Input only. Secret for this Google Cloud CDN key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub private_key: ::bytes::Bytes,

    /// The public name of the Google Cloud CDN key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::GoogleCdnKey::private_key].
    pub fn set_private_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_name][crate::model::GoogleCdnKey::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }
}

impl wkt::message::Message for GoogleCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GoogleCdnKey"
    }
}

/// Configuration for an Akamai CDN key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AkamaiCdnKey {
    /// Input only. Token key for the Akamai CDN edge configuration.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub token_key: ::bytes::Bytes,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AkamaiCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token_key][crate::model::AkamaiCdnKey::token_key].
    pub fn set_token_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.token_key = v.into();
        self
    }
}

impl wkt::message::Message for AkamaiCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AkamaiCdnKey"
    }
}

/// Configuration for a Media CDN key.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MediaCdnKey {
    /// Input only. 64-byte ed25519 private key for this Media CDN key.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub private_key: ::bytes::Bytes,

    /// The keyset name of the Media CDN key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_name: std::string::String,

    /// Optional. If set, the URL will be signed using the Media CDN token.
    /// Otherwise, the URL would be signed using the standard Media CDN signature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub token_config: std::option::Option<crate::model::media_cdn_key::TokenConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MediaCdnKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_key][crate::model::MediaCdnKey::private_key].
    pub fn set_private_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.private_key = v.into();
        self
    }

    /// Sets the value of [key_name][crate::model::MediaCdnKey::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }

    /// Sets the value of [token_config][crate::model::MediaCdnKey::token_config].
    pub fn set_token_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::media_cdn_key::TokenConfig>,
    {
        self.token_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [token_config][crate::model::MediaCdnKey::token_config].
    pub fn set_or_clear_token_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::media_cdn_key::TokenConfig>,
    {
        self.token_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MediaCdnKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.MediaCdnKey"
    }
}

/// Defines additional types related to [MediaCdnKey].
pub mod media_cdn_key {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for a Media CDN token.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TokenConfig {
        /// Optional. The query parameter in which to find the token.
        ///
        /// The name must be 1-64 characters long and match
        /// the regular expression `[a-zA-Z]([a-zA-Z0-9_-])*` which means the
        /// first character must be a letter, and all following characters
        /// must be a dash, underscore, letter or digit.
        ///
        /// Defaults to `edge-cache-token`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_parameter: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TokenConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_parameter][crate::model::media_cdn_key::TokenConfig::query_parameter].
        pub fn set_query_parameter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.query_parameter = v.into();
            self
        }
    }

    impl wkt::message::Message for TokenConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.MediaCdnKey.TokenConfig"
        }
    }
}

/// Metadata for companion ads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompanionAds {
    /// Indicates how many of the companions should be displayed with the ad.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub display_requirement: crate::model::companion_ads::DisplayRequirement,

    /// List of companion ads.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub companions: std::vec::Vec<crate::model::Companion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompanionAds {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_requirement][crate::model::CompanionAds::display_requirement].
    pub fn set_display_requirement<
        T: std::convert::Into<crate::model::companion_ads::DisplayRequirement>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.display_requirement = v.into();
        self
    }

    /// Sets the value of [companions][crate::model::CompanionAds::companions].
    pub fn set_companions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Companion>,
    {
        use std::iter::Iterator;
        self.companions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CompanionAds {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CompanionAds"
    }
}

/// Defines additional types related to [CompanionAds].
pub mod companion_ads {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates how many of the companions should be displayed with the ad.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DisplayRequirement {
        /// Required companions are not specified. The default is ALL.
        Unspecified,
        /// All companions are required to be displayed.
        All,
        /// At least one of companions needs to be displayed.
        Any,
        /// All companions are optional for display.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DisplayRequirement::value] or
        /// [DisplayRequirement::name].
        UnknownValue(display_requirement::UnknownValue),
    }

    #[doc(hidden)]
    pub mod display_requirement {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DisplayRequirement {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::Any => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISPLAY_REQUIREMENT_UNSPECIFIED"),
                Self::All => std::option::Option::Some("ALL"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DisplayRequirement {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DisplayRequirement {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DisplayRequirement {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::Any,
                3 => Self::None,
                _ => Self::UnknownValue(display_requirement::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DisplayRequirement {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISPLAY_REQUIREMENT_UNSPECIFIED" => Self::Unspecified,
                "ALL" => Self::All,
                "ANY" => Self::Any,
                "NONE" => Self::None,
                _ => Self::UnknownValue(display_requirement::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DisplayRequirement {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::Any => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DisplayRequirement {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DisplayRequirement>::new(
                ".google.cloud.video.stitcher.v1.CompanionAds.DisplayRequirement",
            ))
        }
    }
}

/// Metadata for a companion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Companion {
    /// The API necessary to communicate with the creative if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_framework: std::string::String,

    /// The pixel height of the placement slot for the intended creative.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub height_px: i32,

    /// The pixel width of the placement slot for the intended creative.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub width_px: i32,

    /// The pixel height of the creative.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub asset_height_px: i32,

    /// The maximum pixel height of the creative in its expanded state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub expanded_height_px: i32,

    /// The pixel width of the creative.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub asset_width_px: i32,

    /// The maximum pixel width of the creative in its expanded state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub expanded_width_px: i32,

    /// The ID used to identify the desired placement on a publisher's page.
    /// Values to be used should be discussed between publishers and
    /// advertisers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_slot_id: std::string::String,

    /// The list of tracking events for the companion.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    /// Ad resource associated with the companion ad.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ad_resource: std::option::Option<crate::model::companion::AdResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Companion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [api_framework][crate::model::Companion::api_framework].
    pub fn set_api_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_framework = v.into();
        self
    }

    /// Sets the value of [height_px][crate::model::Companion::height_px].
    pub fn set_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height_px = v.into();
        self
    }

    /// Sets the value of [width_px][crate::model::Companion::width_px].
    pub fn set_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width_px = v.into();
        self
    }

    /// Sets the value of [asset_height_px][crate::model::Companion::asset_height_px].
    pub fn set_asset_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.asset_height_px = v.into();
        self
    }

    /// Sets the value of [expanded_height_px][crate::model::Companion::expanded_height_px].
    pub fn set_expanded_height_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expanded_height_px = v.into();
        self
    }

    /// Sets the value of [asset_width_px][crate::model::Companion::asset_width_px].
    pub fn set_asset_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.asset_width_px = v.into();
        self
    }

    /// Sets the value of [expanded_width_px][crate::model::Companion::expanded_width_px].
    pub fn set_expanded_width_px<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.expanded_width_px = v.into();
        self
    }

    /// Sets the value of [ad_slot_id][crate::model::Companion::ad_slot_id].
    pub fn set_ad_slot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_slot_id = v.into();
        self
    }

    /// Sets the value of [events][crate::model::Companion::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource].
    ///
    /// Note that all the setters affecting `ad_resource` are mutually
    /// exclusive.
    pub fn set_ad_resource<
        T: std::convert::Into<std::option::Option<crate::model::companion::AdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = v.into();
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `IframeAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn iframe_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IframeAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::IframeAdResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `IframeAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_iframe_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::IframeAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::IframeAdResource(v.into()),
        );
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `StaticAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::StaticAdResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `StaticAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_static_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::StaticAdResource(v.into()),
        );
        self
    }

    /// The value of [ad_resource][crate::model::Companion::ad_resource]
    /// if it holds a `HtmlAdResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn html_ad_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HtmlAdResource>> {
        #[allow(unreachable_patterns)]
        self.ad_resource.as_ref().and_then(|v| match v {
            crate::model::companion::AdResource::HtmlAdResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ad_resource][crate::model::Companion::ad_resource]
    /// to hold a `HtmlAdResource`.
    ///
    /// Note that all the setters affecting `ad_resource` are
    /// mutually exclusive.
    pub fn set_html_ad_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::HtmlAdResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ad_resource = std::option::Option::Some(
            crate::model::companion::AdResource::HtmlAdResource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Companion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Companion"
    }
}

/// Defines additional types related to [Companion].
pub mod companion {
    #[allow(unused_imports)]
    use super::*;

    /// Ad resource associated with the companion ad.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AdResource {
        /// The IFrame ad resource associated with the companion ad.
        IframeAdResource(std::boxed::Box<crate::model::IframeAdResource>),
        /// The static ad resource associated with the companion ad.
        StaticAdResource(std::boxed::Box<crate::model::StaticAdResource>),
        /// The HTML ad resource associated with the companion ad.
        HtmlAdResource(std::boxed::Box<crate::model::HtmlAdResource>),
    }
}

/// Metadata for an HTML ad resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HtmlAdResource {
    /// The HTML to display for the ad resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub html_source: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HtmlAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [html_source][crate::model::HtmlAdResource::html_source].
    pub fn set_html_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.html_source = v.into();
        self
    }
}

impl wkt::message::Message for HtmlAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.HtmlAdResource"
    }
}

/// Metadata for an IFrame ad resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IframeAdResource {
    /// URI source for an IFrame to display for the ad resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IframeAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::IframeAdResource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for IframeAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.IframeAdResource"
    }
}

/// Metadata for a static ad resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticAdResource {
    /// URI to the static file for the ad resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Describes the MIME type of the ad resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creative_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticAdResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::StaticAdResource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [creative_type][crate::model::StaticAdResource::creative_type].
    pub fn set_creative_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creative_type = v.into();
        self
    }
}

impl wkt::message::Message for StaticAdResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.StaticAdResource"
    }
}

/// Describes an event and a trigger URI.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Describes the event that occurred.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::event::EventType,

    /// The URI to trigger for this event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The ID of the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The offset in seconds if the event type is `PROGRESS`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub offset: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::EventType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Event::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Event::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::Event::offset].
    pub fn set_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [offset][crate::model::Event::offset].
    pub fn set_or_clear_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.offset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Event"
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the event that occurred.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// The event type is unspecified.
        Unspecified,
        /// First frame of creative ad viewed.
        CreativeView,
        /// Creative ad started.
        Start,
        /// Start of an ad break.
        BreakStart,
        /// End of an ad break.
        BreakEnd,
        /// Impression.
        Impression,
        /// First quartile progress.
        FirstQuartile,
        /// Midpoint progress.
        Midpoint,
        /// Third quartile progress.
        ThirdQuartile,
        /// Ad progress completed.
        Complete,
        /// Specific progress event with an offset.
        Progress,
        /// Player muted.
        Mute,
        /// Player unmuted.
        Unmute,
        /// Player paused.
        Pause,
        /// Click event.
        Click,
        /// Click-through event.
        ClickThrough,
        /// Player rewinding.
        Rewind,
        /// Player resumed.
        Resume,
        /// Error event.
        Error,
        /// Ad expanded to a larger size.
        Expand,
        /// Ad collapsed to a smaller size.
        Collapse,
        /// Non-linear ad closed.
        Close,
        /// Linear ad closed.
        CloseLinear,
        /// Ad skipped.
        Skip,
        /// Accept invitation event.
        AcceptInvitation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CreativeView => std::option::Option::Some(1),
                Self::Start => std::option::Option::Some(2),
                Self::BreakStart => std::option::Option::Some(3),
                Self::BreakEnd => std::option::Option::Some(4),
                Self::Impression => std::option::Option::Some(5),
                Self::FirstQuartile => std::option::Option::Some(6),
                Self::Midpoint => std::option::Option::Some(7),
                Self::ThirdQuartile => std::option::Option::Some(8),
                Self::Complete => std::option::Option::Some(9),
                Self::Progress => std::option::Option::Some(10),
                Self::Mute => std::option::Option::Some(11),
                Self::Unmute => std::option::Option::Some(12),
                Self::Pause => std::option::Option::Some(13),
                Self::Click => std::option::Option::Some(14),
                Self::ClickThrough => std::option::Option::Some(15),
                Self::Rewind => std::option::Option::Some(16),
                Self::Resume => std::option::Option::Some(17),
                Self::Error => std::option::Option::Some(18),
                Self::Expand => std::option::Option::Some(21),
                Self::Collapse => std::option::Option::Some(22),
                Self::Close => std::option::Option::Some(24),
                Self::CloseLinear => std::option::Option::Some(25),
                Self::Skip => std::option::Option::Some(26),
                Self::AcceptInvitation => std::option::Option::Some(27),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::CreativeView => std::option::Option::Some("CREATIVE_VIEW"),
                Self::Start => std::option::Option::Some("START"),
                Self::BreakStart => std::option::Option::Some("BREAK_START"),
                Self::BreakEnd => std::option::Option::Some("BREAK_END"),
                Self::Impression => std::option::Option::Some("IMPRESSION"),
                Self::FirstQuartile => std::option::Option::Some("FIRST_QUARTILE"),
                Self::Midpoint => std::option::Option::Some("MIDPOINT"),
                Self::ThirdQuartile => std::option::Option::Some("THIRD_QUARTILE"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::Progress => std::option::Option::Some("PROGRESS"),
                Self::Mute => std::option::Option::Some("MUTE"),
                Self::Unmute => std::option::Option::Some("UNMUTE"),
                Self::Pause => std::option::Option::Some("PAUSE"),
                Self::Click => std::option::Option::Some("CLICK"),
                Self::ClickThrough => std::option::Option::Some("CLICK_THROUGH"),
                Self::Rewind => std::option::Option::Some("REWIND"),
                Self::Resume => std::option::Option::Some("RESUME"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Expand => std::option::Option::Some("EXPAND"),
                Self::Collapse => std::option::Option::Some("COLLAPSE"),
                Self::Close => std::option::Option::Some("CLOSE"),
                Self::CloseLinear => std::option::Option::Some("CLOSE_LINEAR"),
                Self::Skip => std::option::Option::Some("SKIP"),
                Self::AcceptInvitation => std::option::Option::Some("ACCEPT_INVITATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CreativeView,
                2 => Self::Start,
                3 => Self::BreakStart,
                4 => Self::BreakEnd,
                5 => Self::Impression,
                6 => Self::FirstQuartile,
                7 => Self::Midpoint,
                8 => Self::ThirdQuartile,
                9 => Self::Complete,
                10 => Self::Progress,
                11 => Self::Mute,
                12 => Self::Unmute,
                13 => Self::Pause,
                14 => Self::Click,
                15 => Self::ClickThrough,
                16 => Self::Rewind,
                17 => Self::Resume,
                18 => Self::Error,
                21 => Self::Expand,
                22 => Self::Collapse,
                24 => Self::Close,
                25 => Self::CloseLinear,
                26 => Self::Skip,
                27 => Self::AcceptInvitation,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATIVE_VIEW" => Self::CreativeView,
                "START" => Self::Start,
                "BREAK_START" => Self::BreakStart,
                "BREAK_END" => Self::BreakEnd,
                "IMPRESSION" => Self::Impression,
                "FIRST_QUARTILE" => Self::FirstQuartile,
                "MIDPOINT" => Self::Midpoint,
                "THIRD_QUARTILE" => Self::ThirdQuartile,
                "COMPLETE" => Self::Complete,
                "PROGRESS" => Self::Progress,
                "MUTE" => Self::Mute,
                "UNMUTE" => Self::Unmute,
                "PAUSE" => Self::Pause,
                "CLICK" => Self::Click,
                "CLICK_THROUGH" => Self::ClickThrough,
                "REWIND" => Self::Rewind,
                "RESUME" => Self::Resume,
                "ERROR" => Self::Error,
                "EXPAND" => Self::Expand,
                "COLLAPSE" => Self::Collapse,
                "CLOSE" => Self::Close,
                "CLOSE_LINEAR" => Self::CloseLinear,
                "SKIP" => Self::Skip,
                "ACCEPT_INVITATION" => Self::AcceptInvitation,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CreativeView => serializer.serialize_i32(1),
                Self::Start => serializer.serialize_i32(2),
                Self::BreakStart => serializer.serialize_i32(3),
                Self::BreakEnd => serializer.serialize_i32(4),
                Self::Impression => serializer.serialize_i32(5),
                Self::FirstQuartile => serializer.serialize_i32(6),
                Self::Midpoint => serializer.serialize_i32(7),
                Self::ThirdQuartile => serializer.serialize_i32(8),
                Self::Complete => serializer.serialize_i32(9),
                Self::Progress => serializer.serialize_i32(10),
                Self::Mute => serializer.serialize_i32(11),
                Self::Unmute => serializer.serialize_i32(12),
                Self::Pause => serializer.serialize_i32(13),
                Self::Click => serializer.serialize_i32(14),
                Self::ClickThrough => serializer.serialize_i32(15),
                Self::Rewind => serializer.serialize_i32(16),
                Self::Resume => serializer.serialize_i32(17),
                Self::Error => serializer.serialize_i32(18),
                Self::Expand => serializer.serialize_i32(21),
                Self::Collapse => serializer.serialize_i32(22),
                Self::Close => serializer.serialize_i32(24),
                Self::CloseLinear => serializer.serialize_i32(25),
                Self::Skip => serializer.serialize_i32(26),
                Self::AcceptInvitation => serializer.serialize_i32(27),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.video.stitcher.v1.Event.EventType",
            ))
        }
    }
}

/// Indicates a time in which a list of events should be triggered
/// during media playback.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProgressEvent {
    /// The time when the following tracking events occurs. The time is in
    /// seconds relative to the start of the VOD asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_offset: std::option::Option<wkt::Duration>,

    /// The list of progress tracking events for the ad break. These can be of
    /// the following IAB types: `BREAK_START`, `BREAK_END`, `IMPRESSION`,
    /// `CREATIVE_VIEW`, `START`, `FIRST_QUARTILE`, `MIDPOINT`, `THIRD_QUARTILE`,
    /// `COMPLETE`, `PROGRESS`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub events: std::vec::Vec<crate::model::Event>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProgressEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_offset][crate::model::ProgressEvent::time_offset].
    pub fn set_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [time_offset][crate::model::ProgressEvent::time_offset].
    pub fn set_or_clear_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [events][crate::model::ProgressEvent::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProgressEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ProgressEvent"
    }
}

/// Options on how fetches should be made.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchOptions {
    /// Custom headers to pass into fetch request.
    /// Headers must have a maximum of 3 key value pairs.
    /// Each key value pair must have a maximum of 256 characters per key and 256
    /// characters per value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [headers][crate::model::FetchOptions::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for FetchOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.FetchOptions"
    }
}

/// Metadata for used to register live configs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LiveConfig {
    /// Output only. The resource name of the live config, in the form of
    /// `projects/{project}/locations/{location}/liveConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Source URI for the live stream manifest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_uri: std::string::String,

    /// The default ad tag associated with this live stream config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_tag_uri: std::string::String,

    /// Additional metadata used to register a live stream with Google Ad Manager
    /// (GAM)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gam_live_config: std::option::Option<crate::model::GamLiveConfig>,

    /// Output only. State of the live config.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::live_config::State,

    /// Required. Determines how the ads are tracked.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ad_tracking: crate::model::AdTracking,

    /// This must refer to a slate in the same
    /// project. If Google Ad Manager (GAM) is used for ads, this string sets the
    /// value of `slateCreativeId` in
    /// <https://developers.google.com/ad-manager/api/reference/v202211/LiveStreamEventService.LiveStreamEvent#slateCreativeId>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_slate: std::string::String,

    /// Defines the stitcher behavior in case an ad does not align exactly with
    /// the ad break boundaries. If not specified, the default is `CUT_CURRENT`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub stitching_policy: crate::model::live_config::StitchingPolicy,

    /// The configuration for prefetching ads.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prefetch_config: std::option::Option<crate::model::PrefetchConfig>,

    /// Options for fetching source manifests and segments.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_fetch_options: std::option::Option<crate::model::FetchOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::LiveConfig::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::LiveConfig::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [gam_live_config][crate::model::LiveConfig::gam_live_config].
    pub fn set_gam_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GamLiveConfig>,
    {
        self.gam_live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_live_config][crate::model::LiveConfig::gam_live_config].
    pub fn set_or_clear_gam_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GamLiveConfig>,
    {
        self.gam_live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::LiveConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::live_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::LiveConfig::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }

    /// Sets the value of [default_slate][crate::model::LiveConfig::default_slate].
    pub fn set_default_slate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_slate = v.into();
        self
    }

    /// Sets the value of [stitching_policy][crate::model::LiveConfig::stitching_policy].
    pub fn set_stitching_policy<
        T: std::convert::Into<crate::model::live_config::StitchingPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stitching_policy = v.into();
        self
    }

    /// Sets the value of [prefetch_config][crate::model::LiveConfig::prefetch_config].
    pub fn set_prefetch_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrefetchConfig>,
    {
        self.prefetch_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [prefetch_config][crate::model::LiveConfig::prefetch_config].
    pub fn set_or_clear_prefetch_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrefetchConfig>,
    {
        self.prefetch_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_fetch_options][crate::model::LiveConfig::source_fetch_options].
    pub fn set_source_fetch_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_fetch_options][crate::model::LiveConfig::source_fetch_options].
    pub fn set_or_clear_source_fetch_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveConfig"
    }
}

/// Defines additional types related to [LiveConfig].
pub mod live_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the live config.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// Live config is being created.
        Creating,
        /// Live config is ready for use.
        Ready,
        /// Live config is queued up for deletion.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.stitcher.v1.LiveConfig.State",
            ))
        }
    }

    /// Defines the ad stitching behavior in case the ad duration does not align
    /// exactly with the ad break boundaries. If not specified, the default is
    /// `CUT_CURRENT`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StitchingPolicy {
        /// Stitching policy is not specified.
        Unspecified,
        /// Cuts an ad short and returns to content in the middle of the ad.
        CutCurrent,
        /// Finishes stitching the current ad before returning to content.
        CompleteAd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StitchingPolicy::value] or
        /// [StitchingPolicy::name].
        UnknownValue(stitching_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stitching_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StitchingPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CutCurrent => std::option::Option::Some(1),
                Self::CompleteAd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STITCHING_POLICY_UNSPECIFIED"),
                Self::CutCurrent => std::option::Option::Some("CUT_CURRENT"),
                Self::CompleteAd => std::option::Option::Some("COMPLETE_AD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StitchingPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StitchingPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StitchingPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CutCurrent,
                2 => Self::CompleteAd,
                _ => Self::UnknownValue(stitching_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StitchingPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STITCHING_POLICY_UNSPECIFIED" => Self::Unspecified,
                "CUT_CURRENT" => Self::CutCurrent,
                "COMPLETE_AD" => Self::CompleteAd,
                _ => Self::UnknownValue(stitching_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StitchingPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CutCurrent => serializer.serialize_i32(1),
                Self::CompleteAd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StitchingPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StitchingPolicy>::new(
                ".google.cloud.video.stitcher.v1.LiveConfig.StitchingPolicy",
            ))
        }
    }
}

/// The configuration for prefetch ads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrefetchConfig {
    /// Required. Indicates whether the option to prefetch ad requests is enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// The duration in seconds of the part of the break to be prefetched.
    /// This field is only relevant if prefetch is enabled.
    /// You should set this duration to as long as possible to increase the
    /// benefits of prefetching, but not longer than the shortest ad break
    /// expected. For example, for a live event with 30s and 60s ad breaks, the
    /// initial duration should be set to 30s.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_ad_request_duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrefetchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PrefetchConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [initial_ad_request_duration][crate::model::PrefetchConfig::initial_ad_request_duration].
    pub fn set_initial_ad_request_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_ad_request_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_ad_request_duration][crate::model::PrefetchConfig::initial_ad_request_duration].
    pub fn set_or_clear_initial_ad_request_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.initial_ad_request_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PrefetchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.PrefetchConfig"
    }
}

/// Metadata used to register a live stream with Google Ad Manager (GAM)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GamLiveConfig {
    /// Required. Ad Manager network code to associate with the live config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_code: std::string::String,

    /// Output only. The asset key identifier generated for the live config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_key: std::string::String,

    /// Output only. The custom asset key identifier generated for the live config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_asset_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GamLiveConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_code][crate::model::GamLiveConfig::network_code].
    pub fn set_network_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_code = v.into();
        self
    }

    /// Sets the value of [asset_key][crate::model::GamLiveConfig::asset_key].
    pub fn set_asset_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_key = v.into();
        self
    }

    /// Sets the value of [custom_asset_key][crate::model::GamLiveConfig::custom_asset_key].
    pub fn set_custom_asset_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_asset_key = v.into();
        self
    }
}

impl wkt::message::Message for GamLiveConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GamLiveConfig"
    }
}

/// Metadata for a VOD session. The session expires 4 hours after its creation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodSession {
    /// Output only. The name of the VOD session, in the form of
    /// `projects/{project_number}/locations/{location}/vodSessions/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Metadata of what was stitched into the content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interstitials: std::option::Option<crate::model::Interstitials>,

    /// Output only. The playback URI of the stitched content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub play_uri: std::string::String,

    /// URI of the media to stitch. For most use cases, you should create a
    /// [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
    /// rather than setting this field directly.
    ///
    /// [google.cloud.video.stitcher.v1.VodConfig]: crate::model::VodConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_uri: std::string::String,

    /// Ad tag URI. For most use cases, you should create a
    /// [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
    /// rather than setting this field directly.
    ///
    /// [google.cloud.video.stitcher.v1.VodConfig]: crate::model::VodConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_tag_uri: std::string::String,

    /// Key value pairs for ad tag macro replacement, only available for VOD
    /// sessions that do not implement Google Ad manager ad insertion. If the
    /// specified ad tag URI has macros, this field provides the mapping to the
    /// value that will replace the macro in the ad tag URI.
    ///
    /// Macros are designated by square brackets, for example:
    ///
    /// Ad tag URI: `"<https://doubleclick.google.com/ad/1?geo_id=>[geoId]"`
    ///
    /// Ad tag macro map: `{"geoId": "123"}`
    ///
    /// Fully qualified ad tag:
    /// ``https://doubleclick.google.com/ad/1?geo_id=123``
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub ad_tag_macro_map: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional options that affect the output of the manifest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub manifest_options: std::option::Option<crate::model::ManifestOptions>,

    /// Output only. The generated ID of the VodSession's source media.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_id: std::string::String,

    /// Required. Determines how the ad should be tracked.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ad_tracking: crate::model::AdTracking,

    /// This field should be set with appropriate values if GAM is being used for
    /// ads.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gam_settings: std::option::Option<crate::model::vod_session::GamSettings>,

    /// The resource name of the VOD config for this session, in the form of
    /// `projects/{project}/locations/{location}/vodConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vod_config: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interstitials][crate::model::VodSession::interstitials].
    pub fn set_interstitials<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Interstitials>,
    {
        self.interstitials = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interstitials][crate::model::VodSession::interstitials].
    pub fn set_or_clear_interstitials<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Interstitials>,
    {
        self.interstitials = v.map(|x| x.into());
        self
    }

    /// Sets the value of [play_uri][crate::model::VodSession::play_uri].
    pub fn set_play_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.play_uri = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::VodSession::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::VodSession::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_macro_map][crate::model::VodSession::ad_tag_macro_map].
    pub fn set_ad_tag_macro_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ad_tag_macro_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [manifest_options][crate::model::VodSession::manifest_options].
    pub fn set_manifest_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [manifest_options][crate::model::VodSession::manifest_options].
    pub fn set_or_clear_manifest_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_id][crate::model::VodSession::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::VodSession::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }

    /// Sets the value of [gam_settings][crate::model::VodSession::gam_settings].
    pub fn set_gam_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vod_session::GamSettings>,
    {
        self.gam_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_settings][crate::model::VodSession::gam_settings].
    pub fn set_or_clear_gam_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vod_session::GamSettings>,
    {
        self.gam_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vod_config][crate::model::VodSession::vod_config].
    pub fn set_vod_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vod_config = v.into();
        self
    }
}

impl wkt::message::Message for VodSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSession"
    }
}

/// Defines additional types related to [VodSession].
pub mod vod_session {
    #[allow(unused_imports)]
    use super::*;

    /// Defines fields related to Google Ad Manager (GAM). This should be set if
    /// GAM is being used for ads.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GamSettings {
        /// Required. Ad Manager network code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network_code: std::string::String,

        /// Required. The stream ID generated by Ad Manager.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub stream_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_code][crate::model::vod_session::GamSettings::network_code].
        pub fn set_network_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_code = v.into();
            self
        }

        /// Sets the value of [stream_id][crate::model::vod_session::GamSettings::stream_id].
        pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GamSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.VodSession.GamSettings"
        }
    }
}

/// Describes what was stitched into a VOD session's manifest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Interstitials {
    /// List of ad breaks ordered by time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ad_breaks: std::vec::Vec<crate::model::VodSessionAdBreak>,

    /// Information related to the content of the VOD session.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_content: std::option::Option<crate::model::VodSessionContent>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Interstitials {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ad_breaks][crate::model::Interstitials::ad_breaks].
    pub fn set_ad_breaks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodSessionAdBreak>,
    {
        use std::iter::Iterator;
        self.ad_breaks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [session_content][crate::model::Interstitials::session_content].
    pub fn set_session_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodSessionContent>,
    {
        self.session_content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_content][crate::model::Interstitials::session_content].
    pub fn set_or_clear_session_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodSessionContent>,
    {
        self.session_content = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Interstitials {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Interstitials"
    }
}

/// Metadata for an inserted ad in a VOD session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodSessionAd {
    /// Duration in seconds of the ad.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Metadata of companion ads associated with the ad.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub companion_ads: std::option::Option<crate::model::CompanionAds>,

    /// The list of progress tracking events for the ad break. These can be of
    /// the following IAB types: `MUTE`, `UNMUTE`, `PAUSE`, `CLICK`,
    /// `CLICK_THROUGH`, `REWIND`, `RESUME`, `ERROR`, `FULLSCREEN`,
    /// `EXIT_FULLSCREEN`, `EXPAND`, `COLLAPSE`, `ACCEPT_INVITATION_LINEAR`,
    /// `CLOSE_LINEAR`, `SKIP`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub activity_events: std::vec::Vec<crate::model::Event>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionAd {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [duration][crate::model::VodSessionAd::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::VodSessionAd::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [companion_ads][crate::model::VodSessionAd::companion_ads].
    pub fn set_companion_ads<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompanionAds>,
    {
        self.companion_ads = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [companion_ads][crate::model::VodSessionAd::companion_ads].
    pub fn set_or_clear_companion_ads<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompanionAds>,
    {
        self.companion_ads = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activity_events][crate::model::VodSessionAd::activity_events].
    pub fn set_activity_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.activity_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodSessionAd {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionAd"
    }
}

/// Metadata for the entire stitched content in a VOD session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodSessionContent {
    /// The total duration in seconds of the content including the ads stitched
    /// in.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [duration][crate::model::VodSessionContent::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::VodSessionContent::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodSessionContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionContent"
    }
}

/// Metadata for an inserted ad break.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodSessionAdBreak {
    /// List of events that are expected to be triggered, ordered by time.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub progress_events: std::vec::Vec<crate::model::ProgressEvent>,

    /// Ordered list of ads stitched into the ad break.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ads: std::vec::Vec<crate::model::VodSessionAd>,

    /// Ad break end time in seconds relative to the start of the VOD asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time_offset: std::option::Option<wkt::Duration>,

    /// Ad break start time in seconds relative to the start of the VOD asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time_offset: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodSessionAdBreak {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_events][crate::model::VodSessionAdBreak::progress_events].
    pub fn set_progress_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProgressEvent>,
    {
        use std::iter::Iterator;
        self.progress_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ads][crate::model::VodSessionAdBreak::ads].
    pub fn set_ads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodSessionAd>,
    {
        use std::iter::Iterator;
        self.ads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_time_offset][crate::model::VodSessionAdBreak::end_time_offset].
    pub fn set_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time_offset][crate::model::VodSessionAdBreak::end_time_offset].
    pub fn set_or_clear_end_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time_offset][crate::model::VodSessionAdBreak::start_time_offset].
    pub fn set_start_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time_offset][crate::model::VodSessionAdBreak::start_time_offset].
    pub fn set_or_clear_start_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_time_offset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodSessionAdBreak {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodSessionAdBreak"
    }
}

/// Metadata for a live session. The session expires 5 minutes after the client
/// stops fetching the session's playlists.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LiveSession {
    /// Output only. The name of the live session, in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The URI to play the live session's ad-stitched stream.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub play_uri: std::string::String,

    /// Key value pairs for ad tag macro replacement, only available for live
    /// sessions that do not implement Google Ad manager ad insertion. If the
    /// specified ad tag URI has macros, this field provides the mapping to the
    /// value that will replace the macro in the ad tag URI.
    ///
    /// Macros are designated by square brackets, for example:
    ///
    /// Ad tag URI: "<https://doubleclick.google.com/ad/1?geo_id=>[geoId]"
    ///
    /// Ad tag macros: `{"geoId": "123"}`
    ///
    /// Fully qualified ad tag:
    /// ``https://doubleclick.google.com/ad/1?geo_id=123``
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub ad_tag_macros: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional options that affect the output of the manifest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub manifest_options: std::option::Option<crate::model::ManifestOptions>,

    /// This field should be set with appropriate values if GAM is being used for
    /// ads.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gam_settings: std::option::Option<crate::model::live_session::GamSettings>,

    /// Required. The resource name of the live config for this session, in the
    /// form of `projects/{project}/locations/{location}/liveConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub live_config: std::string::String,

    /// Determines how the ad should be tracked. This overrides the value set in
    /// the live config for this session.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ad_tracking: crate::model::AdTracking,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LiveSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LiveSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [play_uri][crate::model::LiveSession::play_uri].
    pub fn set_play_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.play_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_macros][crate::model::LiveSession::ad_tag_macros].
    pub fn set_ad_tag_macros<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ad_tag_macros = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [manifest_options][crate::model::LiveSession::manifest_options].
    pub fn set_manifest_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [manifest_options][crate::model::LiveSession::manifest_options].
    pub fn set_or_clear_manifest_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManifestOptions>,
    {
        self.manifest_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gam_settings][crate::model::LiveSession::gam_settings].
    pub fn set_gam_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::live_session::GamSettings>,
    {
        self.gam_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_settings][crate::model::LiveSession::gam_settings].
    pub fn set_or_clear_gam_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::live_session::GamSettings>,
    {
        self.gam_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [live_config][crate::model::LiveSession::live_config].
    pub fn set_live_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.live_config = v.into();
        self
    }

    /// Sets the value of [ad_tracking][crate::model::LiveSession::ad_tracking].
    pub fn set_ad_tracking<T: std::convert::Into<crate::model::AdTracking>>(
        mut self,
        v: T,
    ) -> Self {
        self.ad_tracking = v.into();
        self
    }
}

impl wkt::message::Message for LiveSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.LiveSession"
    }
}

/// Defines additional types related to [LiveSession].
pub mod live_session {
    #[allow(unused_imports)]
    use super::*;

    /// Defines fields related to Google Ad Manager (GAM).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GamSettings {
        /// Required. The stream ID generated by Ad Manager. This must be set if GAM
        /// is being used for ads and the session uses client-side ad tracking.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub stream_id: std::string::String,

        /// [Targeting
        /// parameters](https://support.google.com/admanager/answer/7320899) to send
        /// to Ad Manager to generate a stream ID. This should only be set if the
        /// session uses server-side ad tracking.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub targeting_parameters:
            std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stream_id][crate::model::live_session::GamSettings::stream_id].
        pub fn set_stream_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stream_id = v.into();
            self
        }

        /// Sets the value of [targeting_parameters][crate::model::live_session::GamSettings::targeting_parameters].
        pub fn set_targeting_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.targeting_parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for GamSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.LiveSession.GamSettings"
        }
    }
}

/// Options for manifest generation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManifestOptions {
    /// If specified, the output manifest will only return renditions matching the
    /// specified filters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_renditions: std::vec::Vec<crate::model::RenditionFilter>,

    /// If specified, the output manifest will orders the video and muxed
    /// renditions by bitrate according to the ordering policy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub bitrate_order: crate::model::manifest_options::OrderPolicy,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManifestOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_renditions][crate::model::ManifestOptions::include_renditions].
    pub fn set_include_renditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RenditionFilter>,
    {
        use std::iter::Iterator;
        self.include_renditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bitrate_order][crate::model::ManifestOptions::bitrate_order].
    pub fn set_bitrate_order<T: std::convert::Into<crate::model::manifest_options::OrderPolicy>>(
        mut self,
        v: T,
    ) -> Self {
        self.bitrate_order = v.into();
        self
    }
}

impl wkt::message::Message for ManifestOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ManifestOptions"
    }
}

/// Defines additional types related to [ManifestOptions].
pub mod manifest_options {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the ordering policy during manifest generation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OrderPolicy {
        /// Ordering policy is not specified.
        Unspecified,
        /// Order by ascending.
        Ascending,
        /// Order by descending.
        Descending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OrderPolicy::value] or
        /// [OrderPolicy::name].
        UnknownValue(order_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod order_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OrderPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ascending => std::option::Option::Some(1),
                Self::Descending => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ORDER_POLICY_UNSPECIFIED"),
                Self::Ascending => std::option::Option::Some("ASCENDING"),
                Self::Descending => std::option::Option::Some("DESCENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OrderPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OrderPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OrderPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ascending,
                2 => Self::Descending,
                _ => Self::UnknownValue(order_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OrderPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ORDER_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ASCENDING" => Self::Ascending,
                "DESCENDING" => Self::Descending,
                _ => Self::UnknownValue(order_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OrderPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ascending => serializer.serialize_i32(1),
                Self::Descending => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OrderPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OrderPolicy>::new(
                ".google.cloud.video.stitcher.v1.ManifestOptions.OrderPolicy",
            ))
        }
    }
}

/// Filters for a video or muxed redition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RenditionFilter {
    /// Bitrate in bits per second for the rendition. If set, only renditions with
    /// the exact bitrate will match.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub bitrate_bps: i32,

    /// Codecs for the rendition. If set, only renditions with the exact value
    /// will match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub codecs: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RenditionFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bitrate_bps][crate::model::RenditionFilter::bitrate_bps].
    pub fn set_bitrate_bps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bitrate_bps = v.into();
        self
    }

    /// Sets the value of [codecs][crate::model::RenditionFilter::codecs].
    pub fn set_codecs<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codecs = v.into();
        self
    }
}

impl wkt::message::Message for RenditionFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.RenditionFilter"
    }
}

/// Slate object
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Slate {
    /// Output only. The name of the slate, in the form of
    /// `projects/{project_number}/locations/{location}/slates/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The URI to fetch the source content for the slate. This URI must return an
    /// MP4 video with at least one audio track.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// gam_slate has all the GAM-related attributes of slates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gam_slate: std::option::Option<crate::model::slate::GamSlate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Slate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Slate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Slate::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [gam_slate][crate::model::Slate::gam_slate].
    pub fn set_gam_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::slate::GamSlate>,
    {
        self.gam_slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_slate][crate::model::Slate::gam_slate].
    pub fn set_or_clear_gam_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::slate::GamSlate>,
    {
        self.gam_slate = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Slate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.Slate"
    }
}

/// Defines additional types related to [Slate].
pub mod slate {
    #[allow(unused_imports)]
    use super::*;

    /// GamSlate object has Google Ad Manager (GAM) related properties for the
    /// slate.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GamSlate {
        /// Required. Ad Manager network code to associate with the live config.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network_code: std::string::String,

        /// Output only. The identifier generated for the slate by GAM.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub gam_slate_id: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GamSlate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_code][crate::model::slate::GamSlate::network_code].
        pub fn set_network_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_code = v.into();
            self
        }

        /// Sets the value of [gam_slate_id][crate::model::slate::GamSlate::gam_slate_id].
        pub fn set_gam_slate_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.gam_slate_id = v.into();
            self
        }
    }

    impl wkt::message::Message for GamSlate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.stitcher.v1.Slate.GamSlate"
        }
    }
}

/// Information related to the interstitial of a VOD session. This resource is
/// only available for VOD sessions that do not implement Google Ad Manager ad
/// insertion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodStitchDetail {
    /// The name of the stitch detail in the specified VOD session, in the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodStitchDetails/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A list of ad processing details for the fetched ad playlist.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ad_stitch_details: std::vec::Vec<crate::model::AdStitchDetail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodStitchDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodStitchDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ad_stitch_details][crate::model::VodStitchDetail::ad_stitch_details].
    pub fn set_ad_stitch_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdStitchDetail>,
    {
        use std::iter::Iterator;
        self.ad_stitch_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VodStitchDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodStitchDetail"
    }
}

/// Metadata for a stitched ad.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdStitchDetail {
    /// Required. The ad break ID of the processed ad.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_break_id: std::string::String,

    /// Required. The ad ID of the processed ad.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_id: std::string::String,

    /// Required. The time offset of the processed ad.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ad_time_offset: std::option::Option<wkt::Duration>,

    /// Optional. Indicates the reason why the ad has been skipped.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub skip_reason: std::string::String,

    /// Optional. The metadata of the chosen media file for the ad.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub media: std::collections::HashMap<std::string::String, wkt::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdStitchDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ad_break_id][crate::model::AdStitchDetail::ad_break_id].
    pub fn set_ad_break_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_break_id = v.into();
        self
    }

    /// Sets the value of [ad_id][crate::model::AdStitchDetail::ad_id].
    pub fn set_ad_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_id = v.into();
        self
    }

    /// Sets the value of [ad_time_offset][crate::model::AdStitchDetail::ad_time_offset].
    pub fn set_ad_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ad_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ad_time_offset][crate::model::AdStitchDetail::ad_time_offset].
    pub fn set_or_clear_ad_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ad_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_reason][crate::model::AdStitchDetail::skip_reason].
    pub fn set_skip_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.skip_reason = v.into();
        self
    }

    /// Sets the value of [media][crate::model::AdStitchDetail::media].
    pub fn set_media<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.media = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AdStitchDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.AdStitchDetail"
    }
}

/// Request message for VideoStitcherService.createCdnKey.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCdnKeyRequest {
    /// Required. The project in which the CDN key should be created, in the form
    /// of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The CDN key resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cdn_key: std::option::Option<crate::model::CdnKey>,

    /// Required. The ID to use for the CDN key, which will become the final
    /// component of the CDN key's resource name.
    ///
    /// This value should conform to RFC-1034, which restricts to
    /// lower-case letters, numbers, and hyphen, with the first character a
    /// letter, the last a letter or a number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cdn_key_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCdnKeyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cdn_key][crate::model::CreateCdnKeyRequest::cdn_key].
    pub fn set_cdn_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdn_key][crate::model::CreateCdnKeyRequest::cdn_key].
    pub fn set_or_clear_cdn_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cdn_key_id][crate::model::CreateCdnKeyRequest::cdn_key_id].
    pub fn set_cdn_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cdn_key_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateCdnKeyRequest"
    }
}

/// Request message for VideoStitcherService.listCdnKeys.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCdnKeysRequest {
    /// Required. The project that contains the list of CDN keys, in the form of
    /// `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCdnKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCdnKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCdnKeysRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCdnKeysRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCdnKeysRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCdnKeysRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCdnKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListCdnKeysRequest"
    }
}

/// Response message for VideoStitcher.ListCdnKeys.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCdnKeysResponse {
    /// List of CDN keys.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cdn_keys: std::vec::Vec<crate::model::CdnKey>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCdnKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cdn_keys][crate::model::ListCdnKeysResponse::cdn_keys].
    pub fn set_cdn_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CdnKey>,
    {
        use std::iter::Iterator;
        self.cdn_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCdnKeysResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCdnKeysResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCdnKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListCdnKeysResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCdnKeysResponse {
    type PageItem = crate::model::CdnKey;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cdn_keys
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getCdnKey.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCdnKeyRequest {
    /// Required. The name of the CDN key to be retrieved, in the form of
    /// `projects/{project}/locations/{location}/cdnKeys/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCdnKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetCdnKeyRequest"
    }
}

/// Request message for VideoStitcherService.deleteCdnKey.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCdnKeyRequest {
    /// Required. The name of the CDN key to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/cdnKeys/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCdnKeyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteCdnKeyRequest"
    }
}

/// Request message for VideoStitcherService.updateCdnKey.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCdnKeyRequest {
    /// Required. The CDN key resource which replaces the resource on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cdn_key: std::option::Option<crate::model::CdnKey>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCdnKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cdn_key][crate::model::UpdateCdnKeyRequest::cdn_key].
    pub fn set_cdn_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cdn_key][crate::model::UpdateCdnKeyRequest::cdn_key].
    pub fn set_or_clear_cdn_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CdnKey>,
    {
        self.cdn_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCdnKeyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCdnKeyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCdnKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateCdnKeyRequest"
    }
}

/// Request message for VideoStitcherService.createVodSession
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVodSessionRequest {
    /// Required. The project and location in which the VOD session should be
    /// created, in the form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Parameters for creating a session.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vod_session: std::option::Option<crate::model::VodSession>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVodSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVodSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vod_session][crate::model::CreateVodSessionRequest::vod_session].
    pub fn set_vod_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodSession>,
    {
        self.vod_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_session][crate::model::CreateVodSessionRequest::vod_session].
    pub fn set_or_clear_vod_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodSession>,
    {
        self.vod_session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateVodSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateVodSessionRequest"
    }
}

/// Request message for VideoStitcherService.getVodSession
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVodSessionRequest {
    /// Required. The name of the VOD session to be retrieved, in the form of
    /// `projects/{project_number}/locations/{location}/vodSessions/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodSessionRequest"
    }
}

/// Request message for VideoStitcherService.listVodStitchDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodStitchDetailsRequest {
    /// Required. The VOD session where the stitch details belong to, in the form
    /// of `projects/{project}/locations/{location}/vodSessions/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodStitchDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodStitchDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodStitchDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodStitchDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodStitchDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodStitchDetailsRequest"
    }
}

/// Response message for VideoStitcherService.listVodStitchDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodStitchDetailsResponse {
    /// A List of stitch Details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vod_stitch_details: std::vec::Vec<crate::model::VodStitchDetail>,

    /// The pagination token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodStitchDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_stitch_details][crate::model::ListVodStitchDetailsResponse::vod_stitch_details].
    pub fn set_vod_stitch_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodStitchDetail>,
    {
        use std::iter::Iterator;
        self.vod_stitch_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodStitchDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodStitchDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodStitchDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodStitchDetailsResponse {
    type PageItem = crate::model::VodStitchDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_stitch_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getVodStitchDetail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVodStitchDetailRequest {
    /// Required. The name of the stitch detail in the specified VOD session, in
    /// the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodStitchDetails/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodStitchDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodStitchDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodStitchDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodStitchDetailRequest"
    }
}

/// Request message for VideoStitcherService.listVodAdTagDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodAdTagDetailsRequest {
    /// Required. The VOD session which the ad tag details belong to, in the form
    /// of `projects/{project}/locations/{location}/vodSessions/{vod_session_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodAdTagDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodAdTagDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodAdTagDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodAdTagDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodAdTagDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodAdTagDetailsRequest"
    }
}

/// Response message for VideoStitcherService.listVodAdTagDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodAdTagDetailsResponse {
    /// A List of ad tag details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vod_ad_tag_details: std::vec::Vec<crate::model::VodAdTagDetail>,

    /// The pagination token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodAdTagDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_ad_tag_details][crate::model::ListVodAdTagDetailsResponse::vod_ad_tag_details].
    pub fn set_vod_ad_tag_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodAdTagDetail>,
    {
        use std::iter::Iterator;
        self.vod_ad_tag_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodAdTagDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVodAdTagDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodAdTagDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodAdTagDetailsResponse {
    type PageItem = crate::model::VodAdTagDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_ad_tag_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getVodAdTagDetail
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVodAdTagDetailRequest {
    /// Required. The name of the ad tag detail for the specified VOD session, in
    /// the form of
    /// `projects/{project}/locations/{location}/vodSessions/{vod_session_id}/vodAdTagDetails/{vod_ad_tag_detail}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodAdTagDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodAdTagDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodAdTagDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodAdTagDetailRequest"
    }
}

/// Request message for VideoStitcherService.listLiveAdTagDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLiveAdTagDetailsRequest {
    /// Required. The resource parent in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The pagination token returned from a previous List request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveAdTagDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLiveAdTagDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLiveAdTagDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLiveAdTagDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveAdTagDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveAdTagDetailsRequest"
    }
}

/// Response message for VideoStitcherService.listLiveAdTagDetails.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLiveAdTagDetailsResponse {
    /// A list of live session ad tag details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub live_ad_tag_details: std::vec::Vec<crate::model::LiveAdTagDetail>,

    /// The pagination token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveAdTagDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_ad_tag_details][crate::model::ListLiveAdTagDetailsResponse::live_ad_tag_details].
    pub fn set_live_ad_tag_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LiveAdTagDetail>,
    {
        use std::iter::Iterator;
        self.live_ad_tag_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLiveAdTagDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveAdTagDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveAdTagDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLiveAdTagDetailsResponse {
    type PageItem = crate::model::LiveAdTagDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.live_ad_tag_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getLiveAdTagDetail
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLiveAdTagDetailRequest {
    /// Required. The resource name in the form of
    /// `projects/{project}/locations/{location}/liveSessions/{live_session}/liveAdTagDetails/{live_ad_tag_detail}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveAdTagDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveAdTagDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveAdTagDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveAdTagDetailRequest"
    }
}

/// Request message for VideoStitcherService.createSlate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSlateRequest {
    /// Required. The project in which the slate should be created, in the form of
    /// `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The unique identifier for the slate.
    /// This value should conform to RFC-1034, which restricts to
    /// lower-case letters, numbers, and hyphen, with the first character a
    /// letter, the last a letter or a number, and a 63 character maximum.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub slate_id: std::string::String,

    /// Required. The slate to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slate: std::option::Option<crate::model::Slate>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSlateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [slate_id][crate::model::CreateSlateRequest::slate_id].
    pub fn set_slate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.slate_id = v.into();
        self
    }

    /// Sets the value of [slate][crate::model::CreateSlateRequest::slate].
    pub fn set_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slate][crate::model::CreateSlateRequest::slate].
    pub fn set_or_clear_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSlateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateSlateRequest"
    }
}

/// Request message for VideoStitcherService.getSlate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSlateRequest {
    /// Required. The name of the slate to be retrieved, of the slate, in the form
    /// of `projects/{project_number}/locations/{location}/slates/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSlateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetSlateRequest"
    }
}

/// Request message for VideoStitcherService.listSlates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSlatesRequest {
    /// Required. The project to list slates, in the form of
    /// `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSlatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSlatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSlatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSlatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSlatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSlatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSlatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListSlatesRequest"
    }
}

/// Response message for VideoStitcherService.listSlates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSlatesResponse {
    /// The list of slates
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub slates: std::vec::Vec<crate::model::Slate>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSlatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [slates][crate::model::ListSlatesResponse::slates].
    pub fn set_slates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Slate>,
    {
        use std::iter::Iterator;
        self.slates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSlatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSlatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSlatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListSlatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSlatesResponse {
    type PageItem = crate::model::Slate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.slates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.updateSlate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSlateRequest {
    /// Required. The resource with updated fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub slate: std::option::Option<crate::model::Slate>,

    /// Required. The update mask which specifies fields which should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [slate][crate::model::UpdateSlateRequest::slate].
    pub fn set_slate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [slate][crate::model::UpdateSlateRequest::slate].
    pub fn set_or_clear_slate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Slate>,
    {
        self.slate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSlateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSlateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateSlateRequest"
    }
}

/// Request message for VideoStitcherService.deleteSlate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSlateRequest {
    /// Required. The name of the slate to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/slates/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSlateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSlateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSlateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteSlateRequest"
    }
}

/// Request message for VideoStitcherService.createLiveSession.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLiveSessionRequest {
    /// Required. The project and location in which the live session should be
    /// created, in the form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Parameters for creating a live session.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub live_session: std::option::Option<crate::model::LiveSession>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLiveSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLiveSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [live_session][crate::model::CreateLiveSessionRequest::live_session].
    pub fn set_live_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveSession>,
    {
        self.live_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_session][crate::model::CreateLiveSessionRequest::live_session].
    pub fn set_or_clear_live_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveSession>,
    {
        self.live_session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLiveSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateLiveSessionRequest"
    }
}

/// Request message for VideoStitcherService.getSession.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLiveSessionRequest {
    /// Required. The name of the live session, in the form of
    /// `projects/{project_number}/locations/{location}/liveSessions/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveSessionRequest"
    }
}

/// Request message for VideoStitcherService.createLiveConfig
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLiveConfigRequest {
    /// Required. The project in which the live config should be created, in
    /// the form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The unique identifier ID to use for the live config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub live_config_id: std::string::String,

    /// Required. The live config resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub live_config: std::option::Option<crate::model::LiveConfig>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLiveConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [live_config_id][crate::model::CreateLiveConfigRequest::live_config_id].
    pub fn set_live_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.live_config_id = v.into();
        self
    }

    /// Sets the value of [live_config][crate::model::CreateLiveConfigRequest::live_config].
    pub fn set_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_config][crate::model::CreateLiveConfigRequest::live_config].
    pub fn set_or_clear_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateLiveConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateLiveConfigRequest"
    }
}

/// Request message for VideoStitcherService.listLiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLiveConfigsRequest {
    /// Required. The project that contains the list of live configs, in the
    /// form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter to apply to list results (see
    /// [Filtering](https://google.aip.dev/160)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results following
    /// [Cloud API
    /// syntax](https://cloud.google.com/apis/design/design_patterns#sorting_order).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLiveConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLiveConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLiveConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLiveConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLiveConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListLiveConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveConfigsRequest"
    }
}

/// Response message for VideoStitcher.ListLiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLiveConfigsResponse {
    /// List of live configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub live_configs: std::vec::Vec<crate::model::LiveConfig>,

    /// The pagination token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLiveConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_configs][crate::model::ListLiveConfigsResponse::live_configs].
    pub fn set_live_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LiveConfig>,
    {
        use std::iter::Iterator;
        self.live_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLiveConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListLiveConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLiveConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListLiveConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLiveConfigsResponse {
    type PageItem = crate::model::LiveConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.live_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getLiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLiveConfigRequest {
    /// Required. The name of the live config to be retrieved, in the form
    /// of
    /// `projects/{project_number}/locations/{location}/liveConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetLiveConfigRequest"
    }
}

/// Request message for VideoStitcherService.deleteLiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLiveConfigRequest {
    /// Required. The name of the live config to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/liveConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLiveConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteLiveConfigRequest"
    }
}

/// Request message for VideoStitcherService.updateLiveConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateLiveConfigRequest {
    /// Required. The LiveConfig resource which replaces the resource on the
    /// server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub live_config: std::option::Option<crate::model::LiveConfig>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLiveConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [live_config][crate::model::UpdateLiveConfigRequest::live_config].
    pub fn set_live_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [live_config][crate::model::UpdateLiveConfigRequest::live_config].
    pub fn set_or_clear_live_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LiveConfig>,
    {
        self.live_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateLiveConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLiveConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLiveConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateLiveConfigRequest"
    }
}

/// Request message for VideoStitcherService.createVodConfig
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVodConfigRequest {
    /// Required. The project in which the VOD config should be created, in
    /// the form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The unique identifier ID to use for the VOD config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vod_config_id: std::string::String,

    /// Required. The VOD config resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vod_config: std::option::Option<crate::model::VodConfig>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVodConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vod_config_id][crate::model::CreateVodConfigRequest::vod_config_id].
    pub fn set_vod_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vod_config_id = v.into();
        self
    }

    /// Sets the value of [vod_config][crate::model::CreateVodConfigRequest::vod_config].
    pub fn set_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_config][crate::model::CreateVodConfigRequest::vod_config].
    pub fn set_or_clear_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVodConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.CreateVodConfigRequest"
    }
}

/// Request message for VideoStitcherService.listVodConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodConfigsRequest {
    /// Required. The project that contains the list of VOD configs, in the
    /// form of `projects/{project_number}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter to apply to list results (see
    /// [Filtering](https://google.aip.dev/160)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results following
    /// [Cloud API
    /// syntax](https://cloud.google.com/apis/design/design_patterns#sorting_order).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVodConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVodConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVodConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVodConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVodConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVodConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodConfigsRequest"
    }
}

/// Response message for VideoStitcher.ListVodConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVodConfigsResponse {
    /// List of VOD configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vod_configs: std::vec::Vec<crate::model::VodConfig>,

    /// The pagination token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVodConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_configs][crate::model::ListVodConfigsResponse::vod_configs].
    pub fn set_vod_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VodConfig>,
    {
        use std::iter::Iterator;
        self.vod_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVodConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVodConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVodConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.ListVodConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVodConfigsResponse {
    type PageItem = crate::model::VodConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vod_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for VideoStitcherService.getVodConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVodConfigRequest {
    /// Required. The name of the VOD config to be retrieved, in the form
    /// of `projects/{project_number}/locations/{location}/vodConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVodConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GetVodConfigRequest"
    }
}

/// Request message for VideoStitcherService.deleteVodConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVodConfigRequest {
    /// Required. The name of the VOD config to be deleted, in the form of
    /// `projects/{project_number}/locations/{location}/vodConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVodConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.DeleteVodConfigRequest"
    }
}

/// Request message for VideoStitcherService.updateVodConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateVodConfigRequest {
    /// Required. The VOD config resource which replaces the resource on the
    /// server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vod_config: std::option::Option<crate::model::VodConfig>,

    /// Required. The update mask applies to the resource.
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateVodConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vod_config][crate::model::UpdateVodConfigRequest::vod_config].
    pub fn set_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vod_config][crate::model::UpdateVodConfigRequest::vod_config].
    pub fn set_or_clear_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VodConfig>,
    {
        self.vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVodConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVodConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateVodConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.UpdateVodConfigRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.OperationMetadata"
    }
}

/// Metadata used to register VOD configs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VodConfig {
    /// Output only. The resource name of the VOD config, in the form of
    /// `projects/{project}/locations/{location}/vodConfigs/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Source URI for the VOD stream manifest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_uri: std::string::String,

    /// Required. The default ad tag associated with this VOD config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ad_tag_uri: std::string::String,

    /// Optional. Google Ad Manager (GAM) metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gam_vod_config: std::option::Option<crate::model::GamVodConfig>,

    /// Output only. State of the VOD config.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::vod_config::State,

    /// Options for fetching source manifests and segments.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_fetch_options: std::option::Option<crate::model::FetchOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VodConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VodConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_uri][crate::model::VodConfig::source_uri].
    pub fn set_source_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_uri = v.into();
        self
    }

    /// Sets the value of [ad_tag_uri][crate::model::VodConfig::ad_tag_uri].
    pub fn set_ad_tag_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ad_tag_uri = v.into();
        self
    }

    /// Sets the value of [gam_vod_config][crate::model::VodConfig::gam_vod_config].
    pub fn set_gam_vod_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GamVodConfig>,
    {
        self.gam_vod_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gam_vod_config][crate::model::VodConfig::gam_vod_config].
    pub fn set_or_clear_gam_vod_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GamVodConfig>,
    {
        self.gam_vod_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::VodConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::vod_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [source_fetch_options][crate::model::VodConfig::source_fetch_options].
    pub fn set_source_fetch_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_fetch_options][crate::model::VodConfig::source_fetch_options].
    pub fn set_or_clear_source_fetch_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FetchOptions>,
    {
        self.source_fetch_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VodConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.VodConfig"
    }
}

/// Defines additional types related to [VodConfig].
pub mod vod_config {
    #[allow(unused_imports)]
    use super::*;

    /// State of the VOD config.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// VOD config is being created.
        Creating,
        /// VOD config is ready for use.
        Ready,
        /// VOD config is queued up for deletion.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.stitcher.v1.VodConfig.State",
            ))
        }
    }
}

/// Metadata used for GAM ad decisioning.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GamVodConfig {
    /// Required. Ad Manager network code to associate with the VOD config.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GamVodConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_code][crate::model::GamVodConfig::network_code].
    pub fn set_network_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_code = v.into();
        self
    }
}

impl wkt::message::Message for GamVodConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.stitcher.v1.GamVodConfig"
    }
}

/// Determines the ad tracking policy.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AdTracking {
    /// The ad tracking policy is not specified.
    Unspecified,
    /// Client-side ad tracking is specified. The client player is expected to
    /// trigger playback and activity events itself.
    Client,
    /// The Video Stitcher API will trigger playback events on behalf of
    /// the client player.
    Server,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AdTracking::value] or
    /// [AdTracking::name].
    UnknownValue(ad_tracking::UnknownValue),
}

#[doc(hidden)]
pub mod ad_tracking {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AdTracking {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Client => std::option::Option::Some(1),
            Self::Server => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AD_TRACKING_UNSPECIFIED"),
            Self::Client => std::option::Option::Some("CLIENT"),
            Self::Server => std::option::Option::Some("SERVER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AdTracking {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AdTracking {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AdTracking {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Client,
            2 => Self::Server,
            _ => Self::UnknownValue(ad_tracking::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AdTracking {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AD_TRACKING_UNSPECIFIED" => Self::Unspecified,
            "CLIENT" => Self::Client,
            "SERVER" => Self::Server,
            _ => Self::UnknownValue(ad_tracking::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AdTracking {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Client => serializer.serialize_i32(1),
            Self::Server => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AdTracking {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AdTracking>::new(
            ".google.cloud.video.stitcher.v1.AdTracking",
        ))
    }
}
