// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Encoding of an input element such as an audio, video, or text track.
/// Elementary streams must be packaged before mapping and sharing between
/// different output formats.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ElementaryStream {
    /// A unique key for this elementary stream. The key must be 1-63
    /// characters in length. The key must begin and end with a letter (regardless
    /// of case) or a number, but can contain dashes or underscores in between.
    pub key: std::string::String,

    /// Required. Encoding of an audio, video, or text track.
    pub elementary_stream: std::option::Option<crate::model::elementary_stream::ElementaryStream>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ElementaryStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::ElementaryStream::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [elementary_stream][crate::model::ElementaryStream::elementary_stream].
    ///
    /// Note that all the setters affecting `elementary_stream` are mutually
    /// exclusive.
    pub fn set_elementary_stream<
        T: std::convert::Into<std::option::Option<crate::model::elementary_stream::ElementaryStream>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.elementary_stream = v.into();
        self
    }

    /// The value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// if it holds a `VideoStream`, `None` if the field is not set or
    /// holds a different branch.
    pub fn video_stream(&self) -> std::option::Option<&std::boxed::Box<crate::model::VideoStream>> {
        #[allow(unreachable_patterns)]
        self.elementary_stream.as_ref().and_then(|v| match v {
            crate::model::elementary_stream::ElementaryStream::VideoStream(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// to hold a `VideoStream`.
    ///
    /// Note that all the setters affecting `elementary_stream` are
    /// mutually exclusive.
    pub fn set_video_stream<T: std::convert::Into<std::boxed::Box<crate::model::VideoStream>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elementary_stream = std::option::Option::Some(
            crate::model::elementary_stream::ElementaryStream::VideoStream(v.into()),
        );
        self
    }

    /// The value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// if it holds a `AudioStream`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio_stream(&self) -> std::option::Option<&std::boxed::Box<crate::model::AudioStream>> {
        #[allow(unreachable_patterns)]
        self.elementary_stream.as_ref().and_then(|v| match v {
            crate::model::elementary_stream::ElementaryStream::AudioStream(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// to hold a `AudioStream`.
    ///
    /// Note that all the setters affecting `elementary_stream` are
    /// mutually exclusive.
    pub fn set_audio_stream<T: std::convert::Into<std::boxed::Box<crate::model::AudioStream>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elementary_stream = std::option::Option::Some(
            crate::model::elementary_stream::ElementaryStream::AudioStream(v.into()),
        );
        self
    }

    /// The value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// if it holds a `TextStream`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_stream(&self) -> std::option::Option<&std::boxed::Box<crate::model::TextStream>> {
        #[allow(unreachable_patterns)]
        self.elementary_stream.as_ref().and_then(|v| match v {
            crate::model::elementary_stream::ElementaryStream::TextStream(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [elementary_stream][crate::model::ElementaryStream::elementary_stream]
    /// to hold a `TextStream`.
    ///
    /// Note that all the setters affecting `elementary_stream` are
    /// mutually exclusive.
    pub fn set_text_stream<T: std::convert::Into<std::boxed::Box<crate::model::TextStream>>>(
        mut self,
        v: T,
    ) -> Self {
        self.elementary_stream = std::option::Option::Some(
            crate::model::elementary_stream::ElementaryStream::TextStream(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ElementaryStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ElementaryStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ElementaryStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __video_stream,
            __audio_stream,
            __text_stream,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ElementaryStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "videoStream" => Ok(__FieldTag::__video_stream),
                            "video_stream" => Ok(__FieldTag::__video_stream),
                            "audioStream" => Ok(__FieldTag::__audio_stream),
                            "audio_stream" => Ok(__FieldTag::__audio_stream),
                            "textStream" => Ok(__FieldTag::__text_stream),
                            "text_stream" => Ok(__FieldTag::__text_stream),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ElementaryStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ElementaryStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__video_stream => {
                            if !fields.insert(__FieldTag::__video_stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for video_stream",
                                ));
                            }
                            if result.elementary_stream.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `elementary_stream`, a oneof with full ID .google.cloud.video.livestream.v1.ElementaryStream.video_stream, latest field was videoStream",
                                ));
                            }
                            result.elementary_stream = std::option::Option::Some(
                                crate::model::elementary_stream::ElementaryStream::VideoStream(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VideoStream>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__audio_stream => {
                            if !fields.insert(__FieldTag::__audio_stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_stream",
                                ));
                            }
                            if result.elementary_stream.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `elementary_stream`, a oneof with full ID .google.cloud.video.livestream.v1.ElementaryStream.audio_stream, latest field was audioStream",
                                ));
                            }
                            result.elementary_stream = std::option::Option::Some(
                                crate::model::elementary_stream::ElementaryStream::AudioStream(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AudioStream>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__text_stream => {
                            if !fields.insert(__FieldTag::__text_stream) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_stream",
                                ));
                            }
                            if result.elementary_stream.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `elementary_stream`, a oneof with full ID .google.cloud.video.livestream.v1.ElementaryStream.text_stream, latest field was textStream",
                                ));
                            }
                            result.elementary_stream = std::option::Option::Some(
                                crate::model::elementary_stream::ElementaryStream::TextStream(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TextStream>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ElementaryStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if let Some(value) = self.video_stream() {
            state.serialize_entry("videoStream", value)?;
        }
        if let Some(value) = self.audio_stream() {
            state.serialize_entry("audioStream", value)?;
        }
        if let Some(value) = self.text_stream() {
            state.serialize_entry("textStream", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ElementaryStream].
pub mod elementary_stream {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Encoding of an audio, video, or text track.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ElementaryStream {
        /// Encoding of a video stream.
        VideoStream(std::boxed::Box<crate::model::VideoStream>),
        /// Encoding of an audio stream.
        AudioStream(std::boxed::Box<crate::model::AudioStream>),
        /// Encoding of a text stream. For example, closed captions or subtitles.
        TextStream(std::boxed::Box<crate::model::TextStream>),
    }
}

/// Multiplexing settings for output stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MuxStream {
    /// A unique key for this multiplexed stream. The key must be 1-63
    /// characters in length. The key must begin and end with a letter (regardless
    /// of case) or a number, but can contain dashes or underscores in between.
    pub key: std::string::String,

    /// The container format. The default is `fmp4`.
    ///
    /// Supported container formats:
    ///
    /// - `fmp4` - the corresponding file extension is `.m4s`
    /// - `ts` - the corresponding file extension is `.ts`
    pub container: std::string::String,

    /// List of `ElementaryStream`
    /// [key][google.cloud.video.livestream.v1.ElementaryStream.key]s multiplexed
    /// in this stream.
    ///
    /// - For `fmp4` container, must contain either one video or one audio stream.
    /// - For `ts` container, must contain exactly one audio stream and up to one
    ///   video stream.
    ///
    /// [google.cloud.video.livestream.v1.ElementaryStream.key]: crate::model::ElementaryStream::key
    pub elementary_streams: std::vec::Vec<std::string::String>,

    /// Segment settings for `fmp4` and `ts`.
    pub segment_settings: std::option::Option<crate::model::SegmentSettings>,

    /// Identifier of the encryption configuration to use. If omitted, output
    /// will be unencrypted.
    pub encryption_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MuxStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::MuxStream::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [container][crate::model::MuxStream::container].
    pub fn set_container<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [elementary_streams][crate::model::MuxStream::elementary_streams].
    pub fn set_elementary_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.elementary_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [segment_settings][crate::model::MuxStream::segment_settings].
    pub fn set_segment_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SegmentSettings>,
    {
        self.segment_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [segment_settings][crate::model::MuxStream::segment_settings].
    pub fn set_or_clear_segment_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SegmentSettings>,
    {
        self.segment_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_id][crate::model::MuxStream::encryption_id].
    pub fn set_encryption_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_id = v.into();
        self
    }
}

impl wkt::message::Message for MuxStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.MuxStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MuxStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __container,
            __elementary_streams,
            __segment_settings,
            __encryption_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MuxStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "container" => Ok(__FieldTag::__container),
                            "elementaryStreams" => Ok(__FieldTag::__elementary_streams),
                            "elementary_streams" => Ok(__FieldTag::__elementary_streams),
                            "segmentSettings" => Ok(__FieldTag::__segment_settings),
                            "segment_settings" => Ok(__FieldTag::__segment_settings),
                            "encryptionId" => Ok(__FieldTag::__encryption_id),
                            "encryption_id" => Ok(__FieldTag::__encryption_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MuxStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MuxStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__elementary_streams => {
                            if !fields.insert(__FieldTag::__elementary_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for elementary_streams",
                                ));
                            }
                            result.elementary_streams = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__segment_settings => {
                            if !fields.insert(__FieldTag::__segment_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for segment_settings",
                                ));
                            }
                            result.segment_settings = map
                                .next_value::<std::option::Option<crate::model::SegmentSettings>>(
                                )?;
                        }
                        __FieldTag::__encryption_id => {
                            if !fields.insert(__FieldTag::__encryption_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_id",
                                ));
                            }
                            result.encryption_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MuxStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.container.is_empty() {
            state.serialize_entry("container", &self.container)?;
        }
        if !self.elementary_streams.is_empty() {
            state.serialize_entry("elementaryStreams", &self.elementary_streams)?;
        }
        if self.segment_settings.is_some() {
            state.serialize_entry("segmentSettings", &self.segment_settings)?;
        }
        if !self.encryption_id.is_empty() {
            state.serialize_entry("encryptionId", &self.encryption_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Manifest configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Manifest {
    /// The name of the generated file. The default is `manifest` with the
    /// extension suffix corresponding to the `Manifest`
    /// [type][google.cloud.video.livestream.v1.Manifest.type]. If multiple
    /// manifests are added to the channel, each must have a unique file name.
    ///
    /// [google.cloud.video.livestream.v1.Manifest.type]: crate::model::Manifest::type
    pub file_name: std::string::String,

    /// Required. Type of the manifest, can be `HLS` or `DASH`.
    pub r#type: crate::model::manifest::ManifestType,

    /// Required. List of `MuxStream`
    /// [key][google.cloud.video.livestream.v1.MuxStream.key]s that should appear
    /// in this manifest.
    ///
    /// - For HLS, either `fmp4` or `ts` mux streams can be specified but not
    ///   mixed.
    /// - For DASH, only `fmp4` mux streams can be specified.
    ///
    /// [google.cloud.video.livestream.v1.MuxStream.key]: crate::model::MuxStream::key
    pub mux_streams: std::vec::Vec<std::string::String>,

    /// Maximum number of segments that this manifest holds. Once the manifest
    /// reaches this maximum number of segments, whenever a new segment is added to
    /// the manifest, the oldest segment will be removed from the manifest.
    /// The minimum value is 3 and the default value is 5.
    pub max_segment_count: i32,

    /// How long to keep a segment on the output Google Cloud Storage bucket after
    /// it is removed from the manifest. This field should be large enough to cover
    /// the manifest propagation delay. Otherwise, a player could receive 404
    /// errors while accessing segments which are listed in the manifest that the
    /// player has, but were already deleted from the output Google Cloud Storage
    /// bucket. Default value is `60s`.
    ///
    /// If both segment_keep_duration and
    /// [RetentionConfig.retention_window_duration][google.cloud.video.livestream.v1.RetentionConfig.retention_window_duration]
    /// are set,
    /// [RetentionConfig.retention_window_duration][google.cloud.video.livestream.v1.RetentionConfig.retention_window_duration]
    /// is used and segment_keep_duration is ignored.
    ///
    /// [google.cloud.video.livestream.v1.RetentionConfig.retention_window_duration]: crate::model::RetentionConfig::retention_window_duration
    pub segment_keep_duration: std::option::Option<wkt::Duration>,

    /// Whether to use the timecode, as specified in timecode config, when setting:
    ///
    /// - `availabilityStartTime` attribute in DASH manifests.
    /// - `#EXT-X-PROGRAM-DATE-TIME` tag in HLS manifests.
    ///
    /// If false, ignore the input timecode and use the time from system clock
    /// when the manifest is first generated. This is the default behavior.
    pub use_timecode_as_timeline: bool,

    /// Optional. A unique key for this manifest.
    pub key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Manifest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::Manifest::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Manifest::type].
    pub fn set_type<T: std::convert::Into<crate::model::manifest::ManifestType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [mux_streams][crate::model::Manifest::mux_streams].
    pub fn set_mux_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mux_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [max_segment_count][crate::model::Manifest::max_segment_count].
    pub fn set_max_segment_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_segment_count = v.into();
        self
    }

    /// Sets the value of [segment_keep_duration][crate::model::Manifest::segment_keep_duration].
    pub fn set_segment_keep_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.segment_keep_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [segment_keep_duration][crate::model::Manifest::segment_keep_duration].
    pub fn set_or_clear_segment_keep_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.segment_keep_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [use_timecode_as_timeline][crate::model::Manifest::use_timecode_as_timeline].
    pub fn set_use_timecode_as_timeline<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_timecode_as_timeline = v.into();
        self
    }

    /// Sets the value of [key][crate::model::Manifest::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for Manifest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Manifest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Manifest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_name,
            __type,
            __mux_streams,
            __max_segment_count,
            __segment_keep_duration,
            __use_timecode_as_timeline,
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Manifest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileName" => Ok(__FieldTag::__file_name),
                            "file_name" => Ok(__FieldTag::__file_name),
                            "type" => Ok(__FieldTag::__type),
                            "muxStreams" => Ok(__FieldTag::__mux_streams),
                            "mux_streams" => Ok(__FieldTag::__mux_streams),
                            "maxSegmentCount" => Ok(__FieldTag::__max_segment_count),
                            "max_segment_count" => Ok(__FieldTag::__max_segment_count),
                            "segmentKeepDuration" => Ok(__FieldTag::__segment_keep_duration),
                            "segment_keep_duration" => Ok(__FieldTag::__segment_keep_duration),
                            "useTimecodeAsTimeline" => Ok(__FieldTag::__use_timecode_as_timeline),
                            "use_timecode_as_timeline" => {
                                Ok(__FieldTag::__use_timecode_as_timeline)
                            }
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Manifest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Manifest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_name => {
                            if !fields.insert(__FieldTag::__file_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_name",
                                ));
                            }
                            result.file_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::manifest::ManifestType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mux_streams => {
                            if !fields.insert(__FieldTag::__mux_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mux_streams",
                                ));
                            }
                            result.mux_streams = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_segment_count => {
                            if !fields.insert(__FieldTag::__max_segment_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_segment_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_segment_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__segment_keep_duration => {
                            if !fields.insert(__FieldTag::__segment_keep_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for segment_keep_duration",
                                ));
                            }
                            result.segment_keep_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__use_timecode_as_timeline => {
                            if !fields.insert(__FieldTag::__use_timecode_as_timeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_timecode_as_timeline",
                                ));
                            }
                            result.use_timecode_as_timeline = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Manifest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_name.is_empty() {
            state.serialize_entry("fileName", &self.file_name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.mux_streams.is_empty() {
            state.serialize_entry("muxStreams", &self.mux_streams)?;
        }
        if !wkt::internal::is_default(&self.max_segment_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSegmentCount", &__With(&self.max_segment_count))?;
        }
        if self.segment_keep_duration.is_some() {
            state.serialize_entry("segmentKeepDuration", &self.segment_keep_duration)?;
        }
        if !wkt::internal::is_default(&self.use_timecode_as_timeline) {
            state.serialize_entry("useTimecodeAsTimeline", &self.use_timecode_as_timeline)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Manifest].
pub mod manifest {
    #[allow(unused_imports)]
    use super::*;

    /// The manifest type can be either `HLS` or `DASH`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ManifestType {
        /// The manifest type is not specified.
        Unspecified,
        /// Create an `HLS` manifest. The corresponding file extension is `.m3u8`.
        Hls,
        /// Create a `DASH` manifest. The corresponding file extension is `.mpd`.
        Dash,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ManifestType::value] or
        /// [ManifestType::name].
        UnknownValue(manifest_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod manifest_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ManifestType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hls => std::option::Option::Some(1),
                Self::Dash => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MANIFEST_TYPE_UNSPECIFIED"),
                Self::Hls => std::option::Option::Some("HLS"),
                Self::Dash => std::option::Option::Some("DASH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ManifestType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ManifestType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ManifestType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hls,
                2 => Self::Dash,
                _ => Self::UnknownValue(manifest_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ManifestType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MANIFEST_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HLS" => Self::Hls,
                "DASH" => Self::Dash,
                _ => Self::UnknownValue(manifest_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ManifestType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hls => serializer.serialize_i32(1),
                Self::Dash => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ManifestType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ManifestType>::new(
                ".google.cloud.video.livestream.v1.Manifest.ManifestType",
            ))
        }
    }
}

/// Sprite sheet configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpriteSheet {
    /// Format type. The default is `jpeg`.
    ///
    /// Supported formats:
    ///
    /// - `jpeg`
    pub format: std::string::String,

    /// Required. File name prefix for the generated sprite sheets. If multiple
    /// sprite sheets are added to the channel, each must have a unique file
    /// prefix.
    /// Each sprite sheet has an incremental 10-digit zero-padded suffix starting
    /// from 0 before the extension, such as `sprite_sheet0000000123.jpeg`.
    pub file_prefix: std::string::String,

    /// Required. The width of the sprite in pixels. Must be an even integer.
    pub sprite_width_pixels: i32,

    /// Required. The height of the sprite in pixels. Must be an even integer.
    pub sprite_height_pixels: i32,

    /// The maximum number of sprites per row in a sprite sheet. Valid range is
    /// [1, 10] and the default value is 1.
    pub column_count: i32,

    /// The maximum number of rows per sprite sheet. When the sprite sheet is full,
    /// a new sprite sheet is created. Valid range is [1, 10] and the default value
    /// is 1.
    pub row_count: i32,

    /// Create sprites at regular intervals. Valid range is [1 second, 1 hour] and
    /// the default value is `10s`.
    pub interval: std::option::Option<wkt::Duration>,

    /// The quality of the generated sprite sheet. Enter a value between 1
    /// and 100, where 1 is the lowest quality and 100 is the highest quality.
    /// The default is 100. A high quality value corresponds to a low image data
    /// compression ratio.
    pub quality: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpriteSheet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::SpriteSheet::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [file_prefix][crate::model::SpriteSheet::file_prefix].
    pub fn set_file_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_prefix = v.into();
        self
    }

    /// Sets the value of [sprite_width_pixels][crate::model::SpriteSheet::sprite_width_pixels].
    pub fn set_sprite_width_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sprite_width_pixels = v.into();
        self
    }

    /// Sets the value of [sprite_height_pixels][crate::model::SpriteSheet::sprite_height_pixels].
    pub fn set_sprite_height_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sprite_height_pixels = v.into();
        self
    }

    /// Sets the value of [column_count][crate::model::SpriteSheet::column_count].
    pub fn set_column_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.column_count = v.into();
        self
    }

    /// Sets the value of [row_count][crate::model::SpriteSheet::row_count].
    pub fn set_row_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::SpriteSheet::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::SpriteSheet::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quality][crate::model::SpriteSheet::quality].
    pub fn set_quality<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.quality = v.into();
        self
    }
}

impl wkt::message::Message for SpriteSheet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.SpriteSheet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpriteSheet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __file_prefix,
            __sprite_width_pixels,
            __sprite_height_pixels,
            __column_count,
            __row_count,
            __interval,
            __quality,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpriteSheet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "filePrefix" => Ok(__FieldTag::__file_prefix),
                            "file_prefix" => Ok(__FieldTag::__file_prefix),
                            "spriteWidthPixels" => Ok(__FieldTag::__sprite_width_pixels),
                            "sprite_width_pixels" => Ok(__FieldTag::__sprite_width_pixels),
                            "spriteHeightPixels" => Ok(__FieldTag::__sprite_height_pixels),
                            "sprite_height_pixels" => Ok(__FieldTag::__sprite_height_pixels),
                            "columnCount" => Ok(__FieldTag::__column_count),
                            "column_count" => Ok(__FieldTag::__column_count),
                            "rowCount" => Ok(__FieldTag::__row_count),
                            "row_count" => Ok(__FieldTag::__row_count),
                            "interval" => Ok(__FieldTag::__interval),
                            "quality" => Ok(__FieldTag::__quality),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpriteSheet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpriteSheet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_prefix => {
                            if !fields.insert(__FieldTag::__file_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_prefix",
                                ));
                            }
                            result.file_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sprite_width_pixels => {
                            if !fields.insert(__FieldTag::__sprite_width_pixels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sprite_width_pixels",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sprite_width_pixels =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sprite_height_pixels => {
                            if !fields.insert(__FieldTag::__sprite_height_pixels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sprite_height_pixels",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sprite_height_pixels =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__column_count => {
                            if !fields.insert(__FieldTag::__column_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.column_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__row_count => {
                            if !fields.insert(__FieldTag::__row_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.row_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__quality => {
                            if !fields.insert(__FieldTag::__quality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quality",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.quality = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpriteSheet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.format.is_empty() {
            state.serialize_entry("format", &self.format)?;
        }
        if !self.file_prefix.is_empty() {
            state.serialize_entry("filePrefix", &self.file_prefix)?;
        }
        if !wkt::internal::is_default(&self.sprite_width_pixels) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("spriteWidthPixels", &__With(&self.sprite_width_pixels))?;
        }
        if !wkt::internal::is_default(&self.sprite_height_pixels) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("spriteHeightPixels", &__With(&self.sprite_height_pixels))?;
        }
        if !wkt::internal::is_default(&self.column_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("columnCount", &__With(&self.column_count))?;
        }
        if !wkt::internal::is_default(&self.row_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowCount", &__With(&self.row_count))?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !wkt::internal::is_default(&self.quality) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("quality", &__With(&self.quality))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Preprocessing configurations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PreprocessingConfig {
    /// Audio preprocessing configuration.
    pub audio: std::option::Option<crate::model::preprocessing_config::Audio>,

    /// Specify the video cropping configuration.
    pub crop: std::option::Option<crate::model::preprocessing_config::Crop>,

    /// Specify the video pad filter configuration.
    pub pad: std::option::Option<crate::model::preprocessing_config::Pad>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PreprocessingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio][crate::model::PreprocessingConfig::audio].
    pub fn set_audio<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Audio>,
    {
        self.audio = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio][crate::model::PreprocessingConfig::audio].
    pub fn set_or_clear_audio<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Audio>,
    {
        self.audio = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crop][crate::model::PreprocessingConfig::crop].
    pub fn set_crop<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Crop>,
    {
        self.crop = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crop][crate::model::PreprocessingConfig::crop].
    pub fn set_or_clear_crop<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Crop>,
    {
        self.crop = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pad][crate::model::PreprocessingConfig::pad].
    pub fn set_pad<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Pad>,
    {
        self.pad = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pad][crate::model::PreprocessingConfig::pad].
    pub fn set_or_clear_pad<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preprocessing_config::Pad>,
    {
        self.pad = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PreprocessingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.PreprocessingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PreprocessingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio,
            __crop,
            __pad,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PreprocessingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audio" => Ok(__FieldTag::__audio),
                            "crop" => Ok(__FieldTag::__crop),
                            "pad" => Ok(__FieldTag::__pad),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PreprocessingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PreprocessingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            result.audio = map.next_value::<std::option::Option<crate::model::preprocessing_config::Audio>>()?
                                ;
                        }
                        __FieldTag::__crop => {
                            if !fields.insert(__FieldTag::__crop) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crop",
                                ));
                            }
                            result.crop = map.next_value::<std::option::Option<crate::model::preprocessing_config::Crop>>()?
                                ;
                        }
                        __FieldTag::__pad => {
                            if !fields.insert(__FieldTag::__pad) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pad",
                                ));
                            }
                            result.pad = map.next_value::<std::option::Option<crate::model::preprocessing_config::Pad>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PreprocessingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.audio.is_some() {
            state.serialize_entry("audio", &self.audio)?;
        }
        if self.crop.is_some() {
            state.serialize_entry("crop", &self.crop)?;
        }
        if self.pad.is_some() {
            state.serialize_entry("pad", &self.pad)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PreprocessingConfig].
pub mod preprocessing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Audio preprocessing configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Audio {
        /// Specify audio loudness normalization in loudness units relative to full
        /// scale (LUFS). Enter a value between -24 and 0 according to the following:
        ///
        /// - -24 is the Advanced Television Systems Committee (ATSC A/85)
        /// - -23 is the EU R128 broadcast standard
        /// - -19 is the prior standard for online mono audio
        /// - -18 is the ReplayGain standard
        /// - -16 is the prior standard for stereo audio
        /// - -14 is the new online audio standard recommended by Spotify, as well as
        ///   Amazon Echo
        /// - 0 disables normalization. The default is 0.
        pub lufs: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Audio {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [lufs][crate::model::preprocessing_config::Audio::lufs].
        pub fn set_lufs<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.lufs = v.into();
            self
        }
    }

    impl wkt::message::Message for Audio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.PreprocessingConfig.Audio"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Audio {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __lufs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Audio")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lufs" => Ok(__FieldTag::__lufs),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Audio;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Audio")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__lufs => {
                                if !fields.insert(__FieldTag::__lufs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lufs",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.lufs = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Audio {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.lufs) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("lufs", &__With(&self.lufs))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Video cropping configuration for the input video. The cropped input video
    /// is scaled to match the output resolution.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Crop {
        /// The number of pixels to crop from the top. The default is 0.
        pub top_pixels: i32,

        /// The number of pixels to crop from the bottom. The default is 0.
        pub bottom_pixels: i32,

        /// The number of pixels to crop from the left. The default is 0.
        pub left_pixels: i32,

        /// The number of pixels to crop from the right. The default is 0.
        pub right_pixels: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Crop {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [top_pixels][crate::model::preprocessing_config::Crop::top_pixels].
        pub fn set_top_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.top_pixels = v.into();
            self
        }

        /// Sets the value of [bottom_pixels][crate::model::preprocessing_config::Crop::bottom_pixels].
        pub fn set_bottom_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.bottom_pixels = v.into();
            self
        }

        /// Sets the value of [left_pixels][crate::model::preprocessing_config::Crop::left_pixels].
        pub fn set_left_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.left_pixels = v.into();
            self
        }

        /// Sets the value of [right_pixels][crate::model::preprocessing_config::Crop::right_pixels].
        pub fn set_right_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.right_pixels = v.into();
            self
        }
    }

    impl wkt::message::Message for Crop {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.PreprocessingConfig.Crop"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Crop {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __top_pixels,
                __bottom_pixels,
                __left_pixels,
                __right_pixels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Crop")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "topPixels" => Ok(__FieldTag::__top_pixels),
                                "top_pixels" => Ok(__FieldTag::__top_pixels),
                                "bottomPixels" => Ok(__FieldTag::__bottom_pixels),
                                "bottom_pixels" => Ok(__FieldTag::__bottom_pixels),
                                "leftPixels" => Ok(__FieldTag::__left_pixels),
                                "left_pixels" => Ok(__FieldTag::__left_pixels),
                                "rightPixels" => Ok(__FieldTag::__right_pixels),
                                "right_pixels" => Ok(__FieldTag::__right_pixels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Crop;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Crop")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__top_pixels => {
                                if !fields.insert(__FieldTag::__top_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.top_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__bottom_pixels => {
                                if !fields.insert(__FieldTag::__bottom_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bottom_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.bottom_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__left_pixels => {
                                if !fields.insert(__FieldTag::__left_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for left_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.left_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__right_pixels => {
                                if !fields.insert(__FieldTag::__right_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for right_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.right_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Crop {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.top_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("topPixels", &__With(&self.top_pixels))?;
            }
            if !wkt::internal::is_default(&self.bottom_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("bottomPixels", &__With(&self.bottom_pixels))?;
            }
            if !wkt::internal::is_default(&self.left_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("leftPixels", &__With(&self.left_pixels))?;
            }
            if !wkt::internal::is_default(&self.right_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rightPixels", &__With(&self.right_pixels))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Pad filter configuration for the input video. The padded input video
    /// is scaled after padding with black to match the output resolution.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Pad {
        /// The number of pixels to add to the top. The default is 0.
        pub top_pixels: i32,

        /// The number of pixels to add to the bottom. The default is 0.
        pub bottom_pixels: i32,

        /// The number of pixels to add to the left. The default is 0.
        pub left_pixels: i32,

        /// The number of pixels to add to the right. The default is 0.
        pub right_pixels: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Pad {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [top_pixels][crate::model::preprocessing_config::Pad::top_pixels].
        pub fn set_top_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.top_pixels = v.into();
            self
        }

        /// Sets the value of [bottom_pixels][crate::model::preprocessing_config::Pad::bottom_pixels].
        pub fn set_bottom_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.bottom_pixels = v.into();
            self
        }

        /// Sets the value of [left_pixels][crate::model::preprocessing_config::Pad::left_pixels].
        pub fn set_left_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.left_pixels = v.into();
            self
        }

        /// Sets the value of [right_pixels][crate::model::preprocessing_config::Pad::right_pixels].
        pub fn set_right_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.right_pixels = v.into();
            self
        }
    }

    impl wkt::message::Message for Pad {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.PreprocessingConfig.Pad"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Pad {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __top_pixels,
                __bottom_pixels,
                __left_pixels,
                __right_pixels,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Pad")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "topPixels" => Ok(__FieldTag::__top_pixels),
                                "top_pixels" => Ok(__FieldTag::__top_pixels),
                                "bottomPixels" => Ok(__FieldTag::__bottom_pixels),
                                "bottom_pixels" => Ok(__FieldTag::__bottom_pixels),
                                "leftPixels" => Ok(__FieldTag::__left_pixels),
                                "left_pixels" => Ok(__FieldTag::__left_pixels),
                                "rightPixels" => Ok(__FieldTag::__right_pixels),
                                "right_pixels" => Ok(__FieldTag::__right_pixels),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Pad;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Pad")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__top_pixels => {
                                if !fields.insert(__FieldTag::__top_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.top_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__bottom_pixels => {
                                if !fields.insert(__FieldTag::__bottom_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bottom_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.bottom_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__left_pixels => {
                                if !fields.insert(__FieldTag::__left_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for left_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.left_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__right_pixels => {
                                if !fields.insert(__FieldTag::__right_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for right_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.right_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Pad {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.top_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("topPixels", &__With(&self.top_pixels))?;
            }
            if !wkt::internal::is_default(&self.bottom_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("bottomPixels", &__With(&self.bottom_pixels))?;
            }
            if !wkt::internal::is_default(&self.left_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("leftPixels", &__With(&self.left_pixels))?;
            }
            if !wkt::internal::is_default(&self.right_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rightPixels", &__With(&self.right_pixels))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Video stream resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VideoStream {
    /// Codec settings.
    pub codec_settings: std::option::Option<crate::model::video_stream::CodecSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VideoStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [codec_settings][crate::model::VideoStream::codec_settings].
    ///
    /// Note that all the setters affecting `codec_settings` are mutually
    /// exclusive.
    pub fn set_codec_settings<
        T: std::convert::Into<std::option::Option<crate::model::video_stream::CodecSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.codec_settings = v.into();
        self
    }

    /// The value of [codec_settings][crate::model::VideoStream::codec_settings]
    /// if it holds a `H264`, `None` if the field is not set or
    /// holds a different branch.
    pub fn h264(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::video_stream::H264CodecSettings>> {
        #[allow(unreachable_patterns)]
        self.codec_settings.as_ref().and_then(|v| match v {
            crate::model::video_stream::CodecSettings::H264(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [codec_settings][crate::model::VideoStream::codec_settings]
    /// to hold a `H264`.
    ///
    /// Note that all the setters affecting `codec_settings` are
    /// mutually exclusive.
    pub fn set_h264<
        T: std::convert::Into<std::boxed::Box<crate::model::video_stream::H264CodecSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.codec_settings =
            std::option::Option::Some(crate::model::video_stream::CodecSettings::H264(v.into()));
        self
    }
}

impl wkt::message::Message for VideoStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.VideoStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VideoStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __h264,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VideoStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "h264" => Ok(__FieldTag::__h264),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VideoStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VideoStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__h264 => {
                            if !fields.insert(__FieldTag::__h264) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for h264",
                                ));
                            }
                            if result.codec_settings.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `codec_settings`, a oneof with full ID .google.cloud.video.livestream.v1.VideoStream.h264, latest field was h264",
                                ));
                            }
                            result.codec_settings = std::option::Option::Some(
                                crate::model::video_stream::CodecSettings::H264(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::video_stream::H264CodecSettings,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VideoStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.h264() {
            state.serialize_entry("h264", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VideoStream].
pub mod video_stream {
    #[allow(unused_imports)]
    use super::*;

    /// H264 codec settings.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct H264CodecSettings {
        /// Required. The width of the video in pixels. Must be an even integer.
        /// Valid range is [320, 1920].
        pub width_pixels: i32,

        /// Required. The height of the video in pixels. Must be an even integer.
        /// Valid range is [180, 1080].
        pub height_pixels: i32,

        /// Required. The target video frame rate in frames per second (FPS). Must be
        /// less than or equal to 60. Will default to the input frame rate if larger
        /// than the input frame rate. The API will generate an output FPS that is
        /// divisible by the input FPS, and smaller or equal to the target FPS. See
        /// [Calculating frame
        /// rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for
        /// more information.
        pub frame_rate: f64,

        /// Required. The video bitrate in bits per second. Minimum value is 10,000.
        ///
        /// - For SD resolution (< 720p), must be <= 3,000,000 (3 Mbps).
        /// - For HD resolution (<= 1080p), must be <= 15,000,000 (15 Mbps).
        pub bitrate_bps: i32,

        /// Specifies whether an open Group of Pictures (GOP) structure should be
        /// allowed or not. The default is `false`.
        pub allow_open_gop: bool,

        /// Size of the Video Buffering Verifier (VBV) buffer in bits. Must be
        /// greater than zero. The default is equal to
        /// [bitrate_bps][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.bitrate_bps].
        ///
        /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.bitrate_bps]: crate::model::video_stream::H264CodecSettings::bitrate_bps
        pub vbv_size_bits: i32,

        /// Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
        /// Must be greater than zero. The default is equal to 90% of
        /// [vbv_size_bits][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.vbv_size_bits].
        ///
        /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.vbv_size_bits]: crate::model::video_stream::H264CodecSettings::vbv_size_bits
        pub vbv_fullness_bits: i32,

        /// The entropy coder to use. The default is `cabac`.
        ///
        /// Supported entropy coders:
        ///
        /// - `cavlc`
        /// - `cabac`
        pub entropy_coder: std::string::String,

        /// Allow B-pyramid for reference frame selection. This may not be supported
        /// on all decoders. The default is `false`.
        pub b_pyramid: bool,

        /// The number of consecutive B-frames. Must be greater than or equal to
        /// zero. Must be less than
        /// [gop_frame_count][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_frame_count]
        /// if set. The default is 0.
        ///
        /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_frame_count]: crate::model::video_stream::H264CodecSettings::gop_mode
        pub b_frame_count: i32,

        /// Specify the intensity of the adaptive quantizer (AQ). Must be between 0
        /// and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
        /// higher value equals a lower bitrate but smoother image. The default is 0.
        pub aq_strength: f64,

        /// Enforces the specified codec profile. The following profiles are
        /// supported:
        ///
        /// * `baseline`
        /// * `main` (default)
        /// * `high`
        ///
        /// The available options are [FFmpeg-compatible Profile
        /// Options](https://trac.ffmpeg.org/wiki/Encode/H.264#Profile).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the
        /// [H264CodecSettings][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings]
        /// message.
        ///
        /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings]: crate::model::video_stream::H264CodecSettings
        pub profile: std::string::String,

        /// Enforces the specified codec tune. The available options are
        /// [FFmpeg-compatible Encode
        /// Options](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune)
        /// Note that certain values for this field may cause the transcoder to
        /// override other fields you set in the
        /// [H264CodecSettings][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings]
        /// message.
        ///
        /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings]: crate::model::video_stream::H264CodecSettings
        pub tune: std::string::String,

        /// GOP mode can be either by frame count or duration.
        pub gop_mode:
            std::option::Option<crate::model::video_stream::h_264_codec_settings::GopMode>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl H264CodecSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [width_pixels][crate::model::video_stream::H264CodecSettings::width_pixels].
        pub fn set_width_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.width_pixels = v.into();
            self
        }

        /// Sets the value of [height_pixels][crate::model::video_stream::H264CodecSettings::height_pixels].
        pub fn set_height_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.height_pixels = v.into();
            self
        }

        /// Sets the value of [frame_rate][crate::model::video_stream::H264CodecSettings::frame_rate].
        pub fn set_frame_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.frame_rate = v.into();
            self
        }

        /// Sets the value of [bitrate_bps][crate::model::video_stream::H264CodecSettings::bitrate_bps].
        pub fn set_bitrate_bps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.bitrate_bps = v.into();
            self
        }

        /// Sets the value of [allow_open_gop][crate::model::video_stream::H264CodecSettings::allow_open_gop].
        pub fn set_allow_open_gop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_open_gop = v.into();
            self
        }

        /// Sets the value of [vbv_size_bits][crate::model::video_stream::H264CodecSettings::vbv_size_bits].
        pub fn set_vbv_size_bits<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.vbv_size_bits = v.into();
            self
        }

        /// Sets the value of [vbv_fullness_bits][crate::model::video_stream::H264CodecSettings::vbv_fullness_bits].
        pub fn set_vbv_fullness_bits<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.vbv_fullness_bits = v.into();
            self
        }

        /// Sets the value of [entropy_coder][crate::model::video_stream::H264CodecSettings::entropy_coder].
        pub fn set_entropy_coder<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.entropy_coder = v.into();
            self
        }

        /// Sets the value of [b_pyramid][crate::model::video_stream::H264CodecSettings::b_pyramid].
        pub fn set_b_pyramid<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.b_pyramid = v.into();
            self
        }

        /// Sets the value of [b_frame_count][crate::model::video_stream::H264CodecSettings::b_frame_count].
        pub fn set_b_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.b_frame_count = v.into();
            self
        }

        /// Sets the value of [aq_strength][crate::model::video_stream::H264CodecSettings::aq_strength].
        pub fn set_aq_strength<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.aq_strength = v.into();
            self
        }

        /// Sets the value of [profile][crate::model::video_stream::H264CodecSettings::profile].
        pub fn set_profile<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.profile = v.into();
            self
        }

        /// Sets the value of [tune][crate::model::video_stream::H264CodecSettings::tune].
        pub fn set_tune<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tune = v.into();
            self
        }

        /// Sets the value of [gop_mode][crate::model::video_stream::H264CodecSettings::gop_mode].
        ///
        /// Note that all the setters affecting `gop_mode` are mutually
        /// exclusive.
        pub fn set_gop_mode<
            T: std::convert::Into<
                    std::option::Option<crate::model::video_stream::h_264_codec_settings::GopMode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.gop_mode = v.into();
            self
        }

        /// The value of [gop_mode][crate::model::video_stream::H264CodecSettings::gop_mode]
        /// if it holds a `GopFrameCount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gop_frame_count(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.gop_mode.as_ref().and_then(|v| match v {
                crate::model::video_stream::h_264_codec_settings::GopMode::GopFrameCount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [gop_mode][crate::model::video_stream::H264CodecSettings::gop_mode]
        /// to hold a `GopFrameCount`.
        ///
        /// Note that all the setters affecting `gop_mode` are
        /// mutually exclusive.
        pub fn set_gop_frame_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.gop_mode = std::option::Option::Some(
                crate::model::video_stream::h_264_codec_settings::GopMode::GopFrameCount(v.into()),
            );
            self
        }

        /// The value of [gop_mode][crate::model::video_stream::H264CodecSettings::gop_mode]
        /// if it holds a `GopDuration`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gop_duration(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
            #[allow(unreachable_patterns)]
            self.gop_mode.as_ref().and_then(|v| match v {
                crate::model::video_stream::h_264_codec_settings::GopMode::GopDuration(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [gop_mode][crate::model::video_stream::H264CodecSettings::gop_mode]
        /// to hold a `GopDuration`.
        ///
        /// Note that all the setters affecting `gop_mode` are
        /// mutually exclusive.
        pub fn set_gop_duration<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.gop_mode = std::option::Option::Some(
                crate::model::video_stream::h_264_codec_settings::GopMode::GopDuration(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for H264CodecSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.VideoStream.H264CodecSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for H264CodecSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __width_pixels,
                __height_pixels,
                __frame_rate,
                __bitrate_bps,
                __allow_open_gop,
                __gop_frame_count,
                __gop_duration,
                __vbv_size_bits,
                __vbv_fullness_bits,
                __entropy_coder,
                __b_pyramid,
                __b_frame_count,
                __aq_strength,
                __profile,
                __tune,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for H264CodecSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "widthPixels" => Ok(__FieldTag::__width_pixels),
                                "width_pixels" => Ok(__FieldTag::__width_pixels),
                                "heightPixels" => Ok(__FieldTag::__height_pixels),
                                "height_pixels" => Ok(__FieldTag::__height_pixels),
                                "frameRate" => Ok(__FieldTag::__frame_rate),
                                "frame_rate" => Ok(__FieldTag::__frame_rate),
                                "bitrateBps" => Ok(__FieldTag::__bitrate_bps),
                                "bitrate_bps" => Ok(__FieldTag::__bitrate_bps),
                                "allowOpenGop" => Ok(__FieldTag::__allow_open_gop),
                                "allow_open_gop" => Ok(__FieldTag::__allow_open_gop),
                                "gopFrameCount" => Ok(__FieldTag::__gop_frame_count),
                                "gop_frame_count" => Ok(__FieldTag::__gop_frame_count),
                                "gopDuration" => Ok(__FieldTag::__gop_duration),
                                "gop_duration" => Ok(__FieldTag::__gop_duration),
                                "vbvSizeBits" => Ok(__FieldTag::__vbv_size_bits),
                                "vbv_size_bits" => Ok(__FieldTag::__vbv_size_bits),
                                "vbvFullnessBits" => Ok(__FieldTag::__vbv_fullness_bits),
                                "vbv_fullness_bits" => Ok(__FieldTag::__vbv_fullness_bits),
                                "entropyCoder" => Ok(__FieldTag::__entropy_coder),
                                "entropy_coder" => Ok(__FieldTag::__entropy_coder),
                                "bPyramid" => Ok(__FieldTag::__b_pyramid),
                                "b_pyramid" => Ok(__FieldTag::__b_pyramid),
                                "bFrameCount" => Ok(__FieldTag::__b_frame_count),
                                "b_frame_count" => Ok(__FieldTag::__b_frame_count),
                                "aqStrength" => Ok(__FieldTag::__aq_strength),
                                "aq_strength" => Ok(__FieldTag::__aq_strength),
                                "profile" => Ok(__FieldTag::__profile),
                                "tune" => Ok(__FieldTag::__tune),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = H264CodecSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct H264CodecSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__width_pixels => {
                                if !fields.insert(__FieldTag::__width_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for width_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.width_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__height_pixels => {
                                if !fields.insert(__FieldTag::__height_pixels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for height_pixels",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.height_pixels =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__frame_rate => {
                                if !fields.insert(__FieldTag::__frame_rate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for frame_rate",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.frame_rate =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__bitrate_bps => {
                                if !fields.insert(__FieldTag::__bitrate_bps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bitrate_bps",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.bitrate_bps =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__allow_open_gop => {
                                if !fields.insert(__FieldTag::__allow_open_gop) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_open_gop",
                                    ));
                                }
                                result.allow_open_gop = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gop_frame_count => {
                                if !fields.insert(__FieldTag::__gop_frame_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gop_frame_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.gop_mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `gop_mode`, a oneof with full ID .google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_frame_count, latest field was gopFrameCount",
                                    ));
                                }
                                result.gop_mode = std::option::Option::Some(
                                    crate::model::video_stream::h_264_codec_settings::GopMode::GopFrameCount(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__gop_duration => {
                                if !fields.insert(__FieldTag::__gop_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gop_duration",
                                    ));
                                }
                                if result.gop_mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `gop_mode`, a oneof with full ID .google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_duration, latest field was gopDuration",
                                    ));
                                }
                                result.gop_mode = std::option::Option::Some(
                                    crate::model::video_stream::h_264_codec_settings::GopMode::GopDuration(
                                        map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__vbv_size_bits => {
                                if !fields.insert(__FieldTag::__vbv_size_bits) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vbv_size_bits",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.vbv_size_bits =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__vbv_fullness_bits => {
                                if !fields.insert(__FieldTag::__vbv_fullness_bits) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vbv_fullness_bits",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.vbv_fullness_bits =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__entropy_coder => {
                                if !fields.insert(__FieldTag::__entropy_coder) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entropy_coder",
                                    ));
                                }
                                result.entropy_coder = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__b_pyramid => {
                                if !fields.insert(__FieldTag::__b_pyramid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for b_pyramid",
                                    ));
                                }
                                result.b_pyramid = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__b_frame_count => {
                                if !fields.insert(__FieldTag::__b_frame_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for b_frame_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.b_frame_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__aq_strength => {
                                if !fields.insert(__FieldTag::__aq_strength) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for aq_strength",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.aq_strength =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__profile => {
                                if !fields.insert(__FieldTag::__profile) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for profile",
                                    ));
                                }
                                result.profile = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tune => {
                                if !fields.insert(__FieldTag::__tune) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tune",
                                    ));
                                }
                                result.tune = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for H264CodecSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.width_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("widthPixels", &__With(&self.width_pixels))?;
            }
            if !wkt::internal::is_default(&self.height_pixels) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("heightPixels", &__With(&self.height_pixels))?;
            }
            if !wkt::internal::is_default(&self.frame_rate) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("frameRate", &__With(&self.frame_rate))?;
            }
            if !wkt::internal::is_default(&self.bitrate_bps) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("bitrateBps", &__With(&self.bitrate_bps))?;
            }
            if !wkt::internal::is_default(&self.allow_open_gop) {
                state.serialize_entry("allowOpenGop", &self.allow_open_gop)?;
            }
            if let Some(value) = self.gop_frame_count() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("gopFrameCount", &__With(value))?;
            }
            if let Some(value) = self.gop_duration() {
                state.serialize_entry("gopDuration", value)?;
            }
            if !wkt::internal::is_default(&self.vbv_size_bits) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("vbvSizeBits", &__With(&self.vbv_size_bits))?;
            }
            if !wkt::internal::is_default(&self.vbv_fullness_bits) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("vbvFullnessBits", &__With(&self.vbv_fullness_bits))?;
            }
            if !self.entropy_coder.is_empty() {
                state.serialize_entry("entropyCoder", &self.entropy_coder)?;
            }
            if !wkt::internal::is_default(&self.b_pyramid) {
                state.serialize_entry("bPyramid", &self.b_pyramid)?;
            }
            if !wkt::internal::is_default(&self.b_frame_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("bFrameCount", &__With(&self.b_frame_count))?;
            }
            if !wkt::internal::is_default(&self.aq_strength) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("aqStrength", &__With(&self.aq_strength))?;
            }
            if !self.profile.is_empty() {
                state.serialize_entry("profile", &self.profile)?;
            }
            if !self.tune.is_empty() {
                state.serialize_entry("tune", &self.tune)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [H264CodecSettings].
    pub mod h_264_codec_settings {
        #[allow(unused_imports)]
        use super::*;

        /// GOP mode can be either by frame count or duration.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GopMode {
            /// Select the GOP size based on the specified frame count.
            /// If GOP frame count is set instead of GOP duration, GOP duration will be
            /// calculated by `gopFrameCount`/`frameRate`. The calculated GOP duration
            /// must satisfy the limitations on `gopDuration` as well.
            /// Valid range is [60, 600].
            GopFrameCount(i32),
            /// Select the GOP size based on the specified duration. The default is
            /// `2s`. Note that `gopDuration` must be less than or equal to
            /// [segment_duration][google.cloud.video.livestream.v1.SegmentSettings.segment_duration],
            /// and
            /// [segment_duration][google.cloud.video.livestream.v1.SegmentSettings.segment_duration]
            /// must be divisible by `gopDuration`. Valid range is [2s, 20s].
            ///
            /// All video streams in the same channel must have the same GOP size.
            ///
            /// [google.cloud.video.livestream.v1.SegmentSettings.segment_duration]: crate::model::SegmentSettings::segment_duration
            GopDuration(std::boxed::Box<wkt::Duration>),
        }
    }

    /// Codec settings.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CodecSettings {
        /// H264 codec settings.
        H264(std::boxed::Box<crate::model::video_stream::H264CodecSettings>),
    }
}

/// Audio stream resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioStream {
    /// Specifies whether pass through (transmuxing) is enabled or not.
    /// If set to `true`, the rest of the settings, other than `mapping`, will be
    /// ignored. The default is `false`.
    pub transmux: bool,

    /// The codec for this audio stream. The default is `aac`.
    ///
    /// Supported audio codecs:
    ///
    /// - `aac`
    pub codec: std::string::String,

    /// Required. Audio bitrate in bits per second. Must be between 1 and
    /// 10,000,000.
    pub bitrate_bps: i32,

    /// Number of audio channels. Must be between 1 and 6. The default is 2.
    pub channel_count: i32,

    /// A list of channel names specifying layout of the audio channels.
    /// This only affects the metadata embedded in the container headers, if
    /// supported by the specified format. The default is `[fl, fr]`.
    ///
    /// Supported channel names:
    ///
    /// - `fl` - Front left channel
    /// - `fr` - Front right channel
    /// - `sl` - Side left channel
    /// - `sr` - Side right channel
    /// - `fc` - Front center channel
    /// - `lfe` - Low frequency
    pub channel_layout: std::vec::Vec<std::string::String>,

    /// The mapping for the input streams and audio channels.
    pub mapping: std::vec::Vec<crate::model::audio_stream::AudioMapping>,

    /// The audio sample rate in Hertz. The default is 48000 Hertz.
    pub sample_rate_hertz: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AudioStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transmux][crate::model::AudioStream::transmux].
    pub fn set_transmux<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.transmux = v.into();
        self
    }

    /// Sets the value of [codec][crate::model::AudioStream::codec].
    pub fn set_codec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codec = v.into();
        self
    }

    /// Sets the value of [bitrate_bps][crate::model::AudioStream::bitrate_bps].
    pub fn set_bitrate_bps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.bitrate_bps = v.into();
        self
    }

    /// Sets the value of [channel_count][crate::model::AudioStream::channel_count].
    pub fn set_channel_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_count = v.into();
        self
    }

    /// Sets the value of [channel_layout][crate::model::AudioStream::channel_layout].
    pub fn set_channel_layout<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.channel_layout = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mapping][crate::model::AudioStream::mapping].
    pub fn set_mapping<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::audio_stream::AudioMapping>,
    {
        use std::iter::Iterator;
        self.mapping = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::AudioStream::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }
}

impl wkt::message::Message for AudioStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.AudioStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transmux,
            __codec,
            __bitrate_bps,
            __channel_count,
            __channel_layout,
            __mapping,
            __sample_rate_hertz,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transmux" => Ok(__FieldTag::__transmux),
                            "codec" => Ok(__FieldTag::__codec),
                            "bitrateBps" => Ok(__FieldTag::__bitrate_bps),
                            "bitrate_bps" => Ok(__FieldTag::__bitrate_bps),
                            "channelCount" => Ok(__FieldTag::__channel_count),
                            "channel_count" => Ok(__FieldTag::__channel_count),
                            "channelLayout" => Ok(__FieldTag::__channel_layout),
                            "channel_layout" => Ok(__FieldTag::__channel_layout),
                            "mapping" => Ok(__FieldTag::__mapping),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transmux => {
                            if !fields.insert(__FieldTag::__transmux) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transmux",
                                ));
                            }
                            result.transmux = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__codec => {
                            if !fields.insert(__FieldTag::__codec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codec",
                                ));
                            }
                            result.codec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bitrate_bps => {
                            if !fields.insert(__FieldTag::__bitrate_bps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitrate_bps",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bitrate_bps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__channel_count => {
                            if !fields.insert(__FieldTag::__channel_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__channel_layout => {
                            if !fields.insert(__FieldTag::__channel_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_layout",
                                ));
                            }
                            result.channel_layout = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mapping => {
                            if !fields.insert(__FieldTag::__mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping",
                                ));
                            }
                            result.mapping = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::audio_stream::AudioMapping>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AudioStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.transmux) {
            state.serialize_entry("transmux", &self.transmux)?;
        }
        if !self.codec.is_empty() {
            state.serialize_entry("codec", &self.codec)?;
        }
        if !wkt::internal::is_default(&self.bitrate_bps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bitrateBps", &__With(&self.bitrate_bps))?;
        }
        if !wkt::internal::is_default(&self.channel_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelCount", &__With(&self.channel_count))?;
        }
        if !self.channel_layout.is_empty() {
            state.serialize_entry("channelLayout", &self.channel_layout)?;
        }
        if !self.mapping.is_empty() {
            state.serialize_entry("mapping", &self.mapping)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AudioStream].
pub mod audio_stream {
    #[allow(unused_imports)]
    use super::*;

    /// The mapping for the input streams and audio channels.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AudioMapping {
        /// Required. The `Channel`
        /// [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]
        /// that identifies the input that this audio mapping applies to. If an
        /// active input doesn't have an audio mapping, the primary audio track in
        /// the input stream will be selected.
        ///
        /// [google.cloud.video.livestream.v1.InputAttachment.key]: crate::model::InputAttachment::key
        pub input_key: std::string::String,

        /// Required. The zero-based index of the track in the input stream.
        /// All [mapping][google.cloud.video.livestream.v1.AudioStream.mapping]s in
        /// the same [AudioStream][google.cloud.video.livestream.v1.AudioStream] must
        /// have the same input track.
        ///
        /// [google.cloud.video.livestream.v1.AudioStream]: crate::model::AudioStream
        /// [google.cloud.video.livestream.v1.AudioStream.mapping]: crate::model::AudioStream::mapping
        pub input_track: i32,

        /// Required. The zero-based index of the channel in the input stream.
        pub input_channel: i32,

        /// Required. The zero-based index of the channel in the output audio stream.
        /// Must be consistent with the
        /// [input_channel][google.cloud.video.livestream.v1.AudioStream.AudioMapping.input_channel].
        ///
        /// [google.cloud.video.livestream.v1.AudioStream.AudioMapping.input_channel]: crate::model::audio_stream::AudioMapping::input_channel
        pub output_channel: i32,

        /// Audio volume control in dB. Negative values decrease volume,
        /// positive values increase. The default is 0.
        pub gain_db: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AudioMapping {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_key][crate::model::audio_stream::AudioMapping::input_key].
        pub fn set_input_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.input_key = v.into();
            self
        }

        /// Sets the value of [input_track][crate::model::audio_stream::AudioMapping::input_track].
        pub fn set_input_track<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.input_track = v.into();
            self
        }

        /// Sets the value of [input_channel][crate::model::audio_stream::AudioMapping::input_channel].
        pub fn set_input_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.input_channel = v.into();
            self
        }

        /// Sets the value of [output_channel][crate::model::audio_stream::AudioMapping::output_channel].
        pub fn set_output_channel<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.output_channel = v.into();
            self
        }

        /// Sets the value of [gain_db][crate::model::audio_stream::AudioMapping::gain_db].
        pub fn set_gain_db<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.gain_db = v.into();
            self
        }
    }

    impl wkt::message::Message for AudioMapping {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.AudioStream.AudioMapping"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AudioMapping {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_key,
                __input_track,
                __input_channel,
                __output_channel,
                __gain_db,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AudioMapping")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputKey" => Ok(__FieldTag::__input_key),
                                "input_key" => Ok(__FieldTag::__input_key),
                                "inputTrack" => Ok(__FieldTag::__input_track),
                                "input_track" => Ok(__FieldTag::__input_track),
                                "inputChannel" => Ok(__FieldTag::__input_channel),
                                "input_channel" => Ok(__FieldTag::__input_channel),
                                "outputChannel" => Ok(__FieldTag::__output_channel),
                                "output_channel" => Ok(__FieldTag::__output_channel),
                                "gainDb" => Ok(__FieldTag::__gain_db),
                                "gain_db" => Ok(__FieldTag::__gain_db),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AudioMapping;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AudioMapping")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_key => {
                                if !fields.insert(__FieldTag::__input_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_key",
                                    ));
                                }
                                result.input_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__input_track => {
                                if !fields.insert(__FieldTag::__input_track) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_track",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.input_track =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__input_channel => {
                                if !fields.insert(__FieldTag::__input_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.input_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__output_channel => {
                                if !fields.insert(__FieldTag::__output_channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_channel",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.output_channel =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__gain_db => {
                                if !fields.insert(__FieldTag::__gain_db) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gain_db",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.gain_db = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AudioMapping {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.input_key.is_empty() {
                state.serialize_entry("inputKey", &self.input_key)?;
            }
            if !wkt::internal::is_default(&self.input_track) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("inputTrack", &__With(&self.input_track))?;
            }
            if !wkt::internal::is_default(&self.input_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("inputChannel", &__With(&self.input_channel))?;
            }
            if !wkt::internal::is_default(&self.output_channel) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("outputChannel", &__With(&self.output_channel))?;
            }
            if !wkt::internal::is_default(&self.gain_db) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("gainDb", &__With(&self.gain_db))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Encoding of a text stream. For example, closed captions or subtitles.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextStream {
    /// Required. The codec for this text stream.
    ///
    /// Supported text codecs:
    ///
    /// - `cea608`
    /// - `cea708`
    pub codec: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextStream {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [codec][crate::model::TextStream::codec].
    pub fn set_codec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codec = v.into();
        self
    }
}

impl wkt::message::Message for TextStream {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.TextStream"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextStream {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __codec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextStream")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "codec" => Ok(__FieldTag::__codec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextStream;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextStream")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__codec => {
                            if !fields.insert(__FieldTag::__codec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codec",
                                ));
                            }
                            result.codec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TextStream {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.codec.is_empty() {
            state.serialize_entry("codec", &self.codec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Segment settings for `fmp4` and `ts`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SegmentSettings {
    /// Duration of the segments in seconds. The default is `6s`. Note that
    /// `segmentDuration` must be greater than or equal to
    /// [gop_duration][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_duration],
    /// and `segmentDuration` must be divisible by
    /// [gop_duration][google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_duration].
    /// Valid range is [2s, 20s].
    ///
    /// All [mux_streams][google.cloud.video.livestream.v1.Manifest.mux_streams] in
    /// the same manifest must have the same segment duration.
    ///
    /// [google.cloud.video.livestream.v1.Manifest.mux_streams]: crate::model::Manifest::mux_streams
    /// [google.cloud.video.livestream.v1.VideoStream.H264CodecSettings.gop_duration]: crate::model::video_stream::H264CodecSettings::gop_mode
    pub segment_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SegmentSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [segment_duration][crate::model::SegmentSettings::segment_duration].
    pub fn set_segment_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.segment_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [segment_duration][crate::model::SegmentSettings::segment_duration].
    pub fn set_or_clear_segment_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.segment_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SegmentSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.SegmentSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SegmentSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __segment_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SegmentSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "segmentDuration" => Ok(__FieldTag::__segment_duration),
                            "segment_duration" => Ok(__FieldTag::__segment_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SegmentSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SegmentSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__segment_duration => {
                            if !fields.insert(__FieldTag::__segment_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for segment_duration",
                                ));
                            }
                            result.segment_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SegmentSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.segment_duration.is_some() {
            state.serialize_entry("segmentDuration", &self.segment_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Timecode configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimecodeConfig {
    /// The source of the timecode that will later be used in outputs/manifests.
    /// It determines the initial timecode/timestamp (first frame) of output
    /// streams.
    pub source: crate::model::timecode_config::TimecodeSource,

    /// For EMBEDDED_TIMECODE source only.
    /// Used to interpret the embedded timecode (which contains only the time part
    /// and no date). We assume all inputs are live.
    pub time_offset: std::option::Option<crate::model::timecode_config::TimeOffset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimecodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::TimecodeConfig::source].
    pub fn set_source<T: std::convert::Into<crate::model::timecode_config::TimecodeSource>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [time_offset][crate::model::TimecodeConfig::time_offset].
    ///
    /// Note that all the setters affecting `time_offset` are mutually
    /// exclusive.
    pub fn set_time_offset<
        T: std::convert::Into<std::option::Option<crate::model::timecode_config::TimeOffset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset = v.into();
        self
    }

    /// The value of [time_offset][crate::model::TimecodeConfig::time_offset]
    /// if it holds a `UtcOffset`, `None` if the field is not set or
    /// holds a different branch.
    pub fn utc_offset(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.time_offset.as_ref().and_then(|v| match v {
            crate::model::timecode_config::TimeOffset::UtcOffset(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_offset][crate::model::TimecodeConfig::time_offset]
    /// to hold a `UtcOffset`.
    ///
    /// Note that all the setters affecting `time_offset` are
    /// mutually exclusive.
    pub fn set_utc_offset<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset = std::option::Option::Some(
            crate::model::timecode_config::TimeOffset::UtcOffset(v.into()),
        );
        self
    }

    /// The value of [time_offset][crate::model::TimecodeConfig::time_offset]
    /// if it holds a `TimeZone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_zone(&self) -> std::option::Option<&std::boxed::Box<gtype::model::TimeZone>> {
        #[allow(unreachable_patterns)]
        self.time_offset.as_ref().and_then(|v| match v {
            crate::model::timecode_config::TimeOffset::TimeZone(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [time_offset][crate::model::TimecodeConfig::time_offset]
    /// to hold a `TimeZone`.
    ///
    /// Note that all the setters affecting `time_offset` are
    /// mutually exclusive.
    pub fn set_time_zone<T: std::convert::Into<std::boxed::Box<gtype::model::TimeZone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_offset = std::option::Option::Some(
            crate::model::timecode_config::TimeOffset::TimeZone(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimecodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.TimecodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimecodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __utc_offset,
            __time_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimecodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "utcOffset" => Ok(__FieldTag::__utc_offset),
                            "utc_offset" => Ok(__FieldTag::__utc_offset),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimecodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimecodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<
                                    crate::model::timecode_config::TimecodeSource,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utc_offset => {
                            if !fields.insert(__FieldTag::__utc_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utc_offset",
                                ));
                            }
                            if result.time_offset.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time_offset`, a oneof with full ID .google.cloud.video.livestream.v1.TimecodeConfig.utc_offset, latest field was utcOffset",
                                ));
                            }
                            result.time_offset = std::option::Option::Some(
                                crate::model::timecode_config::TimeOffset::UtcOffset(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            if result.time_offset.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `time_offset`, a oneof with full ID .google.cloud.video.livestream.v1.TimecodeConfig.time_zone, latest field was timeZone",
                                ));
                            }
                            result.time_offset = std::option::Option::Some(
                                crate::model::timecode_config::TimeOffset::TimeZone(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<gtype::model::TimeZone>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimecodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source) {
            state.serialize_entry("source", &self.source)?;
        }
        if let Some(value) = self.utc_offset() {
            state.serialize_entry("utcOffset", value)?;
        }
        if let Some(value) = self.time_zone() {
            state.serialize_entry("timeZone", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TimecodeConfig].
pub mod timecode_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of timecode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimecodeSource {
        /// The timecode source is not specified.
        Unspecified,
        /// Use input media timestamp.
        MediaTimestamp,
        /// Use input embedded timecode e.g. picture timing SEI message.
        EmbeddedTimecode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimecodeSource::value] or
        /// [TimecodeSource::name].
        UnknownValue(timecode_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod timecode_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimecodeSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MediaTimestamp => std::option::Option::Some(1),
                Self::EmbeddedTimecode => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIMECODE_SOURCE_UNSPECIFIED"),
                Self::MediaTimestamp => std::option::Option::Some("MEDIA_TIMESTAMP"),
                Self::EmbeddedTimecode => std::option::Option::Some("EMBEDDED_TIMECODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimecodeSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimecodeSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimecodeSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MediaTimestamp,
                2 => Self::EmbeddedTimecode,
                _ => Self::UnknownValue(timecode_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimecodeSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIMECODE_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "MEDIA_TIMESTAMP" => Self::MediaTimestamp,
                "EMBEDDED_TIMECODE" => Self::EmbeddedTimecode,
                _ => Self::UnknownValue(timecode_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimecodeSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MediaTimestamp => serializer.serialize_i32(1),
                Self::EmbeddedTimecode => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimecodeSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimecodeSource>::new(
                ".google.cloud.video.livestream.v1.TimecodeConfig.TimecodeSource",
            ))
        }
    }

    /// For EMBEDDED_TIMECODE source only.
    /// Used to interpret the embedded timecode (which contains only the time part
    /// and no date). We assume all inputs are live.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeOffset {
        /// UTC offset. Must be whole seconds, between -18 hours and +18 hours.
        UtcOffset(std::boxed::Box<wkt::Duration>),
        /// Time zone e.g. "America/Los_Angeles".
        TimeZone(std::boxed::Box<gtype::model::TimeZone>),
    }
}

/// Input resource represents the endpoint from which the channel ingests
/// the input stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Input {
    /// The resource name of the input, in the form of:
    /// `projects/{project}/locations/{location}/inputs/{inputId}`.
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Source type.
    pub r#type: crate::model::input::Type,

    /// Tier defines the maximum input specification that is accepted by the
    /// video pipeline. The billing is charged based on the tier specified here.
    /// See [Pricing](https://cloud.google.com/livestream/pricing) for more detail.
    /// The default is `HD`.
    pub tier: crate::model::input::Tier,

    /// Output only. URI to push the input stream to.
    /// Its format depends on the input
    /// [type][google.cloud.video.livestream.v1.Input.type], for example:
    ///
    /// * `RTMP_PUSH`: `rtmp://1.2.3.4/live/{STREAM-ID}`
    /// * `SRT_PUSH`: `srt://1.2.3.4:4201?streamid={STREAM-ID}`
    ///
    /// [google.cloud.video.livestream.v1.Input.type]: crate::model::Input::type
    pub uri: std::string::String,

    /// Preprocessing configurations.
    pub preprocessing_config: std::option::Option<crate::model::PreprocessingConfig>,

    /// Security rule for access control.
    pub security_rules: std::option::Option<crate::model::input::SecurityRule>,

    /// Output only. The information for the input stream. This field will be
    /// present only when this input receives the input stream.
    pub input_stream_property: std::option::Option<crate::model::InputStreamProperty>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Input {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Input::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Input::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Input::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Input::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Input::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Input::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::Input::type].
    pub fn set_type<T: std::convert::Into<crate::model::input::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Input::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::input::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Input::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [preprocessing_config][crate::model::Input::preprocessing_config].
    pub fn set_preprocessing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreprocessingConfig>,
    {
        self.preprocessing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preprocessing_config][crate::model::Input::preprocessing_config].
    pub fn set_or_clear_preprocessing_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreprocessingConfig>,
    {
        self.preprocessing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_rules][crate::model::Input::security_rules].
    pub fn set_security_rules<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::input::SecurityRule>,
    {
        self.security_rules = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_rules][crate::model::Input::security_rules].
    pub fn set_or_clear_security_rules<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::input::SecurityRule>,
    {
        self.security_rules = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_stream_property][crate::model::Input::input_stream_property].
    pub fn set_input_stream_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputStreamProperty>,
    {
        self.input_stream_property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_stream_property][crate::model::Input::input_stream_property].
    pub fn set_or_clear_input_stream_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputStreamProperty>,
    {
        self.input_stream_property = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Input {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Input"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Input {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __type,
            __tier,
            __uri,
            __preprocessing_config,
            __security_rules,
            __input_stream_property,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Input")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "type" => Ok(__FieldTag::__type),
                            "tier" => Ok(__FieldTag::__tier),
                            "uri" => Ok(__FieldTag::__uri),
                            "preprocessingConfig" => Ok(__FieldTag::__preprocessing_config),
                            "preprocessing_config" => Ok(__FieldTag::__preprocessing_config),
                            "securityRules" => Ok(__FieldTag::__security_rules),
                            "security_rules" => Ok(__FieldTag::__security_rules),
                            "inputStreamProperty" => Ok(__FieldTag::__input_stream_property),
                            "input_stream_property" => Ok(__FieldTag::__input_stream_property),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Input;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Input")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::input::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::input::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preprocessing_config => {
                            if !fields.insert(__FieldTag::__preprocessing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preprocessing_config",
                                ));
                            }
                            result.preprocessing_config = map.next_value::<std::option::Option<crate::model::PreprocessingConfig>>()?
                                ;
                        }
                        __FieldTag::__security_rules => {
                            if !fields.insert(__FieldTag::__security_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_rules",
                                ));
                            }
                            result.security_rules = map.next_value::<std::option::Option<crate::model::input::SecurityRule>>()?
                                ;
                        }
                        __FieldTag::__input_stream_property => {
                            if !fields.insert(__FieldTag::__input_stream_property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_stream_property",
                                ));
                            }
                            result.input_stream_property = map.next_value::<std::option::Option<crate::model::InputStreamProperty>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Input {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.tier) {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.preprocessing_config.is_some() {
            state.serialize_entry("preprocessingConfig", &self.preprocessing_config)?;
        }
        if self.security_rules.is_some() {
            state.serialize_entry("securityRules", &self.security_rules)?;
        }
        if self.input_stream_property.is_some() {
            state.serialize_entry("inputStreamProperty", &self.input_stream_property)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Input].
pub mod input {
    #[allow(unused_imports)]
    use super::*;

    /// Security rules for access control. Each field represents one security rule.
    /// Only when the source of the input stream satisfies all the fields, this
    /// input stream can be accepted.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SecurityRule {
        /// At least one ip range must match unless none specified. The IP range is
        /// defined by CIDR block: for example, `192.0.1.0/24` for a range and
        /// `192.0.1.0/32` for a single IP address.
        pub ip_ranges: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecurityRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_ranges][crate::model::input::SecurityRule::ip_ranges].
        pub fn set_ip_ranges<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ip_ranges = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SecurityRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Input.SecurityRule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SecurityRule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ip_ranges,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SecurityRule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ipRanges" => Ok(__FieldTag::__ip_ranges),
                                "ip_ranges" => Ok(__FieldTag::__ip_ranges),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SecurityRule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SecurityRule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ip_ranges => {
                                if !fields.insert(__FieldTag::__ip_ranges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ip_ranges",
                                    ));
                                }
                                result.ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SecurityRule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ip_ranges.is_empty() {
                state.serialize_entry("ipRanges", &self.ip_ranges)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of the input.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Input type is not specified.
        Unspecified,
        /// Input will take an rtmp input stream.
        RtmpPush,
        /// Input will take an srt (Secure Reliable Transport) input stream.
        SrtPush,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RtmpPush => std::option::Option::Some(1),
                Self::SrtPush => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::RtmpPush => std::option::Option::Some("RTMP_PUSH"),
                Self::SrtPush => std::option::Option::Some("SRT_PUSH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RtmpPush,
                2 => Self::SrtPush,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "RTMP_PUSH" => Self::RtmpPush,
                "SRT_PUSH" => Self::SrtPush,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RtmpPush => serializer.serialize_i32(1),
                Self::SrtPush => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.video.livestream.v1.Input.Type",
            ))
        }
    }

    /// Tier of the input specification.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tier {
        /// Tier is not specified.
        Unspecified,
        /// Resolution < 1280x720. Bitrate <= 6 Mbps. FPS <= 60.
        Sd,
        /// Resolution <= 1920x1080. Bitrate <= 25 Mbps. FPS <= 60.
        Hd,
        /// Resolution <= 4096x2160. Not supported yet.
        Uhd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tier::value] or
        /// [Tier::name].
        UnknownValue(tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sd => std::option::Option::Some(1),
                Self::Hd => std::option::Option::Some(2),
                Self::Uhd => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                Self::Sd => std::option::Option::Some("SD"),
                Self::Hd => std::option::Option::Some("HD"),
                Self::Uhd => std::option::Option::Some("UHD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sd,
                2 => Self::Hd,
                3 => Self::Uhd,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_UNSPECIFIED" => Self::Unspecified,
                "SD" => Self::Sd,
                "HD" => Self::Hd,
                "UHD" => Self::Uhd,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sd => serializer.serialize_i32(1),
                Self::Hd => serializer.serialize_i32(2),
                Self::Uhd => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                ".google.cloud.video.livestream.v1.Input.Tier",
            ))
        }
    }
}

/// Channel resource represents the processor that does a user-defined
/// "streaming" operation, which includes getting an input stream through an
/// input, transcoding it to multiple renditions, and publishing output live
/// streams in certain formats (for example, HLS or DASH) to the specified
/// location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Channel {
    /// The resource name of the channel, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of input attachments that this channel uses.
    /// One channel can have multiple inputs as the input sources. Only one
    /// input can be selected as the input source at one time.
    pub input_attachments: std::vec::Vec<crate::model::InputAttachment>,

    /// Output only. The
    /// [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]
    /// that serves as the current input source. The first input in the
    /// [input_attachments][google.cloud.video.livestream.v1.Channel.input_attachments]
    /// is the initial input source.
    ///
    /// [google.cloud.video.livestream.v1.Channel.input_attachments]: crate::model::Channel::input_attachments
    /// [google.cloud.video.livestream.v1.InputAttachment.key]: crate::model::InputAttachment::key
    pub active_input: std::string::String,

    /// Required. Information about the output (that is, the Cloud Storage bucket
    /// to store the generated live stream).
    pub output: std::option::Option<crate::model::channel::Output>,

    /// List of elementary streams.
    pub elementary_streams: std::vec::Vec<crate::model::ElementaryStream>,

    /// List of multiplexing settings for output streams.
    pub mux_streams: std::vec::Vec<crate::model::MuxStream>,

    /// List of output manifests.
    pub manifests: std::vec::Vec<crate::model::Manifest>,

    /// List of output sprite sheets.
    pub sprite_sheets: std::vec::Vec<crate::model::SpriteSheet>,

    /// Output only. State of the streaming operation.
    pub streaming_state: crate::model::channel::StreamingState,

    /// Output only. A description of the reason for the streaming error. This
    /// property is always present when
    /// [streaming_state][google.cloud.video.livestream.v1.Channel.streaming_state]
    /// is
    /// [STREAMING_ERROR][google.cloud.video.livestream.v1.Channel.StreamingState.STREAMING_ERROR].
    ///
    /// [google.cloud.video.livestream.v1.Channel.StreamingState.STREAMING_ERROR]: crate::model::channel::StreamingState::StreamingError
    /// [google.cloud.video.livestream.v1.Channel.streaming_state]: crate::model::Channel::streaming_state
    pub streaming_error: std::option::Option<rpc::model::Status>,

    /// Configuration of platform logs for this channel.
    pub log_config: std::option::Option<crate::model::LogConfig>,

    /// Configuration of timecode for this channel.
    pub timecode_config: std::option::Option<crate::model::TimecodeConfig>,

    /// Encryption configurations for this channel. Each configuration has an ID
    /// which is referred to by each MuxStream to indicate which configuration is
    /// used for that output.
    pub encryptions: std::vec::Vec<crate::model::Encryption>,

    /// The configuration for input sources defined in
    /// [input_attachments][google.cloud.video.livestream.v1.Channel.input_attachments].
    ///
    /// [google.cloud.video.livestream.v1.Channel.input_attachments]: crate::model::Channel::input_attachments
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Optional. Configuration for retention of output files for this channel.
    pub retention_config: std::option::Option<crate::model::RetentionConfig>,

    /// Optional. List of static overlay images. Those images display over the
    /// output content for the whole duration of the live stream.
    pub static_overlays: std::vec::Vec<crate::model::StaticOverlay>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Channel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Channel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Channel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Channel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Channel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Channel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Channel::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [input_attachments][crate::model::Channel::input_attachments].
    pub fn set_input_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InputAttachment>,
    {
        use std::iter::Iterator;
        self.input_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_input][crate::model::Channel::active_input].
    pub fn set_active_input<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.active_input = v.into();
        self
    }

    /// Sets the value of [output][crate::model::Channel::output].
    pub fn set_output<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::channel::Output>,
    {
        self.output = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output][crate::model::Channel::output].
    pub fn set_or_clear_output<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::channel::Output>,
    {
        self.output = v.map(|x| x.into());
        self
    }

    /// Sets the value of [elementary_streams][crate::model::Channel::elementary_streams].
    pub fn set_elementary_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ElementaryStream>,
    {
        use std::iter::Iterator;
        self.elementary_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mux_streams][crate::model::Channel::mux_streams].
    pub fn set_mux_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MuxStream>,
    {
        use std::iter::Iterator;
        self.mux_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [manifests][crate::model::Channel::manifests].
    pub fn set_manifests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Manifest>,
    {
        use std::iter::Iterator;
        self.manifests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sprite_sheets][crate::model::Channel::sprite_sheets].
    pub fn set_sprite_sheets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpriteSheet>,
    {
        use std::iter::Iterator;
        self.sprite_sheets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [streaming_state][crate::model::Channel::streaming_state].
    pub fn set_streaming_state<T: std::convert::Into<crate::model::channel::StreamingState>>(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_state = v.into();
        self
    }

    /// Sets the value of [streaming_error][crate::model::Channel::streaming_error].
    pub fn set_streaming_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.streaming_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [streaming_error][crate::model::Channel::streaming_error].
    pub fn set_or_clear_streaming_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.streaming_error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_config][crate::model::Channel::log_config].
    pub fn set_log_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogConfig>,
    {
        self.log_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_config][crate::model::Channel::log_config].
    pub fn set_or_clear_log_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogConfig>,
    {
        self.log_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timecode_config][crate::model::Channel::timecode_config].
    pub fn set_timecode_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimecodeConfig>,
    {
        self.timecode_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timecode_config][crate::model::Channel::timecode_config].
    pub fn set_or_clear_timecode_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimecodeConfig>,
    {
        self.timecode_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryptions][crate::model::Channel::encryptions].
    pub fn set_encryptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Encryption>,
    {
        use std::iter::Iterator;
        self.encryptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_config][crate::model::Channel::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::Channel::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retention_config][crate::model::Channel::retention_config].
    pub fn set_retention_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RetentionConfig>,
    {
        self.retention_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_config][crate::model::Channel::retention_config].
    pub fn set_or_clear_retention_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RetentionConfig>,
    {
        self.retention_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [static_overlays][crate::model::Channel::static_overlays].
    pub fn set_static_overlays<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StaticOverlay>,
    {
        use std::iter::Iterator;
        self.static_overlays = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Channel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Channel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Channel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __input_attachments,
            __active_input,
            __output,
            __elementary_streams,
            __mux_streams,
            __manifests,
            __sprite_sheets,
            __streaming_state,
            __streaming_error,
            __log_config,
            __timecode_config,
            __encryptions,
            __input_config,
            __retention_config,
            __static_overlays,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Channel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "inputAttachments" => Ok(__FieldTag::__input_attachments),
                            "input_attachments" => Ok(__FieldTag::__input_attachments),
                            "activeInput" => Ok(__FieldTag::__active_input),
                            "active_input" => Ok(__FieldTag::__active_input),
                            "output" => Ok(__FieldTag::__output),
                            "elementaryStreams" => Ok(__FieldTag::__elementary_streams),
                            "elementary_streams" => Ok(__FieldTag::__elementary_streams),
                            "muxStreams" => Ok(__FieldTag::__mux_streams),
                            "mux_streams" => Ok(__FieldTag::__mux_streams),
                            "manifests" => Ok(__FieldTag::__manifests),
                            "spriteSheets" => Ok(__FieldTag::__sprite_sheets),
                            "sprite_sheets" => Ok(__FieldTag::__sprite_sheets),
                            "streamingState" => Ok(__FieldTag::__streaming_state),
                            "streaming_state" => Ok(__FieldTag::__streaming_state),
                            "streamingError" => Ok(__FieldTag::__streaming_error),
                            "streaming_error" => Ok(__FieldTag::__streaming_error),
                            "logConfig" => Ok(__FieldTag::__log_config),
                            "log_config" => Ok(__FieldTag::__log_config),
                            "timecodeConfig" => Ok(__FieldTag::__timecode_config),
                            "timecode_config" => Ok(__FieldTag::__timecode_config),
                            "encryptions" => Ok(__FieldTag::__encryptions),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "retentionConfig" => Ok(__FieldTag::__retention_config),
                            "retention_config" => Ok(__FieldTag::__retention_config),
                            "staticOverlays" => Ok(__FieldTag::__static_overlays),
                            "static_overlays" => Ok(__FieldTag::__static_overlays),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Channel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Channel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_attachments => {
                            if !fields.insert(__FieldTag::__input_attachments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_attachments",
                                ));
                            }
                            result.input_attachments =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InputAttachment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_input => {
                            if !fields.insert(__FieldTag::__active_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_input",
                                ));
                            }
                            result.active_input = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output => {
                            if !fields.insert(__FieldTag::__output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output",
                                ));
                            }
                            result.output = map
                                .next_value::<std::option::Option<crate::model::channel::Output>>(
                                )?;
                        }
                        __FieldTag::__elementary_streams => {
                            if !fields.insert(__FieldTag::__elementary_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for elementary_streams",
                                ));
                            }
                            result.elementary_streams =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ElementaryStream>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mux_streams => {
                            if !fields.insert(__FieldTag::__mux_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mux_streams",
                                ));
                            }
                            result.mux_streams = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MuxStream>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__manifests => {
                            if !fields.insert(__FieldTag::__manifests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manifests",
                                ));
                            }
                            result.manifests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Manifest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sprite_sheets => {
                            if !fields.insert(__FieldTag::__sprite_sheets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sprite_sheets",
                                ));
                            }
                            result.sprite_sheets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SpriteSheet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__streaming_state => {
                            if !fields.insert(__FieldTag::__streaming_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_state",
                                ));
                            }
                            result.streaming_state = map.next_value::<std::option::Option<crate::model::channel::StreamingState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__streaming_error => {
                            if !fields.insert(__FieldTag::__streaming_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_error",
                                ));
                            }
                            result.streaming_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__log_config => {
                            if !fields.insert(__FieldTag::__log_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_config",
                                ));
                            }
                            result.log_config =
                                map.next_value::<std::option::Option<crate::model::LogConfig>>()?;
                        }
                        __FieldTag::__timecode_config => {
                            if !fields.insert(__FieldTag::__timecode_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timecode_config",
                                ));
                            }
                            result.timecode_config = map
                                .next_value::<std::option::Option<crate::model::TimecodeConfig>>(
                                )?;
                        }
                        __FieldTag::__encryptions => {
                            if !fields.insert(__FieldTag::__encryptions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryptions",
                                ));
                            }
                            result.encryptions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Encryption>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__retention_config => {
                            if !fields.insert(__FieldTag::__retention_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_config",
                                ));
                            }
                            result.retention_config = map
                                .next_value::<std::option::Option<crate::model::RetentionConfig>>(
                                )?;
                        }
                        __FieldTag::__static_overlays => {
                            if !fields.insert(__FieldTag::__static_overlays) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_overlays",
                                ));
                            }
                            result.static_overlays = map.next_value::<std::option::Option<std::vec::Vec<crate::model::StaticOverlay>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Channel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.input_attachments.is_empty() {
            state.serialize_entry("inputAttachments", &self.input_attachments)?;
        }
        if !self.active_input.is_empty() {
            state.serialize_entry("activeInput", &self.active_input)?;
        }
        if self.output.is_some() {
            state.serialize_entry("output", &self.output)?;
        }
        if !self.elementary_streams.is_empty() {
            state.serialize_entry("elementaryStreams", &self.elementary_streams)?;
        }
        if !self.mux_streams.is_empty() {
            state.serialize_entry("muxStreams", &self.mux_streams)?;
        }
        if !self.manifests.is_empty() {
            state.serialize_entry("manifests", &self.manifests)?;
        }
        if !self.sprite_sheets.is_empty() {
            state.serialize_entry("spriteSheets", &self.sprite_sheets)?;
        }
        if !wkt::internal::is_default(&self.streaming_state) {
            state.serialize_entry("streamingState", &self.streaming_state)?;
        }
        if self.streaming_error.is_some() {
            state.serialize_entry("streamingError", &self.streaming_error)?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.timecode_config.is_some() {
            state.serialize_entry("timecodeConfig", &self.timecode_config)?;
        }
        if !self.encryptions.is_empty() {
            state.serialize_entry("encryptions", &self.encryptions)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.retention_config.is_some() {
            state.serialize_entry("retentionConfig", &self.retention_config)?;
        }
        if !self.static_overlays.is_empty() {
            state.serialize_entry("staticOverlays", &self.static_overlays)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Channel].
pub mod channel {
    #[allow(unused_imports)]
    use super::*;

    /// Location of output file(s) in a Google Cloud Storage bucket.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Output {
        /// URI for the output file(s). For example, `gs://my-bucket/outputs/`.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Output {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::channel::Output::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for Output {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Channel.Output"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Output {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Output")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Output;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Output")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Output {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// State of streaming operation that the channel is running.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StreamingState {
        /// Streaming state is not specified.
        Unspecified,
        /// Channel is getting the input stream, generating the live streams to the
        /// specified output location.
        Streaming,
        /// Channel is waiting for the input stream through the input.
        AwaitingInput,
        /// Channel is running, but has trouble publishing the live streams onto the
        /// specified output location (for example, the specified Cloud Storage
        /// bucket is not writable).
        StreamingError,
        /// Channel is generating live streams with no input stream. Live streams are
        /// filled out with black screen, while input stream is missing.
        /// Not supported yet.
        StreamingNoInput,
        /// Channel is stopped, finishing live streams.
        Stopped,
        /// Channel is starting.
        Starting,
        /// Channel is stopping.
        Stopping,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StreamingState::value] or
        /// [StreamingState::name].
        UnknownValue(streaming_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod streaming_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StreamingState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Streaming => std::option::Option::Some(1),
                Self::AwaitingInput => std::option::Option::Some(2),
                Self::StreamingError => std::option::Option::Some(4),
                Self::StreamingNoInput => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::Starting => std::option::Option::Some(7),
                Self::Stopping => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STREAMING_STATE_UNSPECIFIED"),
                Self::Streaming => std::option::Option::Some("STREAMING"),
                Self::AwaitingInput => std::option::Option::Some("AWAITING_INPUT"),
                Self::StreamingError => std::option::Option::Some("STREAMING_ERROR"),
                Self::StreamingNoInput => std::option::Option::Some("STREAMING_NO_INPUT"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StreamingState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StreamingState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StreamingState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Streaming,
                2 => Self::AwaitingInput,
                4 => Self::StreamingError,
                5 => Self::StreamingNoInput,
                6 => Self::Stopped,
                7 => Self::Starting,
                8 => Self::Stopping,
                _ => Self::UnknownValue(streaming_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StreamingState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STREAMING_STATE_UNSPECIFIED" => Self::Unspecified,
                "STREAMING" => Self::Streaming,
                "AWAITING_INPUT" => Self::AwaitingInput,
                "STREAMING_ERROR" => Self::StreamingError,
                "STREAMING_NO_INPUT" => Self::StreamingNoInput,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "STOPPING" => Self::Stopping,
                _ => Self::UnknownValue(streaming_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StreamingState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Streaming => serializer.serialize_i32(1),
                Self::AwaitingInput => serializer.serialize_i32(2),
                Self::StreamingError => serializer.serialize_i32(4),
                Self::StreamingNoInput => serializer.serialize_i32(5),
                Self::Stopped => serializer.serialize_i32(6),
                Self::Starting => serializer.serialize_i32(7),
                Self::Stopping => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StreamingState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StreamingState>::new(
                ".google.cloud.video.livestream.v1.Channel.StreamingState",
            ))
        }
    }
}

/// 2D normalized coordinates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NormalizedCoordinate {
    /// Optional. Normalized x coordinate. Valid range is [0.0, 1.0]. Default is 0.
    pub x: f64,

    /// Optional. Normalized y coordinate. Valid range is [0.0, 1.0]. Default is 0.
    pub y: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NormalizedCoordinate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::NormalizedCoordinate::x].
    pub fn set_x<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::NormalizedCoordinate::y].
    pub fn set_y<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for NormalizedCoordinate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.NormalizedCoordinate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NormalizedCoordinate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NormalizedCoordinate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NormalizedCoordinate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NormalizedCoordinate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NormalizedCoordinate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Normalized resolution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NormalizedResolution {
    /// Optional. Normalized width. Valid range is [0.0, 1.0]. Default is 0.
    pub w: f64,

    /// Optional. Normalized height. Valid range is [0.0, 1.0]. Default is 0.
    pub h: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NormalizedResolution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [w][crate::model::NormalizedResolution::w].
    pub fn set_w<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.w = v.into();
        self
    }

    /// Sets the value of [h][crate::model::NormalizedResolution::h].
    pub fn set_h<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.h = v.into();
        self
    }
}

impl wkt::message::Message for NormalizedResolution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.NormalizedResolution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NormalizedResolution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __w,
            __h,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NormalizedResolution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "w" => Ok(__FieldTag::__w),
                            "h" => Ok(__FieldTag::__h),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NormalizedResolution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NormalizedResolution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__w => {
                            if !fields.insert(__FieldTag::__w) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for w",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.w = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__h => {
                            if !fields.insert(__FieldTag::__h) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for h",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.h = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NormalizedResolution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.w) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("w", &__With(&self.w))?;
        }
        if !wkt::internal::is_default(&self.h) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("h", &__With(&self.h))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for the static overlay.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticOverlay {
    /// Required. Asset to use for the overlaid image.
    /// The asset must be represented in the form of:
    /// `projects/{project}/locations/{location}/assets/{assetId}`.
    /// The asset's resource type must be image.
    pub asset: std::string::String,

    /// Optional. Normalized image resolution, based on output video resolution.
    /// Valid values are [0.0, 1.0]. To respect the original image aspect ratio,
    /// set either `w` or `h` to 0. To use the original image resolution, set both
    /// `w` and `h` to 0. The default is {0, 0}.
    pub resolution: std::option::Option<crate::model::NormalizedResolution>,

    /// Optional. Position of the image in terms of normalized coordinates of the
    /// upper-left corner of the image, based on output video resolution. For
    /// example, use the x and y coordinates {0, 0} to position the top-left corner
    /// of the overlay animation in the top-left corner of the output video.
    pub position: std::option::Option<crate::model::NormalizedCoordinate>,

    /// Optional. Target image opacity. Valid values are from `1.0` (solid,
    /// default) to `0.0` (transparent), exclusive. Set this to a value greater
    /// than `0.0`.
    pub opacity: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticOverlay {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [asset][crate::model::StaticOverlay::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [resolution][crate::model::StaticOverlay::resolution].
    pub fn set_resolution<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NormalizedResolution>,
    {
        self.resolution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolution][crate::model::StaticOverlay::resolution].
    pub fn set_or_clear_resolution<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NormalizedResolution>,
    {
        self.resolution = v.map(|x| x.into());
        self
    }

    /// Sets the value of [position][crate::model::StaticOverlay::position].
    pub fn set_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NormalizedCoordinate>,
    {
        self.position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [position][crate::model::StaticOverlay::position].
    pub fn set_or_clear_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NormalizedCoordinate>,
    {
        self.position = v.map(|x| x.into());
        self
    }

    /// Sets the value of [opacity][crate::model::StaticOverlay::opacity].
    pub fn set_opacity<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.opacity = v.into();
        self
    }
}

impl wkt::message::Message for StaticOverlay {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.StaticOverlay"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticOverlay {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __asset,
            __resolution,
            __position,
            __opacity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticOverlay")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "asset" => Ok(__FieldTag::__asset),
                            "resolution" => Ok(__FieldTag::__resolution),
                            "position" => Ok(__FieldTag::__position),
                            "opacity" => Ok(__FieldTag::__opacity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticOverlay;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticOverlay")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resolution => {
                            if !fields.insert(__FieldTag::__resolution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolution",
                                ));
                            }
                            result.resolution = map.next_value::<std::option::Option<crate::model::NormalizedResolution>>()?
                                ;
                        }
                        __FieldTag::__position => {
                            if !fields.insert(__FieldTag::__position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for position",
                                ));
                            }
                            result.position = map.next_value::<std::option::Option<crate::model::NormalizedCoordinate>>()?
                                ;
                        }
                        __FieldTag::__opacity => {
                            if !fields.insert(__FieldTag::__opacity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for opacity",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.opacity = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticOverlay {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asset.is_empty() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if self.resolution.is_some() {
            state.serialize_entry("resolution", &self.resolution)?;
        }
        if self.position.is_some() {
            state.serialize_entry("position", &self.position)?;
        }
        if !wkt::internal::is_default(&self.opacity) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("opacity", &__With(&self.opacity))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for the input sources of a channel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputConfig {
    /// Input switch mode. Default mode is `FAILOVER_PREFER_PRIMARY`.
    pub input_switch_mode: crate::model::input_config::InputSwitchMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_switch_mode][crate::model::InputConfig::input_switch_mode].
    pub fn set_input_switch_mode<
        T: std::convert::Into<crate::model::input_config::InputSwitchMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_switch_mode = v.into();
        self
    }
}

impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.InputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_switch_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputSwitchMode" => Ok(__FieldTag::__input_switch_mode),
                            "input_switch_mode" => Ok(__FieldTag::__input_switch_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_switch_mode => {
                            if !fields.insert(__FieldTag::__input_switch_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_switch_mode",
                                ));
                            }
                            result.input_switch_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::input_config::InputSwitchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.input_switch_mode) {
            state.serialize_entry("inputSwitchMode", &self.input_switch_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InputConfig].
pub mod input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Input switch mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InputSwitchMode {
        /// The input switch mode is not specified.
        Unspecified,
        /// Automatic failover is enabled. The primary input stream is always
        /// preferred over its backup input streams configured using the
        /// [AutomaticFailover][google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]
        /// field.
        ///
        /// [google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]: crate::model::input_attachment::AutomaticFailover
        FailoverPreferPrimary,
        /// Automatic failover is disabled. You must use the
        /// [inputSwitch][google.cloud.video.livestream.v1.Event.input_switch] event
        /// to switch the active input source for the channel to stream from. When
        /// this mode is chosen, the
        /// [AutomaticFailover][google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]
        /// field is ignored.
        ///
        /// [google.cloud.video.livestream.v1.Event.input_switch]: crate::model::Event::task
        /// [google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]: crate::model::input_attachment::AutomaticFailover
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InputSwitchMode::value] or
        /// [InputSwitchMode::name].
        UnknownValue(input_switch_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod input_switch_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InputSwitchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FailoverPreferPrimary => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INPUT_SWITCH_MODE_UNSPECIFIED"),
                Self::FailoverPreferPrimary => std::option::Option::Some("FAILOVER_PREFER_PRIMARY"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InputSwitchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InputSwitchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InputSwitchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FailoverPreferPrimary,
                3 => Self::Manual,
                _ => Self::UnknownValue(input_switch_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InputSwitchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INPUT_SWITCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "FAILOVER_PREFER_PRIMARY" => Self::FailoverPreferPrimary,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(input_switch_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InputSwitchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FailoverPreferPrimary => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InputSwitchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InputSwitchMode>::new(
                ".google.cloud.video.livestream.v1.InputConfig.InputSwitchMode",
            ))
        }
    }
}

/// Configuration of platform logs.
/// See [Using and managing platform
/// logs](https://cloud.google.com/logging/docs/api/platform-logs#managing-logs)
/// for more information about how to view platform logs through Cloud Logging.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogConfig {
    /// The severity level of platform logging for this resource.
    pub log_severity: crate::model::log_config::LogSeverity,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_severity][crate::model::LogConfig::log_severity].
    pub fn set_log_severity<T: std::convert::Into<crate::model::log_config::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_severity = v.into();
        self
    }
}

impl wkt::message::Message for LogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.LogConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_severity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logSeverity" => Ok(__FieldTag::__log_severity),
                            "log_severity" => Ok(__FieldTag::__log_severity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_severity => {
                            if !fields.insert(__FieldTag::__log_severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_severity",
                                ));
                            }
                            result.log_severity = map.next_value::<std::option::Option<crate::model::log_config::LogSeverity>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.log_severity) {
            state.serialize_entry("logSeverity", &self.log_severity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogConfig].
pub mod log_config {
    #[allow(unused_imports)]
    use super::*;

    /// The severity level of platform logging for this channel. Logs with a
    /// severity level higher than or equal to the chosen severity level will be
    /// logged and can be viewed through Cloud Logging.
    /// The severity level of a log is ranked as followed from low to high: DEBUG <
    /// INFO < NOTICE < WARNING < ERROR < CRITICAL < ALERT < EMERGENCY.
    /// See
    /// [LogSeverity](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity)
    /// for more information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogSeverity {
        /// Log severity is not specified. This is the same as log severity is OFF.
        Unspecified,
        /// Log is turned off.
        Off,
        /// Log with severity higher than or equal to DEBUG are logged.
        Debug,
        /// Logs with severity higher than or equal to INFO are logged.
        Info,
        /// Logs with severity higher than or equal to WARNING are logged.
        Warning,
        /// Logs with severity higher than or equal to ERROR are logged.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogSeverity::value] or
        /// [LogSeverity::name].
        UnknownValue(log_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod log_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LogSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Off => std::option::Option::Some(1),
                Self::Debug => std::option::Option::Some(100),
                Self::Info => std::option::Option::Some(200),
                Self::Warning => std::option::Option::Some(400),
                Self::Error => std::option::Option::Some(500),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOG_SEVERITY_UNSPECIFIED"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LogSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LogSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LogSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Off,
                100 => Self::Debug,
                200 => Self::Info,
                400 => Self::Warning,
                500 => Self::Error,
                _ => Self::UnknownValue(log_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LogSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOG_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "OFF" => Self::Off,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(log_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LogSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Off => serializer.serialize_i32(1),
                Self::Debug => serializer.serialize_i32(100),
                Self::Info => serializer.serialize_i32(200),
                Self::Warning => serializer.serialize_i32(400),
                Self::Error => serializer.serialize_i32(500),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LogSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogSeverity>::new(
                ".google.cloud.video.livestream.v1.LogConfig.LogSeverity",
            ))
        }
    }
}

/// Configuration for retention of output files.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetentionConfig {
    /// The minimum duration for which the output files from the channel will
    /// remain in the output bucket. After this duration, output files are
    /// deleted asynchronously.
    ///
    /// When the channel is deleted, all output files are deleted from the output
    /// bucket asynchronously.
    ///
    /// If omitted or set to zero, output files will remain in the output bucket
    /// based on
    /// [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration],
    /// which defaults to 60s.
    ///
    /// If both retention_window_duration and
    /// [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration]
    /// are set, retention_window_duration is used and
    /// [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration]
    /// is ignored.
    ///
    /// [google.cloud.video.livestream.v1.Manifest.segment_keep_duration]: crate::model::Manifest::segment_keep_duration
    pub retention_window_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetentionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_window_duration][crate::model::RetentionConfig::retention_window_duration].
    pub fn set_retention_window_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_window_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_window_duration][crate::model::RetentionConfig::retention_window_duration].
    pub fn set_or_clear_retention_window_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_window_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RetentionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.RetentionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetentionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retention_window_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetentionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retentionWindowDuration" => {
                                Ok(__FieldTag::__retention_window_duration)
                            }
                            "retention_window_duration" => {
                                Ok(__FieldTag::__retention_window_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetentionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetentionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retention_window_duration => {
                            if !fields.insert(__FieldTag::__retention_window_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_window_duration",
                                ));
                            }
                            result.retention_window_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetentionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.retention_window_duration.is_some() {
            state.serialize_entry("retentionWindowDuration", &self.retention_window_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Properties of the input stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputStreamProperty {
    /// The time that the current input stream is accepted and the connection is
    /// established.
    pub last_establish_time: std::option::Option<wkt::Timestamp>,

    /// Properties of the video streams.
    pub video_streams: std::vec::Vec<crate::model::VideoStreamProperty>,

    /// Properties of the audio streams.
    pub audio_streams: std::vec::Vec<crate::model::AudioStreamProperty>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputStreamProperty {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_establish_time][crate::model::InputStreamProperty::last_establish_time].
    pub fn set_last_establish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_establish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_establish_time][crate::model::InputStreamProperty::last_establish_time].
    pub fn set_or_clear_last_establish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_establish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [video_streams][crate::model::InputStreamProperty::video_streams].
    pub fn set_video_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VideoStreamProperty>,
    {
        use std::iter::Iterator;
        self.video_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [audio_streams][crate::model::InputStreamProperty::audio_streams].
    pub fn set_audio_streams<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AudioStreamProperty>,
    {
        use std::iter::Iterator;
        self.audio_streams = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InputStreamProperty {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.InputStreamProperty"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputStreamProperty {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_establish_time,
            __video_streams,
            __audio_streams,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputStreamProperty")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastEstablishTime" => Ok(__FieldTag::__last_establish_time),
                            "last_establish_time" => Ok(__FieldTag::__last_establish_time),
                            "videoStreams" => Ok(__FieldTag::__video_streams),
                            "video_streams" => Ok(__FieldTag::__video_streams),
                            "audioStreams" => Ok(__FieldTag::__audio_streams),
                            "audio_streams" => Ok(__FieldTag::__audio_streams),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputStreamProperty;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputStreamProperty")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_establish_time => {
                            if !fields.insert(__FieldTag::__last_establish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_establish_time",
                                ));
                            }
                            result.last_establish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__video_streams => {
                            if !fields.insert(__FieldTag::__video_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for video_streams",
                                ));
                            }
                            result.video_streams = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VideoStreamProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audio_streams => {
                            if !fields.insert(__FieldTag::__audio_streams) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_streams",
                                ));
                            }
                            result.audio_streams = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AudioStreamProperty>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InputStreamProperty {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_establish_time.is_some() {
            state.serialize_entry("lastEstablishTime", &self.last_establish_time)?;
        }
        if !self.video_streams.is_empty() {
            state.serialize_entry("videoStreams", &self.video_streams)?;
        }
        if !self.audio_streams.is_empty() {
            state.serialize_entry("audioStreams", &self.audio_streams)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Properties of the video stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VideoStreamProperty {
    /// Index of this video stream.
    pub index: i32,

    /// Properties of the video format.
    pub video_format: std::option::Option<crate::model::VideoFormat>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VideoStreamProperty {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::VideoStreamProperty::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [video_format][crate::model::VideoStreamProperty::video_format].
    pub fn set_video_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VideoFormat>,
    {
        self.video_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [video_format][crate::model::VideoStreamProperty::video_format].
    pub fn set_or_clear_video_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VideoFormat>,
    {
        self.video_format = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VideoStreamProperty {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.VideoStreamProperty"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VideoStreamProperty {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __video_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VideoStreamProperty")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "videoFormat" => Ok(__FieldTag::__video_format),
                            "video_format" => Ok(__FieldTag::__video_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VideoStreamProperty;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VideoStreamProperty")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__video_format => {
                            if !fields.insert(__FieldTag::__video_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for video_format",
                                ));
                            }
                            result.video_format =
                                map.next_value::<std::option::Option<crate::model::VideoFormat>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VideoStreamProperty {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.video_format.is_some() {
            state.serialize_entry("videoFormat", &self.video_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Properties of the video format.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VideoFormat {
    /// Video codec used in this video stream.
    pub codec: std::string::String,

    /// The width of the video stream in pixels.
    pub width_pixels: i32,

    /// The height of the video stream in pixels.
    pub height_pixels: i32,

    /// The frame rate of the input video stream.
    pub frame_rate: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VideoFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [codec][crate::model::VideoFormat::codec].
    pub fn set_codec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codec = v.into();
        self
    }

    /// Sets the value of [width_pixels][crate::model::VideoFormat::width_pixels].
    pub fn set_width_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width_pixels = v.into();
        self
    }

    /// Sets the value of [height_pixels][crate::model::VideoFormat::height_pixels].
    pub fn set_height_pixels<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height_pixels = v.into();
        self
    }

    /// Sets the value of [frame_rate][crate::model::VideoFormat::frame_rate].
    pub fn set_frame_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.frame_rate = v.into();
        self
    }
}

impl wkt::message::Message for VideoFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.VideoFormat"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VideoFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __codec,
            __width_pixels,
            __height_pixels,
            __frame_rate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VideoFormat")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "codec" => Ok(__FieldTag::__codec),
                            "widthPixels" => Ok(__FieldTag::__width_pixels),
                            "width_pixels" => Ok(__FieldTag::__width_pixels),
                            "heightPixels" => Ok(__FieldTag::__height_pixels),
                            "height_pixels" => Ok(__FieldTag::__height_pixels),
                            "frameRate" => Ok(__FieldTag::__frame_rate),
                            "frame_rate" => Ok(__FieldTag::__frame_rate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VideoFormat;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VideoFormat")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__codec => {
                            if !fields.insert(__FieldTag::__codec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codec",
                                ));
                            }
                            result.codec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__width_pixels => {
                            if !fields.insert(__FieldTag::__width_pixels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width_pixels",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width_pixels = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__height_pixels => {
                            if !fields.insert(__FieldTag::__height_pixels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height_pixels",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height_pixels =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__frame_rate => {
                            if !fields.insert(__FieldTag::__frame_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frame_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.frame_rate = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VideoFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.codec.is_empty() {
            state.serialize_entry("codec", &self.codec)?;
        }
        if !wkt::internal::is_default(&self.width_pixels) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("widthPixels", &__With(&self.width_pixels))?;
        }
        if !wkt::internal::is_default(&self.height_pixels) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("heightPixels", &__With(&self.height_pixels))?;
        }
        if !wkt::internal::is_default(&self.frame_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("frameRate", &__With(&self.frame_rate))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Properties of the audio stream.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioStreamProperty {
    /// Index of this audio stream.
    pub index: i32,

    /// Properties of the audio format.
    pub audio_format: std::option::Option<crate::model::AudioFormat>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AudioStreamProperty {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index][crate::model::AudioStreamProperty::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [audio_format][crate::model::AudioStreamProperty::audio_format].
    pub fn set_audio_format<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AudioFormat>,
    {
        self.audio_format = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio_format][crate::model::AudioStreamProperty::audio_format].
    pub fn set_or_clear_audio_format<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AudioFormat>,
    {
        self.audio_format = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AudioStreamProperty {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.AudioStreamProperty"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioStreamProperty {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index,
            __audio_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioStreamProperty")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "index" => Ok(__FieldTag::__index),
                            "audioFormat" => Ok(__FieldTag::__audio_format),
                            "audio_format" => Ok(__FieldTag::__audio_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioStreamProperty;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioStreamProperty")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__audio_format => {
                            if !fields.insert(__FieldTag::__audio_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_format",
                                ));
                            }
                            result.audio_format =
                                map.next_value::<std::option::Option<crate::model::AudioFormat>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AudioStreamProperty {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.audio_format.is_some() {
            state.serialize_entry("audioFormat", &self.audio_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Properties of the audio format.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioFormat {
    /// Audio codec used in this audio stream.
    pub codec: std::string::String,

    /// The number of audio channels.
    pub channel_count: i32,

    /// A list of channel names specifying the layout of the audio channels.
    pub channel_layout: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AudioFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [codec][crate::model::AudioFormat::codec].
    pub fn set_codec<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.codec = v.into();
        self
    }

    /// Sets the value of [channel_count][crate::model::AudioFormat::channel_count].
    pub fn set_channel_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_count = v.into();
        self
    }

    /// Sets the value of [channel_layout][crate::model::AudioFormat::channel_layout].
    pub fn set_channel_layout<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.channel_layout = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AudioFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.AudioFormat"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __codec,
            __channel_count,
            __channel_layout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioFormat")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "codec" => Ok(__FieldTag::__codec),
                            "channelCount" => Ok(__FieldTag::__channel_count),
                            "channel_count" => Ok(__FieldTag::__channel_count),
                            "channelLayout" => Ok(__FieldTag::__channel_layout),
                            "channel_layout" => Ok(__FieldTag::__channel_layout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioFormat;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioFormat")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__codec => {
                            if !fields.insert(__FieldTag::__codec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for codec",
                                ));
                            }
                            result.codec = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel_count => {
                            if !fields.insert(__FieldTag::__channel_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__channel_layout => {
                            if !fields.insert(__FieldTag::__channel_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_layout",
                                ));
                            }
                            result.channel_layout = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AudioFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.codec.is_empty() {
            state.serialize_entry("codec", &self.codec)?;
        }
        if !wkt::internal::is_default(&self.channel_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelCount", &__With(&self.channel_count))?;
        }
        if !self.channel_layout.is_empty() {
            state.serialize_entry("channelLayout", &self.channel_layout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A group of information for attaching an input resource to this channel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputAttachment {
    /// A unique key for this input attachment. The key must be 1-63
    /// characters in length. The key must begin and end with a letter (regardless
    /// of case) or a number, but can contain dashes or underscores in between.
    pub key: std::string::String,

    /// The resource name of an existing input, in the form of:
    /// `projects/{project}/locations/{location}/inputs/{inputId}`.
    pub input: std::string::String,

    /// Automatic failover configurations.
    pub automatic_failover: std::option::Option<crate::model::input_attachment::AutomaticFailover>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputAttachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::InputAttachment::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [input][crate::model::InputAttachment::input].
    pub fn set_input<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [automatic_failover][crate::model::InputAttachment::automatic_failover].
    pub fn set_automatic_failover<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::input_attachment::AutomaticFailover>,
    {
        self.automatic_failover = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automatic_failover][crate::model::InputAttachment::automatic_failover].
    pub fn set_or_clear_automatic_failover<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::input_attachment::AutomaticFailover>,
    {
        self.automatic_failover = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InputAttachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.InputAttachment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputAttachment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __input,
            __automatic_failover,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputAttachment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "input" => Ok(__FieldTag::__input),
                            "automaticFailover" => Ok(__FieldTag::__automatic_failover),
                            "automatic_failover" => Ok(__FieldTag::__automatic_failover),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputAttachment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputAttachment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automatic_failover => {
                            if !fields.insert(__FieldTag::__automatic_failover) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic_failover",
                                ));
                            }
                            result.automatic_failover = map.next_value::<std::option::Option<
                                crate::model::input_attachment::AutomaticFailover,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InputAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.input.is_empty() {
            state.serialize_entry("input", &self.input)?;
        }
        if self.automatic_failover.is_some() {
            state.serialize_entry("automaticFailover", &self.automatic_failover)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InputAttachment].
pub mod input_attachment {
    #[allow(unused_imports)]
    use super::*;

    /// Configurations to follow when automatic failover happens.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutomaticFailover {
        /// The
        /// [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]s
        /// of inputs to failover to when this input is disconnected. Currently, only
        /// up to one backup input is supported.
        ///
        /// [google.cloud.video.livestream.v1.InputAttachment.key]: crate::model::InputAttachment::key
        pub input_keys: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutomaticFailover {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_keys][crate::model::input_attachment::AutomaticFailover::input_keys].
        pub fn set_input_keys<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.input_keys = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AutomaticFailover {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutomaticFailover {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_keys,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutomaticFailover")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputKeys" => Ok(__FieldTag::__input_keys),
                                "input_keys" => Ok(__FieldTag::__input_keys),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutomaticFailover;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutomaticFailover")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_keys => {
                                if !fields.insert(__FieldTag::__input_keys) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_keys",
                                    ));
                                }
                                result.input_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutomaticFailover {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.input_keys.is_empty() {
                state.serialize_entry("inputKeys", &self.input_keys)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Event is a sub-resource of a channel, which can be scheduled by the user to
/// execute operations on a channel resource without having to stop the channel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// The resource name of the event, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// When this field is set to true, the event will be executed at the earliest
    /// time that the server can schedule the event and
    /// [execution_time][google.cloud.video.livestream.v1.Event.execution_time]
    /// will be populated with the time that the server actually schedules the
    /// event.
    ///
    /// [google.cloud.video.livestream.v1.Event.execution_time]: crate::model::Event::execution_time
    pub execute_now: bool,

    /// The time to execute the event. If you set
    /// [execute_now][google.cloud.video.livestream.v1.Event.execute_now] to
    /// `true`, then do not set this field in the `CreateEvent` request. In
    /// this case, the server schedules the event and populates this field. If you
    /// set [execute_now][google.cloud.video.livestream.v1.Event.execute_now] to
    /// `false`, then you must set this field to at least 10 seconds in the future
    /// or else the event can't be created.
    ///
    /// [google.cloud.video.livestream.v1.Event.execute_now]: crate::model::Event::execute_now
    pub execution_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of the event.
    pub state: crate::model::event::State,

    /// Output only. An error object that describes the reason for the failure.
    /// This property is always present when `state` is `FAILED`.
    pub error: std::option::Option<rpc::model::Status>,

    /// Required. Operation to be executed by this event.
    pub task: std::option::Option<crate::model::event::Task>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Event::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Event::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Event::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Event::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Event::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Event::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [execute_now][crate::model::Event::execute_now].
    pub fn set_execute_now<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.execute_now = v.into();
        self
    }

    /// Sets the value of [execution_time][crate::model::Event::execution_time].
    pub fn set_execution_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.execution_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_time][crate::model::Event::execution_time].
    pub fn set_or_clear_execution_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.execution_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Event::state].
    pub fn set_state<T: std::convert::Into<crate::model::event::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::Event::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Event::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [task][crate::model::Event::task].
    ///
    /// Note that all the setters affecting `task` are mutually
    /// exclusive.
    pub fn set_task<T: std::convert::Into<std::option::Option<crate::model::event::Task>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `InputSwitch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn input_switch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::event::InputSwitchTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::InputSwitch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `InputSwitch`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_input_switch<
        T: std::convert::Into<std::boxed::Box<crate::model::event::InputSwitchTask>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::InputSwitch(v.into()));
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `AdBreak`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ad_break(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::event::AdBreakTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::AdBreak(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `AdBreak`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_ad_break<
        T: std::convert::Into<std::boxed::Box<crate::model::event::AdBreakTask>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::AdBreak(v.into()));
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `ReturnToProgram`, `None` if the field is not set or
    /// holds a different branch.
    pub fn return_to_program(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::event::ReturnToProgramTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::ReturnToProgram(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `ReturnToProgram`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_return_to_program<
        T: std::convert::Into<std::boxed::Box<crate::model::event::ReturnToProgramTask>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::ReturnToProgram(v.into()));
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `Slate`, `None` if the field is not set or
    /// holds a different branch.
    pub fn slate(&self) -> std::option::Option<&std::boxed::Box<crate::model::event::SlateTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::Slate(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `Slate`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_slate<T: std::convert::Into<std::boxed::Box<crate::model::event::SlateTask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::Slate(v.into()));
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `Mute`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mute(&self) -> std::option::Option<&std::boxed::Box<crate::model::event::MuteTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::Mute(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `Mute`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_mute<T: std::convert::Into<std::boxed::Box<crate::model::event::MuteTask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::Mute(v.into()));
        self
    }

    /// The value of [task][crate::model::Event::task]
    /// if it holds a `Unmute`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unmute(&self) -> std::option::Option<&std::boxed::Box<crate::model::event::UnmuteTask>> {
        #[allow(unreachable_patterns)]
        self.task.as_ref().and_then(|v| match v {
            crate::model::event::Task::Unmute(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [task][crate::model::Event::task]
    /// to hold a `Unmute`.
    ///
    /// Note that all the setters affecting `task` are
    /// mutually exclusive.
    pub fn set_unmute<T: std::convert::Into<std::boxed::Box<crate::model::event::UnmuteTask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = std::option::Option::Some(crate::model::event::Task::Unmute(v.into()));
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Event"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __input_switch,
            __ad_break,
            __return_to_program,
            __slate,
            __mute,
            __unmute,
            __execute_now,
            __execution_time,
            __state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Event")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "inputSwitch" => Ok(__FieldTag::__input_switch),
                            "input_switch" => Ok(__FieldTag::__input_switch),
                            "adBreak" => Ok(__FieldTag::__ad_break),
                            "ad_break" => Ok(__FieldTag::__ad_break),
                            "returnToProgram" => Ok(__FieldTag::__return_to_program),
                            "return_to_program" => Ok(__FieldTag::__return_to_program),
                            "slate" => Ok(__FieldTag::__slate),
                            "mute" => Ok(__FieldTag::__mute),
                            "unmute" => Ok(__FieldTag::__unmute),
                            "executeNow" => Ok(__FieldTag::__execute_now),
                            "execute_now" => Ok(__FieldTag::__execute_now),
                            "executionTime" => Ok(__FieldTag::__execution_time),
                            "execution_time" => Ok(__FieldTag::__execution_time),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Event;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Event")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_switch => {
                            if !fields.insert(__FieldTag::__input_switch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_switch",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.input_switch, latest field was inputSwitch",
                                ));
                            }
                            result.task =
                                std::option::Option::Some(crate::model::event::Task::InputSwitch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::InputSwitchTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__ad_break => {
                            if !fields.insert(__FieldTag::__ad_break) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ad_break",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.ad_break, latest field was adBreak",
                                ));
                            }
                            result.task =
                                std::option::Option::Some(crate::model::event::Task::AdBreak(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::AdBreakTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__return_to_program => {
                            if !fields.insert(__FieldTag::__return_to_program) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_to_program",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.return_to_program, latest field was returnToProgram",
                                ));
                            }
                            result.task = std::option::Option::Some(
                                crate::model::event::Task::ReturnToProgram(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::ReturnToProgramTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__slate => {
                            if !fields.insert(__FieldTag::__slate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slate",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.slate, latest field was slate",
                                ));
                            }
                            result.task =
                                std::option::Option::Some(crate::model::event::Task::Slate(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::SlateTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__mute => {
                            if !fields.insert(__FieldTag::__mute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.mute, latest field was mute",
                                ));
                            }
                            result.task =
                                std::option::Option::Some(crate::model::event::Task::Mute(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::MuteTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__unmute => {
                            if !fields.insert(__FieldTag::__unmute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unmute",
                                ));
                            }
                            if result.task.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `task`, a oneof with full ID .google.cloud.video.livestream.v1.Event.unmute, latest field was unmute",
                                ));
                            }
                            result.task =
                                std::option::Option::Some(crate::model::event::Task::Unmute(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::event::UnmuteTask>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__execute_now => {
                            if !fields.insert(__FieldTag::__execute_now) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execute_now",
                                ));
                            }
                            result.execute_now = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_time => {
                            if !fields.insert(__FieldTag::__execution_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_time",
                                ));
                            }
                            result.execution_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::event::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if let Some(value) = self.input_switch() {
            state.serialize_entry("inputSwitch", value)?;
        }
        if let Some(value) = self.ad_break() {
            state.serialize_entry("adBreak", value)?;
        }
        if let Some(value) = self.return_to_program() {
            state.serialize_entry("returnToProgram", value)?;
        }
        if let Some(value) = self.slate() {
            state.serialize_entry("slate", value)?;
        }
        if let Some(value) = self.mute() {
            state.serialize_entry("mute", value)?;
        }
        if let Some(value) = self.unmute() {
            state.serialize_entry("unmute", value)?;
        }
        if !wkt::internal::is_default(&self.execute_now) {
            state.serialize_entry("executeNow", &self.execute_now)?;
        }
        if self.execution_time.is_some() {
            state.serialize_entry("executionTime", &self.execution_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// Switches to another input stream. Automatic failover is then disabled.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InputSwitchTask {
        /// The
        /// [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]
        /// of the input to switch to.
        ///
        /// [google.cloud.video.livestream.v1.InputAttachment.key]: crate::model::InputAttachment::key
        pub input_key: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputSwitchTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_key][crate::model::event::InputSwitchTask::input_key].
        pub fn set_input_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.input_key = v.into();
            self
        }
    }

    impl wkt::message::Message for InputSwitchTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.InputSwitchTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InputSwitchTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InputSwitchTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputKey" => Ok(__FieldTag::__input_key),
                                "input_key" => Ok(__FieldTag::__input_key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InputSwitchTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InputSwitchTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_key => {
                                if !fields.insert(__FieldTag::__input_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_key",
                                    ));
                                }
                                result.input_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InputSwitchTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.input_key.is_empty() {
                state.serialize_entry("inputKey", &self.input_key)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Inserts a new ad opportunity.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AdBreakTask {
        /// Duration of an ad opportunity. Must be greater than 0.
        pub duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AdBreakTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [duration][crate::model::event::AdBreakTask::duration].
        pub fn set_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [duration][crate::model::event::AdBreakTask::duration].
        pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AdBreakTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.AdBreakTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AdBreakTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AdBreakTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "duration" => Ok(__FieldTag::__duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AdBreakTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AdBreakTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__duration => {
                                if !fields.insert(__FieldTag::__duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for duration",
                                    ));
                                }
                                result.duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AdBreakTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.duration.is_some() {
                state.serialize_entry("duration", &self.duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Inserts a slate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SlateTask {
        /// Optional. Duration of the slate. Must be greater than 0 if specified.
        /// Omit this field for a long running slate.
        pub duration: std::option::Option<wkt::Duration>,

        /// Slate asset to use for the duration. If its duration is less than the
        /// duration of the SlateTask, then the slate loops. The slate must be
        /// represented in the form of:
        /// `projects/{project}/locations/{location}/assets/{assetId}`.
        pub asset: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SlateTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [duration][crate::model::event::SlateTask::duration].
        pub fn set_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [duration][crate::model::event::SlateTask::duration].
        pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [asset][crate::model::event::SlateTask::asset].
        pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.asset = v.into();
            self
        }
    }

    impl wkt::message::Message for SlateTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.SlateTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SlateTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __duration,
                __asset,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SlateTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "duration" => Ok(__FieldTag::__duration),
                                "asset" => Ok(__FieldTag::__asset),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SlateTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SlateTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__duration => {
                                if !fields.insert(__FieldTag::__duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for duration",
                                    ));
                                }
                                result.duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__asset => {
                                if !fields.insert(__FieldTag::__asset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for asset",
                                    ));
                                }
                                result.asset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SlateTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.duration.is_some() {
                state.serialize_entry("duration", &self.duration)?;
            }
            if !self.asset.is_empty() {
                state.serialize_entry("asset", &self.asset)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Stops any events which are currently running. This only applies to events
    /// with a duration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReturnToProgramTask {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReturnToProgramTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ReturnToProgramTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.ReturnToProgramTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReturnToProgramTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReturnToProgramTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReturnToProgramTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReturnToProgramTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReturnToProgramTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Mutes the stream.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MuteTask {
        /// Duration for which the stream should be muted. If omitted, the stream
        /// will be muted until an UnmuteTask event is sent.
        pub duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MuteTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [duration][crate::model::event::MuteTask::duration].
        pub fn set_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [duration][crate::model::event::MuteTask::duration].
        pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MuteTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.MuteTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MuteTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MuteTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "duration" => Ok(__FieldTag::__duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MuteTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MuteTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__duration => {
                                if !fields.insert(__FieldTag::__duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for duration",
                                    ));
                                }
                                result.duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MuteTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.duration.is_some() {
                state.serialize_entry("duration", &self.duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Unmutes the stream. The task fails if the stream is not currently muted.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UnmuteTask {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UnmuteTask {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for UnmuteTask {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Event.UnmuteTask"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UnmuteTask {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UnmuteTask")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UnmuteTask;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UnmuteTask")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UnmuteTask {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// State of the event
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Event state is not specified.
        Unspecified,
        /// Event is scheduled but not executed yet.
        Scheduled,
        /// Event is being executed.
        Running,
        /// Event has been successfully executed.
        Succeeded,
        /// Event fails to be executed.
        Failed,
        /// Event has been created but not scheduled yet.
        Pending,
        /// Event was stopped before running for its full duration.
        Stopped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scheduled => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Pending => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Scheduled,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Pending,
                6 => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SCHEDULED" => Self::Scheduled,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                "STOPPED" => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scheduled => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Pending => serializer.serialize_i32(5),
                Self::Stopped => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.livestream.v1.Event.State",
            ))
        }
    }

    /// Required. Operation to be executed by this event.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Task {
        /// Switches to another input stream.
        InputSwitch(std::boxed::Box<crate::model::event::InputSwitchTask>),
        /// Inserts a new ad opportunity.
        AdBreak(std::boxed::Box<crate::model::event::AdBreakTask>),
        /// Stops any running ad break.
        ReturnToProgram(std::boxed::Box<crate::model::event::ReturnToProgramTask>),
        /// Inserts a slate.
        Slate(std::boxed::Box<crate::model::event::SlateTask>),
        /// Mutes the stream.
        Mute(std::boxed::Box<crate::model::event::MuteTask>),
        /// Unmutes the stream.
        Unmute(std::boxed::Box<crate::model::event::UnmuteTask>),
    }
}

/// Clip is a sub-resource under channel. Each clip represents a clipping
/// operation that generates a VOD playlist from its channel given a set of
/// timestamp ranges.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Clip {
    /// The resource name of the clip, in the following format:
    /// `projects/{project}/locations/{location}/channels/{channelId}/clips/{clipId}`.
    /// `{clipId}` is a user-specified resource id that conforms to the following
    /// criteria:
    ///
    /// 1. 1 character minimum, 63 characters maximum
    /// 1. Only contains letters, digits, underscores, and hyphens
    pub name: std::string::String,

    /// Output only. The creation timestamp of the clip resource.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the clip request starts to be processed.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update timestamp of the clip resource.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels associated with this resource. Each label is a key-value pair.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The state of the clip.
    pub state: crate::model::clip::State,

    /// Specify the `output_uri` to determine where to place the clip segments and
    /// clip manifest files in Cloud Storage. The manifests specified in
    /// `clip_manifests` fields will be placed under this URI. The exact URI of the
    /// generated manifests will be provided in `clip_manifests.output_uri` for
    /// each manifest.
    /// Example:
    /// "output_uri": "gs://my-bucket/clip-outputs"
    /// "clip_manifests.output_uri": "gs://my-bucket/clip-outputs/main.m3u8"
    pub output_uri: std::string::String,

    /// Output only. An error object that describes the reason for the failure.
    /// This property only presents when `state` is `FAILED`.
    pub error: std::option::Option<rpc::model::Status>,

    /// The specified ranges of segments to generate a clip.
    pub slices: std::vec::Vec<crate::model::clip::Slice>,

    /// Required. A list of clip manifests. Currently only one clip manifest is
    /// allowed.
    pub clip_manifests: std::vec::Vec<crate::model::clip::ClipManifest>,

    /// Optional. OutputType of the clip. If not specified, the default value is
    /// MANIFEST.
    pub output_type: crate::model::clip::OutputType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Clip {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Clip::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Clip::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Clip::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Clip::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Clip::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Clip::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Clip::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Clip::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Clip::state].
    pub fn set_state<T: std::convert::Into<crate::model::clip::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [output_uri][crate::model::Clip::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }

    /// Sets the value of [error][crate::model::Clip::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Clip::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [slices][crate::model::Clip::slices].
    pub fn set_slices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::clip::Slice>,
    {
        use std::iter::Iterator;
        self.slices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [clip_manifests][crate::model::Clip::clip_manifests].
    pub fn set_clip_manifests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::clip::ClipManifest>,
    {
        use std::iter::Iterator;
        self.clip_manifests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_type][crate::model::Clip::output_type].
    pub fn set_output_type<T: std::convert::Into<crate::model::clip::OutputType>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_type = v.into();
        self
    }
}

impl wkt::message::Message for Clip {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Clip"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Clip {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __start_time,
            __update_time,
            __labels,
            __state,
            __output_uri,
            __error,
            __slices,
            __clip_manifests,
            __output_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Clip")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "outputUri" => Ok(__FieldTag::__output_uri),
                            "output_uri" => Ok(__FieldTag::__output_uri),
                            "error" => Ok(__FieldTag::__error),
                            "slices" => Ok(__FieldTag::__slices),
                            "clipManifests" => Ok(__FieldTag::__clip_manifests),
                            "clip_manifests" => Ok(__FieldTag::__clip_manifests),
                            "outputType" => Ok(__FieldTag::__output_type),
                            "output_type" => Ok(__FieldTag::__output_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Clip;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Clip")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::clip::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_uri => {
                            if !fields.insert(__FieldTag::__output_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri",
                                ));
                            }
                            result.output_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__slices => {
                            if !fields.insert(__FieldTag::__slices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for slices",
                                ));
                            }
                            result.slices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::clip::Slice>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__clip_manifests => {
                            if !fields.insert(__FieldTag::__clip_manifests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clip_manifests",
                                ));
                            }
                            result.clip_manifests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::clip::ClipManifest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_type => {
                            if !fields.insert(__FieldTag::__output_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_type",
                                ));
                            }
                            result.output_type = map
                                .next_value::<std::option::Option<crate::model::clip::OutputType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Clip {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.output_uri.is_empty() {
            state.serialize_entry("outputUri", &self.output_uri)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.slices.is_empty() {
            state.serialize_entry("slices", &self.slices)?;
        }
        if !self.clip_manifests.is_empty() {
            state.serialize_entry("clipManifests", &self.clip_manifests)?;
        }
        if !wkt::internal::is_default(&self.output_type) {
            state.serialize_entry("outputType", &self.output_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Clip].
pub mod clip {
    #[allow(unused_imports)]
    use super::*;

    /// TimeSlice represents a tuple of Unix epoch timestamps that specifies a time
    /// range.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeSlice {
        /// The mark-in Unix epoch time in the original live stream manifest.
        pub markin_time: std::option::Option<wkt::Timestamp>,

        /// The mark-out Unix epoch time in the original live stream manifest.
        pub markout_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeSlice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [markin_time][crate::model::clip::TimeSlice::markin_time].
        pub fn set_markin_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.markin_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [markin_time][crate::model::clip::TimeSlice::markin_time].
        pub fn set_or_clear_markin_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.markin_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [markout_time][crate::model::clip::TimeSlice::markout_time].
        pub fn set_markout_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.markout_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [markout_time][crate::model::clip::TimeSlice::markout_time].
        pub fn set_or_clear_markout_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.markout_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeSlice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Clip.TimeSlice"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeSlice {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __markin_time,
                __markout_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeSlice")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "markinTime" => Ok(__FieldTag::__markin_time),
                                "markin_time" => Ok(__FieldTag::__markin_time),
                                "markoutTime" => Ok(__FieldTag::__markout_time),
                                "markout_time" => Ok(__FieldTag::__markout_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeSlice;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeSlice")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__markin_time => {
                                if !fields.insert(__FieldTag::__markin_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for markin_time",
                                    ));
                                }
                                result.markin_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__markout_time => {
                                if !fields.insert(__FieldTag::__markout_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for markout_time",
                                    ));
                                }
                                result.markout_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeSlice {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.markin_time.is_some() {
                state.serialize_entry("markinTime", &self.markin_time)?;
            }
            if self.markout_time.is_some() {
                state.serialize_entry("markoutTime", &self.markout_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Slice represents a slice of the requested clip.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Slice {
        /// The allowlist forms of a slice.
        pub kind: std::option::Option<crate::model::clip::slice::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Slice {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::clip::Slice::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::clip::slice::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::clip::Slice::kind]
        /// if it holds a `TimeSlice`, `None` if the field is not set or
        /// holds a different branch.
        pub fn time_slice(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::clip::TimeSlice>> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::clip::slice::Kind::TimeSlice(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::clip::Slice::kind]
        /// to hold a `TimeSlice`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_time_slice<
            T: std::convert::Into<std::boxed::Box<crate::model::clip::TimeSlice>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind =
                std::option::Option::Some(crate::model::clip::slice::Kind::TimeSlice(v.into()));
            self
        }
    }

    impl wkt::message::Message for Slice {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Clip.Slice"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Slice {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_slice,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Slice")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeSlice" => Ok(__FieldTag::__time_slice),
                                "time_slice" => Ok(__FieldTag::__time_slice),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Slice;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Slice")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_slice => {
                                if !fields.insert(__FieldTag::__time_slice) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_slice",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.video.livestream.v1.Clip.Slice.time_slice, latest field was timeSlice",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::clip::slice::Kind::TimeSlice(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::clip::TimeSlice>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Slice {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.time_slice() {
                state.serialize_entry("timeSlice", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Slice].
    pub mod slice {
        #[allow(unused_imports)]
        use super::*;

        /// The allowlist forms of a slice.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// A slice in form of a tuple of Unix epoch time.
            TimeSlice(std::boxed::Box<crate::model::clip::TimeSlice>),
        }
    }

    /// ClipManifest identifies a source manifest for the generated clip manifest.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClipManifest {
        /// Required. A unique key that identifies a manifest config in the parent
        /// channel. This key is the same as `channel.manifests.key` for the selected
        /// manifest.
        pub manifest_key: std::string::String,

        /// Output only. The output URI of the generated clip manifest. This field
        /// will be populated when the CreateClip request is accepted. Current output
        /// format is provided below but may change in the future. Please read this
        /// field to get the uri to the generated clip manifest. Format:
        /// {clip.output_uri}/{channel.manifest.fileName} Example:
        /// gs://my-bucket/clip-outputs/main.m3u8
        pub output_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClipManifest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [manifest_key][crate::model::clip::ClipManifest::manifest_key].
        pub fn set_manifest_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.manifest_key = v.into();
            self
        }

        /// Sets the value of [output_uri][crate::model::clip::ClipManifest::output_uri].
        pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.output_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for ClipManifest {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Clip.ClipManifest"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClipManifest {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __manifest_key,
                __output_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClipManifest")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "manifestKey" => Ok(__FieldTag::__manifest_key),
                                "manifest_key" => Ok(__FieldTag::__manifest_key),
                                "outputUri" => Ok(__FieldTag::__output_uri),
                                "output_uri" => Ok(__FieldTag::__output_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClipManifest;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClipManifest")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__manifest_key => {
                                if !fields.insert(__FieldTag::__manifest_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for manifest_key",
                                    ));
                                }
                                result.manifest_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__output_uri => {
                                if !fields.insert(__FieldTag::__output_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_uri",
                                    ));
                                }
                                result.output_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClipManifest {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.manifest_key.is_empty() {
                state.serialize_entry("manifestKey", &self.manifest_key)?;
            }
            if !self.output_uri.is_empty() {
                state.serialize_entry("outputUri", &self.output_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// State of clipping operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// The operation is pending to be picked up by the server.
        Pending,
        /// The server admitted this create clip request, and
        /// outputs are under processing.
        Creating,
        /// Outputs are available in the specified Cloud Storage bucket. For
        /// additional information, see the `outputs` field.
        Succeeded,
        /// The operation has failed. For additional information, see the `error`
        /// field.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Creating,
                3 => Self::Succeeded,
                4 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "CREATING" => Self::Creating,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.livestream.v1.Clip.State",
            ))
        }
    }

    /// OutputType represents the output type of the clip.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OutputType {
        /// OutputType is not specified.
        Unspecified,
        /// OutputType is a VOD manifest. This is the default value.
        Manifest,
        /// OutputType is an MP4 file.
        Mp4,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OutputType::value] or
        /// [OutputType::name].
        UnknownValue(output_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod output_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OutputType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Manifest => std::option::Option::Some(1),
                Self::Mp4 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OUTPUT_TYPE_UNSPECIFIED"),
                Self::Manifest => std::option::Option::Some("MANIFEST"),
                Self::Mp4 => std::option::Option::Some("MP4"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OutputType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OutputType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OutputType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Manifest,
                2 => Self::Mp4,
                _ => Self::UnknownValue(output_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OutputType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OUTPUT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MANIFEST" => Self::Manifest,
                "MP4" => Self::Mp4,
                _ => Self::UnknownValue(output_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OutputType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Manifest => serializer.serialize_i32(1),
                Self::Mp4 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OutputType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputType>::new(
                ".google.cloud.video.livestream.v1.Clip.OutputType",
            ))
        }
    }
}

/// TimeInterval represents a time interval.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeInterval {
    /// Optional. The start time of the interval.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The end time of the interval.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeInterval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeInterval::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeInterval::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.TimeInterval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeInterval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeInterval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeInterval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeInterval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// DvrSession is a sub-resource under channel. Each DvrSession represents a DVR
/// recording of the live stream for a specific time range.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DvrSession {
    /// Identifier. The resource name of the DVR session, in the following format:
    /// `projects/{project}/locations/{location}/channels/{channelId}/dvrSessions/{dvrSessionId}`.
    /// `{dvrSessionId}` is a user-specified resource id that conforms to the
    /// following criteria:
    ///
    /// 1. 1 character minimum, 63 characters maximum
    /// 1. Only contains letters, digits, underscores, and hyphens
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The state of the clip.
    pub state: crate::model::dvr_session::State,

    /// Output only. An error object that describes the reason for the failure.
    /// This property only presents when `state` is `FAILED`.
    pub error: std::option::Option<rpc::model::Status>,

    /// Required. A list of DVR manifests. Currently only one DVR manifest is
    /// allowed.
    pub dvr_manifests: std::vec::Vec<crate::model::dvr_session::DvrManifest>,

    /// Required. The specified ranges of segments to generate a DVR recording.
    pub dvr_windows: std::vec::Vec<crate::model::dvr_session::DvrWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DvrSession {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DvrSession::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DvrSession::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DvrSession::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DvrSession::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DvrSession::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::DvrSession::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::DvrSession::state].
    pub fn set_state<T: std::convert::Into<crate::model::dvr_session::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::DvrSession::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DvrSession::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dvr_manifests][crate::model::DvrSession::dvr_manifests].
    pub fn set_dvr_manifests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dvr_session::DvrManifest>,
    {
        use std::iter::Iterator;
        self.dvr_manifests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dvr_windows][crate::model::DvrSession::dvr_windows].
    pub fn set_dvr_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dvr_session::DvrWindow>,
    {
        use std::iter::Iterator;
        self.dvr_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DvrSession {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DvrSession"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DvrSession {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __state,
            __error,
            __dvr_manifests,
            __dvr_windows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DvrSession")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "dvrManifests" => Ok(__FieldTag::__dvr_manifests),
                            "dvr_manifests" => Ok(__FieldTag::__dvr_manifests),
                            "dvrWindows" => Ok(__FieldTag::__dvr_windows),
                            "dvr_windows" => Ok(__FieldTag::__dvr_windows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DvrSession;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DvrSession")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::dvr_session::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__dvr_manifests => {
                            if !fields.insert(__FieldTag::__dvr_manifests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_manifests",
                                ));
                            }
                            result.dvr_manifests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dvr_session::DvrManifest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dvr_windows => {
                            if !fields.insert(__FieldTag::__dvr_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_windows",
                                ));
                            }
                            result.dvr_windows = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dvr_session::DvrWindow>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DvrSession {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.dvr_manifests.is_empty() {
            state.serialize_entry("dvrManifests", &self.dvr_manifests)?;
        }
        if !self.dvr_windows.is_empty() {
            state.serialize_entry("dvrWindows", &self.dvr_windows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DvrSession].
pub mod dvr_session {
    #[allow(unused_imports)]
    use super::*;

    /// DvrManifest identifies a source manifest and specifies a file name for the
    /// generated DVR manifest.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DvrManifest {
        /// Required. A unique key that identifies a manifest config in the parent
        /// channel. This key is the same as `channel.manifests.key` for the selected
        /// manifest.
        pub manifest_key: std::string::String,

        /// Output only. The output URI of the DVR manifest. The DVR output will be
        /// placed in a directory named `dvr/dvrSessionId/` under the parent
        /// channel's output uri. Format:
        /// {channel.output.uri}/dvr/{dvrSessionId}/{channel.manifests.fileName}
        /// Example: gs://my-bucket/outputs/dvr/my-dvr-session/main.m3u8
        pub output_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DvrManifest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [manifest_key][crate::model::dvr_session::DvrManifest::manifest_key].
        pub fn set_manifest_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.manifest_key = v.into();
            self
        }

        /// Sets the value of [output_uri][crate::model::dvr_session::DvrManifest::output_uri].
        pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.output_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for DvrManifest {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.DvrSession.DvrManifest"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DvrManifest {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __manifest_key,
                __output_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DvrManifest")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "manifestKey" => Ok(__FieldTag::__manifest_key),
                                "manifest_key" => Ok(__FieldTag::__manifest_key),
                                "outputUri" => Ok(__FieldTag::__output_uri),
                                "output_uri" => Ok(__FieldTag::__output_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DvrManifest;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DvrManifest")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__manifest_key => {
                                if !fields.insert(__FieldTag::__manifest_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for manifest_key",
                                    ));
                                }
                                result.manifest_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__output_uri => {
                                if !fields.insert(__FieldTag::__output_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_uri",
                                    ));
                                }
                                result.output_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DvrManifest {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.manifest_key.is_empty() {
                state.serialize_entry("manifestKey", &self.manifest_key)?;
            }
            if !self.output_uri.is_empty() {
                state.serialize_entry("outputUri", &self.output_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// DvrWindow represents a DVR window.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DvrWindow {
        /// The allowlist forms of a DVR window.
        pub kind: std::option::Option<crate::model::dvr_session::dvr_window::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DvrWindow {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::dvr_session::DvrWindow::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::dvr_session::dvr_window::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::dvr_session::DvrWindow::kind]
        /// if it holds a `TimeInterval`, `None` if the field is not set or
        /// holds a different branch.
        pub fn time_interval(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::TimeInterval>> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::dvr_session::dvr_window::Kind::TimeInterval(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::dvr_session::DvrWindow::kind]
        /// to hold a `TimeInterval`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_time_interval<
            T: std::convert::Into<std::boxed::Box<crate::model::TimeInterval>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::dvr_session::dvr_window::Kind::TimeInterval(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DvrWindow {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.DvrSession.DvrWindow"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DvrWindow {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time_interval,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DvrWindow")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "timeInterval" => Ok(__FieldTag::__time_interval),
                                "time_interval" => Ok(__FieldTag::__time_interval),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DvrWindow;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DvrWindow")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time_interval => {
                                if !fields.insert(__FieldTag::__time_interval) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_interval",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.video.livestream.v1.DvrSession.DvrWindow.time_interval, latest field was timeInterval",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::dvr_session::dvr_window::Kind::TimeInterval(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::TimeInterval>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DvrWindow {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.time_interval() {
                state.serialize_entry("timeInterval", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DvrWindow].
    pub mod dvr_window {
        #[allow(unused_imports)]
        use super::*;

        /// The allowlist forms of a DVR window.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// A time interval in the form of a tuple of Unix epoch time.
            TimeInterval(std::boxed::Box<crate::model::TimeInterval>),
        }
    }

    /// State of the DVR session.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// The operation is pending to be picked up by the server.
        Pending,
        /// The session is being updated.
        Updating,
        /// The session is scheduled and waiting for the start time.
        Scheduled,
        /// The session is currently in progress and the outputs are available in the
        /// specified Cloud Storage bucket. For additional information, see the
        /// `dvr_manifests.output_uri` field.
        Live,
        /// Outputs are available in the specified Cloud Storage bucket. For
        /// additional information, see the `dvr_manifests.output_uri` field.
        Finished,
        /// The operation has failed. For additional information, see the `error`
        /// field.
        Failed,
        /// The session is being deleted.
        Deleting,
        /// The session is being post processed.
        PostProcessing,
        /// The session is in cooldown. The cooldown period lasts for 60 seconds.
        /// When the DVR session is updated by the user to have a new end time that
        /// is likely already in the past, the DVR manifest will end as soon as
        /// possible and the DVR session will move to this state. This is done to
        /// prevent the players to receive a manifest update that removes a segment
        /// that has already been played. After the cooldown period ends, a new
        /// manifest is generated that honors the new end time.
        Cooldown,
        /// The session is being stopped. The session will move to STOPPING state, if
        /// the parent channel is updated.
        Stopping,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Scheduled => std::option::Option::Some(3),
                Self::Live => std::option::Option::Some(4),
                Self::Finished => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Deleting => std::option::Option::Some(7),
                Self::PostProcessing => std::option::Option::Some(8),
                Self::Cooldown => std::option::Option::Some(9),
                Self::Stopping => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::Live => std::option::Option::Some("LIVE"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::PostProcessing => std::option::Option::Some("POST_PROCESSING"),
                Self::Cooldown => std::option::Option::Some("COOLDOWN"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Updating,
                3 => Self::Scheduled,
                4 => Self::Live,
                5 => Self::Finished,
                6 => Self::Failed,
                7 => Self::Deleting,
                8 => Self::PostProcessing,
                9 => Self::Cooldown,
                10 => Self::Stopping,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "UPDATING" => Self::Updating,
                "SCHEDULED" => Self::Scheduled,
                "LIVE" => Self::Live,
                "FINISHED" => Self::Finished,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "POST_PROCESSING" => Self::PostProcessing,
                "COOLDOWN" => Self::Cooldown,
                "STOPPING" => Self::Stopping,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Scheduled => serializer.serialize_i32(3),
                Self::Live => serializer.serialize_i32(4),
                Self::Finished => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Deleting => serializer.serialize_i32(7),
                Self::PostProcessing => serializer.serialize_i32(8),
                Self::Cooldown => serializer.serialize_i32(9),
                Self::Stopping => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.livestream.v1.DvrSession.State",
            ))
        }
    }
}

/// An asset represents a video or an image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Asset {
    /// The resource name of the asset, in the form of:
    /// `projects/{project}/locations/{location}/assets/{assetId}`.
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Based64-encoded CRC32c checksum of the asset file. For more information,
    /// see the crc32c checksum of the [Cloud Storage Objects
    /// resource](https://cloud.google.com/storage/docs/json_api/v1/objects).
    /// If crc32c is omitted or left empty when the asset is created, this field is
    /// filled by the crc32c checksum of the Cloud Storage object indicated by
    /// [VideoAsset.uri][google.cloud.video.livestream.v1.Asset.VideoAsset.uri] or
    /// [ImageAsset.uri][google.cloud.video.livestream.v1.Asset.ImageAsset.uri]. If
    /// crc32c is set, the asset can't be created if the crc32c value does not
    /// match with the crc32c checksum of the Cloud Storage object indicated by
    /// [VideoAsset.uri][google.cloud.video.livestream.v1.Asset.VideoAsset.uri] or
    /// [ImageAsset.uri][google.cloud.video.livestream.v1.Asset.ImageAsset.uri].
    ///
    /// [google.cloud.video.livestream.v1.Asset.ImageAsset.uri]: crate::model::asset::ImageAsset::uri
    /// [google.cloud.video.livestream.v1.Asset.VideoAsset.uri]: crate::model::asset::VideoAsset::uri
    pub crc32c: std::string::String,

    /// Output only. The state of the asset resource.
    pub state: crate::model::asset::State,

    /// Output only. Only present when `state` is `ERROR`. The reason for the error
    /// state of the asset.
    pub error: std::option::Option<rpc::model::Status>,

    /// The reference to the asset.
    /// The maximum size of the resource is 250 MB.
    pub resource: std::option::Option<crate::model::asset::Resource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Asset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Asset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Asset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Asset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [crc32c][crate::model::Asset::crc32c].
    pub fn set_crc32c<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crc32c = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Asset::state].
    pub fn set_state<T: std::convert::Into<crate::model::asset::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::Asset::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Asset::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::Asset::resource].
    ///
    /// Note that all the setters affecting `resource` are mutually
    /// exclusive.
    pub fn set_resource<
        T: std::convert::Into<std::option::Option<crate::model::asset::Resource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource = v.into();
        self
    }

    /// The value of [resource][crate::model::Asset::resource]
    /// if it holds a `Video`, `None` if the field is not set or
    /// holds a different branch.
    pub fn video(&self) -> std::option::Option<&std::boxed::Box<crate::model::asset::VideoAsset>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::asset::Resource::Video(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::Asset::resource]
    /// to hold a `Video`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_video<T: std::convert::Into<std::boxed::Box<crate::model::asset::VideoAsset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(crate::model::asset::Resource::Video(v.into()));
        self
    }

    /// The value of [resource][crate::model::Asset::resource]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&std::boxed::Box<crate::model::asset::ImageAsset>> {
        #[allow(unreachable_patterns)]
        self.resource.as_ref().and_then(|v| match v {
            crate::model::asset::Resource::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource][crate::model::Asset::resource]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `resource` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<std::boxed::Box<crate::model::asset::ImageAsset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource = std::option::Option::Some(crate::model::asset::Resource::Image(v.into()));
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Asset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Asset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __video,
            __image,
            __crc32c,
            __state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Asset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "video" => Ok(__FieldTag::__video),
                            "image" => Ok(__FieldTag::__image),
                            "crc32c" => Ok(__FieldTag::__crc32c),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Asset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Asset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__video => {
                            if !fields.insert(__FieldTag::__video) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for video",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.video.livestream.v1.Asset.video, latest field was video",
                                ));
                            }
                            result.resource =
                                std::option::Option::Some(crate::model::asset::Resource::Video(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::asset::VideoAsset>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource`, a oneof with full ID .google.cloud.video.livestream.v1.Asset.image, latest field was image",
                                ));
                            }
                            result.resource =
                                std::option::Option::Some(crate::model::asset::Resource::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::asset::ImageAsset>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__crc32c => {
                            if !fields.insert(__FieldTag::__crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crc32c",
                                ));
                            }
                            result.crc32c = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::asset::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Asset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if let Some(value) = self.video() {
            state.serialize_entry("video", value)?;
        }
        if let Some(value) = self.image() {
            state.serialize_entry("image", value)?;
        }
        if !self.crc32c.is_empty() {
            state.serialize_entry("crc32c", &self.crc32c)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Asset].
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// VideoAsset represents a video. The supported formats are MP4, MPEG-TS, and
    /// FLV. The supported video codec is H264. The supported audio codecs are
    /// AAC, AC3, MP2, and MP3.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VideoAsset {
        /// Cloud Storage URI of the video. The format is `gs://my-bucket/my-object`.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VideoAsset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::asset::VideoAsset::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for VideoAsset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Asset.VideoAsset"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VideoAsset {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VideoAsset")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VideoAsset;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VideoAsset")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VideoAsset {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Image represents an image. The supported formats are JPEG, PNG.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImageAsset {
        /// Cloud Storage URI of the image. The format is `gs://my-bucket/my-object`.
        pub uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageAsset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::asset::ImageAsset::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }
    }

    impl wkt::message::Message for ImageAsset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Asset.ImageAsset"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImageAsset {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImageAsset")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImageAsset;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImageAsset")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImageAsset {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// State of the asset resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// The asset is being created.
        Creating,
        /// The asset is ready for use.
        Active,
        /// The asset is being deleted.
        Deleting,
        /// The asset has an error.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.video.livestream.v1.Asset.State",
            ))
        }
    }

    /// The reference to the asset.
    /// The maximum size of the resource is 250 MB.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Resource {
        /// VideoAsset represents a video.
        Video(std::boxed::Box<crate::model::asset::VideoAsset>),
        /// ImageAsset represents an image.
        Image(std::boxed::Box<crate::model::asset::ImageAsset>),
    }
}

/// Encryption settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Encryption {
    /// Required. Identifier for this set of encryption options. The ID must be
    /// 1-63 characters in length. The ID must begin and end with a letter
    /// (regardless of case) or a number, but can contain dashes or underscores in
    /// between.
    pub id: std::string::String,

    /// Required. Configuration for DRM systems.
    pub drm_systems: std::option::Option<crate::model::encryption::DrmSystems>,

    /// Defines where content keys are stored.
    pub secret_source: std::option::Option<crate::model::encryption::SecretSource>,

    /// Encryption modes for HLS and MPEG-Dash.
    pub encryption_mode: std::option::Option<crate::model::encryption::EncryptionMode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Encryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Encryption::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [drm_systems][crate::model::Encryption::drm_systems].
    pub fn set_drm_systems<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::encryption::DrmSystems>,
    {
        self.drm_systems = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [drm_systems][crate::model::Encryption::drm_systems].
    pub fn set_or_clear_drm_systems<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::encryption::DrmSystems>,
    {
        self.drm_systems = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_source][crate::model::Encryption::secret_source].
    ///
    /// Note that all the setters affecting `secret_source` are mutually
    /// exclusive.
    pub fn set_secret_source<
        T: std::convert::Into<std::option::Option<crate::model::encryption::SecretSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secret_source = v.into();
        self
    }

    /// The value of [secret_source][crate::model::Encryption::secret_source]
    /// if it holds a `SecretManagerKeySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret_manager_key_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::encryption::SecretManagerSource>> {
        #[allow(unreachable_patterns)]
        self.secret_source.as_ref().and_then(|v| match v {
            crate::model::encryption::SecretSource::SecretManagerKeySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [secret_source][crate::model::Encryption::secret_source]
    /// to hold a `SecretManagerKeySource`.
    ///
    /// Note that all the setters affecting `secret_source` are
    /// mutually exclusive.
    pub fn set_secret_manager_key_source<
        T: std::convert::Into<std::boxed::Box<crate::model::encryption::SecretManagerSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secret_source = std::option::Option::Some(
            crate::model::encryption::SecretSource::SecretManagerKeySource(v.into()),
        );
        self
    }

    /// Sets the value of [encryption_mode][crate::model::Encryption::encryption_mode].
    ///
    /// Note that all the setters affecting `encryption_mode` are mutually
    /// exclusive.
    pub fn set_encryption_mode<
        T: std::convert::Into<std::option::Option<crate::model::encryption::EncryptionMode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_mode = v.into();
        self
    }

    /// The value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// if it holds a `Aes128`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aes128(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::encryption::Aes128Encryption>> {
        #[allow(unreachable_patterns)]
        self.encryption_mode.as_ref().and_then(|v| match v {
            crate::model::encryption::EncryptionMode::Aes128(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// to hold a `Aes128`.
    ///
    /// Note that all the setters affecting `encryption_mode` are
    /// mutually exclusive.
    pub fn set_aes128<
        T: std::convert::Into<std::boxed::Box<crate::model::encryption::Aes128Encryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_mode =
            std::option::Option::Some(crate::model::encryption::EncryptionMode::Aes128(v.into()));
        self
    }

    /// The value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// if it holds a `SampleAes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sample_aes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::encryption::SampleAesEncryption>> {
        #[allow(unreachable_patterns)]
        self.encryption_mode.as_ref().and_then(|v| match v {
            crate::model::encryption::EncryptionMode::SampleAes(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// to hold a `SampleAes`.
    ///
    /// Note that all the setters affecting `encryption_mode` are
    /// mutually exclusive.
    pub fn set_sample_aes<
        T: std::convert::Into<std::boxed::Box<crate::model::encryption::SampleAesEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_mode = std::option::Option::Some(
            crate::model::encryption::EncryptionMode::SampleAes(v.into()),
        );
        self
    }

    /// The value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// if it holds a `MpegCenc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mpeg_cenc(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::encryption::MpegCommonEncryption>> {
        #[allow(unreachable_patterns)]
        self.encryption_mode.as_ref().and_then(|v| match v {
            crate::model::encryption::EncryptionMode::MpegCenc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [encryption_mode][crate::model::Encryption::encryption_mode]
    /// to hold a `MpegCenc`.
    ///
    /// Note that all the setters affecting `encryption_mode` are
    /// mutually exclusive.
    pub fn set_mpeg_cenc<
        T: std::convert::Into<std::boxed::Box<crate::model::encryption::MpegCommonEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_mode =
            std::option::Option::Some(crate::model::encryption::EncryptionMode::MpegCenc(v.into()));
        self
    }
}

impl wkt::message::Message for Encryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Encryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Encryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __secret_manager_key_source,
            __drm_systems,
            __aes128,
            __sample_aes,
            __mpeg_cenc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Encryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "secretManagerKeySource" => Ok(__FieldTag::__secret_manager_key_source),
                            "secret_manager_key_source" => {
                                Ok(__FieldTag::__secret_manager_key_source)
                            }
                            "drmSystems" => Ok(__FieldTag::__drm_systems),
                            "drm_systems" => Ok(__FieldTag::__drm_systems),
                            "aes128" => Ok(__FieldTag::__aes128),
                            "sampleAes" => Ok(__FieldTag::__sample_aes),
                            "sample_aes" => Ok(__FieldTag::__sample_aes),
                            "mpegCenc" => Ok(__FieldTag::__mpeg_cenc),
                            "mpeg_cenc" => Ok(__FieldTag::__mpeg_cenc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Encryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Encryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_manager_key_source => {
                            if !fields.insert(__FieldTag::__secret_manager_key_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_key_source",
                                ));
                            }
                            if result.secret_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `secret_source`, a oneof with full ID .google.cloud.video.livestream.v1.Encryption.secret_manager_key_source, latest field was secretManagerKeySource",
                                ));
                            }
                            result.secret_source = std::option::Option::Some(
                                crate::model::encryption::SecretSource::SecretManagerKeySource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::encryption::SecretManagerSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__drm_systems => {
                            if !fields.insert(__FieldTag::__drm_systems) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for drm_systems",
                                ));
                            }
                            result.drm_systems = map.next_value::<std::option::Option<crate::model::encryption::DrmSystems>>()?
                                ;
                        }
                        __FieldTag::__aes128 => {
                            if !fields.insert(__FieldTag::__aes128) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aes128",
                                ));
                            }
                            if result.encryption_mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `encryption_mode`, a oneof with full ID .google.cloud.video.livestream.v1.Encryption.aes128, latest field was aes128",
                                ));
                            }
                            result.encryption_mode = std::option::Option::Some(
                                crate::model::encryption::EncryptionMode::Aes128(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::encryption::Aes128Encryption>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sample_aes => {
                            if !fields.insert(__FieldTag::__sample_aes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_aes",
                                ));
                            }
                            if result.encryption_mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `encryption_mode`, a oneof with full ID .google.cloud.video.livestream.v1.Encryption.sample_aes, latest field was sampleAes",
                                ));
                            }
                            result.encryption_mode = std::option::Option::Some(
                                crate::model::encryption::EncryptionMode::SampleAes(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::encryption::SampleAesEncryption,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mpeg_cenc => {
                            if !fields.insert(__FieldTag::__mpeg_cenc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mpeg_cenc",
                                ));
                            }
                            if result.encryption_mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `encryption_mode`, a oneof with full ID .google.cloud.video.livestream.v1.Encryption.mpeg_cenc, latest field was mpegCenc",
                                ));
                            }
                            result.encryption_mode = std::option::Option::Some(
                                crate::model::encryption::EncryptionMode::MpegCenc(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::encryption::MpegCommonEncryption,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Encryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if let Some(value) = self.secret_manager_key_source() {
            state.serialize_entry("secretManagerKeySource", value)?;
        }
        if self.drm_systems.is_some() {
            state.serialize_entry("drmSystems", &self.drm_systems)?;
        }
        if let Some(value) = self.aes128() {
            state.serialize_entry("aes128", value)?;
        }
        if let Some(value) = self.sample_aes() {
            state.serialize_entry("sampleAes", value)?;
        }
        if let Some(value) = self.mpeg_cenc() {
            state.serialize_entry("mpegCenc", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Encryption].
pub mod encryption {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for secrets stored in Google Secret Manager.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SecretManagerSource {
        /// Required. The name of the Secret Version containing the encryption key.
        /// `projects/{project}/secrets/{secret_id}/versions/{version_number}`
        pub secret_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecretManagerSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [secret_version][crate::model::encryption::SecretManagerSource::secret_version].
        pub fn set_secret_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_version = v.into();
            self
        }
    }

    impl wkt::message::Message for SecretManagerSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.SecretManagerSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SecretManagerSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __secret_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SecretManagerSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "secretVersion" => Ok(__FieldTag::__secret_version),
                                "secret_version" => Ok(__FieldTag::__secret_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SecretManagerSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SecretManagerSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__secret_version => {
                                if !fields.insert(__FieldTag::__secret_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_version",
                                    ));
                                }
                                result.secret_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SecretManagerSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.secret_version.is_empty() {
                state.serialize_entry("secretVersion", &self.secret_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Widevine configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Widevine {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Widevine {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Widevine {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.Widevine"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Widevine {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Widevine")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Widevine;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Widevine")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Widevine {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Fairplay configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Fairplay {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Fairplay {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Fairplay {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.Fairplay"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Fairplay {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Fairplay")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Fairplay;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Fairplay")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Fairplay {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Playready configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Playready {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Playready {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Playready {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.Playready"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Playready {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Playready")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Playready;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Playready")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Playready {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Clearkey configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Clearkey {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Clearkey {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Clearkey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.Clearkey"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Clearkey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Clearkey")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Clearkey;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Clearkey")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Clearkey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines configuration for DRM systems in use. If a field is omitted,
    /// that DRM system will be considered to be disabled.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DrmSystems {
        /// Widevine configuration.
        pub widevine: std::option::Option<crate::model::encryption::Widevine>,

        /// Fairplay configuration.
        pub fairplay: std::option::Option<crate::model::encryption::Fairplay>,

        /// Playready configuration.
        pub playready: std::option::Option<crate::model::encryption::Playready>,

        /// Clearkey configuration.
        pub clearkey: std::option::Option<crate::model::encryption::Clearkey>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DrmSystems {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [widevine][crate::model::encryption::DrmSystems::widevine].
        pub fn set_widevine<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Widevine>,
        {
            self.widevine = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [widevine][crate::model::encryption::DrmSystems::widevine].
        pub fn set_or_clear_widevine<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Widevine>,
        {
            self.widevine = v.map(|x| x.into());
            self
        }

        /// Sets the value of [fairplay][crate::model::encryption::DrmSystems::fairplay].
        pub fn set_fairplay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Fairplay>,
        {
            self.fairplay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fairplay][crate::model::encryption::DrmSystems::fairplay].
        pub fn set_or_clear_fairplay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Fairplay>,
        {
            self.fairplay = v.map(|x| x.into());
            self
        }

        /// Sets the value of [playready][crate::model::encryption::DrmSystems::playready].
        pub fn set_playready<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Playready>,
        {
            self.playready = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [playready][crate::model::encryption::DrmSystems::playready].
        pub fn set_or_clear_playready<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Playready>,
        {
            self.playready = v.map(|x| x.into());
            self
        }

        /// Sets the value of [clearkey][crate::model::encryption::DrmSystems::clearkey].
        pub fn set_clearkey<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Clearkey>,
        {
            self.clearkey = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [clearkey][crate::model::encryption::DrmSystems::clearkey].
        pub fn set_or_clear_clearkey<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::encryption::Clearkey>,
        {
            self.clearkey = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DrmSystems {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.DrmSystems"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DrmSystems {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __widevine,
                __fairplay,
                __playready,
                __clearkey,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DrmSystems")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "widevine" => Ok(__FieldTag::__widevine),
                                "fairplay" => Ok(__FieldTag::__fairplay),
                                "playready" => Ok(__FieldTag::__playready),
                                "clearkey" => Ok(__FieldTag::__clearkey),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DrmSystems;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DrmSystems")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__widevine => {
                                if !fields.insert(__FieldTag::__widevine) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for widevine",
                                    ));
                                }
                                result.widevine = map.next_value::<std::option::Option<crate::model::encryption::Widevine>>()?
                                    ;
                            }
                            __FieldTag::__fairplay => {
                                if !fields.insert(__FieldTag::__fairplay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fairplay",
                                    ));
                                }
                                result.fairplay = map.next_value::<std::option::Option<crate::model::encryption::Fairplay>>()?
                                    ;
                            }
                            __FieldTag::__playready => {
                                if !fields.insert(__FieldTag::__playready) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for playready",
                                    ));
                                }
                                result.playready = map.next_value::<std::option::Option<crate::model::encryption::Playready>>()?
                                    ;
                            }
                            __FieldTag::__clearkey => {
                                if !fields.insert(__FieldTag::__clearkey) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clearkey",
                                    ));
                                }
                                result.clearkey = map.next_value::<std::option::Option<crate::model::encryption::Clearkey>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DrmSystems {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.widevine.is_some() {
                state.serialize_entry("widevine", &self.widevine)?;
            }
            if self.fairplay.is_some() {
                state.serialize_entry("fairplay", &self.fairplay)?;
            }
            if self.playready.is_some() {
                state.serialize_entry("playready", &self.playready)?;
            }
            if self.clearkey.is_some() {
                state.serialize_entry("clearkey", &self.clearkey)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for HLS AES-128 encryption.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Aes128Encryption {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Aes128Encryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Aes128Encryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.Aes128Encryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Aes128Encryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Aes128Encryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Aes128Encryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Aes128Encryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Aes128Encryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for HLS SAMPLE-AES encryption.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SampleAesEncryption {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SampleAesEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SampleAesEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.SampleAesEncryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SampleAesEncryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SampleAesEncryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SampleAesEncryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SampleAesEncryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SampleAesEncryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for MPEG-Dash Common Encryption (MPEG-CENC).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MpegCommonEncryption {
        /// Required. Specify the encryption scheme, supported schemes:
        ///
        /// - `cenc` - AES-CTR subsample
        /// - `cbcs`- AES-CBC subsample pattern
        pub scheme: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MpegCommonEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scheme][crate::model::encryption::MpegCommonEncryption::scheme].
        pub fn set_scheme<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.scheme = v.into();
            self
        }
    }

    impl wkt::message::Message for MpegCommonEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Encryption.MpegCommonEncryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MpegCommonEncryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __scheme,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MpegCommonEncryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "scheme" => Ok(__FieldTag::__scheme),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MpegCommonEncryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MpegCommonEncryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__scheme => {
                                if !fields.insert(__FieldTag::__scheme) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scheme",
                                    ));
                                }
                                result.scheme = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MpegCommonEncryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.scheme.is_empty() {
                state.serialize_entry("scheme", &self.scheme)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines where content keys are stored.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SecretSource {
        /// For keys stored in Google Secret Manager.
        SecretManagerKeySource(std::boxed::Box<crate::model::encryption::SecretManagerSource>),
    }

    /// Encryption modes for HLS and MPEG-Dash.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EncryptionMode {
        /// Configuration for HLS AES-128 encryption.
        Aes128(std::boxed::Box<crate::model::encryption::Aes128Encryption>),
        /// Configuration for HLS SAMPLE-AES encryption.
        SampleAes(std::boxed::Box<crate::model::encryption::SampleAesEncryption>),
        /// Configuration for MPEG-Dash Common Encryption (MPEG-CENC).
        MpegCenc(std::boxed::Box<crate::model::encryption::MpegCommonEncryption>),
    }
}

/// Pool resource defines the configuration of Live Stream pools for a specific
/// location. Currently we support only one pool resource per project per
/// location. After the creation of the first input, a default pool is created
/// automatically at "projects/{project}/locations/{location}/pools/default".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Pool {
    /// The resource name of the pool, in the form of:
    /// `projects/{project}/locations/{location}/pools/{poolId}`.
    pub name: std::string::String,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-defined key/value metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Network configuration for the pool.
    pub network_config: std::option::Option<crate::model::pool::NetworkConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Pool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Pool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Pool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Pool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Pool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Pool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Pool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [network_config][crate::model::Pool::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::pool::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Pool::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::pool::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Pool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.Pool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Pool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __network_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Pool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Pool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Pool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map.next_value::<std::option::Option<crate::model::pool::NetworkConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Pool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Pool].
pub mod pool {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the network configuration for the pool.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// peered_network is the network resource URL of the network that is peered
        /// to the service provider network. Must be of the format
        /// projects/NETWORK_PROJECT_NUMBER/global/networks/NETWORK_NAME, where
        /// NETWORK_PROJECT_NUMBER is the project number of the Cloud project that
        /// holds your VPC network and NETWORK_NAME is the name of your VPC network.
        /// If peered_network is omitted or empty, the pool will use endpoints that
        /// are publicly available.
        pub peered_network: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [peered_network][crate::model::pool::NetworkConfig::peered_network].
        pub fn set_peered_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.peered_network = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.video.livestream.v1.Pool.NetworkConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __peered_network,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "peeredNetwork" => Ok(__FieldTag::__peered_network),
                                "peered_network" => Ok(__FieldTag::__peered_network),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__peered_network => {
                                if !fields.insert(__FieldTag::__peered_network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for peered_network",
                                    ));
                                }
                                result.peered_network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.peered_network.is_empty() {
                state.serialize_entry("peeredNetwork", &self.peered_network)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request message for "LivestreamService.CreateAsset".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAssetRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The asset resource to be created.
    pub asset: std::option::Option<crate::model::Asset>,

    /// Required. The ID of the asset resource to be created.
    /// This value must be 1-63 characters, begin and end with `[a-z0-9]`,
    /// could contain dashes (-) in between.
    pub asset_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::CreateAssetRequest::asset].
    pub fn set_asset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [asset][crate::model::CreateAssetRequest::asset].
    pub fn set_or_clear_asset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Asset>,
    {
        self.asset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asset_id][crate::model::CreateAssetRequest::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __asset,
            __asset_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "asset" => Ok(__FieldTag::__asset),
                            "assetId" => Ok(__FieldTag::__asset_id),
                            "asset_id" => Ok(__FieldTag::__asset_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__asset => {
                            if !fields.insert(__FieldTag::__asset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset",
                                ));
                            }
                            result.asset =
                                map.next_value::<std::option::Option<crate::model::Asset>>()?;
                        }
                        __FieldTag::__asset_id => {
                            if !fields.insert(__FieldTag::__asset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for asset_id",
                                ));
                            }
                            result.asset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.asset.is_some() {
            state.serialize_entry("asset", &self.asset)?;
        }
        if !self.asset_id.is_empty() {
            state.serialize_entry("assetId", &self.asset_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteAsset".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAssetRequest {
    /// Required. The name of the asset resource, in the form of:
    /// `projects/{project}/locations/{location}/assets/{assetId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAssetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListAssets".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAssetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListAssetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListAssets".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// The list of Assets
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// The next_page_token value returned from a previous List request, if any.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAssetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAssetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __assets,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAssetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "assets" => Ok(__FieldTag::__assets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAssetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAssetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__assets => {
                            if !fields.insert(__FieldTag::__assets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assets",
                                ));
                            }
                            result.assets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Asset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAssetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.assets.is_empty() {
            state.serialize_entry("assets", &self.assets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetAsset".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAssetRequest {
    /// Required. Name of the resource, in the following form:
    /// `projects/{project}/locations/{location}/assets/{asset}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetAssetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAssetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAssetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAssetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAssetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAssetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.CreateChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateChannelRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The channel resource to be created.
    pub channel: std::option::Option<crate::model::Channel>,

    /// Required. The ID of the channel resource to be created.
    /// This value must be 1-63 characters, begin and end with `[a-z0-9]`,
    /// could contain dashes (-) in between.
    pub channel_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateChannelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::CreateChannelRequest::channel].
    pub fn set_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [channel][crate::model::CreateChannelRequest::channel].
    pub fn set_or_clear_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [channel_id][crate::model::CreateChannelRequest::channel_id].
    pub fn set_channel_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateChannelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __channel,
            __channel_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "channel" => Ok(__FieldTag::__channel),
                            "channelId" => Ok(__FieldTag::__channel_id),
                            "channel_id" => Ok(__FieldTag::__channel_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel =
                                map.next_value::<std::option::Option<crate::model::Channel>>()?;
                        }
                        __FieldTag::__channel_id => {
                            if !fields.insert(__FieldTag::__channel_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_id",
                                ));
                            }
                            result.channel_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.channel.is_some() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self.channel_id.is_empty() {
            state.serialize_entry("channelId", &self.channel_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListChannels".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelsRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of items to return. If unspecified, server
    /// will pick an appropriate default. Server may return fewer items than
    /// requested. A caller should only rely on response's
    /// [next_page_token][google.cloud.video.livestream.v1.ListChannelsResponse.next_page_token]
    /// to determine if there are more items left to be queried.
    ///
    /// [google.cloud.video.livestream.v1.ListChannelsResponse.next_page_token]: crate::model::ListChannelsResponse::next_page_token
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    /// The filter to apply to list results.
    pub filter: std::string::String,

    /// Specifies the ordering of results following syntax at
    /// <https://cloud.google.com/apis/design/design_patterns#sorting_order>.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChannelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListChannelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListChannelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListChannels".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChannelsResponse {
    /// A list of channels.
    pub channels: std::vec::Vec<crate::model::Channel>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::ListChannelsResponse::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Channel>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListChannelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChannelsResponse {
    type PageItem = crate::model::Channel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChannelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channels,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChannelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channels" => Ok(__FieldTag::__channels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChannelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChannelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channels => {
                            if !fields.insert(__FieldTag::__channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channels",
                                ));
                            }
                            result.channels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Channel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListChannelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.channels.is_empty() {
            state.serialize_entry("channels", &self.channels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetChannelRequest {
    /// Required. The name of the channel resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteChannelRequest {
    /// Required. The name of the channel resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    /// If the `force` field is set to the default value of `false`, you must
    /// delete all of a channel's events before you can delete the channel itself.
    /// If the field is set to `true`, requests to delete a channel also delete
    /// associated channel events.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteChannelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteChannelRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.UpdateChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateChannelRequest {
    /// Field mask is used to specify the fields to be overwritten in the Channel
    /// resource by the update. You can only update the following fields:
    ///
    /// * [`inputAttachments`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#inputattachment)
    /// * [`inputConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#inputconfig)
    /// * [`output`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#output)
    /// * [`elementaryStreams`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#elementarystream)
    /// * [`muxStreams`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#muxstream)
    /// * [`manifests`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#manifest)
    /// * [`spriteSheets`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#spritesheet)
    /// * [`logConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#logconfig)
    /// * [`timecodeConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#timecodeconfig)
    /// * [`encryptions`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#encryption)
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the mask is not present, then each field from the list above is updated
    /// if the field appears in the request payload. To unset a field, add the
    /// field to the update mask and remove it from the request payload.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The channel resource to be updated.
    pub channel: std::option::Option<crate::model::Channel>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateChannelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateChannelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [channel][crate::model::UpdateChannelRequest::channel].
    pub fn set_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [channel][crate::model::UpdateChannelRequest::channel].
    pub fn set_or_clear_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Channel>,
    {
        self.channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateChannelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.UpdateChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __channel,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "channel" => Ok(__FieldTag::__channel),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel =
                                map.next_value::<std::option::Option<crate::model::Channel>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.channel.is_some() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.StartChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartChannelRequest {
    /// Required. The name of the channel resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StartChannelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StartChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.StartChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.StopChannel".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopChannelRequest {
    /// Required. The name of the channel resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StopChannelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StopChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.StopChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.CreateInput".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInputRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. The input resource to be created.
    pub input: std::option::Option<crate::model::Input>,

    /// Required. The ID of the input resource to be created.
    /// This value must be 1-63 characters, begin and end with `[a-z0-9]`,
    /// could contain dashes (-) in between.
    pub input_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInputRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInputRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input][crate::model::CreateInputRequest::input].
    pub fn set_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Input>,
    {
        self.input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input][crate::model::CreateInputRequest::input].
    pub fn set_or_clear_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Input>,
    {
        self.input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_id][crate::model::CreateInputRequest::input_id].
    pub fn set_input_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInputRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInputRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateInputRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInputRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input,
            __input_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInputRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "input" => Ok(__FieldTag::__input),
                            "inputId" => Ok(__FieldTag::__input_id),
                            "input_id" => Ok(__FieldTag::__input_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInputRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInputRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input =
                                map.next_value::<std::option::Option<crate::model::Input>>()?;
                        }
                        __FieldTag::__input_id => {
                            if !fields.insert(__FieldTag::__input_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_id",
                                ));
                            }
                            result.input_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInputRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.input.is_some() {
            state.serialize_entry("input", &self.input)?;
        }
        if !self.input_id.is_empty() {
            state.serialize_entry("inputId", &self.input_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListInputs".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInputsRequest {
    /// Required. The parent location for the resource, in the form of:
    /// `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of items to return. If unspecified, server
    /// will pick an appropriate default. Server may return fewer items than
    /// requested. A caller should only rely on response's
    /// [next_page_token][google.cloud.video.livestream.v1.ListInputsResponse.next_page_token]
    /// to determine if there are more items left to be queried.
    ///
    /// [google.cloud.video.livestream.v1.ListInputsResponse.next_page_token]: crate::model::ListInputsResponse::next_page_token
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    /// The filter to apply to list results.
    pub filter: std::string::String,

    /// Specifies the ordering of results following syntax at [Sorting
    /// Order](https://cloud.google.com/apis/design/design_patterns#sorting_order).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInputsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInputsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInputsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInputsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInputsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInputsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInputsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListInputsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInputsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInputsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInputsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInputsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInputsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListInputs".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInputsResponse {
    /// A list of inputs.
    pub inputs: std::vec::Vec<crate::model::Input>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInputsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inputs][crate::model::ListInputsResponse::inputs].
    pub fn set_inputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Input>,
    {
        use std::iter::Iterator;
        self.inputs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInputsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInputsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInputsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListInputsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInputsResponse {
    type PageItem = crate::model::Input;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.inputs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInputsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inputs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInputsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputs" => Ok(__FieldTag::__inputs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInputsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInputsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inputs => {
                            if !fields.insert(__FieldTag::__inputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inputs",
                                ));
                            }
                            result.inputs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Input>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInputsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.inputs.is_empty() {
            state.serialize_entry("inputs", &self.inputs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetInput".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInputRequest {
    /// Required. The name of the input resource, in the form of:
    /// `projects/{project}/locations/{location}/inputs/{inputId}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInputRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInputRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInputRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetInputRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInputRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInputRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInputRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInputRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInputRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteInput".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInputRequest {
    /// Required. The name of the input resource, in the form of:
    /// `projects/{project}/locations/{location}/inputs/{inputId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInputRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInputRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInputRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInputRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteInputRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInputRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInputRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInputRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInputRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInputRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.UpdateInput".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInputRequest {
    /// Field mask is used to specify the fields to be overwritten in the Input
    /// resource by the update. You can only update the following fields:
    ///
    /// * [`tier`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.inputs#Tier)
    /// * [`preprocessingConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.inputs#PreprocessingConfig)
    /// * [`securityRules`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.inputs#SecurityRule)
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the mask is not present, then each field from the list above is updated
    /// if the field appears in the request payload. To unset a field, add the
    /// field to the update mask and remove it from the request payload.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The input resource to be updated.
    pub input: std::option::Option<crate::model::Input>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInputRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInputRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInputRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input][crate::model::UpdateInputRequest::input].
    pub fn set_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Input>,
    {
        self.input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input][crate::model::UpdateInputRequest::input].
    pub fn set_or_clear_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Input>,
    {
        self.input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInputRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInputRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.UpdateInputRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInputRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __input,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInputRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "input" => Ok(__FieldTag::__input),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInputRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInputRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input =
                                map.next_value::<std::option::Option<crate::model::Input>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInputRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.input.is_some() {
            state.serialize_entry("input", &self.input)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.CreateEvent".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEventRequest {
    /// Required. The parent channel for the resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub parent: std::string::String,

    /// Required. The event resource to be created.
    pub event: std::option::Option<crate::model::Event>,

    /// Required. The ID of the event resource to be created.
    /// This value must be 1-63 characters, begin and end with `[a-z0-9]`,
    /// could contain dashes (-) in between.
    pub event_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [event][crate::model::CreateEventRequest::event].
    pub fn set_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event][crate::model::CreateEventRequest::event].
    pub fn set_or_clear_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Event>,
    {
        self.event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_id][crate::model::CreateEventRequest::event_id].
    pub fn set_event_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEventRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __event,
            __event_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "event" => Ok(__FieldTag::__event),
                            "eventId" => Ok(__FieldTag::__event_id),
                            "event_id" => Ok(__FieldTag::__event_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event =
                                map.next_value::<std::option::Option<crate::model::Event>>()?;
                        }
                        __FieldTag::__event_id => {
                            if !fields.insert(__FieldTag::__event_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_id",
                                ));
                            }
                            result.event_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.event.is_some() {
            state.serialize_entry("event", &self.event)?;
        }
        if !self.event_id.is_empty() {
            state.serialize_entry("eventId", &self.event_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListEvents".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEventsRequest {
    /// Required. The parent channel for the resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub parent: std::string::String,

    /// The maximum number of items to return. If unspecified, server
    /// will pick an appropriate default. Server may return fewer items than
    /// requested. A caller should only rely on response's
    /// [next_page_token][google.cloud.video.livestream.v1.ListEventsResponse.next_page_token]
    /// to determine if there are more items left to be queried.
    ///
    /// [google.cloud.video.livestream.v1.ListEventsResponse.next_page_token]: crate::model::ListEventsResponse::next_page_token
    pub page_size: i32,

    /// The next_page_token value returned from a previous List request, if any.
    pub page_token: std::string::String,

    /// The filter to apply to list results.
    pub filter: std::string::String,

    /// Specifies the ordering of results following syntax at
    /// <https://cloud.google.com/apis/design/design_patterns#sorting_order>.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEventsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEventsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEventsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEventsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListEventsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListEvents".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEventsResponse {
    /// A list of events.
    pub events: std::vec::Vec<crate::model::Event>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [events][crate::model::ListEventsResponse::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Event>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEventsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEventsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListEventsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEventsResponse {
    type PageItem = crate::model::Event;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.events
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __events,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "events" => Ok(__FieldTag::__events),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Event>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetEvent".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEventRequest {
    /// Required. The name of the event resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteEvent".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEventRequest {
    /// Required. The name of the event resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEventRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEventRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for Start/Stop Channel long-running operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ChannelOperationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChannelOperationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ChannelOperationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ChannelOperationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChannelOperationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChannelOperationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChannelOperationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChannelOperationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChannelOperationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListClips".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClipsRequest {
    /// Required. Parent value for ListClipsRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClipsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClipsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClipsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClipsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClipsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClipsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClipsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListClipsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClipsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClipsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClipsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClipsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClipsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListClips".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClipsResponse {
    /// The list of Clip
    pub clips: std::vec::Vec<crate::model::Clip>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClipsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clips][crate::model::ListClipsResponse::clips].
    pub fn set_clips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Clip>,
    {
        use std::iter::Iterator;
        self.clips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClipsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClipsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClipsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListClipsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClipsResponse {
    type PageItem = crate::model::Clip;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clips
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClipsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clips,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClipsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clips" => Ok(__FieldTag::__clips),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClipsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClipsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clips => {
                            if !fields.insert(__FieldTag::__clips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clips",
                                ));
                            }
                            result.clips = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Clip>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClipsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clips.is_empty() {
            state.serialize_entry("clips", &self.clips)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetClip".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClipRequest {
    /// Required. Name of the resource, in the following form:
    /// `projects/{project}/locations/{location}/channels/{channel}/clips/{clip}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClipRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClipRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClipRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetClipRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClipRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClipRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClipRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClipRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClipRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.CreateClip".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClipRequest {
    /// Required. The parent resource name, in the following form:
    /// `projects/{project}/locations/{location}/channels/{channel}`.
    pub parent: std::string::String,

    /// Required. Id of the requesting object in the following form:
    ///
    /// 1. 1 character minimum, 63 characters maximum
    /// 1. Only contains letters, digits, underscores, and hyphens
    pub clip_id: std::string::String,

    /// Required. The resource being created
    pub clip: std::option::Option<crate::model::Clip>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClipRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClipRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [clip_id][crate::model::CreateClipRequest::clip_id].
    pub fn set_clip_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clip_id = v.into();
        self
    }

    /// Sets the value of [clip][crate::model::CreateClipRequest::clip].
    pub fn set_clip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Clip>,
    {
        self.clip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clip][crate::model::CreateClipRequest::clip].
    pub fn set_or_clear_clip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Clip>,
    {
        self.clip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClipRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClipRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateClipRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClipRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __clip_id,
            __clip,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClipRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clipId" => Ok(__FieldTag::__clip_id),
                            "clip_id" => Ok(__FieldTag::__clip_id),
                            "clip" => Ok(__FieldTag::__clip),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClipRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClipRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clip_id => {
                            if !fields.insert(__FieldTag::__clip_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clip_id",
                                ));
                            }
                            result.clip_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clip => {
                            if !fields.insert(__FieldTag::__clip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clip",
                                ));
                            }
                            result.clip =
                                map.next_value::<std::option::Option<crate::model::Clip>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClipRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.clip_id.is_empty() {
            state.serialize_entry("clipId", &self.clip_id)?;
        }
        if self.clip.is_some() {
            state.serialize_entry("clip", &self.clip)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteClip".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClipRequest {
    /// Required. The name of the clip resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}/clips/{clipId}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClipRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClipRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClipRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClipRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteClipRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClipRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClipRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClipRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClipRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClipRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.ListDvrSessions".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDvrSessionsRequest {
    /// Required. Parent value for ListDvrSessionsRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDvrSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDvrSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDvrSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDvrSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDvrSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDvrSessionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDvrSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListDvrSessionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDvrSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDvrSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDvrSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDvrSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDvrSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for "LivestreamService.ListDvrSessions".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDvrSessionsResponse {
    /// The list of DVR sessions
    pub dvr_sessions: std::vec::Vec<crate::model::DvrSession>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDvrSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dvr_sessions][crate::model::ListDvrSessionsResponse::dvr_sessions].
    pub fn set_dvr_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DvrSession>,
    {
        use std::iter::Iterator;
        self.dvr_sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDvrSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDvrSessionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDvrSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.ListDvrSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDvrSessionsResponse {
    type PageItem = crate::model::DvrSession;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dvr_sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDvrSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dvr_sessions,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDvrSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dvrSessions" => Ok(__FieldTag::__dvr_sessions),
                            "dvr_sessions" => Ok(__FieldTag::__dvr_sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDvrSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDvrSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dvr_sessions => {
                            if !fields.insert(__FieldTag::__dvr_sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_sessions",
                                ));
                            }
                            result.dvr_sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DvrSession>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDvrSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dvr_sessions.is_empty() {
            state.serialize_entry("dvrSessions", &self.dvr_sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetDvrSession".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDvrSessionRequest {
    /// Required. Name of the resource, in the following form:
    /// `projects/{project}/locations/{location}/channels/{channelId}/dvrSessions/{dvrSessionId}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDvrSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDvrSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDvrSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetDvrSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDvrSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDvrSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDvrSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDvrSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDvrSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.CreateDvrSession".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDvrSessionRequest {
    /// Required. The parent resource name, in the following form:
    /// `projects/{project}/locations/{location}/channels/{channelId}`.
    pub parent: std::string::String,

    /// Required. Id of the requesting object in the following form:
    ///
    /// 1. 1 character minimum, 63 characters maximum
    /// 1. Only contains letters, digits, underscores, and hyphens
    pub dvr_session_id: std::string::String,

    /// Required. The resource being created
    pub dvr_session: std::option::Option<crate::model::DvrSession>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDvrSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDvrSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dvr_session_id][crate::model::CreateDvrSessionRequest::dvr_session_id].
    pub fn set_dvr_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dvr_session_id = v.into();
        self
    }

    /// Sets the value of [dvr_session][crate::model::CreateDvrSessionRequest::dvr_session].
    pub fn set_dvr_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DvrSession>,
    {
        self.dvr_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dvr_session][crate::model::CreateDvrSessionRequest::dvr_session].
    pub fn set_or_clear_dvr_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DvrSession>,
    {
        self.dvr_session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDvrSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDvrSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.CreateDvrSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDvrSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dvr_session_id,
            __dvr_session,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDvrSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dvrSessionId" => Ok(__FieldTag::__dvr_session_id),
                            "dvr_session_id" => Ok(__FieldTag::__dvr_session_id),
                            "dvrSession" => Ok(__FieldTag::__dvr_session),
                            "dvr_session" => Ok(__FieldTag::__dvr_session),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDvrSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDvrSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dvr_session_id => {
                            if !fields.insert(__FieldTag::__dvr_session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_session_id",
                                ));
                            }
                            result.dvr_session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dvr_session => {
                            if !fields.insert(__FieldTag::__dvr_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_session",
                                ));
                            }
                            result.dvr_session =
                                map.next_value::<std::option::Option<crate::model::DvrSession>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDvrSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.dvr_session_id.is_empty() {
            state.serialize_entry("dvrSessionId", &self.dvr_session_id)?;
        }
        if self.dvr_session.is_some() {
            state.serialize_entry("dvrSession", &self.dvr_session)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.DeleteDvrSession".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDvrSessionRequest {
    /// Required. The name of the event resource, in the form of:
    /// `projects/{project}/locations/{location}/channels/{channelId}/dvrSessions/{dvrSessionId}`.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDvrSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDvrSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDvrSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDvrSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.DeleteDvrSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDvrSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDvrSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDvrSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDvrSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDvrSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.UpdateDvrSession".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDvrSessionRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// DvrSession resource by the update. You can only update the following
    /// fields:
    ///
    /// * `dvrWindows`
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The DVR session resource to be updated.
    pub dvr_session: std::option::Option<crate::model::DvrSession>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDvrSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDvrSessionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDvrSessionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dvr_session][crate::model::UpdateDvrSessionRequest::dvr_session].
    pub fn set_dvr_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DvrSession>,
    {
        self.dvr_session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dvr_session][crate::model::UpdateDvrSessionRequest::dvr_session].
    pub fn set_or_clear_dvr_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DvrSession>,
    {
        self.dvr_session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDvrSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDvrSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.UpdateDvrSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDvrSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __dvr_session,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDvrSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "dvrSession" => Ok(__FieldTag::__dvr_session),
                            "dvr_session" => Ok(__FieldTag::__dvr_session),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDvrSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDvrSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__dvr_session => {
                            if !fields.insert(__FieldTag::__dvr_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dvr_session",
                                ));
                            }
                            result.dvr_session =
                                map.next_value::<std::option::Option<crate::model::DvrSession>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDvrSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.dvr_session.is_some() {
            state.serialize_entry("dvrSession", &self.dvr_session)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.GetPool".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPoolRequest {
    /// Required. The name of the pool resource, in the form of:
    /// `projects/{project}/locations/{location}/pools/{poolId}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.GetPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for "LivestreamService.UpdatePool".
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePoolRequest {
    /// Field mask is used to specify the fields to be overwritten in the Pool
    /// resource by the update. You can only update the following fields:
    ///
    /// * `networkConfig`
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The pool resource to be updated.
    pub pool: std::option::Option<crate::model::Pool>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported `(00000000-0000-0000-0000-000000000000)`.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdatePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pool][crate::model::UpdatePoolRequest::pool].
    pub fn set_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Pool>,
    {
        self.pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pool][crate::model::UpdatePoolRequest::pool].
    pub fn set_or_clear_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Pool>,
    {
        self.pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.video.livestream.v1.UpdatePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "pool" => Ok(__FieldTag::__pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__pool => {
                            if !fields.insert(__FieldTag::__pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pool",
                                ));
                            }
                            result.pool =
                                map.next_value::<std::option::Option<crate::model::Pool>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.pool.is_some() {
            state.serialize_entry("pool", &self.pool)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
