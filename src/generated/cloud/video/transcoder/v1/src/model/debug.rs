// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("name", &self.name);
        debug_struct.field("input_uri", &self.input_uri);
        debug_struct.field("output_uri", &self.output_uri);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("ttl_after_completion_days", &self.ttl_after_completion_days);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("error", &self.error);
        debug_struct.field("mode", &self.mode);
        debug_struct.field("batch_mode_priority", &self.batch_mode_priority);
        debug_struct.field("optimization", &self.optimization);
        debug_struct.field("fill_content_gaps", &self.fill_content_gaps);
        debug_struct.field("job_config", &self.job_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobTemplate");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobConfig");
        debug_struct.field("inputs", &self.inputs);
        debug_struct.field("edit_list", &self.edit_list);
        debug_struct.field("elementary_streams", &self.elementary_streams);
        debug_struct.field("mux_streams", &self.mux_streams);
        debug_struct.field("manifests", &self.manifests);
        debug_struct.field("output", &self.output);
        debug_struct.field("ad_breaks", &self.ad_breaks);
        debug_struct.field("pubsub_destination", &self.pubsub_destination);
        debug_struct.field("sprite_sheets", &self.sprite_sheets);
        debug_struct.field("overlays", &self.overlays);
        debug_struct.field("encryptions", &self.encryptions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Input");
        debug_struct.field("key", &self.key);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("preprocessing_config", &self.preprocessing_config);
        debug_struct.field("attributes", &self.attributes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Output");
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EditAtom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EditAtom");
        debug_struct.field("key", &self.key);
        debug_struct.field("inputs", &self.inputs);
        debug_struct.field("end_time_offset", &self.end_time_offset);
        debug_struct.field("start_time_offset", &self.start_time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdBreak {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdBreak");
        debug_struct.field("start_time_offset", &self.start_time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ElementaryStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ElementaryStream");
        debug_struct.field("key", &self.key);
        debug_struct.field("elementary_stream", &self.elementary_stream);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MuxStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MuxStream");
        debug_struct.field("key", &self.key);
        debug_struct.field("file_name", &self.file_name);
        debug_struct.field("container", &self.container);
        debug_struct.field("elementary_streams", &self.elementary_streams);
        debug_struct.field("segment_settings", &self.segment_settings);
        debug_struct.field("encryption_id", &self.encryption_id);
        debug_struct.field("container_config", &self.container_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::mux_stream::Fmp4Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fmp4Config");
        debug_struct.field("codec_tag", &self.codec_tag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Manifest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Manifest");
        debug_struct.field("file_name", &self.file_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("mux_streams", &self.mux_streams);
        debug_struct.field("manifest_config", &self.manifest_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::manifest::DashConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DashConfig");
        debug_struct.field("segment_reference_scheme", &self.segment_reference_scheme);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PubsubDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PubsubDestination");
        debug_struct.field("topic", &self.topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SpriteSheet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpriteSheet");
        debug_struct.field("format", &self.format);
        debug_struct.field("file_prefix", &self.file_prefix);
        debug_struct.field("sprite_width_pixels", &self.sprite_width_pixels);
        debug_struct.field("sprite_height_pixels", &self.sprite_height_pixels);
        debug_struct.field("column_count", &self.column_count);
        debug_struct.field("row_count", &self.row_count);
        debug_struct.field("start_time_offset", &self.start_time_offset);
        debug_struct.field("end_time_offset", &self.end_time_offset);
        debug_struct.field("quality", &self.quality);
        debug_struct.field("extraction_strategy", &self.extraction_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Overlay {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Overlay");
        debug_struct.field("image", &self.image);
        debug_struct.field("animations", &self.animations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::NormalizedCoordinate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NormalizedCoordinate");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Image");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("resolution", &self.resolution);
        debug_struct.field("alpha", &self.alpha);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::AnimationStatic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnimationStatic");
        debug_struct.field("xy", &self.xy);
        debug_struct.field("start_time_offset", &self.start_time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::AnimationFade {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnimationFade");
        debug_struct.field("fade_type", &self.fade_type);
        debug_struct.field("xy", &self.xy);
        debug_struct.field("start_time_offset", &self.start_time_offset);
        debug_struct.field("end_time_offset", &self.end_time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::AnimationEnd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnimationEnd");
        debug_struct.field("start_time_offset", &self.start_time_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::overlay::Animation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Animation");
        debug_struct.field("animation_type", &self.animation_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PreprocessingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PreprocessingConfig");
        debug_struct.field("color", &self.color);
        debug_struct.field("denoise", &self.denoise);
        debug_struct.field("deblock", &self.deblock);
        debug_struct.field("audio", &self.audio);
        debug_struct.field("crop", &self.crop);
        debug_struct.field("pad", &self.pad);
        debug_struct.field("deinterlace", &self.deinterlace);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Color {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Color");
        debug_struct.field("saturation", &self.saturation);
        debug_struct.field("contrast", &self.contrast);
        debug_struct.field("brightness", &self.brightness);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Denoise {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Denoise");
        debug_struct.field("strength", &self.strength);
        debug_struct.field("tune", &self.tune);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Deblock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Deblock");
        debug_struct.field("strength", &self.strength);
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Audio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Audio");
        debug_struct.field("lufs", &self.lufs);
        debug_struct.field("high_boost", &self.high_boost);
        debug_struct.field("low_boost", &self.low_boost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Crop {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Crop");
        debug_struct.field("top_pixels", &self.top_pixels);
        debug_struct.field("bottom_pixels", &self.bottom_pixels);
        debug_struct.field("left_pixels", &self.left_pixels);
        debug_struct.field("right_pixels", &self.right_pixels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Pad {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Pad");
        debug_struct.field("top_pixels", &self.top_pixels);
        debug_struct.field("bottom_pixels", &self.bottom_pixels);
        debug_struct.field("left_pixels", &self.left_pixels);
        debug_struct.field("right_pixels", &self.right_pixels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::Deinterlace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Deinterlace");
        debug_struct.field("deinterlacing_filter", &self.deinterlacing_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::deinterlace::YadifConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("YadifConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field(
            "disable_spatial_interlacing",
            &self.disable_spatial_interlacing,
        );
        debug_struct.field("parity", &self.parity);
        debug_struct.field("deinterlace_all_frames", &self.deinterlace_all_frames);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::preprocessing_config::deinterlace::BwdifConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BwdifConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("parity", &self.parity);
        debug_struct.field("deinterlace_all_frames", &self.deinterlace_all_frames);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrackDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrackDefinition");
        debug_struct.field("input_track", &self.input_track);
        debug_struct.field("languages", &self.languages);
        debug_struct.field("detect_languages", &self.detect_languages);
        debug_struct.field("detected_languages", &self.detected_languages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InputAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputAttributes");
        debug_struct.field("track_definitions", &self.track_definitions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VideoStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VideoStream");
        debug_struct.field("codec_settings", &self.codec_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H264ColorFormatSDR {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H264ColorFormatSDR");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H264ColorFormatHLG {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H264ColorFormatHLG");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H264CodecSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H264CodecSettings");
        debug_struct.field("width_pixels", &self.width_pixels);
        debug_struct.field("height_pixels", &self.height_pixels);
        debug_struct.field("frame_rate", &self.frame_rate);
        debug_struct.field(
            "frame_rate_conversion_strategy",
            &self.frame_rate_conversion_strategy,
        );
        debug_struct.field("bitrate_bps", &self.bitrate_bps);
        debug_struct.field("pixel_format", &self.pixel_format);
        debug_struct.field("rate_control_mode", &self.rate_control_mode);
        debug_struct.field("crf_level", &self.crf_level);
        debug_struct.field("allow_open_gop", &self.allow_open_gop);
        debug_struct.field("enable_two_pass", &self.enable_two_pass);
        debug_struct.field("vbv_size_bits", &self.vbv_size_bits);
        debug_struct.field("vbv_fullness_bits", &self.vbv_fullness_bits);
        debug_struct.field("entropy_coder", &self.entropy_coder);
        debug_struct.field("b_pyramid", &self.b_pyramid);
        debug_struct.field("b_frame_count", &self.b_frame_count);
        debug_struct.field("aq_strength", &self.aq_strength);
        debug_struct.field("profile", &self.profile);
        debug_struct.field("tune", &self.tune);
        debug_struct.field("preset", &self.preset);
        debug_struct.field("gop_mode", &self.gop_mode);
        debug_struct.field("color_format", &self.color_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H265ColorFormatSDR {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H265ColorFormatSDR");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H265ColorFormatHLG {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H265ColorFormatHLG");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H265ColorFormatHDR10 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H265ColorFormatHDR10");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::H265CodecSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("H265CodecSettings");
        debug_struct.field("width_pixels", &self.width_pixels);
        debug_struct.field("height_pixels", &self.height_pixels);
        debug_struct.field("frame_rate", &self.frame_rate);
        debug_struct.field(
            "frame_rate_conversion_strategy",
            &self.frame_rate_conversion_strategy,
        );
        debug_struct.field("bitrate_bps", &self.bitrate_bps);
        debug_struct.field("pixel_format", &self.pixel_format);
        debug_struct.field("rate_control_mode", &self.rate_control_mode);
        debug_struct.field("crf_level", &self.crf_level);
        debug_struct.field("allow_open_gop", &self.allow_open_gop);
        debug_struct.field("enable_two_pass", &self.enable_two_pass);
        debug_struct.field("vbv_size_bits", &self.vbv_size_bits);
        debug_struct.field("vbv_fullness_bits", &self.vbv_fullness_bits);
        debug_struct.field("b_pyramid", &self.b_pyramid);
        debug_struct.field("b_frame_count", &self.b_frame_count);
        debug_struct.field("aq_strength", &self.aq_strength);
        debug_struct.field("profile", &self.profile);
        debug_struct.field("tune", &self.tune);
        debug_struct.field("preset", &self.preset);
        debug_struct.field("gop_mode", &self.gop_mode);
        debug_struct.field("color_format", &self.color_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::Vp9ColorFormatSDR {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vp9ColorFormatSDR");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::Vp9ColorFormatHLG {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vp9ColorFormatHLG");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::video_stream::Vp9CodecSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vp9CodecSettings");
        debug_struct.field("width_pixels", &self.width_pixels);
        debug_struct.field("height_pixels", &self.height_pixels);
        debug_struct.field("frame_rate", &self.frame_rate);
        debug_struct.field(
            "frame_rate_conversion_strategy",
            &self.frame_rate_conversion_strategy,
        );
        debug_struct.field("bitrate_bps", &self.bitrate_bps);
        debug_struct.field("pixel_format", &self.pixel_format);
        debug_struct.field("rate_control_mode", &self.rate_control_mode);
        debug_struct.field("crf_level", &self.crf_level);
        debug_struct.field("profile", &self.profile);
        debug_struct.field("gop_mode", &self.gop_mode);
        debug_struct.field("color_format", &self.color_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AudioStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AudioStream");
        debug_struct.field("codec", &self.codec);
        debug_struct.field("bitrate_bps", &self.bitrate_bps);
        debug_struct.field("channel_count", &self.channel_count);
        debug_struct.field("channel_layout", &self.channel_layout);
        debug_struct.field("mapping", &self.mapping);
        debug_struct.field("sample_rate_hertz", &self.sample_rate_hertz);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::audio_stream::AudioMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AudioMapping");
        debug_struct.field("atom_key", &self.atom_key);
        debug_struct.field("input_key", &self.input_key);
        debug_struct.field("input_track", &self.input_track);
        debug_struct.field("input_channel", &self.input_channel);
        debug_struct.field("output_channel", &self.output_channel);
        debug_struct.field("gain_db", &self.gain_db);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TextStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextStream");
        debug_struct.field("codec", &self.codec);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("mapping", &self.mapping);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::text_stream::TextMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextMapping");
        debug_struct.field("atom_key", &self.atom_key);
        debug_struct.field("input_key", &self.input_key);
        debug_struct.field("input_track", &self.input_track);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SegmentSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SegmentSettings");
        debug_struct.field("segment_duration", &self.segment_duration);
        debug_struct.field("individual_segments", &self.individual_segments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Encryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Encryption");
        debug_struct.field("id", &self.id);
        debug_struct.field("drm_systems", &self.drm_systems);
        debug_struct.field("encryption_mode", &self.encryption_mode);
        debug_struct.field("secret_source", &self.secret_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::Aes128Encryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Aes128Encryption");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::SampleAesEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SampleAesEncryption");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::MpegCommonEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MpegCommonEncryption");
        debug_struct.field("scheme", &self.scheme);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::SecretManagerSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretManagerSource");
        debug_struct.field("secret_version", &self.secret_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::Widevine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Widevine");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::Fairplay {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fairplay");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::Playready {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Playready");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::Clearkey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Clearkey");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::encryption::DrmSystems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DrmSystems");
        debug_struct.field("widevine", &self.widevine);
        debug_struct.field("fairplay", &self.fairplay);
        debug_struct.field("playready", &self.playready);
        debug_struct.field("clearkey", &self.clearkey);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("job", &self.job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsResponse");
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateJobTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateJobTemplateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("job_template", &self.job_template);
        debug_struct.field("job_template_id", &self.job_template_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobTemplatesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobTemplatesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJobTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobTemplateRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteJobTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobTemplateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobTemplatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobTemplatesResponse");
        debug_struct.field("job_templates", &self.job_templates);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
