// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Answer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.answer_text.is_empty() {
            state.serialize_entry("answerText", &self.answer_text)?;
        }
        if self.grounding_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("groundingScore", &__With(&self.grounding_score))?;
        }
        if !self.citations.is_empty() {
            state.serialize_entry("citations", &self.citations)?;
        }
        if !self.grounding_supports.is_empty() {
            state.serialize_entry("groundingSupports", &self.grounding_supports)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self.related_questions.is_empty() {
            state.serialize_entry("relatedQuestions", &self.related_questions)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if self.query_understanding_info.is_some() {
            state.serialize_entry("queryUnderstandingInfo", &self.query_understanding_info)?;
        }
        if !self.answer_skipped_reasons.is_empty() {
            state.serialize_entry("answerSkippedReasons", &self.answer_skipped_reasons)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !self.safety_ratings.is_empty() {
            state.serialize_entry("safetyRatings", &self.safety_ratings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::Citation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startIndex", &__With(&self.start_index))?;
        }
        if !wkt::internal::is_default(&self.end_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("endIndex", &__With(&self.end_index))?;
        }
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::CitationSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reference_id.is_empty() {
            state.serialize_entry("referenceId", &self.reference_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::GroundingSupport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startIndex", &__With(&self.start_index))?;
        }
        if !wkt::internal::is_default(&self.end_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("endIndex", &__With(&self.end_index))?;
        }
        if self.grounding_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("groundingScore", &__With(&self.grounding_score))?;
        }
        if self.grounding_check_required.is_some() {
            state.serialize_entry("groundingCheckRequired", &self.grounding_check_required)?;
        }
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::Reference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.unstructured_document_info() {
            state.serialize_entry("unstructuredDocumentInfo", value)?;
        }
        if let Some(value) = self.chunk_info() {
            state.serialize_entry("chunkInfo", value)?;
        }
        if let Some(value) = self.structured_document_info() {
            state.serialize_entry("structuredDocumentInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::reference::UnstructuredDocumentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.chunk_contents.is_empty() {
            state.serialize_entry("chunkContents", &self.chunk_contents)?;
        }
        if self.struct_data.is_some() {
            state.serialize_entry("structData", &self.struct_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::reference::unstructured_document_info::ChunkContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if self.relevance_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("relevanceScore", &__With(&self.relevance_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::reference::ChunkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.chunk.is_empty() {
            state.serialize_entry("chunk", &self.chunk)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.relevance_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("relevanceScore", &__With(&self.relevance_score))?;
        }
        if self.document_metadata.is_some() {
            state.serialize_entry("documentMetadata", &self.document_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::reference::chunk_info::DocumentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if self.struct_data.is_some() {
            state.serialize_entry("structData", &self.struct_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::reference::StructuredDocumentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.struct_data.is_some() {
            state.serialize_entry("structData", &self.struct_data)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::Step {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.thought.is_empty() {
            state.serialize_entry("thought", &self.thought)?;
        }
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::step::Action {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.search_action() {
            state.serialize_entry("searchAction", value)?;
        }
        if self.observation.is_some() {
            state.serialize_entry("observation", &self.observation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::step::action::SearchAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::step::action::Observation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.search_results.is_empty() {
            state.serialize_entry("searchResults", &self.search_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::step::action::observation::SearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.snippet_info.is_empty() {
            state.serialize_entry("snippetInfo", &self.snippet_info)?;
        }
        if !self.chunk_info.is_empty() {
            state.serialize_entry("chunkInfo", &self.chunk_info)?;
        }
        if self.struct_data.is_some() {
            state.serialize_entry("structData", &self.struct_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer::step::action::observation::search_result::SnippetInfo
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snippet.is_empty() {
            state.serialize_entry("snippet", &self.snippet)?;
        }
        if !self.snippet_status.is_empty() {
            state.serialize_entry("snippetStatus", &self.snippet_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::step::action::observation::search_result::ChunkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.chunk.is_empty() {
            state.serialize_entry("chunk", &self.chunk)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.relevance_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("relevanceScore", &__With(&self.relevance_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::QueryUnderstandingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_classification_info.is_empty() {
            state.serialize_entry("queryClassificationInfo", &self.query_classification_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer::query_understanding_info::QueryClassificationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.positive) {
            state.serialize_entry("positive", &self.positive)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AssistAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.replies.is_empty() {
            state.serialize_entry("replies", &self.replies)?;
        }
        if !self.assist_skipped_reasons.is_empty() {
            state.serialize_entry("assistSkippedReasons", &self.assist_skipped_reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assist_answer::Reply {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.grounded_content() {
            state.serialize_entry("groundedContent", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AssistantContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.inline_data() {
            state.serialize_entry("inlineData", value)?;
        }
        if let Some(value) = self.file() {
            state.serialize_entry("file", value)?;
        }
        if let Some(value) = self.executable_code() {
            state.serialize_entry("executableCode", value)?;
        }
        if let Some(value) = self.code_execution_result() {
            state.serialize_entry("codeExecutionResult", value)?;
        }
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !wkt::internal::is_default(&self.thought) {
            state.serialize_entry("thought", &self.thought)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_content::Blob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_content::File {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.file_id.is_empty() {
            state.serialize_entry("fileId", &self.file_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_content::ExecutableCode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_content::CodeExecutionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.outcome) {
            state.serialize_entry("outcome", &self.outcome)?;
        }
        if !self.output.is_empty() {
            state.serialize_entry("output", &self.output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AssistantGroundedContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text_grounding_metadata() {
            state.serialize_entry("textGroundingMetadata", value)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_grounded_content::TextGroundingMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.segments.is_empty() {
            state.serialize_entry("segments", &self.segments)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::assistant_grounded_content::text_grounding_metadata::Segment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startIndex", &__With(&self.start_index))?;
        }
        if !wkt::internal::is_default(&self.end_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("endIndex", &__With(&self.end_index))?;
        }
        if !self.reference_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("referenceIndices", &__With(&self.reference_indices))?;
        }
        if !wkt::internal::is_default(&self.grounding_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("groundingScore", &__With(&self.grounding_score))?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::assistant_grounded_content::text_grounding_metadata::Reference
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.document_metadata.is_some() {
            state.serialize_entry("documentMetadata", &self.document_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::assistant_grounded_content::text_grounding_metadata::reference::DocumentMetadata
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.uri.is_some() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.title.is_some() {
            state.serialize_entry("title", &self.title)?;
        }
        if self.page_identifier.is_some() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if self.domain.is_some() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(all(
    feature = "assistant-service",
    feature = "cmek-config-service",
    feature = "completion-service",
    feature = "control-service",
    feature = "conversational-search-service",
    feature = "data-store-service",
    feature = "document-service",
    feature = "engine-service",
    feature = "grounded-generation-service",
    feature = "identity-mapping-store-service",
    feature = "project-service",
    feature = "rank-service",
    feature = "recommendation-service",
    feature = "schema-service",
    feature = "search-service",
    feature = "search-tuning-service",
    feature = "serving-config-service",
    feature = "session-service",
    feature = "site-search-engine-service",
    feature = "user-event-service",
    feature = "user-license-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Assistant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AssistUserMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.preferred_language_code.is_empty() {
            state.serialize_entry("preferredLanguageCode", &self.preferred_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamAssistRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.user_metadata.is_some() {
            state.serialize_entry("userMetadata", &self.user_metadata)?;
        }
        if self.tools_spec.is_some() {
            state.serialize_entry("toolsSpec", &self.tools_spec)?;
        }
        if self.generation_spec.is_some() {
            state.serialize_entry("generationSpec", &self.generation_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::ToolsSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.vertex_ai_search_spec.is_some() {
            state.serialize_entry("vertexAiSearchSpec", &self.vertex_ai_search_spec)?;
        }
        if self.web_grounding_spec.is_some() {
            state.serialize_entry("webGroundingSpec", &self.web_grounding_spec)?;
        }
        if self.image_generation_spec.is_some() {
            state.serialize_entry("imageGenerationSpec", &self.image_generation_spec)?;
        }
        if self.video_generation_spec.is_some() {
            state.serialize_entry("videoGenerationSpec", &self.video_generation_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::tools_spec::VertexAiSearchSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store_specs.is_empty() {
            state.serialize_entry("dataStoreSpecs", &self.data_store_specs)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::tools_spec::WebGroundingSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::tools_spec::ImageGenerationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::tools_spec::VideoGenerationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_request::GenerationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StreamAssistResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.answer.is_some() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if !self.assist_token.is_empty() {
            state.serialize_entry("assistToken", &self.assist_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "assistant-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::stream_assist_response::SessionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Chunk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.relevance_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("relevanceScore", &__With(&self.relevance_score))?;
        }
        if self.document_metadata.is_some() {
            state.serialize_entry("documentMetadata", &self.document_metadata)?;
        }
        if self.derived_struct_data.is_some() {
            state.serialize_entry("derivedStructData", &self.derived_struct_data)?;
        }
        if self.page_span.is_some() {
            state.serialize_entry("pageSpan", &self.page_span)?;
        }
        if self.chunk_metadata.is_some() {
            state.serialize_entry("chunkMetadata", &self.chunk_metadata)?;
        }
        if !self.data_urls.is_empty() {
            state.serialize_entry("dataUrls", &self.data_urls)?;
        }
        if !self.annotation_contents.is_empty() {
            state.serialize_entry("annotationContents", &self.annotation_contents)?;
        }
        if !self.annotation_metadata.is_empty() {
            state.serialize_entry("annotationMetadata", &self.annotation_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::chunk::DocumentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if self.struct_data.is_some() {
            state.serialize_entry("structData", &self.struct_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::chunk::PageSpan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_start) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageStart", &__With(&self.page_start))?;
        }
        if !wkt::internal::is_default(&self.page_end) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageEnd", &__With(&self.page_end))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::chunk::ChunkMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.previous_chunks.is_empty() {
            state.serialize_entry("previousChunks", &self.previous_chunks)?;
        }
        if !self.next_chunks.is_empty() {
            state.serialize_entry("nextChunks", &self.next_chunks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::chunk::StructuredContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.structure_type) {
            state.serialize_entry("structureType", &self.structure_type)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::chunk::AnnotationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.structured_content.is_some() {
            state.serialize_entry("structuredContent", &self.structured_content)?;
        }
        if !self.image_id.is_empty() {
            state.serialize_entry("imageId", &self.image_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateCmekConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !wkt::internal::is_default(&self.set_default) {
            state.serialize_entry("setDefault", &self.set_default)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetCmekConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "cmek-config-service",
    feature = "data-store-service",
    feature = "identity-mapping-store-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SingleRegionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "cmek-config-service",
    feature = "data-store-service",
    feature = "identity-mapping-store-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CmekConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self.kms_key_version.is_empty() {
            state.serialize_entry("kmsKeyVersion", &self.kms_key_version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.is_default) {
            state.serialize_entry("isDefault", &self.is_default)?;
        }
        if !wkt::internal::is_default(&self.last_rotation_timestamp_micros) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "lastRotationTimestampMicros",
                &__With(&self.last_rotation_timestamp_micros),
            )?;
        }
        if !self.single_region_keys.is_empty() {
            state.serialize_entry("singleRegionKeys", &self.single_region_keys)?;
        }
        if !wkt::internal::is_default(&self.notebooklm_state) {
            state.serialize_entry("notebooklmState", &self.notebooklm_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateCmekConfigMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListCmekConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListCmekConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cmek_configs.is_empty() {
            state.serialize_entry("cmekConfigs", &self.cmek_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteCmekConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cmek-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteCmekConfigMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Interval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.minimum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimum", &__With(value))?;
        }
        if let Some(value) = self.exclusive_minimum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exclusiveMinimum", &__With(value))?;
        }
        if let Some(value) = self.maximum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maximum", &__With(value))?;
        }
        if let Some(value) = self.exclusive_maximum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exclusiveMaximum", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.numbers.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numbers", &__With(&self.numbers))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "recommendation-service",
    feature = "search-service",
    feature = "serving-config-service",
    feature = "user-event-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UserInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DoubleList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("values", &__With(&self.values))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Principal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.user_id() {
            state.serialize_entry("userId", value)?;
        }
        if let Some(value) = self.group_id() {
            state.serialize_entry("groupId", value)?;
        }
        if let Some(value) = self.external_entity_id() {
            state.serialize_entry("externalEntityId", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthcareFhirConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_configurable_schema) {
            state.serialize_entry("enableConfigurableSchema", &self.enable_configurable_schema)?;
        }
        if !wkt::internal::is_default(&self.enable_static_indexing_for_batch_ingestion) {
            state.serialize_entry(
                "enableStaticIndexingForBatchIngestion",
                &self.enable_static_indexing_for_batch_ingestion,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "control-service",
    feature = "conversational-search-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchLinkPromotion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SuggestionDenyListEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.block_phrase.is_empty() {
            state.serialize_entry("blockPhrase", &self.block_phrase)?;
        }
        if !wkt::internal::is_default(&self.match_operator) {
            state.serialize_entry("matchOperator", &self.match_operator)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompletionSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.global_score() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("globalScore", &__With(value))?;
        }
        if let Some(value) = self.frequency() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("frequency", &__With(value))?;
        }
        if !self.suggestion.is_empty() {
            state.serialize_entry("suggestion", &self.suggestion)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.group_id.is_empty() {
            state.serialize_entry("groupId", &self.group_id)?;
        }
        if !wkt::internal::is_default(&self.group_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("groupScore", &__With(&self.group_score))?;
        }
        if !self.alternative_phrases.is_empty() {
            state.serialize_entry("alternativePhrases", &self.alternative_phrases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompleteQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.query_model.is_empty() {
            state.serialize_entry("queryModel", &self.query_model)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if !wkt::internal::is_default(&self.include_tail_suggestions) {
            state.serialize_entry("includeTailSuggestions", &self.include_tail_suggestions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompleteQueryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_suggestions.is_empty() {
            state.serialize_entry("querySuggestions", &self.query_suggestions)?;
        }
        if !wkt::internal::is_default(&self.tail_match_triggered) {
            state.serialize_entry("tailMatchTriggered", &self.tail_match_triggered)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::complete_query_response::QuerySuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.suggestion.is_empty() {
            state.serialize_entry("suggestion", &self.suggestion)?;
        }
        if !self.completable_field_paths.is_empty() {
            state.serialize_entry("completableFieldPaths", &self.completable_field_paths)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Condition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_terms.is_empty() {
            state.serialize_entry("queryTerms", &self.query_terms)?;
        }
        if !self.active_time_range.is_empty() {
            state.serialize_entry("activeTimeRange", &self.active_time_range)?;
        }
        if !self.query_regex.is_empty() {
            state.serialize_entry("queryRegex", &self.query_regex)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::condition::QueryTerm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.full_match) {
            state.serialize_entry("fullMatch", &self.full_match)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::condition::TimeRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Control {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.boost_action() {
            state.serialize_entry("boostAction", value)?;
        }
        if let Some(value) = self.filter_action() {
            state.serialize_entry("filterAction", value)?;
        }
        if let Some(value) = self.redirect_action() {
            state.serialize_entry("redirectAction", value)?;
        }
        if let Some(value) = self.synonyms_action() {
            state.serialize_entry("synonymsAction", value)?;
        }
        if let Some(value) = self.promote_action() {
            state.serialize_entry("promoteAction", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.associated_serving_config_ids.is_empty() {
            state.serialize_entry(
                "associatedServingConfigIds",
                &self.associated_serving_config_ids,
            )?;
        }
        if !wkt::internal::is_default(&self.solution_type) {
            state.serialize_entry("solutionType", &self.solution_type)?;
        }
        if !self.use_cases.is_empty() {
            state.serialize_entry("useCases", &self.use_cases)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::BoostAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.fixed_boost() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fixedBoost", &__With(value))?;
        }
        if let Some(value) = self.interpolation_boost_spec() {
            state.serialize_entry("interpolationBoostSpec", value)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::boost_action::InterpolationBoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.attribute_type) {
            state.serialize_entry("attributeType", &self.attribute_type)?;
        }
        if !wkt::internal::is_default(&self.interpolation_type) {
            state.serialize_entry("interpolationType", &self.interpolation_type)?;
        }
        if !self.control_points.is_empty() {
            state.serialize_entry("controlPoints", &self.control_points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::control::boost_action::interpolation_boost_spec::ControlPoint
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute_value.is_empty() {
            state.serialize_entry("attributeValue", &self.attribute_value)?;
        }
        if !wkt::internal::is_default(&self.boost_amount) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boostAmount", &__With(&self.boost_amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::FilterAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::RedirectAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.redirect_uri.is_empty() {
            state.serialize_entry("redirectUri", &self.redirect_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::SynonymsAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.synonyms.is_empty() {
            state.serialize_entry("synonyms", &self.synonyms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::control::PromoteAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if self.search_link_promotion.is_some() {
            state.serialize_entry("searchLinkPromotion", &self.search_link_promotion)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.control.is_some() {
            state.serialize_entry("control", &self.control)?;
        }
        if !self.control_id.is_empty() {
            state.serialize_entry("controlId", &self.control_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.control.is_some() {
            state.serialize_entry("control", &self.control)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListControlsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "control-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListControlsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.controls.is_empty() {
            state.serialize_entry("controls", &self.controls)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Conversation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Reply {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.context_documents.is_empty() {
            state.serialize_entry("contextDocuments", &self.context_documents)?;
        }
        if !self.active_document.is_empty() {
            state.serialize_entry("activeDocument", &self.active_document)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TextInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input.is_empty() {
            state.serialize_entry("input", &self.input)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConversationMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.user_input() {
            state.serialize_entry("userInput", value)?;
        }
        if let Some(value) = self.reply() {
            state.serialize_entry("reply", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConverseConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !wkt::internal::is_default(&self.safe_search) {
            state.serialize_entry("safeSearch", &self.safe_search)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if self.summary_spec.is_some() {
            state.serialize_entry("summarySpec", &self.summary_spec)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.boost_spec.is_some() {
            state.serialize_entry("boostSpec", &self.boost_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConverseConversationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reply.is_some() {
            state.serialize_entry("reply", &self.reply)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.search_results.is_empty() {
            state.serialize_entry("searchResults", &self.search_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversations.is_empty() {
            state.serialize_entry("conversations", &self.conversations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnswerQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.safety_spec.is_some() {
            state.serialize_entry("safetySpec", &self.safety_spec)?;
        }
        if self.related_questions_spec.is_some() {
            state.serialize_entry("relatedQuestionsSpec", &self.related_questions_spec)?;
        }
        if self.grounding_spec.is_some() {
            state.serialize_entry("groundingSpec", &self.grounding_spec)?;
        }
        if self.answer_generation_spec.is_some() {
            state.serialize_entry("answerGenerationSpec", &self.answer_generation_spec)?;
        }
        if self.search_spec.is_some() {
            state.serialize_entry("searchSpec", &self.search_spec)?;
        }
        if self.query_understanding_spec.is_some() {
            state.serialize_entry("queryUnderstandingSpec", &self.query_understanding_spec)?;
        }
        if !wkt::internal::is_default(&self.asynchronous_mode) {
            state.serialize_entry("asynchronousMode", &self.asynchronous_mode)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if self.end_user_spec.is_some() {
            state.serialize_entry("endUserSpec", &self.end_user_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::SafetySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable) {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self.safety_settings.is_empty() {
            state.serialize_entry("safetySettings", &self.safety_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::safety_spec::SafetySetting {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !wkt::internal::is_default(&self.threshold) {
            state.serialize_entry("threshold", &self.threshold)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::RelatedQuestionsSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable) {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::GroundingSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.include_grounding_supports) {
            state.serialize_entry("includeGroundingSupports", &self.include_grounding_supports)?;
        }
        if !wkt::internal::is_default(&self.filtering_level) {
            state.serialize_entry("filteringLevel", &self.filtering_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::AnswerGenerationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.model_spec.is_some() {
            state.serialize_entry("modelSpec", &self.model_spec)?;
        }
        if self.prompt_spec.is_some() {
            state.serialize_entry("promptSpec", &self.prompt_spec)?;
        }
        if !wkt::internal::is_default(&self.include_citations) {
            state.serialize_entry("includeCitations", &self.include_citations)?;
        }
        if !self.answer_language_code.is_empty() {
            state.serialize_entry("answerLanguageCode", &self.answer_language_code)?;
        }
        if !wkt::internal::is_default(&self.ignore_adversarial_query) {
            state.serialize_entry("ignoreAdversarialQuery", &self.ignore_adversarial_query)?;
        }
        if !wkt::internal::is_default(&self.ignore_non_answer_seeking_query) {
            state.serialize_entry(
                "ignoreNonAnswerSeekingQuery",
                &self.ignore_non_answer_seeking_query,
            )?;
        }
        if self.ignore_low_relevant_content.is_some() {
            state.serialize_entry(
                "ignoreLowRelevantContent",
                &self.ignore_low_relevant_content,
            )?;
        }
        if !wkt::internal::is_default(&self.ignore_jail_breaking_query) {
            state.serialize_entry("ignoreJailBreakingQuery", &self.ignore_jail_breaking_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::answer_generation_spec::ModelSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_version.is_empty() {
            state.serialize_entry("modelVersion", &self.model_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::answer_generation_spec::PromptSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.preamble.is_empty() {
            state.serialize_entry("preamble", &self.preamble)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::SearchSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.search_params() {
            state.serialize_entry("searchParams", value)?;
        }
        if let Some(value) = self.search_result_list() {
            state.serialize_entry("searchResultList", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::SearchParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_return_results) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxReturnResults", &__With(&self.max_return_results))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.boost_spec.is_some() {
            state.serialize_entry("boostSpec", &self.boost_spec)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.search_result_mode) {
            state.serialize_entry("searchResultMode", &self.search_result_mode)?;
        }
        if !self.data_store_specs.is_empty() {
            state.serialize_entry("dataStoreSpecs", &self.data_store_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::SearchResultList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.search_results.is_empty() {
            state.serialize_entry("searchResults", &self.search_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::search_spec::search_result_list::SearchResult
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.unstructured_document_info() {
            state.serialize_entry("unstructuredDocumentInfo", value)?;
        }
        if let Some(value) = self.chunk_info() {
            state.serialize_entry("chunkInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.document_contexts.is_empty() {
            state.serialize_entry("documentContexts", &self.document_contexts)?;
        }
        if !self.extractive_segments.is_empty() {
            state.serialize_entry("extractiveSegments", &self.extractive_segments)?;
        }
        if !self.extractive_answers.is_empty() {
            state.serialize_entry("extractiveAnswers", &self.extractive_answers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::DocumentContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveSegment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.chunk.is_empty() {
            state.serialize_entry("chunk", &self.chunk)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.document_metadata.is_some() {
            state.serialize_entry("documentMetadata", &self.document_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::QueryUnderstandingSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.query_classification_spec.is_some() {
            state.serialize_entry("queryClassificationSpec", &self.query_classification_spec)?;
        }
        if self.query_rephraser_spec.is_some() {
            state.serialize_entry("queryRephraserSpec", &self.query_rephraser_spec)?;
        }
        if !wkt::internal::is_default(&self.disable_spell_correction) {
            state.serialize_entry("disableSpellCorrection", &self.disable_spell_correction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::query_understanding_spec::QueryClassificationSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.types.is_empty() {
            state.serialize_entry("types", &self.types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::query_understanding_spec::QueryRephraserSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disable) {
            state.serialize_entry("disable", &self.disable)?;
        }
        if !wkt::internal::is_default(&self.max_rephrase_steps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxRephraseSteps", &__With(&self.max_rephrase_steps))?;
        }
        if self.model_spec.is_some() {
            state.serialize_entry("modelSpec", &self.model_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::query_understanding_spec::query_rephraser_spec::ModelSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::EndUserSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.end_user_metadata.is_empty() {
            state.serialize_entry("endUserMetadata", &self.end_user_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::answer_query_request::end_user_spec::EndUserMetaData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.chunk_info() {
            state.serialize_entry("chunkInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.document_metadata.is_some() {
            state.serialize_entry("documentMetadata", &self.document_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::answer_query_request::end_user_spec::end_user_meta_data::chunk_info::DocumentMetadata
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AnswerQueryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.answer.is_some() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if self.session.is_some() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.answer_query_token.is_empty() {
            state.serialize_entry("answerQueryToken", &self.answer_query_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "conversational-search-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetAnswerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session.is_some() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session.is_some() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.include_answer_details) {
            state.serialize_entry("includeAnswerDetails", &self.include_answer_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sessions.is_empty() {
            state.serialize_entry("sessions", &self.sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomTuningModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.model_version) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("modelVersion", &__With(&self.model_version))?;
        }
        if !wkt::internal::is_default(&self.model_state) {
            state.serialize_entry("modelState", &self.model_state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.training_start_time.is_some() {
            state.serialize_entry("trainingStartTime", &self.training_start_time)?;
        }
        if !self.metrics.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metrics", &__With(&self.metrics))?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DataStore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.industry_vertical) {
            state.serialize_entry("industryVertical", &self.industry_vertical)?;
        }
        if !self.solution_types.is_empty() {
            state.serialize_entry("solutionTypes", &self.solution_types)?;
        }
        if !self.default_schema_id.is_empty() {
            state.serialize_entry("defaultSchemaId", &self.default_schema_id)?;
        }
        if !wkt::internal::is_default(&self.content_config) {
            state.serialize_entry("contentConfig", &self.content_config)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.advanced_site_search_config.is_some() {
            state.serialize_entry(
                "advancedSiteSearchConfig",
                &self.advanced_site_search_config,
            )?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.cmek_config.is_some() {
            state.serialize_entry("cmekConfig", &self.cmek_config)?;
        }
        if self.billing_estimation.is_some() {
            state.serialize_entry("billingEstimation", &self.billing_estimation)?;
        }
        if !wkt::internal::is_default(&self.acl_enabled) {
            state.serialize_entry("aclEnabled", &self.acl_enabled)?;
        }
        if self.workspace_config.is_some() {
            state.serialize_entry("workspaceConfig", &self.workspace_config)?;
        }
        if self.document_processing_config.is_some() {
            state.serialize_entry("documentProcessingConfig", &self.document_processing_config)?;
        }
        if self.starting_schema.is_some() {
            state.serialize_entry("startingSchema", &self.starting_schema)?;
        }
        if self.healthcare_fhir_config.is_some() {
            state.serialize_entry("healthcareFhirConfig", &self.healthcare_fhir_config)?;
        }
        if !self.identity_mapping_store.is_empty() {
            state.serialize_entry("identityMappingStore", &self.identity_mapping_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::data_store::BillingEstimation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.structured_data_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("structuredDataSize", &__With(&self.structured_data_size))?;
        }
        if !wkt::internal::is_default(&self.unstructured_data_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "unstructuredDataSize",
                &__With(&self.unstructured_data_size),
            )?;
        }
        if !wkt::internal::is_default(&self.website_data_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("websiteDataSize", &__With(&self.website_data_size))?;
        }
        if self.structured_data_update_time.is_some() {
            state.serialize_entry(
                "structuredDataUpdateTime",
                &self.structured_data_update_time,
            )?;
        }
        if self.unstructured_data_update_time.is_some() {
            state.serialize_entry(
                "unstructuredDataUpdateTime",
                &self.unstructured_data_update_time,
            )?;
        }
        if self.website_data_update_time.is_some() {
            state.serialize_entry("websiteDataUpdateTime", &self.website_data_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AdvancedSiteSearchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disable_initial_index.is_some() {
            state.serialize_entry("disableInitialIndex", &self.disable_initial_index)?;
        }
        if self.disable_automatic_refresh.is_some() {
            state.serialize_entry("disableAutomaticRefresh", &self.disable_automatic_refresh)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WorkspaceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.dasher_customer_id.is_empty() {
            state.serialize_entry("dasherCustomerId", &self.dasher_customer_id)?;
        }
        if !self.super_admin_service_account.is_empty() {
            state.serialize_entry(
                "superAdminServiceAccount",
                &self.super_admin_service_account,
            )?;
        }
        if !self.super_admin_email_address.is_empty() {
            state.serialize_entry("superAdminEmailAddress", &self.super_admin_email_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateDataStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cmek_config_name() {
            state.serialize_entry("cmekConfigName", value)?;
        }
        if let Some(value) = self.disable_cmek() {
            state.serialize_entry("disableCmek", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.data_store.is_some() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self.data_store_id.is_empty() {
            state.serialize_entry("dataStoreId", &self.data_store_id)?;
        }
        if !wkt::internal::is_default(&self.create_advanced_site_search) {
            state.serialize_entry(
                "createAdvancedSiteSearch",
                &self.create_advanced_site_search,
            )?;
        }
        if !wkt::internal::is_default(&self.skip_default_schema_creation) {
            state.serialize_entry(
                "skipDefaultSchemaCreation",
                &self.skip_default_schema_creation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetDataStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateDataStoreMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDataStoresRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDataStoresResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteDataStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateDataStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.data_store.is_some() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteDataStoreMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Document {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.struct_data() {
            state.serialize_entry("structData", value)?;
        }
        if let Some(value) = self.json_data() {
            state.serialize_entry("jsonData", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.schema_id.is_empty() {
            state.serialize_entry("schemaId", &self.schema_id)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.parent_document_id.is_empty() {
            state.serialize_entry("parentDocumentId", &self.parent_document_id)?;
        }
        if self.derived_struct_data.is_some() {
            state.serialize_entry("derivedStructData", &self.derived_struct_data)?;
        }
        if self.acl_info.is_some() {
            state.serialize_entry("aclInfo", &self.acl_info)?;
        }
        if self.index_time.is_some() {
            state.serialize_entry("indexTime", &self.index_time)?;
        }
        if self.index_status.is_some() {
            state.serialize_entry("indexStatus", &self.index_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::document::Content {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.raw_bytes() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawBytes", &__With(value))?;
        }
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::document::AclInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.readers.is_empty() {
            state.serialize_entry("readers", &self.readers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::document::acl_info::AccessRestriction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.principals.is_empty() {
            state.serialize_entry("principals", &self.principals)?;
        }
        if !wkt::internal::is_default(&self.idp_wide) {
            state.serialize_entry("idpWide", &self.idp_wide)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "conversational-search-service",
    feature = "document-service",
    feature = "recommendation-service",
    feature = "search-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::document::IndexStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.index_time.is_some() {
            state.serialize_entry("indexTime", &self.index_time)?;
        }
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self.pending_message.is_empty() {
            state.serialize_entry("pendingMessage", &self.pending_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DocumentProcessingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.chunking_config.is_some() {
            state.serialize_entry("chunkingConfig", &self.chunking_config)?;
        }
        if self.default_parsing_config.is_some() {
            state.serialize_entry("defaultParsingConfig", &self.default_parsing_config)?;
        }
        if !self.parsing_config_overrides.is_empty() {
            state.serialize_entry("parsingConfigOverrides", &self.parsing_config_overrides)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::document_processing_config::ChunkingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.layout_based_chunking_config() {
            state.serialize_entry("layoutBasedChunkingConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::document_processing_config::chunking_config::LayoutBasedChunkingConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.chunk_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("chunkSize", &__With(&self.chunk_size))?;
        }
        if !wkt::internal::is_default(&self.include_ancestor_headings) {
            state.serialize_entry("includeAncestorHeadings", &self.include_ancestor_headings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::document_processing_config::ParsingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.digital_parsing_config() {
            state.serialize_entry("digitalParsingConfig", value)?;
        }
        if let Some(value) = self.ocr_parsing_config() {
            state.serialize_entry("ocrParsingConfig", value)?;
        }
        if let Some(value) = self.layout_parsing_config() {
            state.serialize_entry("layoutParsingConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::document_processing_config::parsing_config::DigitalParsingConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::document_processing_config::parsing_config::OcrParsingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enhanced_document_elements.is_empty() {
            state.serialize_entry("enhancedDocumentElements", &self.enhanced_document_elements)?;
        }
        if !wkt::internal::is_default(&self.use_native_text) {
            state.serialize_entry("useNativeText", &self.use_native_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "data-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::document_processing_config::parsing_config::LayoutParsingConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_table_annotation) {
            state.serialize_entry("enableTableAnnotation", &self.enable_table_annotation)?;
        }
        if !wkt::internal::is_default(&self.enable_image_annotation) {
            state.serialize_entry("enableImageAnnotation", &self.enable_image_annotation)?;
        }
        if !self.structured_content_types.is_empty() {
            state.serialize_entry("structuredContentTypes", &self.structured_content_types)?;
        }
        if !self.exclude_html_elements.is_empty() {
            state.serialize_entry("excludeHtmlElements", &self.exclude_html_elements)?;
        }
        if !self.exclude_html_classes.is_empty() {
            state.serialize_entry("excludeHtmlClasses", &self.exclude_html_classes)?;
        }
        if !self.exclude_html_ids.is_empty() {
            state.serialize_entry("excludeHtmlIds", &self.exclude_html_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.document_id.is_empty() {
            state.serialize_entry("documentId", &self.document_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchGetDocumentsMetadataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.matcher.is_some() {
            state.serialize_entry("matcher", &self.matcher)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::batch_get_documents_metadata_request::UrisMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::batch_get_documents_metadata_request::FhirMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fhir_resources.is_empty() {
            state.serialize_entry("fhirResources", &self.fhir_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::batch_get_documents_metadata_request::Matcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uris_matcher() {
            state.serialize_entry("urisMatcher", value)?;
        }
        if let Some(value) = self.fhir_matcher() {
            state.serialize_entry("fhirMatcher", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchGetDocumentsMetadataResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents_metadata.is_empty() {
            state.serialize_entry("documentsMetadata", &self.documents_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::batch_get_documents_metadata_response::DocumentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.matcher_value.is_some() {
            state.serialize_entry("matcherValue", &self.matcher_value)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.last_refreshed_time.is_some() {
            state.serialize_entry("lastRefreshedTime", &self.last_refreshed_time)?;
        }
        if !self.data_ingestion_source.is_empty() {
            state.serialize_entry("dataIngestionSource", &self.data_ingestion_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::batch_get_documents_metadata_response::document_metadata::MatcherValue
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if let Some(value) = self.fhir_resource() {
            state.serialize_entry("fhirResource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Engine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.chat_engine_config() {
            state.serialize_entry("chatEngineConfig", value)?;
        }
        if let Some(value) = self.search_engine_config() {
            state.serialize_entry("searchEngineConfig", value)?;
        }
        if let Some(value) = self.media_recommendation_engine_config() {
            state.serialize_entry("mediaRecommendationEngineConfig", value)?;
        }
        if let Some(value) = self.chat_engine_metadata() {
            state.serialize_entry("chatEngineMetadata", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.data_store_ids.is_empty() {
            state.serialize_entry("dataStoreIds", &self.data_store_ids)?;
        }
        if !wkt::internal::is_default(&self.solution_type) {
            state.serialize_entry("solutionType", &self.solution_type)?;
        }
        if !wkt::internal::is_default(&self.industry_vertical) {
            state.serialize_entry("industryVertical", &self.industry_vertical)?;
        }
        if self.common_config.is_some() {
            state.serialize_entry("commonConfig", &self.common_config)?;
        }
        if !wkt::internal::is_default(&self.disable_analytics) {
            state.serialize_entry("disableAnalytics", &self.disable_analytics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::SearchEngineConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.search_tier) {
            state.serialize_entry("searchTier", &self.search_tier)?;
        }
        if !self.search_add_ons.is_empty() {
            state.serialize_entry("searchAddOns", &self.search_add_ons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::MediaRecommendationEngineConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.optimization_objective.is_empty() {
            state.serialize_entry("optimizationObjective", &self.optimization_objective)?;
        }
        if self.optimization_objective_config.is_some() {
            state.serialize_entry(
                "optimizationObjectiveConfig",
                &self.optimization_objective_config,
            )?;
        }
        if !wkt::internal::is_default(&self.training_state) {
            state.serialize_entry("trainingState", &self.training_state)?;
        }
        if self.engine_features_config.is_some() {
            state.serialize_entry("engineFeaturesConfig", &self.engine_features_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::engine::media_recommendation_engine_config::OptimizationObjectiveConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_field.is_empty() {
            state.serialize_entry("targetField", &self.target_field)?;
        }
        if !wkt::internal::is_default(&self.target_field_value_float) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "targetFieldValueFloat",
                &__With(&self.target_field_value_float),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::engine::media_recommendation_engine_config::EngineFeaturesConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.recommended_for_you_config() {
            state.serialize_entry("recommendedForYouConfig", value)?;
        }
        if let Some(value) = self.most_popular_config() {
            state.serialize_entry("mostPopularConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::engine::media_recommendation_engine_config::RecommendedForYouFeatureConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.context_event_type.is_empty() {
            state.serialize_entry("contextEventType", &self.context_event_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::engine::media_recommendation_engine_config::MostPopularFeatureConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.time_window_days) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("timeWindowDays", &__With(&self.time_window_days))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::ChatEngineConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent_creation_config.is_some() {
            state.serialize_entry("agentCreationConfig", &self.agent_creation_config)?;
        }
        if !self.dialogflow_agent_to_link.is_empty() {
            state.serialize_entry("dialogflowAgentToLink", &self.dialogflow_agent_to_link)?;
        }
        if !wkt::internal::is_default(&self.allow_cross_region) {
            state.serialize_entry("allowCrossRegion", &self.allow_cross_region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::chat_engine_config::AgentCreationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.business.is_empty() {
            state.serialize_entry("business", &self.business)?;
        }
        if !self.default_language_code.is_empty() {
            state.serialize_entry("defaultLanguageCode", &self.default_language_code)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::CommonConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.company_name.is_empty() {
            state.serialize_entry("companyName", &self.company_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::engine::ChatEngineMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dialogflow_agent.is_empty() {
            state.serialize_entry("dialogflowAgent", &self.dialogflow_agent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEngineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.engine.is_some() {
            state.serialize_entry("engine", &self.engine)?;
        }
        if !self.engine_id.is_empty() {
            state.serialize_entry("engineId", &self.engine_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateEngineMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEngineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteEngineMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetEngineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnginesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListEnginesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.engines.is_empty() {
            state.serialize_entry("engines", &self.engines)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateEngineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.engine.is_some() {
            state.serialize_entry("engine", &self.engine)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GroundedGenerationContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.parts.is_empty() {
            state.serialize_entry("parts", &self.parts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::grounded_generation_content::Part {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateGroundedContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.system_instruction.is_some() {
            state.serialize_entry("systemInstruction", &self.system_instruction)?;
        }
        if !self.contents.is_empty() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if self.generation_spec.is_some() {
            state.serialize_entry("generationSpec", &self.generation_spec)?;
        }
        if self.grounding_spec.is_some() {
            state.serialize_entry("groundingSpec", &self.grounding_spec)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_request::GenerationSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.temperature.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("temperature", &__With(&self.temperature))?;
        }
        if self.top_p.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topP", &__With(&self.top_p))?;
        }
        if self.top_k.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topK", &__With(&self.top_k))?;
        }
        if self.frequency_penalty.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("frequencyPenalty", &__With(&self.frequency_penalty))?;
        }
        if self.seed.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("seed", &__With(&self.seed))?;
        }
        if self.presence_penalty.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("presencePenalty", &__With(&self.presence_penalty))?;
        }
        if self.max_output_tokens.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxOutputTokens", &__With(&self.max_output_tokens))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_request::DynamicRetrievalConfiguration
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.predictor.is_some() {
            state.serialize_entry("predictor", &self.predictor)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.version) {
            state.serialize_entry("version", &self.version)?;
        }
        if self.threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("threshold", &__With(&self.threshold))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_request::GroundingSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.search_source() {
            state.serialize_entry("searchSource", value)?;
        }
        if let Some(value) = self.google_search_source() {
            state.serialize_entry("googleSearchSource", value)?;
        }
        if let Some(value) = self.enterprise_web_retrieval_source() {
            state.serialize_entry("enterpriseWebRetrievalSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_request::grounding_source::InlineSource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grounding_facts.is_empty() {
            state.serialize_entry("groundingFacts", &self.grounding_facts)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_request::grounding_source::SearchSource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if !wkt::internal::is_default(&self.max_result_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResultCount", &__With(&self.max_result_count))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.safe_search) {
            state.serialize_entry("safeSearch", &self.safe_search)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_request::grounding_source::GoogleSearchSource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dynamic_retrieval_config.is_some() {
            state.serialize_entry("dynamicRetrievalConfig", &self.dynamic_retrieval_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_request::grounding_source::EnterpriseWebRetrievalSource
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_request::GroundingSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grounding_sources.is_empty() {
            state.serialize_entry("groundingSources", &self.grounding_sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GenerateGroundedContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.candidates.is_empty() {
            state.serialize_entry("candidates", &self.candidates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_response::Candidate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.grounding_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("groundingScore", &__With(&self.grounding_score))?;
        }
        if self.grounding_metadata.is_some() {
            state.serialize_entry("groundingMetadata", &self.grounding_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_response::candidate::GroundingMetadata
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.retrieval_metadata.is_empty() {
            state.serialize_entry("retrievalMetadata", &self.retrieval_metadata)?;
        }
        if !self.support_chunks.is_empty() {
            state.serialize_entry("supportChunks", &self.support_chunks)?;
        }
        if !self.web_search_queries.is_empty() {
            state.serialize_entry("webSearchQueries", &self.web_search_queries)?;
        }
        if self.search_entry_point.is_some() {
            state.serialize_entry("searchEntryPoint", &self.search_entry_point)?;
        }
        if !self.grounding_support.is_empty() {
            state.serialize_entry("groundingSupport", &self.grounding_support)?;
        }
        if !self.images.is_empty() {
            state.serialize_entry("images", &self.images)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source) {
            state.serialize_entry("source", &self.source)?;
        }
        if self.dynamic_retrieval_metadata.is_some() {
            state.serialize_entry("dynamicRetrievalMetadata", &self.dynamic_retrieval_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.predictor_metadata.is_some() {
            state.serialize_entry("predictorMetadata", &self.predictor_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.version) {
            state.serialize_entry("version", &self.version)?;
        }
        if self.prediction.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::option::Option<wkt::internal::F32> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("prediction", &__With(&self.prediction))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rendered_content.is_empty() {
            state.serialize_entry("renderedContent", &self.rendered_content)?;
        }
        if !self.sdk_blob.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sdkBlob", &__With(&self.sdk_blob))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.claim_text.is_empty() {
            state.serialize_entry("claimText", &self.claim_text)?;
        }
        if !self.support_chunk_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("supportChunkIndices", &__With(&self.support_chunk_indices))?;
        }
        if self.support_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("supportScore", &__With(&self.support_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if self.thumbnail.is_some() {
            state.serialize_entry("thumbnail", &self.thumbnail)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.width) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("width", &__With(&self.width))?;
        }
        if !wkt::internal::is_default(&self.height) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("height", &__With(&self.height))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CheckGroundingSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.citation_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("citationThreshold", &__With(&self.citation_threshold))?;
        }
        if self.enable_claim_level_score.is_some() {
            state.serialize_entry("enableClaimLevelScore", &self.enable_claim_level_score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CheckGroundingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grounding_config.is_empty() {
            state.serialize_entry("groundingConfig", &self.grounding_config)?;
        }
        if !self.answer_candidate.is_empty() {
            state.serialize_entry("answerCandidate", &self.answer_candidate)?;
        }
        if !self.facts.is_empty() {
            state.serialize_entry("facts", &self.facts)?;
        }
        if self.grounding_spec.is_some() {
            state.serialize_entry("groundingSpec", &self.grounding_spec)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CheckGroundingResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.support_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("supportScore", &__With(&self.support_score))?;
        }
        if !self.cited_chunks.is_empty() {
            state.serialize_entry("citedChunks", &self.cited_chunks)?;
        }
        if !self.cited_facts.is_empty() {
            state.serialize_entry("citedFacts", &self.cited_facts)?;
        }
        if !self.claims.is_empty() {
            state.serialize_entry("claims", &self.claims)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::check_grounding_response::CheckGroundingFactChunk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.chunk_text.is_empty() {
            state.serialize_entry("chunkText", &self.chunk_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::check_grounding_response::Claim {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_pos.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("startPos", &__With(&self.start_pos))?;
        }
        if self.end_pos.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("endPos", &__With(&self.end_pos))?;
        }
        if !self.claim_text.is_empty() {
            state.serialize_entry("claimText", &self.claim_text)?;
        }
        if !self.citation_indices.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("citationIndices", &__With(&self.citation_indices))?;
        }
        if self.grounding_check_required.is_some() {
            state.serialize_entry("groundingCheckRequired", &self.grounding_check_required)?;
        }
        if self.score.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GroundingFact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fact_text.is_empty() {
            state.serialize_entry("factText", &self.fact_text)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "grounded-generation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FactChunk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.chunk_text.is_empty() {
            state.serialize_entry("chunkText", &self.chunk_text)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if !self.source_metadata.is_empty() {
            state.serialize_entry("sourceMetadata", &self.source_metadata)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IdentityMappingStore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.cmek_config.is_some() {
            state.serialize_entry("cmekConfig", &self.cmek_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IdentityMappingEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.user_id() {
            state.serialize_entry("userId", value)?;
        }
        if let Some(value) = self.group_id() {
            state.serialize_entry("groupId", value)?;
        }
        if !self.external_identity.is_empty() {
            state.serialize_entry("externalIdentity", &self.external_identity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateIdentityMappingStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cmek_config_name() {
            state.serialize_entry("cmekConfigName", value)?;
        }
        if let Some(value) = self.disable_cmek() {
            state.serialize_entry("disableCmek", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.identity_mapping_store_id.is_empty() {
            state.serialize_entry("identityMappingStoreId", &self.identity_mapping_store_id)?;
        }
        if self.identity_mapping_store.is_some() {
            state.serialize_entry("identityMappingStore", &self.identity_mapping_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetIdentityMappingStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteIdentityMappingStoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportIdentityMappingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if !self.identity_mapping_store.is_empty() {
            state.serialize_entry("identityMappingStore", &self.identity_mapping_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_identity_mappings_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_mapping_entries.is_empty() {
            state.serialize_entry("identityMappingEntries", &self.identity_mapping_entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportIdentityMappingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeIdentityMappingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if !self.identity_mapping_store.is_empty() {
            state.serialize_entry("identityMappingStore", &self.identity_mapping_store)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.force.is_some() {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::purge_identity_mappings_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_mapping_entries.is_empty() {
            state.serialize_entry("identityMappingEntries", &self.identity_mapping_entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIdentityMappingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_mapping_store.is_empty() {
            state.serialize_entry("identityMappingStore", &self.identity_mapping_store)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIdentityMappingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_mapping_entries.is_empty() {
            state.serialize_entry("identityMappingEntries", &self.identity_mapping_entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIdentityMappingStoresRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListIdentityMappingStoresResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.identity_mapping_stores.is_empty() {
            state.serialize_entry("identityMappingStores", &self.identity_mapping_stores)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::IdentityMappingEntryOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !wkt::internal::is_default(&self.total_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCount", &__With(&self.total_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "identity-mapping-store-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteIdentityMappingStoreMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "completion-service",
    feature = "document-service",
    feature = "user-event-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_uris.is_empty() {
            state.serialize_entry("inputUris", &self.input_uris)?;
        }
        if !self.data_schema.is_empty() {
            state.serialize_entry("dataSchema", &self.data_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "completion-service",
    feature = "document-service",
    feature = "user-event-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BigQuerySource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.partition_date() {
            state.serialize_entry("partitionDate", value)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !self.data_schema.is_empty() {
            state.serialize_entry("dataSchema", &self.data_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SpannerSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !wkt::internal::is_default(&self.enable_data_boost) {
            state.serialize_entry("enableDataBoost", &self.enable_data_boost)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BigtableOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_field_name.is_empty() {
            state.serialize_entry("keyFieldName", &self.key_field_name)?;
        }
        if !self.families.is_empty() {
            state.serialize_entry("families", &self.families)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::bigtable_options::BigtableColumnFamily {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.encoding) {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::bigtable_options::BigtableColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.qualifier.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("qualifier", &__With(&self.qualifier))?;
        }
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.encoding) {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BigtableSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if self.bigtable_options.is_some() {
            state.serialize_entry("bigtableOptions", &self.bigtable_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FhirStoreSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fhir_store.is_empty() {
            state.serialize_entry("fhirStore", &self.fhir_store)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !self.resource_types.is_empty() {
            state.serialize_entry("resourceTypes", &self.resource_types)?;
        }
        if !wkt::internal::is_default(&self.update_from_latest_predefined_schema) {
            state.serialize_entry(
                "updateFromLatestPredefinedSchema",
                &self.update_from_latest_predefined_schema,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CloudSqlSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !wkt::internal::is_default(&self.offload) {
            state.serialize_entry("offload", &self.offload)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AlloyDbSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.location_id.is_empty() {
            state.serialize_entry("locationId", &self.location_id)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirestoreSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.database_id.is_empty() {
            state.serialize_entry("databaseId", &self.database_id)?;
        }
        if !self.collection_id.is_empty() {
            state.serialize_entry("collectionId", &self.collection_id)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "completion-service",
    feature = "document-service",
    feature = "search-tuning-service",
    feature = "user-event-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportErrorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_prefix() {
            state.serialize_entry("gcsPrefix", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportUserEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.bigquery_source() {
            state.serialize_entry("bigquerySource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_user_events_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_events.is_empty() {
            state.serialize_entry("userEvents", &self.user_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportUserEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !wkt::internal::is_default(&self.joined_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("joinedEventsCount", &__With(&self.joined_events_count))?;
        }
        if !wkt::internal::is_default(&self.unjoined_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("unjoinedEventsCount", &__With(&self.unjoined_events_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportUserEventsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !wkt::internal::is_default(&self.total_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCount", &__With(&self.total_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.bigquery_source() {
            state.serialize_entry("bigquerySource", value)?;
        }
        if let Some(value) = self.fhir_store_source() {
            state.serialize_entry("fhirStoreSource", value)?;
        }
        if let Some(value) = self.spanner_source() {
            state.serialize_entry("spannerSource", value)?;
        }
        if let Some(value) = self.cloud_sql_source() {
            state.serialize_entry("cloudSqlSource", value)?;
        }
        if let Some(value) = self.firestore_source() {
            state.serialize_entry("firestoreSource", value)?;
        }
        if let Some(value) = self.alloy_db_source() {
            state.serialize_entry("alloyDbSource", value)?;
        }
        if let Some(value) = self.bigtable_source() {
            state.serialize_entry("bigtableSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !wkt::internal::is_default(&self.reconciliation_mode) {
            state.serialize_entry("reconciliationMode", &self.reconciliation_mode)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.auto_generate_ids) {
            state.serialize_entry("autoGenerateIds", &self.auto_generate_ids)?;
        }
        if !self.id_field.is_empty() {
            state.serialize_entry("idField", &self.id_field)?;
        }
        if !wkt::internal::is_default(&self.force_refresh_content) {
            state.serialize_entry("forceRefreshContent", &self.force_refresh_content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_documents_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportSuggestionDenyListEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_suggestion_deny_list_entries_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportSuggestionDenyListEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !wkt::internal::is_default(&self.imported_entries_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "importedEntriesCount",
                &__With(&self.imported_entries_count),
            )?;
        }
        if !wkt::internal::is_default(&self.failed_entries_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedEntriesCount", &__With(&self.failed_entries_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportSuggestionDenyListEntriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportCompletionSuggestionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.bigquery_source() {
            state.serialize_entry("bigquerySource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::import_completion_suggestions_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.suggestions.is_empty() {
            state.serialize_entry("suggestions", &self.suggestions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportCompletionSuggestionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImportCompletionSuggestionsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "project-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Project {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.provision_completion_time.is_some() {
            state.serialize_entry("provisionCompletionTime", &self.provision_completion_time)?;
        }
        if !self.service_terms_map.is_empty() {
            state.serialize_entry("serviceTermsMap", &self.service_terms_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "project-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::project::ServiceTerms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.accept_time.is_some() {
            state.serialize_entry("acceptTime", &self.accept_time)?;
        }
        if self.decline_time.is_some() {
            state.serialize_entry("declineTime", &self.decline_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "project-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProvisionProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.accept_data_use_terms) {
            state.serialize_entry("acceptDataUseTerms", &self.accept_data_use_terms)?;
        }
        if !self.data_use_terms_version.is_empty() {
            state.serialize_entry("dataUseTermsVersion", &self.data_use_terms_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "project-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProvisionProjectMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeUserEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeUserEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purge_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("purgeCount", &__With(&self.purge_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeUserEventsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeErrorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_prefix() {
            state.serialize_entry("gcsPrefix", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::purge_documents_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purge_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("purgeCount", &__With(&self.purge_count))?;
        }
        if !self.purge_sample.is_empty() {
            state.serialize_entry("purgeSample", &self.purge_sample)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "document-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeDocumentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !wkt::internal::is_default(&self.ignored_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ignoredCount", &__With(&self.ignored_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeSuggestionDenyListEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeSuggestionDenyListEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purge_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("purgeCount", &__With(&self.purge_count))?;
        }
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeSuggestionDenyListEntriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeCompletionSuggestionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeCompletionSuggestionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purge_succeeded) {
            state.serialize_entry("purgeSucceeded", &self.purge_succeeded)?;
        }
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "completion-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PurgeCompletionSuggestionsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "rank-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RankingRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "rank-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RankRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ranking_config.is_empty() {
            state.serialize_entry("rankingConfig", &self.ranking_config)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.top_n) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("topN", &__With(&self.top_n))?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.records.is_empty() {
            state.serialize_entry("records", &self.records)?;
        }
        if !wkt::internal::is_default(&self.ignore_record_details_in_response) {
            state.serialize_entry(
                "ignoreRecordDetailsInResponse",
                &self.ignore_record_details_in_response,
            )?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "rank-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RankResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.records.is_empty() {
            state.serialize_entry("records", &self.records)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "recommendation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RecommendRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if self.user_event.is_some() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.params.is_empty() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "recommendation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RecommendResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.missing_ids.is_empty() {
            state.serialize_entry("missingIds", &self.missing_ids)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "recommendation-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::recommend_response::RecommendationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SafetyRating {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !wkt::internal::is_default(&self.probability) {
            state.serialize_entry("probability", &self.probability)?;
        }
        if !wkt::internal::is_default(&self.probability_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("probabilityScore", &__With(&self.probability_score))?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !wkt::internal::is_default(&self.severity_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("severityScore", &__With(&self.severity_score))?;
        }
        if !wkt::internal::is_default(&self.blocked) {
            state.serialize_entry("blocked", &self.blocked)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "data-store-service", feature = "schema-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Schema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.struct_schema() {
            state.serialize_entry("structSchema", value)?;
        }
        if let Some(value) = self.json_schema() {
            state.serialize_entry("jsonSchema", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSchemasRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListSchemasResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.schemas.is_empty() {
            state.serialize_entry("schemas", &self.schemas)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.schema_id.is_empty() {
            state.serialize_entry("schemaId", &self.schema_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schema.is_some() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSchemaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSchemaMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateSchemaMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "schema-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSchemaMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if !self.branch.is_empty() {
            state.serialize_entry("branch", &self.branch)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if self.image_query.is_some() {
            state.serialize_entry("imageQuery", &self.image_query)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if !wkt::internal::is_default(&self.one_box_page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("oneBoxPageSize", &__With(&self.one_box_page_size))?;
        }
        if !self.data_store_specs.is_empty() {
            state.serialize_entry("dataStoreSpecs", &self.data_store_specs)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.canonical_filter.is_empty() {
            state.serialize_entry("canonicalFilter", &self.canonical_filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if self.user_info.is_some() {
            state.serialize_entry("userInfo", &self.user_info)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.facet_specs.is_empty() {
            state.serialize_entry("facetSpecs", &self.facet_specs)?;
        }
        if self.boost_spec.is_some() {
            state.serialize_entry("boostSpec", &self.boost_spec)?;
        }
        if !self.params.is_empty() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.query_expansion_spec.is_some() {
            state.serialize_entry("queryExpansionSpec", &self.query_expansion_spec)?;
        }
        if self.spell_correction_spec.is_some() {
            state.serialize_entry("spellCorrectionSpec", &self.spell_correction_spec)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if self.content_search_spec.is_some() {
            state.serialize_entry("contentSearchSpec", &self.content_search_spec)?;
        }
        if !wkt::internal::is_default(&self.safe_search) {
            state.serialize_entry("safeSearch", &self.safe_search)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if self.search_as_you_type_spec.is_some() {
            state.serialize_entry("searchAsYouTypeSpec", &self.search_as_you_type_spec)?;
        }
        if self.display_spec.is_some() {
            state.serialize_entry("displaySpec", &self.display_spec)?;
        }
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.session_spec.is_some() {
            state.serialize_entry("sessionSpec", &self.session_spec)?;
        }
        if !wkt::internal::is_default(&self.relevance_threshold) {
            state.serialize_entry("relevanceThreshold", &self.relevance_threshold)?;
        }
        if self.relevance_score_spec.is_some() {
            state.serialize_entry("relevanceScoreSpec", &self.relevance_score_spec)?;
        }
        if !self.ranking_expression.is_empty() {
            state.serialize_entry("rankingExpression", &self.ranking_expression)?;
        }
        if !wkt::internal::is_default(&self.ranking_expression_backend) {
            state.serialize_entry("rankingExpressionBackend", &self.ranking_expression_backend)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::ImageQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.image_bytes() {
            state.serialize_entry("imageBytes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::DataStoreSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.boost_spec.is_some() {
            state.serialize_entry("boostSpec", &self.boost_spec)?;
        }
        if !self.custom_search_operators.is_empty() {
            state.serialize_entry("customSearchOperators", &self.custom_search_operators)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::FacetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.facet_key.is_some() {
            state.serialize_entry("facetKey", &self.facet_key)?;
        }
        if !wkt::internal::is_default(&self.limit) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("limit", &__With(&self.limit))?;
        }
        if !self.excluded_filter_keys.is_empty() {
            state.serialize_entry("excludedFilterKeys", &self.excluded_filter_keys)?;
        }
        if !wkt::internal::is_default(&self.enable_dynamic_position) {
            state.serialize_entry("enableDynamicPosition", &self.enable_dynamic_position)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::facet_spec::FacetKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.intervals.is_empty() {
            state.serialize_entry("intervals", &self.intervals)?;
        }
        if !self.restricted_values.is_empty() {
            state.serialize_entry("restrictedValues", &self.restricted_values)?;
        }
        if !self.prefixes.is_empty() {
            state.serialize_entry("prefixes", &self.prefixes)?;
        }
        if !self.contains.is_empty() {
            state.serialize_entry("contains", &self.contains)?;
        }
        if !wkt::internal::is_default(&self.case_insensitive) {
            state.serialize_entry("caseInsensitive", &self.case_insensitive)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::BoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition_boost_specs.is_empty() {
            state.serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::boost_spec::ConditionBoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if self.boost_control_spec.is_some() {
            state.serialize_entry("boostControlSpec", &self.boost_control_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::search_request::boost_spec::condition_boost_spec::BoostControlSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.field_name.is_empty() {
            state.serialize_entry("fieldName", &self.field_name)?;
        }
        if !wkt::internal::is_default(&self.attribute_type) {
            state.serialize_entry("attributeType", &self.attribute_type)?;
        }
        if !wkt::internal::is_default(&self.interpolation_type) {
            state.serialize_entry("interpolationType", &self.interpolation_type)?;
        }
        if !self.control_points.is_empty() {
            state.serialize_entry("controlPoints", &self.control_points)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::search_request::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute_value.is_empty() {
            state.serialize_entry("attributeValue", &self.attribute_value)?;
        }
        if !wkt::internal::is_default(&self.boost_amount) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boostAmount", &__With(&self.boost_amount))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::QueryExpansionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.condition) {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !wkt::internal::is_default(&self.pin_unexpanded_results) {
            state.serialize_entry("pinUnexpandedResults", &self.pin_unexpanded_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::SpellCorrectionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::ContentSearchSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.snippet_spec.is_some() {
            state.serialize_entry("snippetSpec", &self.snippet_spec)?;
        }
        if self.summary_spec.is_some() {
            state.serialize_entry("summarySpec", &self.summary_spec)?;
        }
        if self.extractive_content_spec.is_some() {
            state.serialize_entry("extractiveContentSpec", &self.extractive_content_spec)?;
        }
        if !wkt::internal::is_default(&self.search_result_mode) {
            state.serialize_entry("searchResultMode", &self.search_result_mode)?;
        }
        if self.chunk_spec.is_some() {
            state.serialize_entry("chunkSpec", &self.chunk_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::content_search_spec::SnippetSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_snippet_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSnippetCount", &__With(&self.max_snippet_count))?;
        }
        if !wkt::internal::is_default(&self.reference_only) {
            state.serialize_entry("referenceOnly", &self.reference_only)?;
        }
        if !wkt::internal::is_default(&self.return_snippet) {
            state.serialize_entry("returnSnippet", &self.return_snippet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::content_search_spec::SummarySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.summary_result_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("summaryResultCount", &__With(&self.summary_result_count))?;
        }
        if !wkt::internal::is_default(&self.include_citations) {
            state.serialize_entry("includeCitations", &self.include_citations)?;
        }
        if !wkt::internal::is_default(&self.ignore_adversarial_query) {
            state.serialize_entry("ignoreAdversarialQuery", &self.ignore_adversarial_query)?;
        }
        if !wkt::internal::is_default(&self.ignore_non_summary_seeking_query) {
            state.serialize_entry(
                "ignoreNonSummarySeekingQuery",
                &self.ignore_non_summary_seeking_query,
            )?;
        }
        if !wkt::internal::is_default(&self.ignore_low_relevant_content) {
            state.serialize_entry(
                "ignoreLowRelevantContent",
                &self.ignore_low_relevant_content,
            )?;
        }
        if !wkt::internal::is_default(&self.ignore_jail_breaking_query) {
            state.serialize_entry("ignoreJailBreakingQuery", &self.ignore_jail_breaking_query)?;
        }
        if self.model_prompt_spec.is_some() {
            state.serialize_entry("modelPromptSpec", &self.model_prompt_spec)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.model_spec.is_some() {
            state.serialize_entry("modelSpec", &self.model_spec)?;
        }
        if !wkt::internal::is_default(&self.use_semantic_chunks) {
            state.serialize_entry("useSemanticChunks", &self.use_semantic_chunks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::search_request::content_search_spec::summary_spec::ModelPromptSpec
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.preamble.is_empty() {
            state.serialize_entry("preamble", &self.preamble)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::content_search_spec::summary_spec::ModelSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::content_search_spec::ExtractiveContentSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_extractive_answer_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxExtractiveAnswerCount",
                &__With(&self.max_extractive_answer_count),
            )?;
        }
        if !wkt::internal::is_default(&self.max_extractive_segment_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxExtractiveSegmentCount",
                &__With(&self.max_extractive_segment_count),
            )?;
        }
        if !wkt::internal::is_default(&self.return_extractive_segment_score) {
            state.serialize_entry(
                "returnExtractiveSegmentScore",
                &self.return_extractive_segment_score,
            )?;
        }
        if !wkt::internal::is_default(&self.num_previous_segments) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numPreviousSegments", &__With(&self.num_previous_segments))?;
        }
        if !wkt::internal::is_default(&self.num_next_segments) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numNextSegments", &__With(&self.num_next_segments))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::content_search_spec::ChunkSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.num_previous_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numPreviousChunks", &__With(&self.num_previous_chunks))?;
        }
        if !wkt::internal::is_default(&self.num_next_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numNextChunks", &__With(&self.num_next_chunks))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::SearchAsYouTypeSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.condition) {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::DisplaySpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.match_highlighting_condition) {
            state.serialize_entry(
                "matchHighlightingCondition",
                &self.match_highlighting_condition,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::SessionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_id.is_empty() {
            state.serialize_entry("queryId", &self.query_id)?;
        }
        if self.search_result_persistence_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "searchResultPersistenceCount",
                &__With(&self.search_result_persistence_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "search-service",
    feature = "serving-config-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_request::RelevanceScoreSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.return_relevance_score) {
            state.serialize_entry("returnRelevanceScore", &self.return_relevance_score)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.facets.is_empty() {
            state.serialize_entry("facets", &self.facets)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.redirect_uri.is_empty() {
            state.serialize_entry("redirectUri", &self.redirect_uri)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.corrected_query.is_empty() {
            state.serialize_entry("correctedQuery", &self.corrected_query)?;
        }
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if self.query_expansion_info.is_some() {
            state.serialize_entry("queryExpansionInfo", &self.query_expansion_info)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if !self.search_link_promotions.is_empty() {
            state.serialize_entry("searchLinkPromotions", &self.search_link_promotions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::SearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.chunk.is_some() {
            state.serialize_entry("chunk", &self.chunk)?;
        }
        if !self.model_scores.is_empty() {
            state.serialize_entry("modelScores", &self.model_scores)?;
        }
        if self.rank_signals.is_some() {
            state.serialize_entry("rankSignals", &self.rank_signals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::search_result::RankSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.keyword_similarity_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "keywordSimilarityScore",
                &__With(&self.keyword_similarity_score),
            )?;
        }
        if self.relevance_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("relevanceScore", &__With(&self.relevance_score))?;
        }
        if self.semantic_similarity_score.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "semanticSimilarityScore",
                &__With(&self.semantic_similarity_score),
            )?;
        }
        if self.pctr_rank.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pctrRank", &__With(&self.pctr_rank))?;
        }
        if self.topicality_rank.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topicalityRank", &__With(&self.topicality_rank))?;
        }
        if self.document_age.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("documentAge", &__With(&self.document_age))?;
        }
        if self.boosting_factor.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("boostingFactor", &__With(&self.boosting_factor))?;
        }
        if !wkt::internal::is_default(&self.default_rank) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("defaultRank", &__With(&self.default_rank))?;
        }
        if !self.custom_signals.is_empty() {
            state.serialize_entry("customSignals", &self.custom_signals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::search_result::rank_signals::CustomSignal {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::Facet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !wkt::internal::is_default(&self.dynamic_facet) {
            state.serialize_entry("dynamicFacet", &self.dynamic_facet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::facet::FacetValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.value() {
            state.serialize_entry("value", value)?;
        }
        if let Some(value) = self.interval() {
            state.serialize_entry("interval", value)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::Summary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summary_text.is_empty() {
            state.serialize_entry("summaryText", &self.summary_text)?;
        }
        if !self.summary_skipped_reasons.is_empty() {
            state.serialize_entry("summarySkippedReasons", &self.summary_skipped_reasons)?;
        }
        if self.safety_attributes.is_some() {
            state.serialize_entry("safetyAttributes", &self.safety_attributes)?;
        }
        if self.summary_with_metadata.is_some() {
            state.serialize_entry("summaryWithMetadata", &self.summary_with_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::SafetyAttributes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.scores.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("scores", &__With(&self.scores))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::CitationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.citations.is_empty() {
            state.serialize_entry("citations", &self.citations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::Citation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.start_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startIndex", &__With(&self.start_index))?;
        }
        if !wkt::internal::is_default(&self.end_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("endIndex", &__With(&self.end_index))?;
        }
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::CitationSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.reference_index) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("referenceIndex", &__With(&self.reference_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::Reference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.document.is_empty() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.chunk_contents.is_empty() {
            state.serialize_entry("chunkContents", &self.chunk_contents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::reference::ChunkContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.page_identifier.is_empty() {
            state.serialize_entry("pageIdentifier", &self.page_identifier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::summary::SummaryWithMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if self.citation_metadata.is_some() {
            state.serialize_entry("citationMetadata", &self.citation_metadata)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::QueryExpansionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.expanded_query) {
            state.serialize_entry("expandedQuery", &self.expanded_query)?;
        }
        if !wkt::internal::is_default(&self.pinned_result_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pinnedResultCount", &__With(&self.pinned_result_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "search-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::search_response::SessionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.query_id.is_empty() {
            state.serialize_entry("queryId", &self.query_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListCustomModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListCustomModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TrainCustomModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_training_input() {
            state.serialize_entry("gcsTrainingInput", value)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !self.model_type.is_empty() {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::train_custom_model_request::GcsTrainingInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.corpus_data_path.is_empty() {
            state.serialize_entry("corpusDataPath", &self.corpus_data_path)?;
        }
        if !self.query_data_path.is_empty() {
            state.serialize_entry("queryDataPath", &self.query_data_path)?;
        }
        if !self.train_data_path.is_empty() {
            state.serialize_entry("trainDataPath", &self.train_data_path)?;
        }
        if !self.test_data_path.is_empty() {
            state.serialize_entry("testDataPath", &self.test_data_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TrainCustomModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.error_config.is_some() {
            state.serialize_entry("errorConfig", &self.error_config)?;
        }
        if !self.model_status.is_empty() {
            state.serialize_entry("modelStatus", &self.model_status)?;
        }
        if !self.metrics.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::F64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("metrics", &__With(&self.metrics))?;
        }
        if !self.model_name.is_empty() {
            state.serialize_entry("modelName", &self.model_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "search-tuning-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TrainCustomModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "serving-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.media_config() {
            state.serialize_entry("mediaConfig", value)?;
        }
        if let Some(value) = self.generic_config() {
            state.serialize_entry("genericConfig", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.solution_type) {
            state.serialize_entry("solutionType", &self.solution_type)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self.diversity_level.is_empty() {
            state.serialize_entry("diversityLevel", &self.diversity_level)?;
        }
        if !self.ranking_expression.is_empty() {
            state.serialize_entry("rankingExpression", &self.ranking_expression)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.filter_control_ids.is_empty() {
            state.serialize_entry("filterControlIds", &self.filter_control_ids)?;
        }
        if !self.boost_control_ids.is_empty() {
            state.serialize_entry("boostControlIds", &self.boost_control_ids)?;
        }
        if !self.redirect_control_ids.is_empty() {
            state.serialize_entry("redirectControlIds", &self.redirect_control_ids)?;
        }
        if !self.synonyms_control_ids.is_empty() {
            state.serialize_entry("synonymsControlIds", &self.synonyms_control_ids)?;
        }
        if !self.oneway_synonyms_control_ids.is_empty() {
            state.serialize_entry(
                "onewaySynonymsControlIds",
                &self.oneway_synonyms_control_ids,
            )?;
        }
        if !self.dissociate_control_ids.is_empty() {
            state.serialize_entry("dissociateControlIds", &self.dissociate_control_ids)?;
        }
        if !self.replacement_control_ids.is_empty() {
            state.serialize_entry("replacementControlIds", &self.replacement_control_ids)?;
        }
        if !self.ignore_control_ids.is_empty() {
            state.serialize_entry("ignoreControlIds", &self.ignore_control_ids)?;
        }
        if !self.promote_control_ids.is_empty() {
            state.serialize_entry("promoteControlIds", &self.promote_control_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "serving-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::serving_config::MediaConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.content_watched_percentage_threshold() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contentWatchedPercentageThreshold", &__With(value))?;
        }
        if let Some(value) = self.content_watched_seconds_threshold() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contentWatchedSecondsThreshold", &__With(value))?;
        }
        if !self.demotion_event_type.is_empty() {
            state.serialize_entry("demotionEventType", &self.demotion_event_type)?;
        }
        if !wkt::internal::is_default(&self.demote_content_watched_past_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "demoteContentWatchedPastDays",
                &__With(&self.demote_content_watched_past_days),
            )?;
        }
        if !wkt::internal::is_default(&self.content_freshness_cutoff_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "contentFreshnessCutoffDays",
                &__With(&self.content_freshness_cutoff_days),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "serving-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::serving_config::GenericConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.content_search_spec.is_some() {
            state.serialize_entry("contentSearchSpec", &self.content_search_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "serving-config-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateServingConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.serving_config.is_some() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Session {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if !self.turns.is_empty() {
            state.serialize_entry("turns", &self.turns)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.is_pinned) {
            state.serialize_entry("isPinned", &self.is_pinned)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "conversational-search-service", feature = "session-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::session::Turn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if self.detailed_answer.is_some() {
            state.serialize_entry("detailedAnswer", &self.detailed_answer)?;
        }
        if !self.query_config.is_empty() {
            state.serialize_entry("queryConfig", &self.query_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "assistant-service",
    feature = "conversational-search-service",
    feature = "session-service",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Query {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if !self.query_id.is_empty() {
            state.serialize_entry("queryId", &self.query_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SiteSearchEngine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSite {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.provided_uri_pattern.is_empty() {
            state.serialize_entry("providedUriPattern", &self.provided_uri_pattern)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.exact_match) {
            state.serialize_entry("exactMatch", &self.exact_match)?;
        }
        if !self.generated_uri_pattern.is_empty() {
            state.serialize_entry("generatedUriPattern", &self.generated_uri_pattern)?;
        }
        if !self.root_domain_uri.is_empty() {
            state.serialize_entry("rootDomainUri", &self.root_domain_uri)?;
        }
        if self.site_verification_info.is_some() {
            state.serialize_entry("siteVerificationInfo", &self.site_verification_info)?;
        }
        if !wkt::internal::is_default(&self.indexing_status) {
            state.serialize_entry("indexingStatus", &self.indexing_status)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.failure_reason.is_some() {
            state.serialize_entry("failureReason", &self.failure_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_site::FailureReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.quota_failure() {
            state.serialize_entry("quotaFailure", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_site::failure_reason::QuotaFailure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_required_quota) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalRequiredQuota", &__With(&self.total_required_quota))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SiteVerificationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.site_verification_state) {
            state.serialize_entry("siteVerificationState", &self.site_verification_state)?;
        }
        if self.verify_time.is_some() {
            state.serialize_entry("verifyTime", &self.verify_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Sitemap {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetSiteSearchEngineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateTargetSiteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.target_site.is_some() {
            state.serialize_entry("targetSite", &self.target_site)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateTargetSiteMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchCreateTargetSitesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GetTargetSiteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateTargetSiteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target_site.is_some() {
            state.serialize_entry("targetSite", &self.target_site)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateTargetSiteMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteTargetSiteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteTargetSiteMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTargetSitesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListTargetSitesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_sites.is_empty() {
            state.serialize_entry("targetSites", &self.target_sites)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchCreateTargetSiteMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchCreateTargetSitesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_sites.is_empty() {
            state.serialize_entry("targetSites", &self.target_sites)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSitemapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.sitemap.is_some() {
            state.serialize_entry("sitemap", &self.sitemap)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSitemapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FetchSitemapsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.matcher.is_some() {
            state.serialize_entry("matcher", &self.matcher)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::fetch_sitemaps_request::UrisMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::fetch_sitemaps_request::Matcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uris_matcher() {
            state.serialize_entry("urisMatcher", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CreateSitemapMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteSitemapMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FetchSitemapsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sitemaps_metadata.is_empty() {
            state.serialize_entry("sitemapsMetadata", &self.sitemaps_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::fetch_sitemaps_response::SitemapMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sitemap.is_some() {
            state.serialize_entry("sitemap", &self.sitemap)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EnableAdvancedSiteSearchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.site_search_engine.is_empty() {
            state.serialize_entry("siteSearchEngine", &self.site_search_engine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EnableAdvancedSiteSearchResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::EnableAdvancedSiteSearchMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisableAdvancedSiteSearchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.site_search_engine.is_empty() {
            state.serialize_entry("siteSearchEngine", &self.site_search_engine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisableAdvancedSiteSearchResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisableAdvancedSiteSearchMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RecrawlUrisRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.site_search_engine.is_empty() {
            state.serialize_entry("siteSearchEngine", &self.site_search_engine)?;
        }
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self.site_credential.is_empty() {
            state.serialize_entry("siteCredential", &self.site_credential)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RecrawlUrisResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.failure_samples.is_empty() {
            state.serialize_entry("failureSamples", &self.failure_samples)?;
        }
        if !self.failed_uris.is_empty() {
            state.serialize_entry("failedUris", &self.failed_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::recrawl_uris_response::FailureInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.failure_reasons.is_empty() {
            state.serialize_entry("failureReasons", &self.failure_reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::recrawl_uris_response::failure_info::FailureReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.corpus_type) {
            state.serialize_entry("corpusType", &self.corpus_type)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RecrawlUrisMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.invalid_uris.is_empty() {
            state.serialize_entry("invalidUris", &self.invalid_uris)?;
        }
        if !wkt::internal::is_default(&self.invalid_uris_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("invalidUrisCount", &__With(&self.invalid_uris_count))?;
        }
        if !self.noindex_uris.is_empty() {
            state.serialize_entry("noindexUris", &self.noindex_uris)?;
        }
        if !wkt::internal::is_default(&self.noindex_uris_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("noindexUrisCount", &__With(&self.noindex_uris_count))?;
        }
        if !self.uris_not_matching_target_sites.is_empty() {
            state.serialize_entry(
                "urisNotMatchingTargetSites",
                &self.uris_not_matching_target_sites,
            )?;
        }
        if !wkt::internal::is_default(&self.uris_not_matching_target_sites_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "urisNotMatchingTargetSitesCount",
                &__With(&self.uris_not_matching_target_sites_count),
            )?;
        }
        if !wkt::internal::is_default(&self.valid_uris_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("validUrisCount", &__With(&self.valid_uris_count))?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.pending_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pendingCount", &__With(&self.pending_count))?;
        }
        if !wkt::internal::is_default(&self.quota_exceeded_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("quotaExceededCount", &__With(&self.quota_exceeded_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchVerifyTargetSitesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchVerifyTargetSitesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchVerifyTargetSitesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FetchDomainVerificationStatusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.site_search_engine.is_empty() {
            state.serialize_entry("siteSearchEngine", &self.site_search_engine)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "site-search-engine-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FetchDomainVerificationStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_sites.is_empty() {
            state.serialize_entry("targetSites", &self.target_sites)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UserEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event_type.is_empty() {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self.conversion_type.is_empty() {
            state.serialize_entry("conversionType", &self.conversion_type)?;
        }
        if !self.user_pseudo_id.is_empty() {
            state.serialize_entry("userPseudoId", &self.user_pseudo_id)?;
        }
        if !self.engine.is_empty() {
            state.serialize_entry("engine", &self.engine)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if self.user_info.is_some() {
            state.serialize_entry("userInfo", &self.user_info)?;
        }
        if !wkt::internal::is_default(&self.direct_user_request) {
            state.serialize_entry("directUserRequest", &self.direct_user_request)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if self.page_info.is_some() {
            state.serialize_entry("pageInfo", &self.page_info)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if self.panel.is_some() {
            state.serialize_entry("panel", &self.panel)?;
        }
        if self.search_info.is_some() {
            state.serialize_entry("searchInfo", &self.search_info)?;
        }
        if self.completion_info.is_some() {
            state.serialize_entry("completionInfo", &self.completion_info)?;
        }
        if self.transaction_info.is_some() {
            state.serialize_entry("transactionInfo", &self.transaction_info)?;
        }
        if !self.tag_ids.is_empty() {
            state.serialize_entry("tagIds", &self.tag_ids)?;
        }
        if !self.promotion_ids.is_empty() {
            state.serialize_entry("promotionIds", &self.promotion_ids)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if self.media_info.is_some() {
            state.serialize_entry("mediaInfo", &self.media_info)?;
        }
        if !self.panels.is_empty() {
            state.serialize_entry("panels", &self.panels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pageview_id.is_empty() {
            state.serialize_entry("pageviewId", &self.pageview_id)?;
        }
        if !self.page_category.is_empty() {
            state.serialize_entry("pageCategory", &self.page_category)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.referrer_uri.is_empty() {
            state.serialize_entry("referrerUri", &self.referrer_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SearchInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.search_query.is_empty() {
            state.serialize_entry("searchQuery", &self.search_query)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if self.offset.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CompletionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.selected_suggestion.is_empty() {
            state.serialize_entry("selectedSuggestion", &self.selected_suggestion)?;
        }
        if !wkt::internal::is_default(&self.selected_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("selectedPosition", &__With(&self.selected_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TransactionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.value.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self.currency.is_empty() {
            state.serialize_entry("currency", &self.currency)?;
        }
        if !self.transaction_id.is_empty() {
            state.serialize_entry("transactionId", &self.transaction_id)?;
        }
        if self.tax.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("tax", &__With(&self.tax))?;
        }
        if self.cost.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("cost", &__With(&self.cost))?;
        }
        if self.discount_value.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("discountValue", &__With(&self.discount_value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DocumentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.id() {
            state.serialize_entry("id", value)?;
        }
        if let Some(value) = self.name() {
            state.serialize_entry("name", value)?;
        }
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if self.quantity.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("quantity", &__With(&self.quantity))?;
        }
        if !self.promotion_ids.is_empty() {
            state.serialize_entry("promotionIds", &self.promotion_ids)?;
        }
        if !wkt::internal::is_default(&self.joined) {
            state.serialize_entry("joined", &self.joined)?;
        }
        if self.conversion_value.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("conversionValue", &__With(&self.conversion_value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PanelInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.panel_id.is_empty() {
            state.serialize_entry("panelId", &self.panel_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.panel_position.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("panelPosition", &__With(&self.panel_position))?;
        }
        if self.total_panels.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalPanels", &__With(&self.total_panels))?;
        }
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "recommendation-service", feature = "user-event-service",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::MediaInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.media_progress_duration.is_some() {
            state.serialize_entry("mediaProgressDuration", &self.media_progress_duration)?;
        }
        if self.media_progress_percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "mediaProgressPercentage",
                &__With(&self.media_progress_percentage),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WriteUserEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.user_event.is_some() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if !wkt::internal::is_default(&self.write_async) {
            state.serialize_entry("writeAsync", &self.write_async)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-event-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CollectUserEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.user_event.is_empty() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if self.uri.is_some() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.ets.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ets", &__With(&self.ets))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UserLicense {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_principal.is_empty() {
            state.serialize_entry("userPrincipal", &self.user_principal)?;
        }
        if !self.user_profile.is_empty() {
            state.serialize_entry("userProfile", &self.user_profile)?;
        }
        if !wkt::internal::is_default(&self.license_assignment_state) {
            state.serialize_entry("licenseAssignmentState", &self.license_assignment_state)?;
        }
        if !self.license_config.is_empty() {
            state.serialize_entry("licenseConfig", &self.license_config)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_login_time.is_some() {
            state.serialize_entry("lastLoginTime", &self.last_login_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListUserLicensesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ListUserLicensesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_licenses.is_empty() {
            state.serialize_entry("userLicenses", &self.user_licenses)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateUserLicensesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_source() {
            state.serialize_entry("inlineSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.delete_unassigned_user_licenses) {
            state.serialize_entry(
                "deleteUnassignedUserLicenses",
                &self.delete_unassigned_user_licenses,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::batch_update_user_licenses_request::InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_licenses.is_empty() {
            state.serialize_entry("userLicenses", &self.user_licenses)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateUserLicensesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "user-license-service")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BatchUpdateUserLicensesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_licenses.is_empty() {
            state.serialize_entry("userLicenses", &self.user_licenses)?;
        }
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
